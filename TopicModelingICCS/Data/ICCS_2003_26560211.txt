Eﬃcient and Non-malleable Proofs of Plaintext
Knowledge and Applications
(Extended Abstract)
Jonathan Katz
Dept. of Computer Science, University of Maryland, College Park, MD
jkatz@cs.umd.edu

Abstract. We describe eﬃcient protocols for non-malleable (interactive) proofs of plaintext knowledge for the RSA, Rabin, Paillier, and El
Gamal encryption schemes. We also highlight some important applications of these protocols:
– Chosen-ciphertext-secure, interactive encryption. In settings where
both parties are on-line, an interactive encryption protocol may be
used. We construct chosen-ciphertext-secure interactive encryption
schemes based on any of the schemes above. In each case, the improved scheme requires only a small overhead beyond the original,
semantically-secure scheme.
– Password-based authenticated key exchange. We derive eﬃcient protocols for password-based key exchange in the public-key model [28,
5] whose security may be based on any of the cryptosystems mentioned above.
– Deniable authentication. Our techniques give the ﬁrst eﬃcient constructions of deniable authentication protocols based on, e.g., the
RSA or computational Diﬃe-Hellman assumption.
Of independent interest, we consider the concurrent composition of proofs
of knowledge; this is essential to prove security of our protocols when run
in an asynchronous, concurrent environment.

1

Introduction

Given an instance of an encryption scheme with public key pk and secret key
sk, a proof of plaintext knowledge (PPK) allows a sender S to prove knowledge
of the contents m of some ciphertext C = Epk (m) to a receiver R (a formal
deﬁnition appears in Section 2). To be useful, a PPK should also ensure that no
information about m is revealed, either to the receiver – in case the receiver does
not have sk – or to an eavesdropper. As we show here, PPKs have applications
to chosen-ciphertext-secure (IND-CCA2) public-key encryption schemes [31,35],
password-based authentication and key exchange (password-AKE) protocols in
the public-key model [28,5], and deniable authentication [15,17].
The full version of this work appears in [29].
(Work done while at Columbia University)
E. Biham (Ed.): EUROCRYPT 2003, LNCS 2656, pp. 211–228, 2003.
c International Association for Cryptologic Research 2003

212

J. Katz

Of course, PPKs may be achieved using generic zero-knowledge (ZK) proofs
of knowledge [20,25,3]; similarly [21,12], non-interactive PPKs are possible assuming appropriate public parameters are included with pk. For the Rabin,
RSA, Paillier, or El-Gamal [34,36,33,19] encryption schemes, the well-known Σprotocols [7] for these schemes (e.g., [32,26,8,38]) may be adapted to give PPKs,
although modiﬁcations are needed to ensure security against a cheating veriﬁer.
For the applications listed above, however, these solutions are not suﬃcient; the
following considerations additionally need to be taken into account:
– Non-malleability. An active adversary M may be controlling all communication between the honest parties in a classic “man-in-the-middle” attack.
We then need to ensure that the adversary cannot divert the proof of knowledge being given by S to R. For example, S may be giving a PPK of C , yet
M might be able to change this to a PPK of some C even though M has no
knowledge of the real decryption of C.
– Concurrency. A receiver may be interacting asynchronously and concurrently with many senders who are simultaneously giving PPKs for diﬀerent
ciphertexts. The protocol should remain secure even in this environment.
Generic solutions to the above problems exist (cf. Section 1.2). However, these
solutions – particularly in the case of non-malleability – are extremely ineﬃcient. Our main contribution is to give very eﬃcient non-malleable PPKs for the
commonly-used cryptosystems mentioned above; namely, Rabin, RSA, Paillier,
and El Gamal. As discussed in the following section, we furthermore show how
these PPKs yield eﬃcient protocols (even in a concurrent setting) for a number
of applications.
1.1

Applications and Results

We describe some applications of our non-malleable PPKs, and also the notion
of concurrent proofs of knowledge which arises when proving security for these
applications.
Interactive public-key encryption. When a sender and receiver are both online, it may be perfectly acceptable to use an interactive encryption protocol.1
Known non-interactive IND-CCA2 encryption schemes are either impractical
[15,37] or are based on speciﬁc, decisional assumptions [10,11]. It is therefore
reasonable to look for eﬃcient constructions of interactive IND-CCA2 encryption
schemes based on (potentially weaker) computational assumptions.
Interactive encryption schemes based on PPKs have been proposed previously
[22,27,24]; these, however, achieve only non-adaptive CCA1 security. Interactive
encryption was also considered by [15], who give a generic and relatively eﬃcient
IND-CCA2 scheme. This scheme requires a signature from the receiver making
it unsuitable for use in some applications (see below). Moreover, their protocol
1

Note that interaction may be taking place already (e.g., to establish a TCP connection) as part of the larger protocol in which encryption is taking place.

Eﬃcient and Non-malleable Proofs of Plaintext Knowledge and Applications

213

requires the receiver – for each encrypted message – to (1) compute an existentially unforgeable signature and (2) run the key-generation algorithm for a
public-key encryption scheme. Our protocols, optimized for particular numbertheoretic assumptions, are more eﬃcient still.
Using the non-malleable PPKs presented here, we construct interactive encryption schemes secure against chosen-ciphertext attacks in the standard model.
Their eﬃciency is comparable to known schemes [10,11]; in fact, our protocols
require only a small computational overhead beyond a basic, semantically-secure
scheme. The security of our protocols may be based on a variety of computational assumptions, such as RSA, the composite residuosity assumption [33], or
the hardness of factoring.
Password-based authentication and key exchange. Interactive encryption
becomes an even more appealing solution when encryption is used within a
larger, already-interactive protocol. For example, consider password-based authentication and key exchange in the public-key model [28,5]. In this setting,
a client and a server share a weak password which they use to authenticate
each other and to derive a key for securing future communication; additionally,
the client knows the server’s public key. Since the password is short, oﬀ-line
dictionary attacks must be explicitly prevented. Previous work [28,5] gives elegant, interactive2 protocols for securely realizing this task using any IND-CCA2
public-key cryptosystem; our techniques allow the ﬁrst eﬃcient realization of
these protocols based on, e.g., the factoring or RSA assumptions.
Deniable authentication. A deniable authentication protocol [15,17,18,16] allows a prover P (who has a public key) to authenticate a message to a veriﬁer
V such that the transcript of the interaction cannot be used as evidence that P
took part in the protocol (i.e., P can later deny that the authentication took
place). In addition to deniability, we require (informally) that an adversary who
interacts with the prover – who authenticates messages m1 , . . . , m of the adversary’s choice – should be unable to forge the authentication of any message
m ∈
/ {m1 , . . . , m } for an honest veriﬁer.
Constructions of deniable authentication protocols based on any IND-CCA2
encryption scheme are known [17,18,16]. However, these protocols are not secure
(in general) when an IND-CCA2 interactive encryption scheme is used. For example, the scheme of [15] requires a signature from the prover and hence the
resulting authentication protocol is no longer deniable; this problem is pointed
out explicitly in [17].
The only previously-known protocol which is both practical and also satisﬁes
the strongest notion of deniability uses the construction of [17] instantiated with
the encryption scheme of [10]; security is based on the DDH assumption. We
present here the ﬁrst eﬃcient protocols based on factoring or other assumptions
which are secure under the strongest notion of deniability. We also show (in the
full version) a deniable authentication protocol based on the CDH assumption
2

Interaction is essential in any authentication protocol to prevent replay attacks.

214

J. Katz

which is computationally more eﬃcient and requires a shorter public key than
the previous best-known solution.
Recently, Naor [30] has suggested applications of the protocols presented here
to the problem of deniable ring authentication.
Concurrent proofs of knowledge. When using our PPKs for the applications
described above, we must ensure that the protocols remain secure even when
run in an asynchronous, concurrent environment. In the context of proofs of
knowledge, this requires that witness extraction be possible even when multiple
provers are concurrently interacting with a single veriﬁer. Although the issue
of concurrency in the context of zero-knowledge proofs has been investigated
extensively (following [17]), concurrent proofs of knowledge have received much
less attention (we are only aware of [23]). We believe the notion of concurrent
proofs of knowledge is of independent interest, and hope our work motivates
future research on this topic.
1.2

Related Work

Proofs of plaintext knowledge are explicitly considered by Aumann and Rabin [1], who provide a generic solution for any public-key encryption scheme.
Our solutions diﬀer from theirs in many respects: (1) by working with speciﬁc,
number-theoretic assumptions we achieve much better eﬃciency and round complexity; (2) we explicitly consider malleability and ensure that our solutions are
non-malleable; (3) our protocols are secure even against a dishonest veriﬁer; and
(4) we explicitly handle concurrency and our protocols remain provably-secure
under asynchronous, concurrent composition.
Non-malleable zero-knowledge (interactive) proofs were deﬁned and constructed by Dolev, Dwork, and Naor [15]; recently, Barak [2] has given constructions with O(1) round complexity. Sahai [37] and De Santis, et al. [13]
provide deﬁnitions and constructions for non-malleable NIZK proofs and proofs
of knowledge.3 These solutions are all based on general assumptions and are
impractical for giving proofs related to number-theoretic problems of interest.
Non-malleable PPKs were considered, inter alia, by Cramer, et al. [8] in the
context of communication-eﬃcient multi-party computation; they also present
an eﬃcient construction suitable for their application (no deﬁnitions of nonmalleable PPKs are given in [8]). Here, in addition to constructions, we give formal deﬁnitions and also show applications to a number of other cryptographic
protocols. Furthermore, we note some important diﬀerences between our approaches. First, their solution relies in an essential way upon the fact that the
set of participants (i.e., their number and their identities) is ﬁxed and publicly
known. Our protocols do not require any notion of user identities and we assume
no bound on the number of potential participants. Second, their work considers
synchronous communication; here, we allow for asynchronous (concurrent) communication which is more realistic in the context of, e.g., public-key encryption.
3

Interestingly, ours is the ﬁrst work to explicitly consider non-malleable interactive
proofs of knowledge.

Eﬃcient and Non-malleable Proofs of Plaintext Knowledge and Applications

215

Universal composability (UC) [6] has been proposed as a general framework
in which to analyze the security and composition of protocols; a UC protocol is,
in particular, non-malleable. Although the PPKs given here are not universallycomposable, they are proven secure in alternate – yet standard – models of security. The resulting protocols are more eﬃcient than known UC proofs of knowledge. We note also that security requirements for certain applications (deniable
authentication in particular) do not seem to ﬁt readily into the UC framework;
for such applications, deﬁnitions of the sort used here seem more appropriate.
1.3

Outline of the Paper

In Section 2 we present a deﬁnition of PPKs and non-malleable PPKs, and in
Section 3 we show and prove secure a construction of a non-malleable PPK for
the RSA cryptosystem. (We have obtained similar results for the Rabin, Paillier,
and El Gamal cryptosystems [29], but we omit further details in the present
abstract.) In Section 4 we brieﬂy sketch some applications of our non-malleable
PPKs. Deﬁnitions, details, and complete proofs appear in the full version [29].

2

Deﬁnitions and Preliminaries

The deﬁnitions given here focus on proofs of plaintext knowledge, yet they may
be easily extended to proofs of knowledge for general NP-relations. Let (K, E, D)
be a non-interactive public-key encryption scheme which need not be semantically secure. The encryption of message m under public key pk using randomness
r to give ciphertext C is denoted as C := Epk (m; r), and we say that (m, r) is a
witness to the decryption of C under pk. For convenience, we assume |pk| = k,
the security parameter. We let A(a), B(b) (c) be the random variable denoting
the output of B following an execution of an interactive protocol between A
(with private input a) and B (with private input b) on joint input c, where A
and B have uniformly-distributed random tapes.
In a PPK protocol, sender S proves knowledge to receiver R of a witness to
the decryption of some ciphertext C under the known public key. Both S and R
have an additional joint input σ; in practice, this may be published along with the
public key pk.4 Our deﬁnitions build on the standard one for proofs of knowledge
[3,24], except that our protocols are technically arguments of knowledge and we
therefore restrict ourselves to consideration of provers running in probabilistic,
polynomial time.
To ensure that no information about m is revealed, a PPK is required to
be “perfect zero-knowledge” in the following sense: Let the joint input σ be
generated by some algorithm G(pk). We require the existence of a simulator
SIM which takes pk as input and outputs parameters σ whose distribution is
equivalent to the output of G(pk). Then, given any ciphertext C (but no witness
to its decryption), SIM should be able to perfectly simulate a PPK of C with
any (malicious) receiver R using parameters σ .
4

In all our applications, there is no incentive to cheat when generating σ.

216

J. Katz

Deﬁnition 1. Let Π = (G, S, R) be a tuple of ppt algorithms. Π is a proof
of plaintext knowledge (PPK) for encryption scheme (K, E, D) if the following
conditions hold:
(Completeness) For all pk output by K(1k ), all σ output by G(pk), and all C
with witness w to the decryption of C under pk we have S(w), R (pk, σ, C) = 1.
(When R outputs 1 we say it accepts.)
(Perfect zero-knowledge) There exists a ppt simulator SIM such that, for
all pk output by K(1k ), all R , and all m, r, the following distributions are equivalent:
{σ ← G(pk); C := Epk (m; r) : S(m, r), R (pk, σ, C)}
{(σ, s) ← SIM1 (pk); C := Epk (m; r) : SIM2 (s), R (pk, σ, C)}.
(Note that SIM2 does not need to rewind R .)
(Witness extraction) There exists a function κ : {0, 1}∗ → [0, 1], a negligible
function ε(·), and an expected polynomial-time knowledge extractor KE such
that, for all ppt algorithms S , with all but negligible probability over pk, σ, r,
machine KE satisﬁes the following:
Denote by ppk,σ,r the probability that R accepts when interacting with
S (using random tape r) on joint input pk, σ, C (where C is chosen by
S ). On input pk, σ, and access to Sr , the probability that KE outputs a
witness to the decryption of C under pk is at least:
ppk,σ,r − κ(pk) − ε(|pk|).
Our deﬁnition of non-malleability ensures that “anything proven by a manin-the-middle adversary M is known by M (unless M simply copies a proof).”
To formalize this, we allow M to interact with a simulator5 (cf. Deﬁnition 1)
while simultaneously interacting with an honest receiver R. The goal of M is to
successfully complete a PPK of C to R while the simulator is executing a PPK
of C to M (where C , C are chosen adaptively by M). The following deﬁnition
states (informally) that if R accepts M’s proof – yet the transcripts of the two
proofs are diﬀerent – then a knowledge extractor KE ∗ can extract a witness to
the decryption of C.
Deﬁnition 2. PPK (G, S, R) is non-malleable if there exists a simulator SIM
(as in Deﬁnition 1), a function κ∗ : {0, 1}∗ → [0, 1], a negligible function ε∗ (·),
and an expected polynomial-time knowledge extractor KE ∗ such that, for all
ppt algorithms M, with all but negligible probability over choice of pk, σ, s, r, r ,
machine KE ∗ satisﬁes the following:
Assume M (using random tape r ) acts as a receiver with SIM2 (s; r)
on joint input pk, σ, C and simultaneously as a sender with R on joint
5

Note that, by the perfect zero-knowledge property, M’s probability of convincing R
remains unchanged whether M interacts with the simulator or a real sender.

Eﬃcient and Non-malleable Proofs of Plaintext Knowledge and Applications

217

input pk, σ, C (where C , C are chosen by M). Let the transcripts of these
two interactions be π and π. Denote by p∗ the probability (taken over
random coins of R) that R accepts in the above interaction and π = π.
On input s, r, pk, σ, and access to Mr , the probability that KE ∗ outputs
a witness to the decryption of C under pk is at least:
p∗ − κ∗ (pk) − ε∗ (|pk|).
Our deﬁnitions of zero-knowledge (in Deﬁnition 1) and non-malleability (in Deﬁnition 2) both consider the single-theorem case. The deﬁnitions may be modiﬁed
for the multi-theorem case; however, the present deﬁnitions suﬃce for our intended applications.
2.1

A Note on Complexity Assumptions

Our complexity assumptions are with respect to adversaries permitted to run in
expected polynomial time. For example, we assume that RSA inverses cannot be
computed with more than negligible probability by any expected polynomialtime algorithm. The reason for this is our reliance on (eﬃcient) constant-round
proofs of knowledge, for which only expected polynomial-time knowledge extractors are known.

3

A Non-malleable PPK for the RSA Cryptosystem

We begin with an overview of our technique. Recall the parameter σ which is
used as a common input during execution of the PPK. To allow simulation, a ﬁrst
attempt is to have a PPK for ciphertext C consist of a witness-indistinguishable
proof of knowledge of either a witness to the decryption of C or a witness x
corresponding in some way to σ (using the known techniques for constructing
such proofs [9]). Notice that a simulator who knows x can easily simulate a PPK
for any ciphertext; on the other hand (informally), the protocol is sound since a
ppt adversary does not know x.
This approach does not suﬃce to achieve non-malleability. To see why, consider a simulator interacting with man-in-the-middle M while M simultaneously
interacts with receiver R. Using the approach sketched above, the simulator gives
a proof of “w or x” while M gives a proof of “w or x”, where w (resp. w ) is a
witness to the decryption of ciphertext C (resp. C ). The idea is now to rewind
M and thus (hopefully) extract w . But since the simulator must know x (since w
is unknown; recall that C is chosen by M), there is no contradiction is extracting
x (and not w ) from M! Indeed, a more careful approach is needed.
To overcome this obstacle, we adapt a technique used previously in the context of non-malleable commitment [14]. The prover will choose a value α and
prove knowledge of “w or xα ”, where xα corresponds to some function of σ and
α. Thus, in the man-in-the-middle attack above, the simulator will be proving
knowledge of “w or xα ” while M proves knowledge of “w or xα ”; in particular,

218

J. Katz

rewinding M will extract either the desired value w or xα . The desired witness
will be extracted (and hence the PPK will be non-malleable) if the following
conditions hold: (1) the simulator can know the witness xα ; yet (2) extracting
xα for any α = α results in a contradiction; furthermore, (3) M cannot duplicate the value α used by the simulator, so that α = α. Details follow in the
remainder of this section.
The PPK we describe here will be for the following encryption scheme for
-bit messages [4], which is semantically-secure under the RSA assumption: The
modulus N is chosen as a product of two random k/2-bit primes, and e is a
prime number such that |e| = O(k).6 The public key is (N, e). Let hc(·) be a
def

−1

hard-core bit [24] for the RSA permutation, and deﬁne hc∗ (r) = hc(re ) ◦
· · · ◦ hc(re ) ◦ hc(r). Encryption of -bit message m is done by choosing random
def

r ∈ Z∗N , computing C = re mod N , and sending C, c = hc∗ (r) ⊕ m . (Clearly,
we could also extract more than a single hard-core bit per application of the
RSA permutation.)
The PPK builds on the following Σ-protocol for proving knowledge of e th roots, based on [26]: To prove knowledge of r = C 1/e , the prover chooses
a random element r1 ∈ Z∗N and sends A = r1e to the veriﬁer. The veriﬁer
replies with a random challenge q ∈ Ze . The prover responds with R = rq r1
?
and the receiver veriﬁes that Re = C q A. To see that special soundness holds,
consider two accepting conversations (A, q, R) and (A, q , R ). Since Re = C q A
and (R )e = C q A we have (R/R )e = C q−q . Noting that |q − q | is relatively
prime to e , standard techniques may be used to compute the desired witness
C 1/e [26]. Special honest-veriﬁer zero knowledge is demonstrated by the simulator which, on input C and a “target” challenge q, chooses random R ∈ Z∗N ,
computes A = Re /C q , and outputs the transcript (A, q, R).
We now describe the non-malleable PPK (cf. Figure 1). Parameters σ are
generated by selecting two random elements g, h ∈ Z∗N and a random function
H : {0, 1}∗ → Ze from a family of universal one-way hash functions. Given
σ, a PPK for ciphertext C, c proceeds as follows: ﬁrst, a key-generation algorithm for a one-time signature scheme is run to yield veriﬁcation key VK
and signing key SK, and α = H(VK) is computed. The PPK will be a witnessindistinguishable proof of knowledge (using techniques of [9]) of either r = C 1/e
def

or xα = (g α h)1/e . In more detail, the sender chooses random r1 , R2 ∈ Z∗N and
q2 ∈ Ze , and then computes A1 = r1e and A2 = R2e /(g α h)q2 . These values
are sent (along with VK, C, c) as the ﬁrst message. The receiver sends challenge
q ∈ Ze . The sender responds with q1 = q − q2 mod e, and also R1 = rq1 r1 (completing the “real” proof of knowledge with “challenge” q1 ) and R2 (completing
the “simulated” proof of knowledge with “challenge” q2 ). To complete the proof,
the sender signs a transcript of the entire execution (including C, c) using SK
and sends the signature to the receiver. The receiver veriﬁes correctness of the
6

For eﬃciency, the protocol may be modiﬁed for small e (e.g., e = 3); see [29].

Eﬃcient and Non-malleable Proofs of Plaintext Knowledge and Applications

219

Public key: N ; prime e
σ : g, h ∈ Z∗N ; H : {0, 1}∗ → Ze
S (input m ∈ {0, 1} )

R

(VK, SK) ← SigGen(1k )
r, r1 , R2 ← Z∗N ; q2 ← Ze
C := re ; c := hc∗ (r) ⊕ m
α := H(VK)
A1 := r1e
A2 := R2e / (g α h)q2

q1 := q − q2 mod e

VK, C, c, A1 , A2 ✲
q ← Ze

q

✛

R1 := rq1 r1
s ← SignSK (transcript)

q 1 , R1 , R2 , s

✲

?

Verify: R1e = C q1 A1
?

R2e = g H(VK) h

(q−q1 mod e)

A2

?

VrfyVK (transcript, s) = 1
Fig. 1. Non-malleable PPK for the RSA cryptosystem.

?

?

proofs by checking that R1e = C q1 A1 and R2e = (g α h)(q−q1 mod e) A2 . Finally, the
receiver veriﬁes the correctness of the signature on the transcript.
Theorem 1. Under the RSA assumption for expected poly-time algorithms, the
protocol of Figure 1 is a non-malleable PPK (with κ∗ (pk) = 1/e) for the RSA
cryptosystem.
The proof appears in Appendix B.
Concurrent composition. In many applications, it may be necessary to consider the case where multiple, concurrent proofs are conducted and witness extraction is required from each of them (and extraction is required as soon as the
relevant proof is completed). If arbitrary interleaving of the proofs is allowed, a
knowledge extractor operating in the obvious way may require exponential time;
a similar problem is encountered in simulation of concurrent zero-knowledge
proofs [17]. (In the context of concurrent zero-knowledge, the diﬃculty is to ensure that the concurrent interaction of a single prover with multiple veriﬁers is
simulatable; for concurrent proofs of knowledge, the diﬃculty is to ensure that
the concurrent interaction of a single veriﬁer with multiple provers still allows

220

J. Katz

witness extraction.) To ensure that our protocols remain proofs of knowledge
in a concurrent setting, we introduce timing constraints [17]; essentially, these
constraints prevent “bad” interleavings and allow extraction of all relevant witnesses. We describe this in more detail in the following section; further details
and full proofs of security appear in the full version [29].

4

Applications

In this section, we brieﬂy discuss applications of our non-malleable PPKs to the
construction of protocols for (1) interactive IND-CCA2 encryption, (2) passwordAKE in the public-key model, and (3) strong deniable authentication. The protocols described here may be based on any of the PPKs given in the full version
of this work; security of these protocols may therefore be based on a variety of
assumptions (e.g., RSA, hardness of factoring, or composite residuosity). All our
applications are assumed to run in an asynchronous, concurrent environment;
thus, in each case we augment our PPKs with timing constraints as discussed
in the previous section. Further details and proofs of all theorems stated here
appear in the full version [29].
Chosen-ciphertext-secure, interactive encryption. We give a deﬁnition of
chosen-ciphertext security for interactive encryption in Appendix A. The nonmalleable PPK of Figure 1 immediately yields an interactive encryption scheme:
The receiver generates N, e, σ as above and sets the public key pk = (N, e, σ)
(the secret key is as usual for RSA). To encrypt message m under public key pk,
the sender computes C = re and c = hc∗ (r) ⊕ m, sends C, c to the receiver,
and then executes the PPK using parameters σ. To decrypt, the receiver ﬁrst
determines whether to accept or reject the proof; if the receiver accepts, the
receiver decrypts C, c as in the standard RSA scheme. If the proof is rejected,
the receiver outputs ⊥.
This scheme above is secure against adaptive chosen-ciphertext attacks when
the adversary is given sequential access to the decryption oracle. To ensure security against an adversary given concurrent access to the decryption oracle,
timing constraints are necessary. In particular, we require that the sender respond to the challenge within time α from when the challenge is sent. If the
response is not received in time, the proof is rejected. Additionally, an acknowledgment is sent from the receiver to the sender upon completion of the protocol;
this message is ack if the sender’s proof was accepted and ⊥ otherwise. The
receiver delays sending the acknowledgment until time β has elapsed from when
the second message of the protocol was sent (with β > α).
Theorem 2. Under the RSA assumption for expected poly-time algorithms, the
protocol of Figure 1 (with |e| = Θ(k)) is secure against sequential chosenciphertext attacks. If timing constraints are enforced, the protocol is secure
against concurrent chosen-ciphertext attacks.

Eﬃcient and Non-malleable Proofs of Plaintext Knowledge and Applications

221

Password-based authentication and key exchange. Protocols for
password-based authentication may be constructed from any IND-CCA2 encryption scheme as follows [28,5]: Let pw be the user’s password. To authenticate the
user, the server sends a nonce n and the user replies with an encryption of pw ◦ n
(this brief description suppresses details which are unimportant here; see [28,5]).
When non-interactive encryption is used, the nonce is needed to prevent replay
attacks. The server decrypts and veriﬁes correctness of the password and the
nonce. (Previous work [28,5] proved security when non-interactive IND-CCA2
encryption was used, but the proofs extend for the case of interactive encryption.) If desired, a key K may be exchanged by encrypting K ◦ pw ◦ n.
Our interactive IND-CCA2 encryption schemes allow the ﬁrst eﬃcient implementations of these protocols based on assumptions other than DDH (e.g.,
we may base security on the RSA or factoring assumptions). Furthermore, since
interaction is essential (to prevent replay attacks), using interactive encryption
is not a serious drawback. Finally, if interactive encryption is used, the nonce
is not needed if the probability that a server repeats its messages is negligible.
Thus, password-AKE protocols constructed from our PPKs ultimately require
only one more round than previous constructions.
Deniable authentication. Deﬁnitions of security for deniable authentication
appear in Appendix A. Our non-malleable PPKs may be adapted to give deniable authentication protocols whose security is based on the one-wayness (rather
than semantic security) of an underlying encryption scheme. This results in protocols with improved eﬃciency and with security based on potentially weaker
assumptions (recall that previous eﬃcient constructions achieving strong deniability require the DDH assumption).
We present a generic paradigm for constructing a deniable authentication
protocol based on our non-malleable PPKs. The basic idea is for V to encrypt
a random value, send the resulting ciphertext to the prover, and then execute a
non-malleable PPK for the ciphertext (here, V acts as the prover in the PPK).
To “bind” the protocol to a message m to be authenticated, m is included in the
transcript and signed along with everything else. Assuming V’s proof succeeds,
P authenticates the message by decrypting the ciphertext and sending back the
resulting value.
Figure 2 shows an example of this approach applied to the PPK of Figure
1. The public key of the prover P is an RSA modulus N , a prime e (with
|e| = Θ(k)), elements g, h ∈ Z∗N , and a hash function H chosen randomly from
a family of universal one-way hash functions. Additionally, P has secret key d
such that de = 1 mod ϕ(N ). To have m authenticated by P, the veriﬁer chooses
a random y ∈ Z∗N , computes C = y e , and then performs a non-malleable PPK
for C. Additionally, the message m is sent as part of the ﬁrst message of the
protocol, and is signed along withe the rest of the transcript. If the veriﬁer’s
proof succeeds, the prover computes C d (i.e., y) and sends this value to the
veriﬁer. Otherwise, the prover simply replies with ⊥.
As before, timing constraints are needed when concurrent access to the prover
is allowed. In this case, we require that the veriﬁer respond to the challenge

222

J. Katz
Public key: N ; prime e; g, h ∈ Z∗N ; H : {0, 1}∗ → Ze

V (input m ∈ {0, 1}∗ )

P (input d)

(VK, SK) ← SigGen(1k )
y, r1 , R2 ← Z∗N ; q2 ← Ze
C := y e ; α := H(VK)
A1 := r1e
A2 :=

R2e / (g α h)q2

q1 := q − q2 mod e

VK, m, C, A1 , A2 ✲

✛

q ← Ze

q

R1 := y q1 r1
s ← SignSK (transcript)

q 1 , R1 , R2 , s

✲

?

Verify: R1e = C q1 A1
?

R2e = g H(VK) h

✛

Cd

(q−q1 mod e)

A2

?

VrfyVK (transcript, s) = 1

Fig. 2. A deniable authentication protocol based on RSA.

within time α from when the challenge is sent (the proof is rejected otherwise).
Additionally, the ﬁnal message of the protocol is not sent by the prover until at
least time β has elapsed since sending the challenge (with β > α).
Theorem 3. Under the RSA assumption for expected poly-time algorithms, the
protocol of Figure 2 (with |e| = Θ(k)) is a strong deniable authentication protocol
for adversaries given sequential access to the prover. If timing constraints are enforced, the protocol is a strong ε-deniable authentication protocol for adversaries
given concurrent access to the prover.
We stress that the resulting deniable authentication protocols are quite practical. For example, the full version of this work shows a deniable authentication
protocol based on the CDH assumption which has the same round-complexity,
requires fewer exponentiations, has a shorter public key, and is based on a weaker
assumption than the most eﬃcient previously-known protocol for strong deniable
authentication. Furthermore, no previous eﬃcient protocols were known based
on the RSA, factoring, or composite residuosity assumptions. We also remark
that interactive IND-CCA2 encryption schemes do not, in general, yield deniable authentication protocols using the paradigm sketched above. For example,
when using the IND-CCA2 interactive encryption scheme of [15], two additional

Eﬃcient and Non-malleable Proofs of Plaintext Knowledge and Applications

223

Public key: N ; prime e; g, h ∈ Z∗N
V (input m ∈ Mk ⊂ Ze )

P (input d)

y, r1 , R2 ← Z∗N ; q2 ← Ze
C := y e ; A1 := r1e
A2 := R2e / (g m h)q2

q1 := q − q2 mod e

m, C, A1 , A2

✛

R1 := y q1 r1

q ← Ze

q
q 1 , R1 , R2

✛

✲

Cd

✲

?

Verify: R1e = C q1 A1
?

R2e = (g m h)(q−q1 mod e) A2

Fig. 3. A deniable authentication protocol with improved eﬃciency.

rounds are necessary just to achieve weak deniable authentication (the terms
“strong” and “weak” are explained in Appendix A).
Further eﬃciency improvements (see Figure 3) result from the observation
that, in the context of deniable authentication, it is not necessary to generate
and send a signature key VK and sign the transcript (recall this is done to force
the adversary to use α = H(VK ) = H(VK) = α; see Section 3). Instead, we may
simply use m (i.e., the message to be authenticated) as our α: informally, this
works since the adversary must choose m = m in order to falsely authenticate
a new message m which was never authenticated by the prover. On the other
hand, because the adversary chooses m (and this value must be guessed by the
simulator in advance), the scheme is only provably secure for polynomial-size
message spaces Mk . We refer to [29] for further details.
Acknowledgments. I am grateful to Moti Yung and Rafail Ostrovsky for their
many helpful comments and suggestions regarding the work described here.

References
1. Y. Aumann and M.O. Rabin. A Proof of Plaintext Knowledge Protocol and Applications. Manuscript. June, 2001.
2. B. Barak. Constant-Round Coin Tossing with a Man in the Middle or Realizing
the Shared Random String Model. Proceedings of the 43rd Annual Symposium on
Foundations of Computer Science, IEEE, 2002, pp. 345–355.
3. M. Bellare and O. Goldreich. On Deﬁning Proofs of Knowledge. Advances in Cryptology – Crypto ’92, LNCS vol. 740, E. Brickell, ed., Springer-Verlag, 1992, pp.
390–420.

224

J. Katz

4. M. Blum and S. Goldwasser. An Eﬃcient Probabilistic Public-Key Encryption
Scheme which Hides All Partial Information. Advances in Cryptology – Crypto
’84, LNCS vol. 196, G. Blakley and D. Chaum, eds., Springer-Verlag, pp. 289–302.
5. M. Boyarsky. Public-Key Cryptography and Password Protocols: the Multi-User
Case. ACM Conference on Computer and Communications Security, 1999, pp. 63–
72.
6. R. Canetti. Universally Composable Security: A New Paradigm for Cryptographic
Protocols. Proceedings of the 42nd Annual Symposium on Foundations of Computer
Science, IEEE, 2001, pp. 136–145.
7. R. Cramer. Modular Design of Secure Yet Practical Cryptographic Protocols. PhD
Thesis, CWI and U. Amsterdam, 1996.
8. R. Cramer, I. Damg˚
ard, and J.B. Nielsen. Multiparty Computation from Threshold
Homomorphic Encryption. Advances in Cryptology – Eurocrypt 2001, LNCS vol.
2045, B. Pﬁtzmann, ed., Springer-Verlag, 2001, pp. 280–299.
9. R. Cramer, I. Damg˚
ard, and B. Schoenmakers. Proofs of Partial Knowledge and
Simpliﬁed Design of Witness Hiding Protocols. Advances in Cryptology – Crypto
’94, LNCS vol. 839, Y. Desmedt, ed., Springer-Verlag, 1994, pp. 174–187.
10. R. Cramer and V. Shoup. A Practical Public-Key Cryptosystem Provably Secure
against Adaptive Chosen Ciphertext Attack. Advances in Cryptology – Crypto ’98,
LNCS vol. 1462, H. Krawczyk, ed., Springer-Verlag, 1998, pp. 13–25.
11. R. Cramer and V. Shoup. Universal Hash Proofs and a Paradigm for Adaptive
Chosen-Ciphertext-Secure Public-Key Encryption. Advances in Cryptology – Eurocrypt 2002, LNCS vol. 2332, L. Knudsen, ed., Springer-Verlag, 2002, pp. 45–64.
12. A. De Santis and G. Persiano. Zero-Knowledge Proofs of Knowledge Without Interaction. Proceedings of the 43rd Annual Symposium on Foundations of Computer
Science, IEEE, 1992, pp. 427–436.
13. A. De Santis, G. Di Crescenzo, R. Ostrovsky, G. Persiano, and A. Sahai. Robust
Non-Interactive Zero Knowledge. Advances in Cryptology – Crypto 2001, LNCS
vol. 2139, J. Kilian, ed., Springer-Verlag, 2001, pp. 566–598.
14. G. Di Crescenzo, J. Katz, R. Ostrovsky, and A. Smith. Eﬃcient and NonInteractive Non-Malleable Commitment. Advances in Cryptology – Eurocrypt 2001,
LNCS vol. 2045, B. Pﬁtzmann, ed., Springer-Verlag, 2001, pp. 40–59
15. D. Dolev, C. Dwork, and M. Naor. Non-Malleable Cryptography. SIAM J. Computing 30(2): 391–437 (2000).
16. C. Dwork and M. Naor. Zaps and Their Applications. Proceedings of the 41st
Annual Symposium on Foundations of Computer Science, IEEE, 2000, pp. 283–
293.
17. C. Dwork, M. Naor, and A. Sahai. Concurrent Zero-Knowledge. Proceedings of the
30th Annual Symposium on Theory of Computing, ACM, 1998, pp. 409–418.
18. C. Dwork and A. Sahai. Concurrent Zero-Knowledge: Reducing the Need for
Timing Constraints. Advances in Cryptology – Crypto ’98, LNCS vol. 1462, H.
Krawczyk, ed., Springer-Verlag, 1998, pp. 442–457.
19. T. El Gamal. A Public-Key Cryptosystem and a Signature Scheme Based on
Discrete Logarithms. IEEE Transactions on Information Theory 31(4): 469–472
(1985).
20. U. Feige, A. Fiat, and A. Shamir. Zero-Knowledge Proofs of Identity. Journal of
Cryptology 1(2): 77–94 (1988).
21. U. Feige, D. Lapidot, and A. Shamir. Multiple Non-Interactive Zero-Knowledge
Proofs Based on a Single Random String. Proceedings of the 31st Annual Symposium on Foundations of Computer Science, IEEE, 1990, pp. 308–317.

Eﬃcient and Non-malleable Proofs of Plaintext Knowledge and Applications

225

22. Z. Galil, S. Haber, and M. Yung. Symmetric Public-Key Encryption. Advances in
Cryptology – Crypto ’85, LNCS vol. 218, H.C. Williams, ed., Springer-Verlag, 1985,
pp. 128–137.
23. J. Garay and P. MacKenzie. Concurrent Oblivious Transfer. Proceedings of the
41st Annual Symposium on Foundations of Computer Science, IEEE, 2000, pp.
314–324.
24. O. Goldreich. Foundations of Cryptography: Basic Tools. Cambridge University
Press, Cambridge, UK, 2001.
25. O. Goldreich, S. Micali, and A. Wigderson. Proofs that Yield Nothing but Their
Validity or: All Languages in NP Have Zero-Knowledge Proof Systems. JACM
38(3): 691–729 (1991).
26. L.C. Guillou and J.-J. Quisquater. A Practical Zero-Knowledge Protocol Fitted to
Security Microprocessors Minimizing Both Transmission and Memory. Advances
in Cryptology – Eurocrypt ’88, LNCS vol. 330, C.G. G¨
unther, ed., Springer-Verlag,
1988, pp. 123–128.
27. S. Haber. Multi-Party Cryptographic Computations: Techniques and Applications.
PhD Thesis, Columbia University, 1987.
28. S. Halevi and H. Krawczyk. Public-Key Cryptography and Password Protocols.
ACM Transactions on Information and System Security 2(3): 230–268 (1999).
29. J. Katz. Eﬃcient Cryptographic Protocols Preventing “Man-in-the-Middle” Attacks. PhD Thesis, Columbia University, 2002.
30. M. Naor. Deniable Ring Authentication. Advances in Cryptology – Crypto 2002,
LNCS vol. 2442, M. Yung, ed., Springer-Verlag, 2002, pp. 481–498.
31. M. Naor and M. Yung. Public-Key Cryptosystems Provably Secure Against
Chosen-Ciphertext Attack. Proceedings of the 22th Annual Symposium on Theory of Computing, ACM, 1990, pp. 427–437.
32. H. Ong and C.P. Schnorr. Fast Signature Generation With a Fiat-Shamir-Like
Scheme. Advances in Cryptology – Eurocrypt ’90, LNCS vol. 473, I. Damg˚
ard, ed.,
Springer-Verlag, 1990, pp. 432–440.
33. P. Paillier. Public-Key Cryptosystems Based on Composite Degree Residuosity
Classes. Advances in Cryptology – Eurocrypt ’99, LNCS vol. 1592, J. Stern, ed.,
Springer-Verlag, 1999, pp. 223–238.
34. M. Rabin. Digitalized Signatures and Public-Key Functions as Intractable as Factorization. Technical Report MIT/LCS/TR-212, MIT Laboratory for Computer
Science, January 1979.
35. C. Rackoﬀ and D. Simon. Non-Interactive Zero-Knowledge Proof of Knowledge
and Chosen-Ciphertext Attack. Advances in Cryptology – Crypto ’91, LNCS vol.
576, J. Feigenbaum, ed., Springer-Verlag, 1991, pp. 433–444.
36. R. Rivest, A. Shamir, and L.M. Adleman. A Method for Obtaining Digital Signatures and Public-Key Cryptosystems. Communications of the ACM 21(2): 120–126
(1978).
37. A. Sahai. Non-Malleable Non-Interactive Zero-Knowledge and Adaptive ChosenCiphertext Security. Proceedings of the 40th Annual Symposium on Foundations of
Computer Science, IEEE, 1999, pp. 543–553.
38. C.P. Schnorr. Eﬃcient Identiﬁcation and Signatures for Smart Cards. Advances in
Cryptology – Crypto ’89, LNCS vol. 435, G. Brassard, ed., Springer-Verlag, 1989,
pp. 239–252.

226

A

J. Katz

Additional Deﬁnitions

Interactive encryption. A number of approaches for deﬁning chosenciphertext security in the interactive setting are possible; we sketch one such
deﬁnition here.
We have a sender, a receiver, and an adversary M who controls all communication between them. To model this, we deﬁne an encryption oracle Eb,pk
(playing the role of the sender) and a decryption oracle Dsk (player the role
of the receiver) to which M is given access. The adversary may interact with
Eb,pk multiple times, and may arbitrarily interleave requests to this oracle with
requests to the decryption oracle. At the outset of the experiment, a bit b is
chosen at random. An instance of the adversary’s interaction with the encryption oracle proceeds as follows: ﬁrst, the adversary sends two messages m0 , m1
to Eb,pk . The oracle then executes the encryption protocol for message mb ; the
adversary, however, need not act as an honest receiver. The oracle maintains
state between the adversary’s oracle calls, and the adversary may have multiple
concurrent interactions with the oracle. When Eb,pk sends the ﬁnal message for
a given instance of its execution, we say that instance is completed.
Dsk also maintains state between oracle calls, and the adversary may again
have multiple concurrent interactions with this oracle. Furthermore, the adversary need not act as an honest sender. Each time a given decryption-instance is
completed, the decryption oracle decrypts and returns the result (i.e., a message
or ⊥) to the adversary.
The adversary succeeds if it can guess b. Clearly, some limitations must be
placed on the adversary’s access to Dsk or else the adversary may simply forward
messages between Eb,pk and Dsk and thereby trivially determine b. At any point
during the adversary’s execution, the set of transcripts of completed encryptioninstances of Eb,pk is well deﬁned. Upon completing a decryption-instance, let
S = {π1 , . . . , π } denote the transcripts of all completed encryption-instances.
We allow the adversary to receive the decryption corresponding to a decryptioninstance with transcript π only if π ∈ S.
Deﬁnition 3. Let Π = (K, E, D) be an interactive, public-key encryption
scheme. Π is CCA2-secure if, for any ppt adversary A, the following is negligible:
Pr (sk, pk) ← K(1k ); b ← {0, 1} : AEb,pk ,Dsk (1k , pk) = b − 1/2 ,
where A’s access to Dsk is restricted as discussed above.
Deniable authentication. We review the deﬁnitions of [17,16]. We have a
prover P who is willing to authenticate messages to a veriﬁer V; however, P is
not willing to allow the veriﬁer to convince a third party (after the fact) that
P authenticated anything. This is formalized by ensuring that any transcript
of an execution of the protocol can be simulated by a veriﬁer alone (without
any access to P). Furthermore, an adversary M (acting as man-in-the-middle
between P and a veriﬁer) should not be able to authenticate a message m to

Eﬃcient and Non-malleable Proofs of Plaintext Knowledge and Applications

227

the veriﬁer which P does not authenticate for M. More formally, a strong deniable authentication protocol satisﬁes the following (in addition to a standard
completeness requirement):
– Soundness. Assume P concurrently authenticates messages m1 , m2 , . . . chosen adaptively by a ppt adversary M. Then M will succeed with at most
negligible probability in authenticating a message m ∈ {m1 , . . .} to an honest
veriﬁer.
– Strong deniability. Assume P concurrently authenticates polynomiallymany messages chosen adaptively by a ppt adversary V . Then there exists
an expected-polynomial-time simulator that, given black-box access to V ,
can output a transcript indistinguishable from a transcript of a real execution
between V and P.
A relaxation of the above deﬁnition [17] allows the simulator to have access to
P when producing the simulated transcript, but P authenticates some ﬁxed sequence of messages independent of those chosen by V . We call this weak deniable
authentication. In practice, weak deniability may not be acceptable because the
protocol then leaves an undeniable record that P authenticated something (even
if not revealing what). However, P may want to deny that any such interaction
ever took place.
The notion of ε-deniability [17] requires that for any given ε > 0, there
exists a simulator whose expected running time is polynomial in k and 1/ε
and which outputs a simulated transcript such that the advantage of any polytime algorithm in distinguishing real transcripts from simulated transcripts is
negligibly close to ε.

B

Proof of Theorem 1

A sketch of the proof is given here; full details can be found in [29]. It is easy
to show that the protocol is a PPK. To prove non-malleability, consider the
following simulator: SIM1 (N, e) chooses random hash function H, runs the keygeneration algorithm for the one-time signature scheme to generate (VK , SK ),
and computes α = H(VK ). Random elements g, x ∈ Z∗N are chosen, and h is set
def

equal to g −α xe . Finally, σ = g, h, H is output along with state information
state = VK , SK, x . Note that σ output by SIM1 has the correct distribution.
Furthermore, given state, SIM2 can simulate the proof of Figure 1 for any
1/e

ciphertext: simply use veriﬁcation key VK and then the witness x = g α h
is known. The resulting simulation is perfect and is achieved without rewinding
the (potentially) dishonest veriﬁer.
Fix pk, σ, state, and randomness r for SIM2 . We are given adversary M
using (unknown) random tape r who interacts with both SIM2 (state; r) and
honest receiver R. Once the challenge q of R is ﬁxed, the entire interaction is
completely determined (recall that ciphertext C , c for which SIM2 will be
required to prove a witness, is chosen adaptively by M). Deﬁne π (q) as the

228

J. Katz

transcript of the conversation between SIM2 (state; r) and Mr when q is the
challenge sent by R; analogously, deﬁne π(q) as the transcript of the conversation
between Mr and R when q is the challenge of R.
The knowledge extractor KE ∗ is given pk, σ, state, r, and access to Mr . When
we say that KE ∗ runs Mr with challenge q we mean that KE ∗ interacts with
Mr by running algorithm SIM2 (state; r) and sending challenge q for R. We
stress that interleaving of messages (i.e., scheduling of messages to/from R and
SIM2 ) is completely determined by Mr .
KE ∗ ﬁrst picks a random value q 1 ∈ Ze and runs Mr with challenge q 1 . If
1
π(q ) is not accepting, or if π(q 1 ) = π (q 1 ), stop and output ⊥. Otherwise, let VK
denote the veriﬁcation key used by M, and let α = H(VK). Using standard rewinding techniques (see [29]), KE ∗ extracts either (1) a witness to the decryption
def

of the ciphertext C, c sent by M or (2) the value y = (g α h)1/e (or possibly
both). Further, KE ∗ runs in expected polynomial time.
To complete the proof, we need to argue that extraction of y occurs with
negligible probability (and thus KE ∗ extracts a witness to the decryption of C, c
with all but negligible probability). We ﬁrst note that, w.h.p., H(VK) = H(VK );
this follows from the security of the one-time signature scheme (so VK = VK )
def

and the universal one-way hash function. But then ∆ = α − α = 0 and
def

1/e

y = (g α h)
def

= g ∆ xe

1/e

= g∆

1/e

x,

and therefore y˜ = y/x satisﬁes y˜e = g ∆ . Note that |∆| and e are relatively prime
since ∆ ∈ (−e, e). Standard techniques allow eﬃcient computation of g 1/e .
The above shows that extraction of y enables KE ∗ to compute g 1/e and hence
invert a given RSA instance N, e, g (note that KE ∗ needs no secret information
about N, e, or g to run). So, under the RSA assumption for expected polynomialtime algorithms, extraction of y occurs with negligible probability.

