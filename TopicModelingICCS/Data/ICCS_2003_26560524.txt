A Framework for Password-Based Authenticated
Key Exchange
Extended Abstract
Rosario Gennaro and Yehuda Lindell
IBM T.J. Watson Research Center
Yorktown Heights, NY 10528, USA.
{rosario,lindell}@us.ibm.com

Abstract. In this paper we present a general framework for passwordbased authenticated key exchange protocols, in the common reference
string model. Our protocol is actually an abstraction of the key exchange
protocol of Katz et al. and is based on the recently introduced notion of
smooth projective hashing by Cramer and Shoup. We gain a number of
beneﬁts from this abstraction. First, we obtain a modular protocol that
can be described using just three high-level cryptographic tools. This
allows a simple and intuitive understanding of its security. Second, our
proof of security is signiﬁcantly simpler and more modular. Third, we
are able to derive analogues to the Katz et al. protocol under additional
cryptographic assumptions. Speciﬁcally, in addition to the DDH assumption used by Katz et al., we obtain protocols under both the Quadratic
and N -Residuosity assumptions. In order to achieve this, we construct
new smooth projective hash functions.

1

Introduction

A central problem in cryptography is that of enabling parties to communicate
secretly and reliably in the presence of an adversary. This is often achieved by
having the parties run a protocol for generating a mutual and secret session
key. This session key can then be used for secure communication using known
techniques (e.g., applying encryption and message authentication codes to all
communication). Two important parameters to deﬁne regarding this problem
relate to the strength of the adversary and the initial setup for the parties.
Adversarial power. The problem of session-key generation was initially studied
by Diﬃe and Hellman [13] who considered a passive adversary that can eavesdrop on the communication of the parties, but cannot actively modify messages
on the communication line. Thus, the parties are assumed to be connected by
reliable, albeit non-private, channels. Many eﬃcient and secure protocols are
known for this scenario. In contrast, in this paper, we consider a far more powerful adversary who can modify and delete messages sent between the parties,
A full version of this paper is available from the Cryptology ePrint Archive,
http://eprint.iacr.org/2003/032/
E. Biham (Ed.): EUROCRYPT 2003, LNCS 2656, pp. 524–543, 2003.
c International Association for Cryptologic Research 2003

A Framework for Password-Based Authenticated Key Exchange

525

as well as insert messages of its own choice. Such an adversarial attack could be
carried out by the owner of a routing server on the Internet, for example.
Setup assumptions. In order to achieve authenticated key exchange, the parties
Alice and Bob must hold some secret information. Otherwise, there is nothing
preventing an adversary from pretending to be Bob while communicating with
Alice (and vice versa). Thus, some initial setup assumption is required. Known
setup assumptions range from the case that the parties share high entropy secret
keys to the case that all they share are low entropy passwords that can be
remembered and typed in by human users. Although many secure and eﬃcient
protocols exist for the high entropy case, our understanding of the low entropy
case is far from satisfactory. This is despite the fact that the most common setup
assumption used today in practice is that of passwords.
This paper focuses on the question of password-based key exchange in the
face of a powerful, active adversary. Before proceeding further, we describe this
setting in some more detail.
Password-based authenticated key-exchange. We consider a multi-party scenario
where all pairs of parties share a password that is chosen uniformly from some
small dictionary (the assumption of uniformity is made for simplicity only).
The parties interact in a network in which an active adversary has full control
over the communication lines. Essentially, this means that the parties cannot
communicate directly with each other; rather, all communication is carried out
via the adversary. Nevertheless, the parties attempt to generate session keys
that they can then use to secretly and reliably communicate with each other.
An immediate observation is that in this scenario it is impossible to guarantee
that the adversary’s success is negligible (where success means, for example, that
it succeeds in learning the session key). This is because it can guess the password
and then impersonate Bob while communicating with Alice. If its password guess
was correct, then it clearly obtains the session key. The important point is that
because the password dictionary may be small (i.e., polynomial in the security
parameter), the success by the adversary in this naive attack may be quite
high. This type of attack is called an on-line guessing attack and is inherent
whenever security depends on low entropy passwords. The aim of password-based
authenticated key exchange is thus to limit the adversary to such an attack only.
Prior related work. The ﬁrst (unbroken) protocol suggested for password-based
session-key generation was by Bellovin and Merritt [4]. This work was very inﬂuential and became the basis for much future work in this area [5,26,19,22,
25,27]. However, these protocols have not been proven secure and their conjectured security is based on heuristic arguments. Despite the strong need for
secure password-based protocols, the problem was not treated rigorously until
quite recently.
A ﬁrst rigorous treatment of this problem was provided by Halevi and
Krawczyk [18]. They actually considered an asymmetric hybrid model in which
one party (the server) may hold a high entropy key and the other party (the

526

R. Gennaro and Y. Lindell

human) may only hold a password. The human is also assumed to have secure
access to a corresponding public-key of the server. The protocol of [18] provides
a password-based solution; however, it requires additional setup assumptions beyond that of human passwords. The ﬁrst (and only currently known) protocol
to achieve security without any additional setup is that of Goldreich and Lindell [17]. Their protocol is based on general assumptions (i.e., the existence of
trapdoor permutations) and constitutes a proof that password-based authenticated key exchange can actually be obtained. Unfortunately, the [17] protocol is
not eﬃcient and thus cannot be used in practice.
Recently, Katz, Ostrovsky and Yung (KOY) [21] presented a highly eﬃcient
protocol for the problem of password-based authenticated key-exchange in the
common reference string model. In this model, it is assumed that all parties
have access to a set of public parameters, chosen by some trusted third party.
Although this is a stronger setup assumption than where only human passwords
are shared, it is still signiﬁcantly weaker than other models that have been studied (like, for example, the Halevi–Krawczyk model). Furthermore, in practice
there are settings in which such a setup can reasonably be implemented at little cost.1 The KOY protocol is based on the Decisional Diﬃe-Hellman (DDH)
assumption and has complexity that is only 5–8 times the complexity of unauthenticated key-exchange protocols. We remark that our work was borne out of
an abstraction of the KOY protocol.
We note that password-based authenticated key-exchange protocols in the
password only setting have been presented in the random oracle model [1,6]. In
this model, all parties are assumed to have oracle access to a totally random
(universal) function [2]. The common interpretation of such results is that security is likely to hold even if the random oracle is replaced by a (“reasonable”)
concrete function known explicitly to all parties (e.g., SHA-1). However, it has
been shown that it is impossible to replace the random oracle in a generic manner with any concrete function [7]. Thus, the proofs of security of these protocols
are actually heuristic in nature.
1.1

Our Contributions

In this paper, we present a framework for password-based authenticated keyexchange protocols in the common reference string model. Our construction is an
abstraction of the KOY protocol [21] and uses non-malleable commitments [14],
one-time signature schemes and the smooth projective hash functions of Cramer
and Shoup [10]. The advantages of this abstraction are as follows:
1. The security of the resulting protocol can be intuitively understood. Our
work can thus also be seen as an “explanation” of the KOY protocol (in a
similar way to the fact that [10] can be seen as an explanation of [9]).
1

An example of where it is reasonable to assume a common reference string is when
a large organization wishes to implement secure login for its employees. In this case,
the organization is trusted to choose the common reference string properly, and this
string can then be hardwired into the software code.

A Framework for Password-Based Authenticated Key Exchange

527

2. The proof of our protocol is signiﬁcantly simpler than that of [21], although
there are deﬁnite similarities in the high-level overview of the proof (see [20]
for a full proof of the protocol of [21]). Having abstracted out the building
blocks of the protocol, the exact requirements on each element of the protocol
also become clearer. One speciﬁc result of this is that by slightly modifying
the protocol of [21], we are able to show that non-malleable commitments
suﬃce (in contrast to [21] whose proof heavily relies on the fact that they
use an encryption scheme that is secure against adaptive chosen-ciphertext
attacks (CCA2)).
3. The KOY protocol assumes the DDH assumption. We demonstrate additional instantiations of the framework and obtain password-based authenticated key-exchange protocols under both the Quadratic Residuosity and
N -Residuosity assumptions. The resulting protocol for N -Residuosity is also
highly eﬃcient. In contrast, the protocol based on Quadratic Residuosity is
less eﬃcient, but has the advantage of being based on a more standard assumption.
Before presenting our protocol, we brieﬂy (and informally) describe its components (we stress that the descriptions below are very high-level and thus are not
accurate):
Non-interactive non-malleable commitments [14]: A non-malleable commitment scheme has the property that given a commitment to a value x, it
is hard to generate a commitment to a related value y (with probability that
is greater than the a priori probability). Non-interactive non-malleable commitments are known to exist in the common reference string model [11,12].
We actually need these commitments to be perfectly binding. In the common
reference string model, such schemes can be obtained from any public-key encryption scheme that is non-malleable against chosen-plaintext attacks [12].
The common reference string for the non-malleable commitments is taken as
the common reference string for our password protocol.
Smooth projective hashing [10]: Let X be a set and L ⊂ X a language.
Loosely speaking, a hash function Hk that maps X to some set is projective
if there exists a projection key that deﬁnes the action of Hk over the subset
L of the domain X. That is, there exists a projection function α(·) that maps
keys k into their projections s = α(k). The projection key s is such that for
every x ∈ L it holds that the value of Hk (x) is uniquely determined by s and
x. In contrast, nothing is guaranteed for x ∈ L, and it may not be possible
to compute Hk (x) from s and x. A smooth projective hash function has the
additional property that for x ∈
/ L, the projection key s actually says nothing
about the value of Hk (x). More speciﬁcally, given x and s = α(k), the value
Hk (x) is uniformly distributed (or statistically close) to a random element
in the range of Hk .
An interesting feature of smooth projective hashing is that if L is an NPlanguage, then for every x ∈ L it is possible to compute Hk (x) using the
projection key s = α(k) and a witness of the fact that x ∈ L.

528

R. Gennaro and Y. Lindell

In this paper we prove another important property of smooth projective
hash functions that holds when L is a hard-on-the-average NP-language. For
a random x ∈R L, given x and s = α(k) the value Hk (x) is computationally
indistinguishable from a random value in the range of Hk (x). Thus, even if
x ∈ L, the value Hk (x) is pseudorandom, unless a witness is known. (Of
course, as described above, for x ∈ L the value of Hk (x) is statistically close
to a random element in the range of Hk .)
Our protocol uses a very simple combination of the above tools. In particular,
we deﬁne a hard-on-the-average NP-language L = {(c, m)}, where c is a nonmalleable commitment to m. (Notice that for a randomly generated commitment,
it is hard to know whether or not c is a commitment to m, even given m.) The
basic idea behind the protocol is to have the parties exchange non-malleable
commitments of the joint password and compute the session key by applying
smooth projective hash functions to these commitments. The smooth projective
hash functions that they use are based on the hard language L described above.
That is, let w be the parties’ joint password. Then, for a commitment c we have
that (c, w) ∈ L if and only if c is a commitment of the password w. An informal
(and incomplete) description of the protocol appears in Figure 1. We stress
that this protocol description is incomplete. In particular, a one-time signature
scheme and an additional exchange of a projection key and hash value should
also be included.
Security of the protocol framework: We now explain why the protocol is secure.
First, consider the case that the adversary passively eavesdrops on a protocol
execution between two parties. The security of the session key in this case is
based on the above-described property of smooth projective hash functions over
hard languages. Speciﬁcally, the adversary sees (c, s, c , s ) where c and c are
randomly generated commitments of w; in other words, (c, w), (c , w) ∈R L.
Therefore, Hk (c, w) and Hk (c , w) are pseudorandom and the generated session
key is secure. Next, assume that the adversary sends one of the parties a commitment c that it generated itself. If c is a commitment to some value w which
is not the correct password, then the statement (c, w) is not in the language L.
Therefore, by the smoothness of Hk , the part of the key Hk (c, w) is statistically
close to uniform with respect to the adversary (who only sees s and not k).
Thus, as above, the generated key meets the requirements for a secret session
key. (That is, the adversary has only a negligible advantage in distinguishing
the session key output by the parties from a uniformly distributed key that is
chosen independently of the protocol.)
The only “bad event” that can occur is if the adversary itself generates a commitment to the correct password w. In this case, we cannot say anything about
the security of the session key. However, the adversary can succeed in generating
such a commitment with only the same probability as guessing the password
outright. This is due to the non-malleability of the commitment scheme which
implies that all the “correct” commitments that the adversary sees throughout the executions do not help it in generating any new “correct” commitment.

A Framework for Password-Based Authenticated Key Exchange

529

Password-Based Session-Key Exchange
• Common reference string: a common reference string ρ for a nonmalleable non-interactive commitment scheme.
• Common input: a shared (low-entropy) password w.
• The protocol:
1. Party P1 computes a commitment c = Cρ (w) using common reference string ρ and sends it to party P2 .
2. Party P2 chooses a key k for the smooth projective hash function
(for the language L described above), and sends its projection s =
α(k) to P1 .
In addition, P2 computes another commitment c = Cρ (w) and
sends it to party P1 .
3. Party P1 chooses another key k for the smooth projective hash
function, and sends its projection s = α(k ) to P2 .
• Session key deﬁnition: Both parties compute the session key to be
Hk (c, w) ⊕ Hk (c , w).
1. P1 computes Hk (c, w) using the projection s and its knowledge of
a witness for the fact that c is a commitment to the password w (it
knows a witness because it generated c). In contrast, it computes
Hk (c , w) using its knowledge of k (and without a witness).
2. P2 computes Hk (c, w) using its knowledge of k, and Hk (c , w) using
s and its knowledge of a witness.
Fig. 1. An informal and incomplete description of the protocol framework

Thus, the adversary’s success probability is essentially limited to its probability
of guessing the password on-line.
Our constructions of smooth projective hash functions. One of the main contributions of this paper regards our use of the recently introduced notion of smooth
projective hash functions [10]. First, we ﬁnd a new and novel application of this
notion to password-based key exchange. Second, we construct new smooth projective hash functions for languages not considered by [10]. Speciﬁcally, we construct smooth projective hash functions for the language of pairs (c, m) where c
is an encryption of m by a CCA2-secure encryption scheme [14]. This suﬃces for
our protocol framework since any CCA2-secure encryption scheme can be used as
a non-interactive non-malleable commitment scheme (in the common reference
string model). The KOY protocol implicitly contains one such construction for
the encryption scheme of Cramer and Shoup based on the DDH assumption [9].
We prove this fact and then build new smooth projective hash functions for the
recent CCA2-secure encryption schemes of Cramer and Shoup [10] that are based
on the quadratic residuosity and N -residuosity assumptions. Our constructions
of these smooth projective hash functions build on the work of [10]. However,
it is important to notice the diﬀerence between their constructions and ours.

530

R. Gennaro and Y. Lindell

Consider the case of quadratic residuosity, for example. The smooth projective
hash function constructed by [10] is for the language of quadratic residues in
∗
ZN
. In contrast, our construction is for the far more involved language of pairs
of plaintexts and ciphertexts for the entire encryption scheme of [10]. We remark
that our constructions require a careful combination of ideas from both [10] and
[21].
In addition to providing new constructions, we also make some modiﬁcations
to the deﬁnition of smooth projective hash functions, as presented in [10]. We
both strengthen and weaken their deﬁnition (in diﬀerent ways) so that it sufﬁces for our application. This diﬀerent use may also open the door to further
applications.
Editorial Remark: Due to lack of space in this abstract, a number of important
sections have been omitted. Speciﬁcally, both the formal deﬁnition of passwordbased authenticated key-exchange and the proof of security for our password
protocol have been omitted (we remark that we use the deﬁnition of [1]). Also,
only one out of the three construction of smooth projective hash functions is
presented. The full version of the paper contains all of the missing material.

2

Smooth Projective Hash Functions

A central element of our new framework for password-based key exchange is the
recently introduced notion of smooth projective hashing of Cramer and Shoup
[10]. However, their precise deﬁnition actually does not suﬃce for our application.
Rather, we use a variant of their deﬁnition. In this abstract, we present only our
variant of the deﬁnition, and brieﬂy describe the diﬀerences between the two
notions. We begin by deﬁning hard subset membership problems which form the
basis for the smooth projective hash functions that are of interest to us.
Notation. The security parameter is denoted by n. For a distribution D, x ← D
denotes the action of choosing x according to D. We denote by x ∈R S the action
of uniformly choosing an element from the set S. Finally, we denote statistical
s
closeness of probability ensembles by ≡, and computational indistinguishability
c
by ≡.
Subset membership problems. Intuitively, a hard subset membership problem is
a problem for which “hard instances” can be eﬃciently sampled. More formally,
a subset membership problem I speciﬁes a collection {In }n∈N such that for
every n, In is a probability distribution over problem instance descriptions Λ.
A problem instance description deﬁnes a set and a hard language for that set.
Formally, each instance description Λ speciﬁes the following:
1. Finite, non-empty sets Xn , Ln ⊆ {0, 1}poly(n) such that Ln ⊂ Xn , and distributions D(Ln ) over Ln and D(Xn \Ln ) over Xn \Ln .

A Framework for Password-Based Authenticated Key Exchange

531

2. A witness set Wn ⊆ {0, 1}poly(n) and an NP-relation Rn ⊆ Xn × Wn . Rn and
Wn must have the property that x ∈ Ln if and only if there exists w ∈ Wn
such that (x, w) ∈ Rn .
We are interested in subset membership problems I which are eﬃciently samplable. That is, the following algorithms must exist:
1. Problem instance samplability: a probabilistic polynomial-time algorithm
that upon input 1n , samples Λ = (Xn , D(Xn \Ln ), Ln , D(Ln ), Wn , Rn ) from
the distribution of problem instances In .
2. Instance member samplability: a probabilistic polynomial-time algorithm
that upon input 1n and an instance (Xn , D(Xn \Ln ), Ln , D(Ln ), Wn , Rn ),
samples x ∈ Ln according to distribution D(Ln ), together with a witness w
for which (x, w) ∈ Rn .
3. Instance non-member samplability: a probabilistic polynomial-time algorithm that upon input 1n and an instance (Xn , D(Xn \Ln ), Ln , D(Ln ),
Wn , Rn ), samples x ∈ Xn \Ln according to distribution D(Xn \Ln ).
We are now ready to deﬁne hard subset membership problems:
Deﬁnition 1. (hard subset membership problems): Let V (Ln ) be the following
random variable: Choose a problem instance Λ according to In , a value x ∈ Ln
according to D(Ln ) (as speciﬁed in Λ), and then output (Λ, x). Similarly, deﬁne
V (Xn \Ln ) as follows: Choose a problem instance Λ according to In , a value
x ∈ Xn \Ln according to D(Xn \Ln ) (as speciﬁed in Λ) and then output (Λ, x).
Then, we say that a subset membership problem I is hard if
V (Ln )

c

n∈N

≡ V (Xn \Ln )

n∈N

In other words, I is hard if random members of Ln cannot be distinguished
from random non-members (according to the speciﬁed distributions). In order
to simplify notation, from here on we drop the subscript of n from all sets.
However, all mention of sets X and L etc., should be understood as having
being sampled according to the security parameter n.
Smooth projective hash functions. We present the notion of smooth projective
hash functions in the context of hard subset membership problems. Thus, the
sets X and L mentioned below should be thought of those derived from such a
problem. Loosely speaking a smooth projective hash function is a function with
two keys. The ﬁrst key maps the entire set X to some set G. The second key
(called the projection key) is such that it can be used to correctly compute the
mapping of L to G. However, it gives no information about the mapping of X \L
to G. In fact, given the projection key, the distribution over the mapping of X \L
to G is statistically close to uniform (or “smooth”). We now present the formal
deﬁnition.

532

R. Gennaro and Y. Lindell

Let X and G be ﬁnite, non-empty sets and let H = {Hk }k∈K be a collection
of hash functions from X to G. We call K the key space of the family. Now, let
L be a non-empty, proper subset of X (i.e., L is a language). Then, we deﬁne a
key projection function α : K × X → S, where S is the space of key projections.
Informally, the above system deﬁnes a projective hash system if for x ∈ L,
the projection key sx = α(k, x) uniquely determines Hk (x). (Ignoring issues of
eﬃciency, this means that Hk (x) can be computed given only sx and x ∈ L.)
We stress that the projection key s = α(k, x) is only guaranteed to determine
Hk (x) when x ∈ L, and nothing is guaranteed otherwise. Formally,
Deﬁnition 2. (projective hash functions): The family (H, K, X, L, G, S, α) is a
projective hash family if for all k ∈ K and x ∈ L, it holds that the value of Hk (x)
is uniquely determined by α(k, x) and x.
Of course, projective hash functions can always be deﬁned by taking α(k, x) =
k. However, we will be interested in smooth projective hash functions which
have the property that for every x ∈ X \L, the projection key sx = α(k, x),
reveals (almost) nothing about the value Hk (x). More exactly, for x ∈ L chosen
according to D(X \L), the distribution of Hk (x) given sx = α(k, x) should be
statistically close to uniform. Formally,
Deﬁnition 3. (smooth projective hash functions: Let (H, K, X, L, G, S, α) be
a projective hash family. Then, for every x ∈ X \L let V (x, α(k, x), Hk (x)) be
the following random variable: choose k ∈R K and output (x, α(k, x), Hk (x)).
Similarly, deﬁne V (x, α(k, x), g) as follows: choose k ∈R K and g ∈R G and
output (x, α(k, x), g). Then, the projective hash family (H, K, X, L, G, S, α) is
smooth if for all x ∈ X \L
V (x, α(k), Hk (x))

s

n∈N

≡ V (x, α(k), g)

n∈N

To summarize, a smooth projective hash function has the property that a projection of a key may be computed which enables the computation of Hk (x) for
x ∈ L, but gives almost no information about the value of Hk (x) for x ∈ L.
Eﬃcient smooth projective hash functions. We say that a smooth projective hash
family is eﬃcient if the following algorithms exist:
1. Key sampling: a probabilistic polynomial-time algorithm that upon input 1n
samples k ∈ K uniformly at random.
2. Projection computation: a deterministic polynomial-time algorithm that
upon input 1n , k ∈ K and x ∈ X, outputs sx = α(k, x).
3. Eﬃcient hashing from key: a deterministic polynomial-time algorithm that
upon input 1n , k ∈ K and x ∈ X, outputs Hk (x).
4. Eﬃcient hashing from projection key and witness: a deterministic
polynomial-time algorithm that upon input 1n , x ∈ L, a witness w such
that (x, w) ∈ R, and sx = α(k, x) (for some k ∈ K), computes Hk (x).

A Framework for Password-Based Authenticated Key Exchange

533

We note an interesting and important property of such hash functions. For x ∈ L,
it is possible to compute Hk (x) in two ways: either by knowing the key k (as in
item 3 above) or by knowing the projection sx of the key, and a witness for x
(as in item 4 above). This property plays a central role in our password-based
protocol.
A new property of smooth projective hash functions that we prove in this
paper is that for a randomly chosen x ∈R L the value Hk (x) is computationally
indistinguishable from a random element in the range of Hk , even when given
sx = α(k, x). This essentially implies that the two ways described above to
compute Hk (x) are the only two eﬃcient ways.
2.1

Diﬀerences from the Original Deﬁnition

As we have mentioned, our deﬁnition of smooth hashing diﬀers from the one
presented in [10]. Here we describe the main diﬀerences between the two notions:
1. The deﬁnition of hard subset membership problems in [10] relates only to
the uniform distributions over X and L, whereas we allow any samplable
distributions over L and X \L.
2. The deﬁnition in [10] requires the projection to be a function of the key only;
i.e., α : K → S. The value s = α(k) then uniquely deﬁnes the value of Hk (x)
for every x ∈ L. In contrast, we allow the projection to be element dependent.
Notice that this is a weaker requirement because smooth hashing of the
original deﬁnition always satisﬁes this condition (i.e., deﬁne α(k, x) = α(k)
for all x).
3. The original smoothness property in [10] relates to the case that the element
x is randomly chosen in X \L (according to the distribution D(X \L)). However, for our application, we need to deal with the case that x is adversarially
chosen. We therefore require smoothness with respect to every x ∈ X \L.
This is clearly a strengthening of the requirement. (We note that the notion
of -universal hashing in [10] does relate to the case of an arbitrary x ∈ X \L;
however, their notion of smooth hashing does not.)
We remark that the weakening of the projection requirement actually makes
it harder to satisfy the stronger smoothness property. This is because we
must rule out the case that the adversary ﬁnds a “bad” x such that sx reveals more than it should. Indeed, this technical diﬃculty arises in our constructions of smooth hash functions under the N -Residuosity and Quadratic
Residuosity assumptions. Fortunately, it can be shown that these “bad” x’s
are hard to ﬁnd and this suﬃces.
2.2

Our Usage of Smooth Projective Hashing

As we have mentioned, for our password protocol, we construct smooth projective
hash functions for a speciﬁc family of hard subset membership problems. In
this section we describe this family. Let C be a non-interactive non-malleable
perfectly-binding commitment scheme; such schemes are known to exist in the

534

R. Gennaro and Y. Lindell

common reference string model. We denote by Cρ (m; r) a commitment to m
using random-coins r and common reference string ρ. Such a commitment scheme
is the basis for our hard problem. Let Cρ denote the space of all strings that may
be output by the commitment scheme C when the CRS is ρ, and let M denote
the message space. We note that actually, Cρ and M must be supersets of these
spaces that are eﬃciently recognizable; the actual deﬁnition of the supersets
depends on the speciﬁc commitment scheme used; see Section 4. Next, deﬁne
the following sets:
• Xρ = Cρ × M .
• Lρ = {(c, m) | ∃r c = Cρ (m; r)}
Having deﬁned the sets Xρ and Lρ , we now proceed to deﬁne the distributions
D(Lρ ) and D(Xρ \ Lρ ). The distribution D(Lρ ) is deﬁned by choosing a random r and a message m (according to some other distribution) and outputting
(Cρ (m; r), m). In contrast, the distribution D(Xρ \Lρ ) is deﬁned by choosing a
random r and outputting (Cρ (0|m| ; r), m).2 Clearly, by the hiding property of
C, it holds that for every m, random elements chosen from D(Lρ ) are computationally indistinguishable from random elements chosen from D(Xρ \Lρ ). This
therefore constitutes a hard subset membership problem. (The witness set Wρ
and NP-relation Rρ are deﬁned in the natural way.)
To summarize, the problem instance sampler for this problem uniformly
chooses a common reference string ρ from CRS. This then deﬁnes the sets
Xρ , Lρ , Wρ and the NP-relation Rρ . Taking the distributions D(Lρ ) and D(Xρ \
Lρ ) as deﬁned above, we have that
Λ = (Xρ , D(Xρ \Lρ ), Lρ , D(Lρ ), Wρ , Rρ )
is a hard subset membership problem.
Our password-based key exchange protocol assumes the existence of a smooth
projective hash family for the problem Λ. This hash family H is indexed by the
key space K and it holds that for every k ∈ K,
Hk : Cρ × M → G
where G is a group of super-polynomial size. Let α be the key projection function.
We require that α be a function of the hash key and the commitment only. That
is,
α : K × Cρ → S
In Section 2.1, we allowed α to depend on the element x, which in this case is a
pair (c, m). In our application, m will contain the secret password and we require
that α can be computed without knowledge of the password. Therefore, α is a
function of k and c, rather than a function of k and (c, m).
2

In actuality, these distributions need to be deﬁned in a slightly diﬀerent way, due to
the dependence on the message m. However, due to lack of space in this abstract,
we slightly simpliﬁed the presentation. See the full version for details.

A Framework for Password-Based Authenticated Key Exchange

3

535

The Protocol

Our protocol below uses a non-interactive and non-malleable perfectly-binding
commitment scheme. The only known such schemes are in the common reference string (CRS) model, and we therefore write the protocol accordingly. Let ρ
denote the CRS and let Cρ (m; r) denote a commitment to the message m using
random coin tosses r and the CRS ρ. We also denote by Cρ (m) a commitment
to m using unspeciﬁed random coins. As described in Section 2.2, we use a family of smooth projective functions H = {Hk } such that for every k in the key
space K, Hk : Cρ × M → G, where M is the message space, Cρ is an eﬃciently
recognizable superset of {Cρ (m; r) | m ∈ M & r ∈ {0, 1}∗ }, and G is a group of
super-polynomial size. Recall that the key projection function α is deﬁned as a
function of K and Cρ . See Section 2.2 for more details.
We assume that there is a mechanism that enables the parties to diﬀerentiate
between diﬀerent concurrent executions and to identify who they are interacting
with. This can easily be implemented by having Pi choose a suﬃciently long
random string r and send the pair (i, r) to Pj along with its ﬁrst message. Pi
and Pj will then include r in any future messages of the protocol. We stress that
the security of the protocol does not rest on the fact that these values are not
modiﬁed by the adversary. Rather, this just ensures correct communication for
protocols that are not under attack. The protocol appears in Figure 2 on the
next page.
Motivation for the protocol. First notice that both Pi and Pj can compute the
session key as instructed. Speciﬁcally, Pi can compute Hk (c, V K ◦ w ◦ i ◦ j)
because it has the projection key s and the witness r for c. Furthermore, it can
compute Hk (c , w) because it has the key k (and therefore does not need the
witness r for c ). Likewise, Pj can also correctly compute both the hash values
(and thus the session key). Second, when both parties Pi and Pj see the same
messages (c, s, c , s ), the session keys that they compute are the same. This is
because the same hash value is obtained when using the hash keys (k and k ) and
when using the projection keys (s and s ). This implies that partnered parties
conclude with the same session key.
We now proceed to motivate why the adversary cannot distinguish a session
key from a random key with probability greater that Qsend /|D|, where Qsend
equals the number of Send oracle calls made by the adversary to diﬀerent protocol
instances and D is the password dictionary. In order to see this, notice that if
Pi , for example, receives c that is not a commitment to w by CRS ρ, then Pi ’s
session key will be statistically close to uniform. This is because Pi computes
Hk (c , w), and for c ∈ Cρ (w) we have that the statement (c , w) is not in
the language Lρ deﬁned for H (see Section 2.2). Therefore, by the deﬁnition
of smooth projective hashing, {c , w, α(k, c ), Hk (c , w)} is statistically close to
{c , w, α(k, c ), g}, where g ∈R G is a random element. The same argument holds
if Pj receives c that is not a commitment to V K ◦ w ◦ i ◦ j. It therefore follows
that if the adversary is to distinguish the session key from a random element,
it must hand the parties commitments of the valid messages (and in particular

536

R. Gennaro and Y. Lindell
F-PaKE
Common reference string: A common reference string ρ for a noninteractive and non-malleable perfectly-binding commitment scheme C.
Common private input: A password w = wi,j .
Messages:
1. Party Pi chooses a key-pair (V K, SK) from a one-time signature
scheme, generates a commitment c = Cρ (V K ◦ w ◦ i ◦ j; r), and sends
(V K, c) to Pj .
2. Party Pj receives (V K, c), and checks that c is of the proper format
(i.e., c ∈ Cρ as deﬁned in Section 2.2). If yes, then, Pj does the following:
a) Choose two keys k and ktest for the smooth projective hash function family H deﬁned in Section 2.2 and compute the projections
s = α(k, c) and stest = α(ktest , c).
b) Generate a commitment c = Cρ (w; r ).
Pj sends (s, c , stest ) to Pi .
3. Pi receives (s, c , stest ), checks that c ∈ Cρ , and does the following:
a) Choose a key k for H and compute the projection s = α(k , c ).
b) Compute the signature σ = SignSK (s, s ).
c) Compute the hash htest = Hktest (c, V K ◦ w ◦ i ◦ j) using the projection key stest and the witness r.
Pi then sends (s , σ, htest ) to Pj .
Session-Key Deﬁnition:
– Pi computes sk = Hk (c, V K ◦ w ◦ i ◦ j) + Hk (c , w), where addition
is in the group G. (Note that Pi computes the ﬁrst element using the
projection key s and the witness r.)
– Pj checks that the following two conditions hold:
1. htest = Hktest (c, V K ◦ w ◦ i ◦ j)
2. VerifyV K ((s, s ), σ) = 1.
If at least one of the above conditions does not hold, then Pj aborts
(setting acc = 0). Otherwise, Pj computes sk = Hk (c, V K ◦ w ◦ i ◦
j) + Hk (c , w). (Note that the second element is computed using the
projection key s and the witness r ).
Session-Identiﬁer Deﬁnition: Both parties take the series of messages
(c, s, c , s ) to be their session identiﬁers.
Fig. 2. A framework for Password Based Key Exchange

containing the correct passwords). One way for the adversary to do this is to
copy (valid) commitments that are sent by the honest parties in the protocol
executions. However, in this case, the adversary does not know the random
coins used in generating the commitment, and once again the result of the hash
function is pseudorandom in G. This means that the only option left to the

A Framework for Password-Based Authenticated Key Exchange

537

adversary is to come up with valid commitments that were not previously sent by
honest parties. However, by the non-malleability of the commitment scheme, the
adversary cannot succeed in doing this with probability non-negligibly greater
than just a priori guessing the password. Since it eﬀectively has Qsend password
guesses, its success probability is limited to Qsend /|D| + negl(n). We remark that
the value htest constitutes a test that c is a valid commitment; this is included
to ensure that Pj rejects in case it receives an invalid commitment c. This is
needed in the proof.
We note one more important point regarding the protocol. Based on the
above explanation, one may wonder why it does not suﬃce to exchange c and
s only, without the second exchange of c and s . The need for this additional
exchange is best demonstrated with the following “attack”. Assume that the
parties only exchange c and s. Then, the adversary A can interact with Pi and
obtain the commitment c. Next, A chooses k and returns s = α(k, c) to Pi .
Now, if the session key was deﬁned to be Hk (c, w), then A can distinguish this
from random as follows. By traversing the dictionary D with all possible w’s,
A can compile a list of all |D| possible candidates for the session key (A can
do this because it knows k and so can compute Hk (c, w) without a witness for
c). Since D may be small, this enables A to easily distinguish the session key
from random. This problem is overcome, however, by having the parties repeat
the commitment/projection exchange in both directions. We have the following
theorem:
Theorem 1. Assume that C is a non-interactive and non-malleable perfectlybinding commitment scheme that is secure under multiple commitments, and
assume that H is a family of smooth projective hash functions. Then, Protocol
F-PaKE in Figure 2 is a secure password-based session-key generation protocol.
The proof of Theorem 1 appears in the full version of the paper. Our proof of
security diﬀers from the proof of [21] in a number of ways. First, our proof is
based on more generic primitives and is therefore more modular. Second, our
proof holds for the case that the parties commit to their passwords etc. using a
non-malleable commitment scheme. In contrast, the proof of [21] requires that
the parties “commit” using a CCA2-secure encryption scheme. In particular,
their proof uses the capability of decryption in an essential way, whereas ours
does not.
Using CCA2-encryption instead of non-malleable commitments. If a CCA2encryption scheme is used to implement the non-malleable commitments, then
the stest and htest values can be removed from the protocol, improving the eﬃciency. The proof of the security of the protocol with this modiﬁcation is actually
very diﬀerent from our proof of Theorem 1, and is quite similar to the proof
of [21]. This version of the protocol has the advantage of being slightly more
eﬃcient.
Protocol F-PaKE and the protocol of KOY [21]. Consider the above-mentioned
modiﬁcation of the protocol that relies on CCA2 encryption. Then, a protocol
almost identical to that of [21] is obtained by using the CCA2-encryption scheme

538

R. Gennaro and Y. Lindell

of Cramer and Shoup [9] that is based on the DDH assumption. Indeed, as we
have mentioned, our protocol framework was obtained through an abstraction
of [21].

4

Encryption Schemes with Smooth Projective Hashing

As we discussed in Section 2.2, the underlying language for the hard subset membership problem that we refer to is the language of pairs (c, m) where c = Cρ (m).
However, in all our speciﬁc instantiations of the protocol, we use a CCA2-secure
encryption scheme for the non-malleable commitment. Thus, in the context of
our protocol, the common reference string ρ is deﬁned to be the public-key pk
of the encryption scheme, and a commitment to m is deﬁned as an encryption
Epk (m).
In the full paper, we construct smooth projective hash functions for all three
CCA2-secure encryption schemes proposed by Cramer and Shoup in [9,10]. The
smooth hashing for the DDH-based scheme from [9] was already implicitly described in the KOY protocol [21]. We explicitly deﬁne the construction and
prove that it constitutes a smooth projective hash family. Furthermore, we construct new smooth projective hash functions for the CCA2-schemes based on
the Quadratic Residuosity and N -Residuosity Assumptions presented in [10].
In this abstract we only present the construction based on the N -residuosity
assumption.
4.1

A Relaxed Notion of Smooth Projective Hashing

The smooth projective hash functions we present do not satisfy the deﬁnition
we presented in Section 2 but rather a relaxed deﬁnition.3 This weaker notion is
still suﬃcient to prove the security of our password-based key exchange protocol.
The relaxation here involves modifying the stronger smoothness condition as
deﬁned in Section 2. Informally speaking, we no longer require that the smoothness condition hold for all values x ∈ X \L. Rather, we deﬁne a subset ∆ ⊂ X \L
in which the smoothness property may not hold. However, we require that it is
computationally hard to ﬁnd any element in ∆. This suﬃces because the result is
that a computationally bound adversary cannot produce any “bad” elements for
which the smoothness property will not hold. Formally, we say that the family
H is a weak smooth projective hash family if the stronger smoothness condition
is replaced by the following two conditions:
1. There exists a subset ∆ ⊂ X \L which is hard to sample, i.e. for all probabilistic polynomial-time Turing Machines A
Pr[A(1n , X, L) ∈ ∆] < negl(n)
Furthermore, it is easy to verify membership in ∆. That is, there exists a
probabilistic polynomial-time Turing Machine T such that for every x ∈ ∆,
3

We remark that the smooth projection hash functions for the encryption scheme
based on the DDH assumption do satisfy the stricter original deﬁnition.

A Framework for Password-Based Authenticated Key Exchange

539

Pr[T (X, L, x) = 1] > 1 − negl(|x|) and for every x ∈ ∆, Pr[T (X, L, x) = 1] <
negl(|x|);
2. For every x ∈ X \ (∆ ∪ L):
V (x, α(k, x), Hk (x))

s

n∈N

≡ V (x, α(k, x), g)

n∈N

The random variable V is deﬁned in Section 2.
In other words, the strong smoothness property only holds for values x ∈
/ ∆. In
particular, it may be possible to distinguish Hk (x ) from a random g for x ∈ ∆.
This would be worrisome were it not for the ﬁrst condition above that tells us
that the probability that the adversary will ﬁnd such an x ∈ ∆ is negligible.
4.2

The Cramer-Shoup Scheme Based on N -Residuosity

This construction is for the Cramer-Shoup CCA2-secure encryption scheme
∗
based on the hardness of deciding N -residuosity in ZN
2 [10]. This assumption
was originally introduced by Paillier in [24]. We describe a small variation of
the original Cramer-Shoup scheme, which can easily be proven secure using the
same techniques used in [10].
Let N = pq be the product of two safe primes, i.e. p = 2p +1 and q = 2q +1,
with p , q prime as well. Let N = p q . Assume w.lo.g. that q < p and that
|q | = |p | = poly(n) > 2n where n is the security parameter.
∗
Consider the group ZN
2 ; its order is 4N N . Let’s consider the subgroup JN
∗
of ZN 2 which contains all the elements whose Jacobi symbol with respect to N
is 1. It is not hard to see that JN is cyclic, has order 2N N and can be written
as the direct product of three cyclic subgroup JN = G · G1 · G2 where G is the
subgroup of JN which contains all the (2N )-residues. Clearly G has order N .
On the other hand G1 is a group of order N and G2 is the group generated by
(−1). Denote G = G · G2 . See [10] for details.
∗
A generator g for G can be found by selecting µ ∈R ZN
2 and setting g =
2N
−µ . It is not hard to see that this results in a generator with overwhelming
probability, and that the distribution is statistically close to uniform over all
generators of G . Clearly g 2 will then be a generator for G.
The N -residuosity assumption says that it’s hard to distinguish between
∗
2
a random element of ZN
2 and a random N -residue mod N . The following
encryption scheme is CCA2-secure under this assumption.
A preliminary Lemma. Before describing the scheme we prove a technical Lemma
that will be useful later in the construction of the smooth projective hash function for it. The Lemma states that, if factoring is hard, it is computationally
infeasible to ﬁnd elements of “low” order in the group G.
Lemma 1. Let N = pq, with p = 2p + 1, q = 2q + 1 and p, q, p , q all distinct
primes. Let g be a generator of G as above and let h = (g )z mod N , with
h = ±1. If GCD(z, N ) > 1 then GCD(h ± 1, N ) > 1.
We now describe the scheme.

540

R. Gennaro and Y. Lindell

Key Generation. Randomly choose the secret key z, z˜, zˆ ∈ [0..N 2 /2] and publish
˜ = g z˜ and h
ˆ = g zˆ. We assume w.l.o.g that h = 1 and
the public key h = g z , h
GCD(˜
z , N ) = 1 since the opposite happens only with negligible probability.
The public key also includes a universal one-way hash function [23] H which
maps inputs to ZN .
Encryption. To encrypt a message m ∈ ZN , choose r ∈R [0..N/4] and compute
˜h
ˆ θ )r , where θ = H(u, e) and the function
u = g r , e = (1 + mN )hr and v = (h
· is deﬁned as v = v if v ≤ N 2 /2 and v = N 2 − v otherwise4 .
Decryption. We describe the decryption mechanism for completeness. Given a
ciphertext (u, e, v) the receiver checks that v ≤ N 2 /2, then computes θ = H(u, e)
and checks if v 2 = u2(˜z+θzˆ) . If either test fails it outputs “?”, otherwise let
˜ = (1 + mN ) for some m, output m, otherwise output “?”.
m
˜ = eu−z . If m
A smooth projective hash function. We deﬁne a smooth projective hashing for
this encryption scheme, by specifying the sets X, L, K, the projection function
α, and the hash function Hk . In order to deﬁne the set C (that must be an
eﬃciently recognizable superset of all possible ciphertexts; see Section 2.2), we
ﬁrst deﬁne the notion of a proper ciphertext: A ciphertext c = (u, e, v) is called
proper if u, e, v all have Jacobi symbol equal to 1, with respect to N . Also given
˜h
ˆ θ = 1 then v = 1 as well. We now deﬁne X =
θ = H(u, e), we require that if h
{(c, m)}, where c is any proper ciphertext and m is any message. Observe that
proper ciphertexts can be easily recognized, as required. As deﬁned in Section 2.2,
the language L is the subset of X where c is an encryption of m with publickey pk.
The key space is [0..2N N ]3 i.e. the key for a hash function is k = (a1 , a2 , a3 )
such that ai ∈R [0..2N N ]. However this space is not eﬃciently samplable so
we replace it with [0..N 2 /2]. The uniform distribution over [0..N 2 /2] is statistically close to the uniform one over [0..2N N ]. The description of the family
also includes a hash function U H randomly chosen from a 2-universal family.
U H : JN −→ {0, 1}n .
Given an input x = (c, m) = ((u, e, v), m) the projection function is deﬁned
by
˜h
ˆ θ )2a3
sx = α(k, x) = g 2a1 h2a2 (h
˜ h)
ˆ constitutes the public key and θ = H(u, e).
where (g, h, h,
Given an input x = (c, m) = ((u, e, v), m) the hash function is deﬁned as
Hk (x) = U H[fk (x)] where
fk (x) = u2a1

e
1 + mN

2a2

v 2a3

Notice that if c is a correct encryption of m under key pk, then fk (x) = srx ,
where r is the randomness used to construct c. Thus, it is possible to compute
Hk (x) given only the projection and the witness, as required.
4

The full version explains why the absolute value function

·

is needed.

A Framework for Password-Based Authenticated Key Exchange

541

We need to prove the smoothness property. Consider x = (c, m) ∈ X \L; i.e.,
c = (u, e, v) is a proper ciphertext, but is not a correct encryption of m using the
˜ h).
ˆ Let θ = H(u, e) and consider λ = z˜ + θˆ
public key (g, h, h,
z mod N . Notice
˜h
ˆ θ )2 = g 2λ .
that we can write (h
We are going to prove that Hk is a weak smooth projective hash. Thus we
need to deﬁne a set ∆ of commitments for which the smoothness property may
not hold, but such that ﬁnding an element in ∆ is infeasible. We say that a
commitment is in ∆ if GCD(λ, N ) = 1, N . Lemma 1 shows that producing a
commitment with this property is equivalent to factoring N . It also shows how
˜h
ˆ θ )2 ±1, N ) is a non-trivial
to easily recognize such elements (just test if GCD((h
factor of N ). From now on, we assume to be outside of ∆.
˜h
ˆ θ )2 is diﬀerent than 1, then it is also a generator for G.
By assumption, if (h
2
2
Notice that g and h are also generators of G, thus we can write the commitment
˜h
ˆ θ )2 ]r3
as u = (−1)b1 γ1 (g 2 )r1 , e = (−1)b2 γ2 (h2 )r2 (1 + mN ) and v = (−1)b3 γ3 [(h
where γi ∈ G1 . Notice that in the computation of Hk (x) the (−1) components
are irrelevant since we raise each term to the power 2a. So we ignore them from
now on.
Consider now the equation in the ai ’s deﬁned by the projection sx . Notice
that sx ∈ G since we are squaring each term. Therefore:
logg2 sx = a1 + za2 + λa3 mod N

(1)

Let us distinguish two cases:
• There exists γi = 1. Then we have that fk (x) = (γi2 )ai · σ for some σ ∈ JN .
Let [a1 , a2 , a3 ] be a solution of Equation (1), mod N . Consider the set of
keys obtained as
Aa1 ,a2 ,a3 = [a1 + d1 N , a2 + d2 N , a3 + d3 N ]
for di ∈ [0..2N − 1]. Given sx the key k is uniformly distributed in the union
over all [a1 , a2 , a3 ] which are solutions of Eq. (1) of the sets Aa1 ,a2 ,a3 . Let’s
focus on one speciﬁc set Aa1 ,a2 ,a3 . Recall that γi ∈ G1 and γi = 1 so its order
is either p, q, N . Since 2 is co-prime with these values, the order of γi2 is the
same as the one of γi . And since GCD(N, N ) = 1 we have that keys of the
form ai + di N map (γi2 )ai +di N uniformly over the group generated by γi .
In conclusion, given sx the value (γi2 )ai and consequently fk (x), can be
guessed with probability at most 1/q.
• γi = 1 for all i = 1, 2, 3. Then fk (x) is an element of G and thus its discrete log with respect to g 2 deﬁnes another equation in the ai ’s (recall that
GCD(2, N ) = 1 thus 2−1 is well deﬁned mod N ):
2−1 logg2 fk (x) = r1 a1 + r2 za3 + r3 λa3 mod N

(2)

We want to prove that Equations (1) and (2) are “linearly independent”, i.e.
the 2 × 3 matrix of the coeﬃcients of these equations in the ai ’s has at least
one 2 × 2 minor whose determinant is non-zero mod N .

542

R. Gennaro and Y. Lindell

Since c is not a correct commitment to m then we must have that either
r2 = r1 or r3 = r1 . Then the corresponding minors have determinant z(r2 −
r1 ) and λ(r3 − r2 ). Since z and λ are co-prime with N (recall that we
are outside of ∆), we have that at least one of these minors has non-zero
determinant.
If this determinant is invertible mod N , then it is easy to see that fk (x)
is uniformly distributed over G given sx .
Assume now that both determinants are non-invertible. Then it must be
that both r2 − r1 and r3 − r1 are multiples of either p or q . Assume w.l.o.g.
that r2 = r1 + γ2 p and r3 = r1 + γ3 q (the argument is the same if you switch
p and q ). Then the corresponding minor has determinant zλ(r3 − r2 ) which
is invertible mod N . Thus again fk (x) is uniformly distributed over G given
sx .
Finally we are left with the case in which r2 = r1 + γ2 p and r3 = r1 +
γ3 p (again w.l.o.g. since the argument is the same for q ). This means that
Equations (1) and (2) are linearly dependent mod p but they must be linearly
independent mod q (recall that either r2 = r1 or r3 = r1 mod N ). Thus
logg fk (x) is uniformly distributed mod q .
In any case we can bound the probability of guessing Hk (x) given sx ,
with 1/q .
In conclusion we have that given sx the value fk (x) can be guessed with probability at most 1/q < 2−2n by choice of the security parameter. Applying the
properties of 2-universal hash functions we have that the distribution of Hk (x)
is 2−n/3 close to uniform over {0, 1}n .
Acknowledgements. We are grateful to both Jonathan Katz and Victor Shoup
for answering our questions about their respective papers [21] and [10]. We also
thank Jonathan for some helpful comments on the presentation.

References
1. M. Bellare, D. Pointcheval and P. Rogaway. Authenticated Key Exchange Secure
Against Dictionary Attacks. In Eurocrypt 2000, Springer-Verlag (LNCS 1807),
pages 139–155, 2000.
2. M. Bellare and P. Rogaway. Random Oracles are Practical: A Paradigm for Designing Eﬃcient Protocols. In 1st Conf. on Computer and Communications Security,
ACM, pages 62–73, 1993.
3. M. Bellare and P. Rogaway. Entity Authentication and Key Distribution. In
CRYPTO’93, Springer-Verlag (LNCS 773), pages 232–249, 1994.
4. S. M. Bellovin and M. Merritt. Encrypted Key Exchange: Password based protocols secure against dictionary attacks. In Proceedings 1992 IEEE Symposium on
Research in Security and Privacy, pages 72–84. IEEE Computer Society, 1992.
5. S. M. Bellovin and M. Merritt. Augmented encrypted key exchange: A passwordbased protocol secure against dictionary attacks and password ﬁle compromise. In
Proceedings of the 1st ACM Conference on Computer and Communication Security,
pages 244–250, 1993.

A Framework for Password-Based Authenticated Key Exchange

543

6. V. Boyko, P. MacKenzie and S. Patel. Provably Secure Password-Authenticated
Key Exchange Using Diﬃe-Hellman. In Eurocrypt 2000, Springer-Verlag (LNCS
1807), pages 156–171, 2000.
7. R. Canetti, O. Goldreich, and S. Halevi. The Random Oracle Methodology, Revisited. In 30th STOC, pages 209–218, 1998.
8. R. Canetti and H. Krawczyk. Analysis of Key-Exchange Protocols and Their Use
for Building Secure Channels. In Eurocrypt 2001, Springer-Verlag (LNCS 2045),
pages 453–474, 2001.
9. R. Cramer and V.Shoup. A practical public-key cryptosystem secure against adaptive chosen ciphertexts attacks. In CRYPTO’98, Springer-Verlag (LNCS 1462),
pages 13–25, 1998.
10. R. Cramer and V.Shoup. Universal Hash Proofs and a Paradigm for Adaptive
Chosen Ciphertext Secure Public-Key Encryption. In Eurocrypt 2002, SpringerVerlag (LNCS 2332), pages 45–64, 2002.
11. G. Di Crescenzo, Y. Ishai, and R. Ostrovsky. Non-Interactive and Non-Malleable
Commitment. In 30th STOC, pages 141–150, 1998.
12. G. Di Crescenzo, J. Katz, R. Ostrovsky and A. Smith. Eﬃcient and Non-interactive
Non-malleable Commitment. In Eurocrypt 2001, Springer-Verlag (LNCS 2045),
pages 40–59, 2001.
13. W. Diﬃe and M.E. Hellman. New Directions in Cryptography. IEEE Trans. on
Inf. Theory, IT-22, pp. 644–654, Nov. 1976.
14. D. Dolev, C. Dwork and M. Naor. Non-malleable Cryptography. SIAM Journal of
Computing, 30(2):391–437.
15. C. Dwork. The non-malleability lectures. Course notes for CS 359, Stanford University, Spring 1999. Available at: theory.stanford.edu/∼gdurf/cs359-s99.
16. O. Goldreich. Foundations of Cryptography – Basic Tools. Cambridge University
Press. 2001.
17. O. Goldreich and Y. Lindell. Session Key Generation using Human Passwords
Only. In CRYPTO 2001, Springer-Verlag (LNCS 2139), pages 408–432, 2001.
18. S. Halevi and H. Krawczyk. Public-Key Cryptography and Password Protocols.
In ACM Conference on Computer and Communications Security, 1998.
19. D.P. Jablon. Strong password-only authenticated key exchange. SIGCOMM Computer Communication Review, 26(5):5–26, 1996.
20. J. Katz. Eﬃcient Cryptographic Protocols Preventing “Man-in-the-Middle” Attacks. Ph.D. Thesis, Columbia University, 2002.
21. J. Katz, R. Ostrovsky and M. Yung. Practical Password-Authenticated Key Exchange Provably Secure under Standard Assumptions. In Eurocrypt 2001, SpringerVerlag (LNCS 2045), pp. 475–494, 2001.
22. S. Lucks. Open key exchange: How to defeat dictionary attacks without encrypting
public keys. In Proceedings of the Workshop on Security Protocols, Ecole Normale
Superieure, 1997.
23. M. Naor and M. Yung. Universal One-Way Hash Functions and their Cryptographic Applications. In 21st STOC, pages 33–43, 1989.
24. P. Paillier. Public-Key Cryptosystems based on Composite Degree Residue Classes.
In EUROCRYPT’99, Springer-Verlag (LNCS 1592), pages 223–228, 1999.
25. S. Patel. Number theoretic attacks on secure password schemes. In Proceedings of
the 1997 IEEE Symposium on Security and Privacy, pages 236–247, 1997.
26. M. Steiner, G. Tsudik and M. Waidner. Reﬁnement and extension of encrypted
key exchange. ACM SIGOPS Oper. Syst. Rev., 29(3):22–30, 1995.
27. T. Wu. The secure remote password protocol. In 1998 Internet Society Symposium
on Network and Distributed System Security, pp. 97–111, 1998.

