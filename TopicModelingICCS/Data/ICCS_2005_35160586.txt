An Algebraic Method for Analyzing Open-Loop
Dynamic Systems
W. Zhou, D.J. Jeﬀrey, and G.J. Reid
Department of Applied Mathematics, The University of Western Ontario,
London, Ontario, Canada N6A 5B7

Abstract. This paper reports on the results of combining the Maple
packages Dynaflex and RifSimp. The Dynaflex package has been
developed to generate the governing dynamical equations for mechanical systems; the RifSimp package has been developed for the symbolic
analysis of diﬀerential equations. We show that the output equations
from Dynaflex can be converted into a form which can be analyzed by
RifSimp. Of particular interest is the ability of RifSimp to split a set
of diﬀerential equations into diﬀerent cases; each case corresponds to a
diﬀerent set of assumptions, and under some sets of assumptions there
are signiﬁcant simpliﬁcations. In order to allow RifSimp to conduct its
analysis, the governing equations must be converted from trigonometric
form into a polynomial form. After this is done, RifSimp can analyze
the system and present its results either graphically, or in list form. The
mechanical systems considered are restricted to open-loop systems, because at present, closed-loop systems require too much computation by
RifSimp to permit analysis.
Keywords: Dynaflex, RifSimp, Case Splitting, Symbolic Simpliﬁcation, Graph Theory, Computer Algebra.

1

Introduction

A principal goal of multibody dynamics is the automatic generation of the equations of motion for complex mechanical systems [1]. Numerically based programs
exist, for example Adams, James and Working Model, that can generate the
governing equations [2]; they are commercial programs and are in widespread
use in the automotive, aerospace and robotics industries [3]. However, being
numerically based programs they have several drawbacks.
– It is diﬃcult to check the equations of motion, because they are represented
by large volumes of numerical data.
– One cannot develop any physical insight.
– Closed-form solutions for the numerical equations are not possible.
– When used for simulations, they are ineﬃcient because the equations are
eﬀectively re-assembled at each time step, and this may include many multiplications by 0 and 1.
V.S. Sunderam et al. (Eds.): ICCS 2005, LNCS 3516, pp. 586–593, 2005.
c Springer-Verlag Berlin Heidelberg 2005

An Algebraic Method for Analyzing Open-Loop Dynamic Systems

587

An alternative approach to equation generation uses symbolic processing.
Dynaflex (http://real.uwaterloo.ca/~dynaflex/) is a Maple package that
generates the equations of motion for a mechanical system from an input description based on a graph-theoretic method [4]. The equations are in a completely
analytical form, and this oﬀers several advantages [5].
– The structure of the equations is easily obtained and manipulated, giving
the user a physical insight into the system.
– The equations can be easily exchanged with other groups of engineers or
design groups.
– Real-time simulations are facilitated.
The symbolic models generated by Dynaflex are usually too complex to
be solved symbolically, but there is still the possibility of symbolically preprocessing the output of Dynaflex before attempting a solution. The purpose
of this paper is to apply the package RifSimp to this task. The RifSimp package
analyzes ODE- and PDE-systems and returns canonical diﬀerential forms. The
basic form is Reduced Involutive Form (RIF), and the package has the following
features [6]:
– Computation with polynomial nonlinearities.
– Advanced case splitting capabilities for the discovery of particular solution
branches with desired properties.
– A visualization tool for the examination of the binary tree that results from
multiple cases.
– Algorithms for working with formal power series solutions of the system.
When RifSimp is applied to an equation system, it identiﬁes special cases
during the reduction. The analysis of the system then splits according to the
special cases. In a full case analysis, some cases can be very complicated while
others are simple enough to be analytically solvable. The canonical form generated by RifSimp is of low (0 or 1) diﬀerential index, which is suitable for the
application of numerical solvers (whereas the output of Dynaflex may not have
been suitable). An important option with RifSimp is the possibility of excluding
special cases that are known to be not of interest. Thus if RifSimp detects a
special case, say m = 0, but we know that this is of no physical interest, then
we can pass this information to RifSimp as an inequation m = 0 appended to
the input system.
1.1

Open-Loop and Closed-Loop Systems

The problems addressed by Dynaflex can be separated into two classes: openloop systems and closed-loop systems. The terminology comes from the graphtheoretic method which is the basis of Dynaflex. The example in the next
section will show the basic graph-theory method. For the present, we can note
that an open-loop system corresponds to a system such as a robot arm, in which
several components, such as joints and arm segments, are joined together in a
conﬁguration that terminates at a free end. This is in contrast to a framework,

588

W. Zhou, D.J. Jeﬀrey, and G.J. Reid

such as a four-bar mechanism, in which the components connect back to the
structure being considered.
When a structure forms a closed loop, then Dynaflex will generate constraint equations that describe the drop in the degrees of freedom that accompanies the closing of a loop. From the point of view of this paper, we have
discovered that the RifSimp package takes a great deal of time and memory to
analyze closed-loop systems, but can make good progress with open-loop ones.
This is what is reported here.

2

Example System Analysed Using Dynaflex

In order to keep the examples within printable limits, we shall use a simple
spinning top as an example. A top is an axisymmetric body that spins about its
body-ﬁxed symmetry axis. It can precess about a vertical (Z) axis, and nutate
about the rotated X axis. Figure 1 shows gravity acting in the −Z direction.
The center of mass is located at C, and the spinning top is assumed to rotate
without slipping on the ground; this connection is modelled by a spherical (balland-socket) joint at O. The joint coordinates at O are represented by Euler
angles (ζ, η, ξ), in the form of 3-1-3 Euler angles, meaning that they correspond
to precession, nutation, and spin, respectively.
2.1

The System Graph

The system graph for the top is shown in Figure 2. The graph consists of nodes
and edges. The nodes correspond to centres of coordinates, while the edges describe the system. Thus in the ﬁgure, we see nodes labelled 1,2,3 which are
connected by edges e1, e2, e3,e4.
Node (1) can be thought of as the datum, or ground, on which the system
is resting. Nodes (2) and (3) denote the top. The geometric fact that the top is
connected to the ground is described by the edge e2, connecting node 1 to node
2. The fact that the top is free to spin, but not free to slide is described by e2
being speciﬁed as a spherical joint (one can think of a ball in a socket). The fact

g

Z
C

m1g

O

Y

X

Fig. 1. The three-dimensional top. The centre of mass is at C and OC= l. The mass is
here denoted m1, giving a gravitational force equal to m1g acting in the −Z direction

An Algebraic Method for Analyzing Open-Loop Dynamic Systems

589

3

e3
2
e1

e4

e2
1
Datum
Fig. 2. The graph-theoretic method for the top

that the body is a top is described by edge e1 being speciﬁed as a rigid body
with a diagonal moment of inertia. The position of the centre of mass is speciﬁed
by e3, which formally is a rigid-arm element. Finally, gravity is deﬁned by e4,
being a force element.
It is important to note that the graph consisting of {e2, e3} is denoted by
heavy lines, whereas elements e1 and e4 are drawn in light lines. The elements
{e2,e3} correspond to the open loop referred to above.
2.2

Maple Input File

The Maple input ﬁle corresponding to the above system is as follows.
NOofedges:=4; NOofnodes:=3; Datum:=1;
#Note that Datum stands for the ground node.
edge[1]:=table([(1)=N, (2)=[1,3], (3)=BE_R,
(4)=table([inert=[[x,0,0], [0,y,0], [0,0,z]], mass=c ])]);
edge[2]:=table([(1)=Y, (2)=[1,2], (3)=JE, (4)=SPH ]);
edge[3]:=table([(1)=Y, (2)=[3,2], (3)=AE_R,
(4)=table([coords=[0,0,c] ])]);
edge[4]:=table([(1)=N, (2)=[1,3], (3)=FDE,
(4)=table([type=PD, fz=-m1*g, force=gl ])]);
Iedge:=[];
2.3

The Symbolic Equations

The equations produced by Dynaflex from the above input ﬁle are presented
below. By default, Dynaflex assigns its own notation for quantities such as Euler angles, moments of inertia, etc. Although Dynaflex notation is convenient
of its internal programming, it results in equations which are diﬃcult, and even
ugly, to read when printed out for human use. Therefore we have edited the raw
Dynaflex output format to simplify the notation to bring it in line with what
human readers are used to seeing. The centre of mass is a distance l from the
point of contact, the mass is m, the moment of inertia about the symmetry axis
is C, and about a perpendicular axis is A. The Euler angles are given above.

590

3

W. Zhou, D.J. Jeﬀrey, and G.J. Reid

¨ cos2 η(t) + C ξ(t)
¨ cos η(t) − Aζ(t)
¨ cos2 η(t) − C η(t)
˙ sin η(t)
C ζ(t)
˙ ξ(t)
˙ sin η(t) cos η(t) + 2Aη(t)
˙ sin η(t) cos η(t) + Aζ(t)
¨ =0,
−2C η(t)
˙ ζ(t)
˙ ζ(t)
2
˙
˙
˙
−mg sin η(t) − Aζ (t) sin η(t) cos η(t) + A¨
η (t) + C ξ(t)ζ(t) sin η(t)

(1)

+C ζ˙ 2 (t) sin η(t) cos η(t) = 0 ,
¨ − ζ(t)
¨ cos η(t) + η(t)
˙ sin η(t)) = 0 .
−C(−ξ(t)
˙ ζ(t)

(2)
(3)

Automatic Symbolic Simplification Using RifSimp

The package RifSimp can process systems of polynomially nonlinear PDEs with
dependent variables u1 , u2 , . . . un , which can be functions of several independent
variables. For the present application the only independent variable is time. The
variables ui can obey diﬀerential equations of varying order. RifSimp takes as
its input a system of diﬀerential equations and a ranking of dependent variables
and derivatives. RifSimp orders the dependent variables lexicographically1 and
the derivatives primarily by total derivative order:
u1 ≺ u2 ≺ ... ≺ un ≺ u1 ≺ u2 ≺ ... ≺ un ≺ u1 ≺ ...

(4)

Then equations are classiﬁed as being either leading linear (i.e. linear in their
highest derivative with respect to the ordering ≺) or leading nonlinear (i.e. nonlinear in their highest derivative).
RifSimp proceeds by solving the leading linear equations for their highest
derivatives until it can no longer ﬁnd any such equations. Leading nonlinear
equations (the so-called constraints), are treated by methods involving a combination of Gr¨
obner Bases and Triangular Decomposition. It diﬀerentiates the
leading nonlinear equations and then reduce them with respect to the leading
linear equations. If zero is obtained, it means the equation is included in the ideal
generated by the leading linear equations. If not, it means that this equation is
a new constraint to the system. This is repeated until no new constraints are
found.
Theorem: (Output RifSimp form)
If v is a list of derivatives and w is a list of all derivatives (including dependent
variables) lower in ranking than v, then the output of RifSimp has the structure
v = f (t, w)

(5)

subject to a list of constraint equations and inequations
g(t, w) = 0,

h(t, w) = 0

(6)

Proof. See [6] and references therein.
1

Readers who are not familiar with the ideas of term ordering in polynomial
systems can read this as meaning that the variables are placed in alphabetical order.

An Algebraic Method for Analyzing Open-Loop Dynamic Systems

591

Theorem: (Existence and Uniqueness)
Given an initial condition g(t0 , w0 ) = 0, h(t0 , w0 ) = 0, there is a local analytic
solution with this initial condition.
Proof. See [6].

4

Application of RifSimp to Example Problem

In order to apply RifSimp to the example above, we proceed as follows.
2

2u(t)
1. Change coordinates using cos η = 1−u(t)
1+u(t)2 , sin η = 1+u(t)2 to get a rational
polynomial diﬀerential system instead of trigonometric nonlinear diﬀerential
system. (RifSimp does not allow trigonometric functions.)
2. Give this polynomial diﬀerential equation system to RifSimp, specifying the
case split option to get normalized diﬀerential equations.
3. Use RifSimp case tree to analyze the diﬀerent cases.

With no assumptions on the parameters, we obtain 24 cases, each split corresponds to some quantity being zero or not. The Maple output lists, for each
split, exactly what the quantity is.

<>

<>

=

<>

=

<>

=

1

2

3

4

=

<>

<>

=

=

<>

=

7
<>

<>

<>

=

5

6

8

9

Fig. 3. The case-split tree after the exclusion of cases that are not of physical interest

An examination of the output case-split list shows that many of the cases can
be removed on physical grounds. Thus RifSimp identiﬁes that there is division
by g, by m, and by l and therefore ﬂags these cases as points of case splitting.
Since we know in this application that these cases are not of physical interest,
we can exclude them automatically from the case analysis by including a list
of inequations in the RifSimp parameters. After including g = 0, m = 0, and
l = 0, RifSimp returns a tree containing 9 cases, as shown in Figure 3.

592

5

W. Zhou, D.J. Jeﬀrey, and G.J. Reid

Some Special Cases

The importance of the RifSimp analysis is the identiﬁcation of special cases.
The general (“generic”) case cannot be simpliﬁed further. However, any analysis
of a mechanical system should look for special cases, either to exploit these
particularly simple cases or to avoid them. The example shows that RifSimp
can be used to ﬁnd these cases automatically.
5.1

First Group of Special Cases

We group two cases together that diﬀer in that RifSimp identiﬁes one case as
being A = 0 and one as A = 0. However, the equation containing A is identically
zero because of the condition u = 0, and hence the value of A is irrelevant. The
equations simplify to
v¨(t) = −w(t),
¨

u(t) = 0

(7)

These equations can be integrated in closed form to
u(t) = 0,

v(t) = v1 t + v0 ,

w(t) = −v1 t + w0

(8)

where v1 , v0 , w0 are given by the initial conditions. From the deﬁnition of η(t) =
arccos((1 − u(t)2 )/(1 + u(t)2 )), we have η = 0 which means that the top is
spinning vertically without any inclination with respect to axis Z.
5.2

Second Group of Special Cases

Again RifSimp identiﬁes A = 0 and A = 0 separately. The common equations
are
w(t)
¨ = 0,

u(t)
˙
= 0,

v(t)
˙
=

gml
C w(t)
˙

(9)

and with constraint: u(t)2 − 1 = 0. The analytic solution is:
u(t) = u0 ,

v(t) =

gmlt + v0 w1 C
,
w1 C

w(t) = w1 t + w0

(10)

and with the constraints: u20 − 1 = 0 and v0 , w0 , w1 are given by the initial
conditions. Also from the deﬁnition of η(t) = arccos((1 − u(t)2 )/(1 + u(t)2 )), we
have η = π/2, which means the top is moving horizontally in the x − y plane,
i.e. it is precessing without nutation.

6

Conclusion and Future Work

Because of space limitations, we have restricted the example problem to being a
simple one. Further experiments with other mechanical systems, such as double
and triple pendulums, were made but not included here. However, from the example, we can identify successes and limitations of RifSimp. We ﬁrst point to

An Algebraic Method for Analyzing Open-Loop Dynamic Systems

593

the success of RifSimp in identifying the special cases of top motion. In the simple example shown here, these might seem well known, but the important point
is that these were identiﬁed automatically rather than by human inspection.
One of the limitations of the combination of RifSimp and Dynaflex is the
fact that Dynaflex generates a plethora of parameters. Too many parameters
can cause a serious degradation of the performance of a computer algebra system,
as well as leading to a large number of special cases that can prevent a human
user from seeing the patterns of interest in the output. This is reﬂected in the
24 special cases initially identiﬁed by RifSimp. Controlling the consequences of
a large number of parameters will be vitally important to further applications.
This paper has concentrated on open loop systems, because RifSimp has
been most successful in these cases. Closed loop systems generate further constraint equations that can cause RifSimp to exhaust computing resources before
completing its analysis. One reason for this is the symbolic inversion of matrices
in order to obtain RIF form. Computing techniques for handling large expressions have been developed in other contexts, see for example [7]. Combining
these with RifSimp will increase the complexity of problems that can be solved.

Acknowledgments
We gratefully acknowledge John McPhee, Chad Schmidt and Pengfei Shi for
their development of Dynaflex and for making their system available to us.

References
1. Schiehlen, W. Multibody Systems Handbook ; Springer-Verlag: Berlin, 1990.
2. P. Rideau. Computer Algegbra and Mechanics, The James Software; Computer Algebra in Industry I, 1993 John Wiley & Sons Ltd.
3. Pengfei Shi, John McPhee. Symbolic Programming of a Graph-Theoretic Approach
to Flexible Multibody Dynamics; Mechanics of Structures and Machines, 30(1), 123154(2002).
4. P. Shi, J. McPhee. Dynamics of ﬂexible multibody systems using virtual work and
linear graph theory; Multibody System Dynamics, 4(4), 355-381(2000).
5. Christian Rudolf. Road Vehicle Modeling Using Symbolic Multibody System Dynamics, Diploma Thesis; University of Waterloo in cooperation with University of Karlsruhe(2003).
6. Reid, G.J., Wittkopf, A.D., and Boulton, A. Reduction of Systems of Nonlinear
Partial Diﬀerential Equations to Simpliﬁed Involutive Forms. Eur. J. Appl. Math.
7 (1996): 604-635.
7. R. M. Corless, D. J. Jeﬀrey. Two Perturbation Calculation in Fluid Mechanics Using
Large-Expression Management; J. Symbolic Computation(1996) 11, 1-17.

