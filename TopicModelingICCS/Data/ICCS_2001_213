The Monitoring and Steering Environment
Christian Glasner, Roland Hügl, Bernhard Reitinger,
Dieter Kranzlmüller, and Jens Volkert
GUP Linz, Johannes Kepler University Linz,
Altenbergerstr. 69, A-4040 Linz, Austria/Europe,
kranzlmueller@gup.uni-linz.ac.at,
http://www.gup.uni-linz.ac.at/

Abstract. Monitoring and steering promises interactive computing and
visualization for large-scale scientiﬁc simulations. This is achieved by retrieving data about a program’s execution during runtime, analyzing
these data with sophisticated graphical representations, and applying
changes to parameters of the simulation in progress. Based on these requirements the MoSt environment oﬀers some novel ideas: Firstly, instrumentation of the code is performed on-the-ﬂy during execution without a
priori preparation of the target application’s code. Secondly, all functionality is provided in modules which communicate with each other via a
specialized network protocol, allowing the user to adapt MoSt to speciﬁc
situations. Thirdly, visual representations can be generated by arbitrary
visualization packages, which integrate an interface to the monitoring
environment. The latter may also apply Virtual Reality techniques in
order to enhance the user’s understanding. This paper oﬀers an overview
of MoSt, the strategy behind it, and its main modules.

1

Introduction

Computational science and engineering requires not only huge amounts of processing power from high-performance computing (HPC) architectures, but also
dedicated concepts, methods, and solutions incorporated in sophisticated programming and program analysis tools. Such a class of tools are computational
steering environments, which oﬀer functionality for online modiﬁcations of executing scientiﬁc and engineering simulations. In principle, there are two questions
being addressed by the tools in this area:
– How to analyze a program’s state at some arbitrary point during execution?
– How to modify a program (or its parameters, respectively) during execution?
Corresponding to these two questions, two distinct activities can be deﬁned:
monitoring and steering. Monitoring identiﬁes the process of observing a program’s execution during runtime, which helps the user to learn about a program’s
behavior. Based on the observed data, steering deﬁnes the activities applied to
modify a program’s execution by manipulating key characteristics of its algorithms.
V.N. Alexandrov et al. (Eds.): ICCS 2001, LNCS 2074, pp. 781–790, 2001.
c Springer-Verlag Berlin Heidelberg 2001
�

782

C. Glasner et al.

Several software tools based on these two activities have been developed [15].
Some well-known examples are the on-line monitoring and steering environment
Falcon [5], the Computational Steering Environment Cse [6], the Visualization
and Steering Environment Vase [1], the runtime interaction framework Daqv
[8] and its successor Daqv-II [9], the visualization and steering library Cumulvs
[7], and the scientiﬁc programming environment Scirun [16].
The work described in this paper is based on some ideas derived from analyzing the tools mentioned above. Especially three aspects have been investigated:
– Attaching the monitoring part to the target application during runtime without prior instrumentation
– Using Virtual Reality technology to improve the analysis tasks, especially
the problem of ﬁnding a suitable starting point for in-depth investigations
– Re-using existing visualization packages for in-depth investigations by integrating them via dedicated interfaces and eﬃcient networking protocols.
These aspects have been implemented in the Monitoring and Steering environment MoSt. Originally intended only as a test-bed for the ideas described
above, it has lately been extended to a complete environment, that it is available
for usage in real-world computational science applications.
This paper is organized as follows: The next section brieﬂy describes the main
strategy behind MoSt, as well as the main modules currently available. The instrumentation and monitoring module is described in Section 3. The observed
data is visualized either in Virtual Reality (Section 4) or with conventional visualization tools (Section 5). Afterwards, the experiences with our MoSt prototype
are summarized together with an outlook on future ideas in this project.

2

Computational Steering Strategy

The strategy incorporated in the MoSt environment can be described with a
simple example. We assume, that an arbitrary scientiﬁc application is already
executed on some kind of HPC system. A some time during its execution, the
user decides to investigate the two questions given in Section 1, which initiates
the following steps:
1. The interface of MoSt is initialized on a graphical workstation.
2. With MoSt, the user logs into the HPC system and attaches the monitoring
part to the target application.
3. After attaching, the user is eﬀectively in control over the target application
and starts downloading program state data.
4. The observed data is presented to the user, which in turn tries to identify
critical points for in-depth investigation.
5. At these critical points, in-depth analysis is carried out, revealing more and
more information about the program’s execution and increasing the user’s
knowledge.
6. Eventually, the user identiﬁes some key parameters, and changes their values.

The Monitoring and Steering Environment
CAVE

High Performance
Computer System
P0

P1

P2

P3

Parallel Program

783

PreMoSt

��
��
��
��
��
��

��� ���
��� ���

MoSt−I

MoSt++

MoSt−Vis

Fig. 1. Structure of the MoSt Environment

7. After the changes have been committed, MoSt is detached from the target
application and awaits future initiation.
This example execution of MoSt demonstrates the diﬀerent steps conducted
during monitoring and steering. In practice, these steps are distributed among
several independent modules, which communicate on a client-server basis via a
dedicated networking protocol. The structure and interconnection of the MoSt
modules is shown in Figure 1. The following components can be identiﬁed:
–
–
–
–

MoSt++: user interface and control center
PreMoSt: instrumentation and monitoring module
MoSt-I: visualization of activity data in VR
MoSt-Vis: (conventional) data visualization

The main module of MoSt is MoSt++, which represents the control center
and graphical user interface for all activities. All other modules are initiated via
commands in MoSt++, and status information as well as small amounts of
analysis data (such as single scalar values) are displayed within it.
The PreMoSt module performs the instrumentation and monitoring parts
of MoSt. Upon initiation of MoSt++, it logs into the HPC system and retrieves information about the running processes. After selecting a set of processes, PreMoSt attaches itself to the running code.
The next module initiated by MoSt++ is MoSt-I, which receives activity
data about the target application. This data is visualized by MoSt-I within a
Virtual Reality (VR) environment (e.g. a CAVE). It is used to identify critical
areas or hotspots in the program, which are qualiﬁed as starting points for indepth investigation activities.
After critical areas have been detected with MoSt-I, the user initiates the
MoSt-Vis module from the MoSt++ interface. In contrast to MoSt-I, which
focuses on program activity data, MoSt-Vis displays application dependant
information, for example data structures processed by the scientiﬁc algorithms.

784

C. Glasner et al.

The graphical representations oﬀered by MoSt-Vis are used to improve
program comprehension in order to understand an application’s computation.
It is therefore comparable to related work in this area, which oﬀer functionality
for model exploration, algorithm experimentation, and performance optimization [15]. Additionally, the user may induce parameter changes to the running
application in order to change its behavior. These changes are conducted within
MoSt++, which allows modiﬁcation of program data or even code patching of
a program’s original functions.
Of course, the actual modiﬁcations are again carried out by PreMoSt, which
is actually the only module which needs to be executed on the same machine
as the target application. After the monitoring and steering functions have been
completed, PreMoSt can be completely removed from the HPC system, leaving
the original application with only the applied changes.
The next sections oﬀer some more details about the ideas included in MoSt,
with special focus on the main diﬀerences between MoSt and other related
monitoring and steering environments.

3

On-line Instrumentation with PreMoSt

One of the main goals of PreMoSt’s design was to cope with the perturbation
introduced when monitoring an arbitrary program. This is a general problem
of on-line monitoring systems, because a program being observed is diﬀerent
from its counterpart without observation, and in some cases the observation
target may even reveal completely diﬀerent execution behavior [2]. Consequently,
developers of monitoring tools must seek to generate as little monitor overhead
as possible.
Most current approaches in this area apply dynamic monitoring [5], where
the amount of overhead can be adjusted at runtime, such that less overhead
is generated when less data is needed. Nevertheless, there is always a certain
amount of overhead, no matter how few data is obtained. Consequently, the
generated data has to be analyzed with care.
As an improvement, the approach incorporated in PreMoSt does not generate any monitor overhead if no analysis data are needed. This is especially
useful for long-running scientiﬁc applications, where users are not constantly
monitoring the program’s execution. In concrete, PreMoSt is only attached to
the target application if observation is actually requested.
The on-the-ﬂy technique included in PreMoSt is based on the dynamic
program instrumentation approach described in [11], which is available in the
DyninstAPI [10]. Besides its main usage for performance tuning [13], DyninstAPI has also been applied to several other areas like debugging and program
optimization.
DyninstAPI oﬀers functionality to instrument an application that is already
being executed on a computer system by inserting monitoring code on-the-ﬂy. In
addition, DyninstAPI can be used to establish connections between the program

The Monitoring and Steering Environment

785

in memory and its source code by accessing the symbol table information stored
in the program’s object code.
Although DyninstAPI has proved very useful for our eﬀorts, it still lacks some
needed functionality. For example, access to raw memory locations are performed
in DyninstAPI only via the symbol table information, which represents a certain
restriction, especially for the example described in the next section. Therefore,
some additional functionality had to be developed to fulﬁl the requirements of
PreMoSt.

4

“Feel the Program” with Most-I

After PreMoSt has been attached to the program, a user needs to ﬁnd out,
what a target application is currently doing, or what parts of the program’s
data are actually being processed. The idea incorporated in MoSt is to collect
program activity data based on the number of accesses to a particular memory
region. In concrete, the memory blocks containing the code- and data-segments
of an arbitrary program are divided into areas with high activity and areas with
low activity. Then, the normalized activity of an arbitrary area A consisting of
n memory cells is computed as
�

tmax

n
�

activity(A) =

i=1

ai (t)dt

tmin

tmax −tmin

n

In this formula, the activity a(t) of a memory block at a certain time t is
0, if the memory block is not accessed, or 1, if it has been accessed recently.
Furthermore, the activity over a given interval of time [tmin , tmax ] will yield
higher values for memory location with more accesses.
Based on this formula, the activity of arbitrary areas or memory blocks, of
distinct processes, or even a complete program can be determined. A problem
is that each memory cell has to be obtained iteratively by the monitor in order
to compute accurate activity values. However, as a ﬁrst approximation memory
blocks of coarser granularity can be selected for a(t). Over time, the granularity
of the cells can be reﬁned for those blocks, that yield higher activities values in
the ﬁrst place. Please note, that the reﬁnements are applied during the target
program’s execution, and the program’s behavior is subject to change over time,
Consequently, it is necessary to verify the focus of the reﬁnement periodically.
The hierarchical reﬁnement process is described in more detail in [12].
The activity data obtained by PreMoSt is then visualized with MoSt-I.
The main problem is to present the activity data of an executing program in a
meaningful way to the user, so that the user understands what is happening in
the program. Therefore, it was of major importance to investigate visualization
techniques, which should guide the user through the activity data, where to guide
means to support the user in discovering things, that were unknown before [14].

786

C. Glasner et al.

With the visualization, we want to improve the process of forming a mental
image of the program’s execution, which is utilized to aid the reasoning and
understanding of program behavior [17].
This goal was addressed by Virtual Reality (VR) technology incorporated in
MoSt-I, where the ”I” stands for Immersion. Currently, the chosen environment
is the CAVE (CAVE Automatic Virtual Environment), a multi-person, roomsized, high-resolution, 3D video and audio environment developed in 1992 at EVL
(Electronic Visualization Laboratory, University of Illinois at Chicago). The task
of MoSt-I is to generate the immersive model of the program’s behavior in the
CAVE. Then the user may interactively explore this virtual world and gain more
and more knowledge about the program’s characteristics.
The idea of using VR in MoSt-I is, that it allows to cause a “feeling” in
the user about the program’s behavior. By exploring the activity data presented
in the CAVE, the user can intuitively investigate even huge amounts of data.
This can mainly be attributed to the fact, that VR oﬀers additional dimensions
compared to traditional 2-dimensional displays. Some important characteristics
in this context are: Firstly, the number of available dimensions is increased (e.g.
3D, immersion, sound). Secondly, important issues can be emphasized by combining attributes (e.g. color+sound). Thirdly, animation can be used to describe
the variation of data over time.
A major diﬃculty for visualization is always to choose an appropriate visual
representation. For MoSt-I several approaches have been investigated. The most
suitable of these approaches seems to be the activity tunnel, which arranges the
memory of parallel processes as stripes in a 3-dimensional tunnel [12]. Within
this tunnel, the activity is visualized with attributes like color, shades, object
size, and animation.
An example of the activity tunnel is presented in Figure 2. It shows the memory activity of 8 application processes, with diﬀerent shades indicating diﬀerent
levels of activity. This picture has been taken within the CAVE environment
and also contains the user who controls the application. In order to intensify the
eﬀect of VR onto the user, all interaction with the system is performed via voice
input, which is shown in Figure 2 with the mounted headset.
In addition to the graphical representation, mappings to other sensory input
are currently investigated. One example is sound, which was originally inspired
by the following story about the Whirlwind computer (1950) [4]: You even had
audio output in the sense that you could hear the program because there was an
audio ampliﬁer on one of the bits of one of registers - so each program had a
signature. You could hear the tempo of how your program was running. You could
sense when it was running well, or when it was doing something surprising.
Similar ideas are discussed in [3]. By integrating sound output in MoSt-I,
we try to emphasize the activity of a program in the region of the tunnel, that is
currently inspected by the user. Other ideas include the soniﬁcation of hardware
performance counters, the program counter, and similar state data.

The Monitoring and Steering Environment

787

Fig. 2. Picture of user (with microphone) and the activity tunnel in the CAVE.

5

Data Visualization with MoSt-Vis

As described above, the visualization MoSt-I is mainly used as a starting
point for in-depth investigations. Therefore, after the user has decided where
to perform program and data analysis, symbol table information is presented by
MoSt++. Based on this information, interesting data structures of the running
program can be selected. The selected data is then extracted by PreMoSt.
Depending on the amount of data, the results of PreMoSt are either printed
in a window of MoSt++, or forwarded to the visualization module MoSt-Vis.
The graphical representations provided by MoSt-Vis have to be chosen
corresponding the the scientiﬁc applications data. Since most of these data is
already visualized during post-mortem analysis, it seems beneﬁcial to re-use
existing visualization packages. This is achieved within MoSt by developing
corresponding input interfaces, such that PreMoSt can forward its data to an
arbitrary visualization tool. At present, input interfaces for IBM’s Open Data
Explorer (OpenDX) are available, while similar functions are currently being
implemented for AVS/Express.
Some examples of data visualization are shown in Figure 3 to Figure 5. All
screenshots have been produced with MoSt while the target application was
actually running. Figure 3 shows the scalar value of a chosen variable over time,
with each curve corresponding to one process of the application. Figure 4 shows
a two-dimensional heat-diagram of an array, that is currently processed by the
target application. Figure 5 shows a 3-dimensional visualization of a crank shaft
grid, that is currently used for computing the stress around this object.
The visualizations are constructed within MoSt as follows: MoSt++ reads
the symbol table information and presents the set of available data structures

788

C. Glasner et al.

Fig. 3. Example visualization of scalar values on 8 processes over time

to the user. Upon choosing some of the data structures, PreMoSt begins to
download the corresponding data from the running program. In addition, the
user selects a suitable graphical representation within MoSt++ and speciﬁes
the mapping of the data structures onto the dimensions of the graphical output.
These data and the mapping speciﬁcation are forwarded to MoSt-Vis which
ﬁnally generates the output described above.

6

Conclusions

The MoSt environment described in this paper oﬀers some novel ideas for analyzing and controlling applications from computational science and engineering.
Although originally intended only to verify some of our ideas, the ﬁrst results
with the tool where rather promising. This convinced us to develop the system
into an environment, that can be oﬀered interested scientists.
Most useful is the dynamic instrumentation module, which oﬀers to inject commands on-the-ﬂy. Therefore the application needs not be stopped and
restarted, which allows to decrease the overall computation time, a factor that
may be crucial for users of expensive HPC systems.
On contrary, the VR visualization of activity data may seem a little bit
controversial in the ﬁrst place. However, the problem of leading the user to an
suitable starting place for in-depth investigations is very important, and there
seems to be only limited support from related work in this area. Nevertheless,
it is certainly necessary to assess the usefulness of the current approach for
real-world applications, and to continue studying this important aspect.
Finally, the idea of re-using existing visualization tools by developing corresponding interfaces allowed to shift lots of concentration to the other aspects

The Monitoring and Steering Environment

789

Fig. 4. Example heat diagram of 2-dimensional data array

Fig. 5. Example 3-dimensional data visualization of a crank shaft

of this project. The problem in this area is mainly related to the eﬃciency of
the networking protocol and the underlying network infrastructure. Especially
for tools with huge amounts of data, dedicated methods for ﬁltering or preprocessing need to be developed.

References
1. Brunner, J.D., Jablonowski, D.J., Bliss, B., Haber, R.B., ”VASE: The Visualization
and Application Steering Environment”, Proc. Supercomputing ‘93, Portland, OR,
pp. 560-569 (November 1993).
2. Eisenhauer, G., Gu, W., Kraemer, E., Schwan, E., Stasko, J., ”Online Displays of
Parallel Programs: Problems and Solutions”, Proc. PDPTA ‘97, Intl. Conference
on Parallel and Distributed Processing Techniques and Applications, Las Vegas,
NV, pp.11-20 (July 1997).

790

C. Glasner et al.

3. Francioni, J.M., Jackson, J.A., ”Breaking the Silence: Auralization of Parallel Program Behavior”, Journal of Parallel and Distributed Computing, Vol. 18, pp. 181194 (1993).
4. Frenkel, K.A., ”An Interview with Fernando Jose Corbató”, Communications of
the ACM, Vol. 34, No. 9, pp. 83-90 (September 1991).
5. Gu, W., Eisenhauer, G., Schwan, K., Vetter, J., ”Falcon: On-line Monitoring and
Steering of Large-Scale Parallel Programs”, Concurrency: Practice and Experience,
Vol. 10, No. 9, pp. 699-736 (August 1998).
6. van Liere, R., Mulder, J.D., van Wijk, J.J., ”Computational Steering”, Future
Generation Computer Systems, Vol. 12, No. 5, pp. 441-450 (April 1997).
7. Geist, G.A., Kohl, J.A., Papadopoulos, P.M., ”CUMULVS: Providing FaultTolerance, Visualization, and Steering of Parallel Applications”, Intl. Journal of
Supercomputer Applications and High Performance Computing, Vol. 11, No. 3, pp.
224-236 (Fall 1997).
8. Harrop, Ch.W., Hackstadt, S.T., Cuny, J.E., Malony, A.D., Magde, L.S., ”Supporting Runtime Tool Interaction for Parallel Simulations”, Proc. Supercomputing
‘98, Orlando, FL (November 1998).
9. Hackstadt, S.T., Harrop, Ch.W., Malony, A.D., ”A Framework for Interacting with
Distributed Programs and Data”, Proc. HPDC-7, 7th IEEE Intl. Symposium on
High Performance Distributed Computing, Chicago, IL, pp. 206-214 (July 1998).
10. Hollingsworth,
J.K.,
Buck,
B.,
”DyninstAPI
Programmer’s
Guide
Release
2.0”,
Computer
Science
Department,
URL:
http://www.cs.umd.edu/projects/dyninstAPI (2000).
11. Hollingsworth, J.K., Miller, B.P., Cargille, J., ”Dynamic Program Instrumentation
for Scalable Performance Tools”, Proc. 1994 Scalable High Performance Comp.
Conf., Knoxville, TN (1994).
12. Kranzlmüller, D., Reitinger, B., Volkert, J., ”Experiencing a Program’s Execution
in the CAVE”, Proc. PDCS 2000, Conference on Parallel and Distributed Computing Systems, Las Vegas, NV, USA, pp. 259-265 (November 2000).
13. Miller, B.P., Callaghan, M.D., Cargille, J.M., Hollingsworth, J.K., Irvin, R.B.,
Karavanic, K.L., Kunchithapadam, K., Newhall, T., ”The Paradyn Parallel Performance Measurement Tool”, IEEE Computer, Vol. 28, No. 11, pp. 37-46 (November
1995).
14. Miller, B.P., ”What to Draw? When to Draw? - An Essay on Parallel Program
Visualization”, Journal of Parallel and Distributed Computing, Vol. 18, No. 2, pp.
265-269 (June 1993).
15. Mulder, J.D., van Liere, R., van Wijk, J.J., ”A Survey of Computational Steering
Environments”, Future Generation Computer Systems, Vol. 15, No. 1, pp. 119-129
(February 1999).
16. Parker, S.G., Johnson, C.R., ”SCIRun: A Scientiﬁc Programming Environment for
Computational Steering”, Proc. Supercomputing ‘95, San Diego, CA, (December
1995).
17. Zhang, K., Ma, X., Hintz, T., ”The Role of Graphics in Parallel Program Development”, Journal of Visual Languages and Computing, Academic Press, Vol.10,
No.3, pp. 215-243 (June 1999).

