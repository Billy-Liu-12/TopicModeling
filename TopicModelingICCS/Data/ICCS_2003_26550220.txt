Getting System Metrics Using POSIX Tracing Services
Agust´ın Espinosa Minguet1 , Vicente Lorente Garc´es2 , Ana Garc´ıa Fornes1 , and
Alfons Crespo i Lorente2
1

2

Departamento de Sistemas Inform´aticos y Computaci´on
Universidad Polit´ecnica de Valencia, Spain
{aespinos,agarcia}@dsic.upv.es
http://www.dsic.upv.es
Departamento de Inform´atica de Sistemas y Computadoras
Universidad Polit´ecnica de Valencia, Spain
{vlorente,alfons}@disca.upv.es
http://www.disca.upv.es

Abstract. One of the possible applications of the POSIX tracing services is to
obtain system metrics from trace streams. A trace stream stores a sequence of
events generated by the system during the application execution. By interpreting
this sequence of events, interesting system metrics can be obtained. Unfortunately,
the interpretation of these sequences of events may be very difficult for a programmer who does not know the system implementation in detail. In order to solve this
problem, we present an interface which is implemented on top of the POSIX tracing services. This interface allows the programmer to obtain predefined system
metrics and user-defined metrics from trace streams without having to know the
system implementation.

1

Introduction

The POSIX tracing services [1] specify a set of interfaces to allow for portable access
to underlying trace management services by application programs. Programmers may
use these services to get a sequence of trace events generated by the system during the
execution of their application. These trace events are kept in a POSIX trace stream. The
contents of a trace stream can be analyzed while the tracing activity takes place or it
can be analyzed later, once the tracing activity has been completed. A trace event is
generated when some action takes place in the system and this trace event may be stored
in one or several trace streams. Each trace event contains data which is relative to the
action that has generated it. The POSIX tracing services require that event type, time
stamp, process identifier and thread identifier be associated to each trace event. Using
these data, we can get time related system metrics such as the execution time of a given
system call, the duration of an interrupt handler, etc.
Unfortunately, the interpretation of the events which are stored in trace streams may
be difficult for programmers who do not know the system implementation in detail.
This work has been funded by the Ministerio de Ciencia y Tecnologia of the Spanish Government under grants DPI2002-04434-C04-02 and TIC2002-04123-C03-03 and by the Generalitat
Valenciana under grant CTIDIB/2002/61
J.-P. Rosen and A. Strohmeier (Eds.): Ada-Europe 2003, LNCS 2655, pp. 220–231, 2003.
c Springer-Verlag Berlin Heidelberg 2003

Getting System Metrics Using POSIX Tracing Services

221

Events stored in a trace stream represent system actions such as context switches, hardware interrupts, state changes, etc. In order to extract metrics from these events it is
necessary to know how the execution of the system generates these events. Usually only
the programmer who has implemented the system knows this information. In order to
solve this problem, we present an interface which is implemented on top of the POSIX
tracing services. This interface allows the programmer to obtain predefined system metrics and user-defined metrics from trace streams without having to know the system
implementation.
This metrics interface has been implemented in the real-time MaRTE OS operating
system [7]. MaRTE OS is a real-time kernel for embedded applications that follows
the Minimal Real-Time POSIX.13 subset [2]. Most of its code is written in Ada with
some C code and assembler parts. It allows for the software development of Ada and
C embedded applications. We implemented a subset of the POSIX tracing services in
MaRTE OS and an Ada binding to these services in a previous work [5]. The metrics
interface has been built on top of this Ada binding. The MaRTE OS operating system
and the GNAT run-time system have been modified so that these systems generate events
that are appropriate for a set of useful metrics.
The metrics interface is discussed in the remainder of the paper. Section 2 describes
the Metrics package, which implements the metrics interface. Section 3 shows how this
interface has been implemented. Section 4 presents how a set of system metrics which
is suitable for real-time applications may be obtained using this interface.

2 The Metrics Package Specification
A metric is a temporal property of the system, just like the duration of a context switch
or the execution time of a task. The Metrics package offers an interface that allows the
programmer to obtain metrics from the events stored in a POSIX trace stream.
with Ada.Real Time;
with Ada.Task Identification;
with Posix.Trace;
package Metrics is
type Metric
is private;
type Metric Result (Size : Natural) is private;
is private;
type Metric Result Element
function System Metric (Metric Name
return Metric;

: String)

function New User Metric (Metric Name
Initial Event
Final Event
Include System
return Metric;

: String;
: POSIX.Trace.Event Identifier;
: POSIX.Trace.Event Identifier;
: Boolean := True)

function Events Required By (M
: Metric;
Trid : POSIX.Trace.Trace Identifier)
return POSIX.Trace.Event Set;
procedure Get Metric Result (From
: in Metric;
Trid
: in POSIX.Trace.Trace Identifier;
Result : in out Metric Result);

222

A. Espinosa Minguet et al.

function Metric Result Element Count (From : Metric Result)
return Natural;
function Get Metric Result Element (From : Metric Result;
I
: Natural)
return Metric Result Element;
function Begin Time
(From : Metric Result Element)
return Ada.Real Time.Time;
function End Time
(From : Metric Result Element)
return Ada.Real Time.Time;
function Length
(From : Metric Result Element)
return Ada.Real Time.Time Span;
function Task Id
(From : Metric Result Element)
return Ada.Task Identification.Task Id;
function Intermediate Events (From : Metric Result Element)
return Natural;
end Metrics;

In this interface, metrics are identified by names and these metrics are used through
objects of the type Metric. There are two types of metrics, system metrics and user
metrics.
System metrics are implementation-defined and usually correspond to temporal properties of the run-time or operating system. These metrics are used by calling the function
System Metric.
M1 : Metric;
M2 : Metric;
M1 := System Metric ("Delay Until Wakeup");
M2 := System Metric ("Schedule And Dispath");

Programmers can define their own user metrics, which allow them to measure the
execution time between two points of their programs, with these points being defined
by two trace events. These metrics may or may not include the system execution time
and are created using the function New User Metric.
M3 : Metric;
Initial Event : POSIX.Trace.Event Identifier;
: POSIX.Trace.Event Identifier;
Final Event
Initial Event := POSIX.Trace.Open ("Initial Event");
:= POSIX.Trace.Open ("Final Event");
Final Event
M3 := New Metric (
"My Metric", Initial Event, Final Event, Include System => False);

Each metric is obtained from a set of events that should be in the trace stream that is
being analyzed. It is important that these events be stored in the trace stream when these
events are generated. When programmers prepare the tracing of their applications, they
can use the function Events Required By to obtain the set of events on which a metric
depends, indicating to the trace system that the events of this set should be stored in the

Getting System Metrics Using POSIX Tracing Services

223

trace stream. The following code fragment illustrates how an application can be coded
to create a trace stream so that programmers can obtain the metrics that they require.
Attr : POSIX.Trace.Attributes;
Trid : POSIX.Trace.Trace Identifier;
File : POSIX.IO.File Descriptor;
Interesting Events : POSIX.Trace.Event Set;
: POSIX.Trace.Event Set;
All Events

POSIX.Trace.Initialize (Attr);
File := POSIX.IO.Open("Logfile",POSIX.IO.Read Write);
Trid := POSIX.Trace.Create With Log
(POSIX.Process Identification.Null Process ID,
Attr,
File);
POSIX.Trace.Add Event Set (Interesting Events, Events Required By (M1, Trid));
POSIX.Trace.Add Event Set (Interesting Events, Events Required By (M2, Trid));
POSIX.Trace.Add Event Set (Interesting Events, Events Required By (M3, Trid));
POSIX.Trace.Add All Events (All Events);
POSIX.Trace.Set Filter (Trid, All Events);
POSIX.Trace.Subtract From Filter (Trid, Interesting Events);
POSIX.Trace.Start (Trid);
Start Aplication;
POSIX.Trace.Shutdown (Trid);

In the previous code fragment, a trace stream is created by calling
POSIX.Trace.Create With Log. Next, the trace stream is configured so that it filters all

the events that are generated, except the events on which metrics M1, M2 and M3 depend.
Once the trace stream is configured, this is activated by calling POSIX.Trace.Start
and the application begins. From this instant, the events which are not filtered will be
stored in the trace stream. Once the application ends, it stops the trace stream by calling
POSIX.Trace.Shutdown. After this action, the trace stream is stored in the file logfile.
This trace stream can be analyzed later to obtain the results of the metrics M1, M2 and
M3.
A metric result is an object of the type Metric Result. Each one of these objects is
a list which is formed by all the measurements (objects of the type
Time Metric Result Element) which have been detected in the trace stream that is being
analyzed. An individual measurement registers the following five values:
Value
Task Id
Length
Begin Time

Description
Task identifier
Measured time
Instant in which the beginning of the measure is detected
End Time
Instant in which the finalization of the measure is detected
Intermediate Events Number of trace events detected while making the measure

224

A. Espinosa Minguet et al.

Task Id and Length are the main values obtained from a measurement. Begin Time
and End Time allow the user to detect when the measurement has begun in the trace
stream. For example, it can be useful to analyze a measurement with a strange Length
value. Intermediate Events allows the programmer to estimate the overhead caused
by the tracing system. Sometimes different measurements from the same metric have
a different number of trace events and so it is important to adjust the Length value by
using the Intermediate Events value. Of course, to make this adjustment it is necessary
to known how much time is consumed in storing a trace event in a trace stream.
A metric result is obtained by calling the procedure Get Metric Result. When being
called, this procedure scans the trace stream indicated in the parameter Trid searching for measurements that correspond to the metric indicated in the parameter From.
These measurements are stored in the parameter Result. The number of measurements
found can be consulted by calling function Metric Result Element Count. The function Get Metric Result Element is used to obtain one of these measurements from a
result. The values of each measurement are consulted using the functions Begin Time,
End Time, Length, Task Id and Intermediate Events. The following code fragment illustrates how programmers obtain the results of a metric from a previously created trace
stream. Figure 2 shows the output of this example.
File := POSIX.IO.Open("Logfile",POSIX.IO.Read Only);
Trid := POSIX.Trace.Open (File);
Get Metric Result (M1, Trid, Result);
N := Metric Result Element Count (Result);
for I in 1 .. N loop
Measure := Get Metric Result Element (Result, I);
L := Length (Measure);
T := Task Id (Measure);
....
Show Result Element;
end loop;

Task Length Begin Time End Time Int Events
8
44
14393
14445
5
9
51
24392
24495
5
10
47
24409
24521
5
45
24424
24545
5
6
7
43
24438
24569
5
11
44
45393
45445
5
6
50
49391
49464
5
7
45
49409
49489
5
12
51
54393
54482
5
13
46
54410
54507
5
..
..
.....
.....
.
Fig. 1. Metric result (time in µs)

Getting System Metrics Using POSIX Tracing Services

225

3 The Metrics Package Implementation
The results of a metric are obtained by scanning sequences of events stored in a prerecorded trace stream that correspond to the metric the programmer wants to obtain.
Each metric provided by the Metrics package is analyzed by an automaton, or more
precisely, by a group of equivalent automata, each of which is associated to a different
task identifier. As these automata are internal to the implementation of the Metrics
package users of this package do not use them directly.
We decided to use automata because they adapt very well to the nature of the information which is a sequence of trace events. Another advantage of using automata is they
facilitate the implementation of new metrics, which is specially important if we want to
port the implementation of the Metrics package to a system other than MaRTE OS.
The alphabet used by these automata is formed by tuples of three elements
(Event Type, Task Id, Timestamp). These tuples are obtained from the events which
are stored in a pre-recorded trace stream. The elements Event Type and Task Id are
used to determine when a transition is applied, while the element Timestamp is used to
obtain the measurement.
A transition between two states is applied in accordance with both the input tuple
and the transition label according to the following rules:
Label
Event Type, i

Event Type, not i

Event Type
λ
∗

The transition is applied if...
the input event is equal to Event Type and
the input task is the task associated to the
automaton.
the input event is equal to Event Type and
the input task is not the task associated to
the automaton.
the input event is equal to Event Type.
the label is λ.
the input tuple does not match any of the
previous rules.

The states of an automaton can be one of the following types: begin, end, cancel, in,
out and cond. The calculation of a measurement takes place according to the following
rules:
1. When entering in a begin state, a new measurement begins.
2. When entering in a cancel state, the current measurement is discarded.
3. When entering in an end state, the current measurement is completed and the values
associated to this measurement are determined as follows:
Value
Task Id
Begin Time
End Time

Calculation
Identifier of the task associated to the automaton.
Timestamp of the input tuple that caused the application
of rule 1.
Timestamp of the input tuple that caused the application
of rule 3.

226

A. Espinosa Minguet et al.

Length

The sum of the duration of the segments detected by the
automaton. A segment is formed by a sequence of states
which are exclusively of type in, or by a sequence of
states that begins with states of the type cond and which
ends with states of type in. The duration of a segment is
calculated as the difference between the Timestamp values
of the input tuples that have determined the initial and final
states of the segment.
Intermediate Events The sum of the sizes of the segments which are detected
by the automaton. The size of a segment is the number of
states that compose the segment minus one.

In other words, a measurement begins when the automaton reaches a state of type
begin. From this point the automaton looks for segments that belong to the metric that
the programmer wants to obtain. These segments are detected in accordance with the
type of the automaton states in, out and cond. In and out states are states that are inside
or outside of a segment, respectively. Cond states are states whose membership to a
segment is conditioned to later states of the automaton. If an in state is reached after a
sequence of cond states , the sequence of cond states belongs to the segment. If an out
state is reached, the sequence of cond states is discarded as belonging to a segment. In
this way, cond states allow the automaton to detect segments whose membership to the
measurement is conditioned by events that have not yet been obtained from the trace
stream. A measurement ends when an end or cancel state is reached. If an end state
is reached, the length of the measurement is the sum of the duration of the segments
detected. Conversely, if a cancel state is reached, the current measurement is discarded.
Cancel states are used when the automaton detects that the current situation does not
really correspond to the metric which is being analyzed.
An example of these automata is shown in Fig. 2. This is the automaton which analyzes user-defined metrics in which the system execution time is included. These metrics
measure the execution time performed by a task between two points of its execution.
These points are marked by two trace events which are user-defined. It is important take
into account that the hardware may interrupt the task execution, and so the execution time
consumed by the interrupt handler must not be part of the measurement. If the running

*

0

initial_event, i

l

1

out

beg

2

l
final_event, i

3

in

in

interrupt
context_end, i
No_Preempt
context_end, not i
*

5

6

out

out

*

Fig. 2. User metric automaton

l

4

end

Getting System Metrics Using POSIX Tracing Services

227

task is preempted by a higher priority task as a consequence of an interrupt, the execution
time performed by this higher priority task must not be part of the measurement. In this
way, a measurement of a user defined metric is formed by a sequence of segments in
which the task is using the processor. The first segment is detected by the automaton (in
the state 0) when the initial event defined by the user is detected. The automaton then
reaches state 1 and the measurement begins. By the λ transition, the automaton reaches
state 2. With the automaton in state 2, if the task is interrupted, the current segment is
completed and the automaton reaches state 5. If the running task is preempted as a consequence of the interrupt the automaton reaches state 6. States 5 and 6 are of type out,
and so they are no part of the measurement. When the task again becomes the running
task state 2 is reached and a new segment begins. When the final event is detected, the
current segment is completed. The automaton reaches state 4 and the measurement ends.
Finally, the automaton returns to state 0 and waits for a new measurement.

4

Usage Example

In this section, we describe how the Metrics package can be used to know the system
overload that takes place in a real-time application formed by a set of periodic tasks.
To carry out this study, we began with the following equation [3] which calculates the
worst-case response time for a task πi .
Ri = Ci + Bi +
∀j∈hp(i)

Ri
Ci
Bi
Tj
hp(i)

Ri
Cj
Tj

(1)

worst-case response time of πi .
worst-case execution time of πi .
blocking of πi .
period of πi .
set of all tasks of higher priority than πi .

In order for equation 1 to be correct, it is necessary to incorporate the system overload
to the terms of the equation. All the activities of the system caused by the task, such as
its activation or system calls should be included in Ci . Bi should be calculated keeping
in mind the critical sections implemented by the program, as well as the system sections
whose activity is in charge of lower priority tasks. These sections can delay the execution
of πi .
Our system is formed by the real-time operating system MaRTE OS and the run-time
system of the GNAT compiler. We want to analyze the overload that this system produces
in a set of periodic tasks which are implemented according to the following outline:
task body Periodic is
begin
loop
Application Code;
Next Activation := Next Activation + Period;
delay until Next Activation;
end loop;
end Periodic;

228

A. Espinosa Minguet et al.

When adapting the results of the works described in [6] and [4] to our system, the
terms of equation 1 can be calculated in the following way:
Ci = (Ciuser + JSTi )
Bi = Biactivation + Bicritical
Bicritical

section

(2)
section

= max((SBk : k ∈ lp(i)) ∪ Biuser )

Biactivation =
∀k∈lp(i)

Ri
DU Wk
Tk

(3)
(4)
(5)

The meanings of the terms of these equations are the following:
– Ciuser : worst-case execution time of πi , only taking into account the code at application level.
– Biuser : blocking which takes place from critical sections at application level.
– Job System T imei (JSTi ): System execution time of the task πi .
This execution includes the execution of the statement delay until and other system
executions requested by the task.
– System Blockingk (SBk ): System-level blocking that can produce the task πk .
Some parts of the execution of the GNAT run-time system are critical sections
protected by POSIX mutexes . The ceiling of these mutexes is the maximum priority
of the system, so the duration of these critical sections must be considered as possible
blocking for any task whose base priority is greater than πk .
– Delay U ntil W akeupi (DU Wk ): System execution time which is necessary to
wake up a task πk that is suspended in a statement delay until.
Programmers need to know the following metrics in order to know the overload that
the system has in the real-time application: Job System T ime, System Blocking and
Delay U ntil W akeup. Next, we describe how a metric can be implemented, using the
metric Delay U ntil W akeup as an example.
In our system, when a task executes the statement delay until, a call takes place to
the GNAT run-time system, which registers the new state of the task and calls the POSIX
function pthread cond timedwait so that the task is suspended in a POSIX condition.
MaRTE OS services this call by scheduling a temporal event and selects a new task for
execution. To measure the time that the system needs to wake up a task that is suspended
in a statement delay until, we can build the automaton shown in Fig. 3.
This automaton (in state 0) waits until the hardware timer interrupts. When this interrupt takes place, the MaRTE OS timer interrupt handler is executed and a measurement
begins (state 1). State 4 is reached after the first phase of the timer interrupt handler
and MaRTE OS begins to extract the temporal events that have expired at this instant.
If one of these events implies waking up the task i, the automaton changes to state 7.
Otherwise, the measurement is canceled (state 6) and the automaton returns to its initial
state.

Getting System Metrics Using POSIX Tracing Services

6

l

*

cancel

timer_return

*

0

timer

l

1

*

timer_first

2

in

begin

out

229

3

in

l

*

next_event

4

5

cond

timer_timedwait, not i

timer_timedwait, i

in

other_timer_service
*

7

*

timer_timed_wait_return, i

8

in

in

*

*

context_end, not i

10

l

sched

9

out

11

cond

out

context_end, i

context_end, i

*

12

*

*

context_end, not i

mutex_unlock

13

in

in

No_Preempt

14

in

l

15

end

l

0

out

timer
context_end, i
No_Preempt
context_end, not i

16
*

17

out

out

*

Fig. 3. Delay U ntil W akeupi automaton

If the measurement continues, the automaton waits until the service for the function
pthread cond timedwait for the task i completes (state 8). In state 9, the system activity

that is related to the extraction of other temporal events is discarded. MaRTE OS next
calls the scheduler to select a task to execute. Once the task i continues its execution (state
12), the automaton can wait until the GNAT run-time system releases the mutex that was
acquired at the beginning of the execution of the statement delay until (state 13). The
measurement then completes when MaRTE OS decides what task will continue being
executed (state 14). If new interrupts of the hardware timer occur when the automaton
in in state 12, states 16 and 17 discard the execution that may occur due to this interrupt.
To obtain the three metrics from MaRTE OS, we prepared a test made up of a group
of 15 periodic tasks. The periods of these tasks ranged between 25 and 200 ms and
their computation times ranged between 2 and 20 ms. This task set was executed on a
200 Mhz Intel Pentium processor. Storing a trace event in a trace stream takes around
1 microsecond on this processor. Figure 4 shows a summary of the results obtained
for the three metrics in which the interference caused by the tracing system has been
subtracted. These values correspond to the largest measurement obtained for each task.
For example, when analyzing the results for task 1, we observe the following. The
time that the system dedicates to each job of this task is at most 84.838 µs. The exe-

230

A. Espinosa Minguet et al.
Task Job System Time System Blocking Delay Until Wakeup
1
84.838
27.837
44.235
2
81.521
27.972
43.680
3
73.326
27.131
36.207
4
74.768
28.257
35.291
5
83.278
28.632
43.380
6
77.258
28.302
37.602
7
80.952
27.807
43.726
8
80.472
26.921
42.435
9
74.753
26.786
37.392
10
81.327
27.687
42.241
11
77.814
28.377
37.617
12
76.778
28.182
36.762
13
76.540
28.572
35.936
14
76.209
28.047
36.041
15
75.488
27.282
36.552
Fig. 4. Results of the metrics (time in microseconds)

cution of the task 1 may be delayed up to 28.632 µs by system blocking coming from
tasks of lower priority. In the worst case, if tasks 2 to 15 are activated while task 1 is
running, the execution of task 1 will be delayed 544.862 µs, which is the sum of the
Delay Until Wakeup metric for tasks 2 to 15.

5

Conclusions

In this paper, we have presented an interface that allows programmers to obtain system metrics from POSIX trace streams. The approach that we have used offers several
advantages. Programmers can obtain system metrics from trace streams which are generated by a system whose implementation is unknown. The proposed interface is easily
portable since it is implemented on top of POSIX standard services. The use of automata
facilitates the creation of new metrics as well as the adaptation of this interface to other
systems where the events generated could possibly be different. We are currently using this interface for the analysis of Ada real-time applications in the operating system
MaRTE OS, for which we have defined a wide set of system metrics.

References
1. 1003.1q-2000 IEEE Standard for Information technology-Portable Operating Systems Interface (POSIX®)-Part 1: System Application Program Interface (API)-Amendment 7: Tracing
[C Language]
2. 1003.13-1998 IEEE Standard for Information Technology–Standardized Application Environment Profile (AEP)–POSIX® Realtime Application Support. [0-7381-0178-8]
3. N. Audsley, A. Burns, M. Richardson, K. Tindell and A. Wellings. Applying new scheduling
threory to static priority pre-emptive scheduling. Software Engineering Journal, 8, (5), 284–
292. (1993)

Getting System Metrics Using POSIX Tracing Services

231

4. A. Burns, A.J. Wellings. Engineering a hard real-time system: from theory to practice. Software
Practice and Experience, vol 27(7), 705–726
5. A. Espinosa, A. Garc´ıa-Fornes, A. Crespo. An Ada Binding to the IEEE 1003.1q (POSIX Tracing) Standard. 7th Ada-Europe International Conference on Reliable Software Technologies,
Vienna. LNCS 2361, p. 321.
6. D. Katcher, H. Arakawa, J. Strosnider. Engineering and analysis of fixed priority schedulers.
IEEE Transactions on Software Engineering, vol. 19, 920–934.
7. M. Aldea, M. Gonzalez. MaRTE OS: An Ada Kernel for Real-Time Embedded Applications.
6th Ada-Europe International Conference on Reliable Software Technologies, Leuven. LNCS
2043, p. 305

