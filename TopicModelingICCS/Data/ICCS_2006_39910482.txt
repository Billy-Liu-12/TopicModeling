An Improved Algorithm for Sequence Pair Generation
Mingxu Huo and Koubao Ding∗
Dept. of Information and Electronic Engineering, Zhejiang University,
Hangzhou 310027, P.R. China
{huomingxu, dingkb}@zju.edu.cn

Abstract. Sequence Pair is an elegant representation for block placement of IC
design, and the procedure to generate the SP from an existing placement is
necessary in most cases. An improved generation algorithm is proposed instead
of the existing methods that are either difficult or inefficient to be implemented.
The algorithm simplifies the definition of relation between blocks and avoids
employing complicated graph operations. The time complexity of the algorithm
is O (n2) and can be reduced to O (n log n), where n is the number of blocks.
The experimental results of the algorithm show its superiority in running time.

1 Introduction
The floorplanning and block placement problems become increasingly important in
physical design of Integrated Circuits (IC), where floorplanning can be regarded as
placement with soft module blocks. Such problems are usually solved in two phases,
i.e., the initial constructive phase, and iterative improvement one [1]. They are
complex combinatorial optimization problems and most of their sub-problems are
NP-Complete or NP-Hard [2]. Therefore heuristic approaches such as Simulated
Annealing (SA) algorithm [3] are widely used to generate good layouts at the iterative
stage, where representations of the placement is one of the crucial factors in
evaluation of the costs.
In contrast with the so-called flat or absolute representations where the blocks are
specified in terms of absolute coordinates on a plane without grids, a large number of
representations of geometrical topological relations of blocks were proposed, e.g.,
slicing [4], mosaic [5], compacted [6] and P*-admissible representations [2, 7, 8, 9].
The P*-admissible representations can represent the most general floorplans and
contain a complete structure for searching an optimal solution, among which the
Sequence Pair (SP) is most favored and widely researched recently.
The SP related efforts with SA algorithms in the literature usually randomly
generate an initial SP and then pack it to evaluate its cost. However, Force Directed
Relaxation [10, 11] and other analytical algorithms that have been studied for a long
time can construct better placements than the random ones. In addition, with the
occurrence of incremental physical design [12] or Engineering Change Orders (ECO),
it is imperative to find an effective and efficient approach to generate the SP from an
arbitrary existing placement as an initial configuration.
∗

Corresponding author.

V.N. Alexandrov et al. (Eds.): ICCS 2006, Part I, LNCS 3991, pp. 482 – 489, 2006.
© Springer-Verlag Berlin Heidelberg 2006

An Improved Algorithm for Sequence Pair Generation

483

The original method to generate SP is “Gridding” [2], which is so complicated that
it can hardly be implemented and the time complexity is assumed to be O (n3), where
n is the number of blocks. The generation procedure in Parquet [13] uses dynamic
programming algorithm to find transitive closure graphs (TCG), which runs in O (n2)
time. In [14], Huo and Ding proposed a much faster generation method and an
algorithm that runs much faster than the TCG algorithm from Parquet. As we know,
the time complexity of traversing a graph is O (n2) or O (n + e), where e is the number
of edges, although it was reported (without proof or experimental results) by Kodama
et. al. that the time complexity of the proposed “Fast-Gridding” algorithm by means
of tracing a constraint graph in [15] is O (n log n).
In this paper, an improved algorithm to generate SP is proposed, which determines
the position of each block on a generation plane based on the relations of every two
blocks, and the time complexity is O (n2). A faster O (n log n) algorithm is also
proposed.

2 Sequence Pair
The topological relations of any two non-overlap module blocks are horizontal and
vertical, i.e., left to, right to, above and below [16], as shown in Fig. 1. Diagonal
relations can be simply degenerated by preferring horizontal relations to vertical ones,
as in Fig. 1(c) where bi is assumed to be left to bj, unless there is a chain of vertical
relations, which is considered as a vertical relation, as shown in Fig. 1(d). For
example, in Fig. 2 block 8 is both left to and above block 3, but there is a vertical
relation chain of them, i.e., block 8 is above block 6 and block 6 above block 3, so
block 8 is said to be above block 3 instead of left to it. Such relations cannot be
determined by just check two blocks, so that many procedures calculate indirect
relations from the transitive closure of immediate relations, which is usually timeconsuming.
An HV-Relation-Set (HVRS) for a set of blocks is a set of horizontal or vertical
relations for all block pairs [17], and a Feasible-HVRS involves all the relations of
blocks excluding non-realizable relations, e.g. {bi is left to bj, bj is left to bk, bk is left
to bi} is not a Feasible-HVRS for blocks bi, bj and bk.

Fig. 1. Possible relations between two blocks bi and bj. (a) bi is left to bj; (b) bi is above bj; (c) bi
is diagonal to bj and assumed to be left to bj; (d) bi is diagonal to bj but a vertical relation chain
exists between bi and bj, i.e., bi is above bk and bk is above bj, so bi is above bj .

484

M. Huo and K. Ding

A Sequence Pair (SP) is an ordered pair of sequences Γ+ and Γ-, each of which is a
sequence of n block names [2], e.g., the SP from Fig. 2 is (Γ+, Γ-) = (154806273,
012453687). A sequence pair corresponds to a Feasible-HVRS as follows:
− bi is left to bj (bj is right to bi): if (Γ+, Γ-) = (… bi … bj …, … bi … bj …)
− bi is below bj (bj is above bi): if (Γ+, Γ-) = (… bj … bi …, … bi … bj …)
The time complexity of the original evaluation procedure “Packing” is O (n2) [2],
and it was later sped up to O (n log log n ) [18].

Fig. 2. A placement of the MCNC apte benchmark with SP (1 5 4 8 0 6 2 7 3, 0 1 2 4 5 3 6 8 7)

3 Generation Algorithms
3.1 Algorithm Embedding
According to the generation method Embedding from [14], algorithm Embedding can
be proposed naturally. To determine the Feasible-HVRS of n blocks, each block
needs to be compared with every other n-1 blocks, which implies the O (n2) time
complexity. However, not all the comparisons are necessary and some of them can be
removed to accelerate the procedure, e.g., if the information of bi above bj and bj
above bk is acquired, bi is absolutely above bk.
Resolve relations and ordering criteria in sequences
The orders of blocks in both sequences can be determined from relations of blocks bi
and bj, as follows:
− bi is before bj (bj is behind bi ) in Γ+: if bi is left to bj or above bj
− bi is before bj (bj is behind bi ) in Γ-: if bi is left to bj or below bj
− bi is before bk in either sequence: if bi is before bj and bj is before bk.
The relations of any two blocks can be just determined by their locations and sizes.
Here we ignore the vertical chain and if bi and bj have both horizontal and vertical
relations. We simply assume their relation is horizontal.
Sort the blocks according to their x coordinates
The order of blocks to be embedded must be determined, in order to eliminate
ambiguities and achieve a correct result. In this algorithm, we sort the blocks

An Improved Algorithm for Sequence Pair Generation

485

according to their x coordinates with introspective sorting and selection algorithms
that performs O (n log n) time complexity in worst cases as discussed in [19].
Insert block names into linked lists according to the sorted order
Two linked lists listx and listy are used to represent the Γ+ and Γ- respectively, which
are generated separately by inserting the block names. To insert block bi into a list, we
traverse the list from its header, check the relations of bi with every visited block bj,
and stop to insert bi before bj, if it is found that bj should be behind bi in the list.
However, if no such block exists, bi is appended to list because it should be current
list tail.
Program section of Embedding for in C++ (only for listx)

sort_blocks(xx) // sort by x coordinates
listx.push_back(xx[0]);// insert the first block
for(idx=1; idx<n; ++idx ) {
i = xx[idx]; //get the block name
for(pos=listx.begin();pos!=listx.end();++pos) {
j = *pos;
r = relation(i,j);
if(r == LEFT || r == ABOVE) { // i precedes j
listx.insert(pos, i);// insert i before j
break;
}
}
if(pos == listx.end()){ // i is currently list tail
listx.push_back(i);
}
}
The procedure “relation” in the algorithm compares block bi and block bj only, so it
runs for constant time. The time complexity of the outer for loop is O (n), so is the
inner one. And thus the total time complexity of algorithm Embedding is O (n2).
Sometimes a placement may correspond to multiple sequence pairs, e.g., the
placement in Fig. 2 has another sequence pair (1 5 4 8 0 6 7 2 3, 0 1 2 3 4 5 6 7 8) as
well as the one discussed in this paper. We pack the generated SP again and check
whether the locations of all the blocks in the new placement match those in the old
one, in order to validate the result.
A sequence pair obtained by Embedding imposes horizontal relation on any pair of
blocks only when the relation of the pair cannot be coded as vertical.
Lemma. Embedding is correct when vertical relation chains exists.
Proof: Suppose the relation of bi and bj is diagonal and there exists a chain of vertical
relations between them. Without loss of generality, bi is supposed to be left to and
above bj, and only one block bk is in the chain, i.e., bi is above bk and bk is above bj, as
illustrated in Fig. 1 (d). If the relation of bi and bj is checked first, the incorrect result
will be returned, i.e., bi is left to bj, according to the ordering criteria. Now that the
relation of x coordinates of the three blocks is xi < xk < xj, and the order to embed
blocks is according to their x coordinates, bk is embedded in advance of bj and the
correct vertical relation of bi and bk is obtained first. Accordingly, the correct vertical

486

M. Huo and K. Ding

relation of bk and bj is obtained later, so the relation of bi and bj is implicated
correctly, i.e., a vertical one, instead of being mistakenly resolved.
Theorem. The Sequence Pair generated by algorithm Embedding is correct.
Proof: If no diagonal relations exist, the relation of every two blocks is unique and the
orders of blocks in both sequences can be correctly determined. If diagonal relations
exist but there are no chains of vertical relations, since we regard such diagonal
relations as horizontal ones, the relation of every pair of blocks is also unique and the
result is correct. The last case is there are both diagonal relations and vertical relation
chains in a placement. According to the preceding Lemma, the algorithm is correct
too. Since the relations of every pair of blocks are determined without ambiguity, the
order in either sequence of SP is correct.
3.2 Reducing Running Time to O (n log n)
Since both Γ+ and Γ- are ordered sequences, we can use balanced binary search trees
to store them. Make use of two binary trees treex and treey to represent Γ+ and Γrespectively, and generate treex and treey separately by inserting the blocks into the
trees. We name this algorithm LogAlgo.
Program section of LogAlgo algorithm in C++ (for treex only)

sort_blocks(xx)
//ltspx is a function object
Ltlogsp ltspx(LEFT, ABOVE);
//treex is a binary tree with
//ordering criteria ltspx
Btree treex(ltspx);
for(idx=0; idx<n; ++idx ) {
i = xx[idx].idx;
treex.insert(i);
}
Class Ltlogsp invokes procedure relation (i, j) that functions the same with the one
of algorithm Embedding when a comparison of two blocks bi and bj is needed. The
insertion operation of Btree includes searching on a binary tree and keeping it
balanced, whose time complexity is O (log n). There are n blocks to be inserted to the
tree in the loop, so the total time complexity is now reduced to O (n log n) from O (n2).
3.3 Experimental Results
After sorting, the order of blocks of the placement in Fig. 1 to be embedded is: 0 1 4 5
2 6 8 3 7. Γ+ and Γ- can be generated separately and simultaneously. Table 1 shows
the running process of the algorithm Embedding to generate the listx from the
placement in Fig. 1 (the results for listy and for other benchmarks is omitted), and the
number of comparisons is 34. Table 2 shows the process of algorithm LogAlgo, with
20 comparisons. Fig. 3 demonstrates the balanced binary tree treex when block 3 and
block 7 is inserted respectively.

An Improved Algorithm for Sequence Pair Generation

487

Table 1. Run of the algorithm after inserted block 0 in list listx. A, B, L and R stand for
relations between two blocks of above, below, left to and right to respectively. List listx is the
list before (without block name in parenthesis) and after intertion of current block.

#
1
4
5

Comparisons
A0
R1, A0
R1, A4

ListX
(1) 0
1 (4) 0
1 (5) 4 0

#
6
8
3

2

R1, B5, B4, R0

1 5 4 0 (2)

7

Comparisons
R1, R5, R4, R0, A2
R1, R5, R4, R0, A6
R1, R5, R4, R0, R8,
B6, R2
R1, R5, R4, R0, R8,
R6, R2, A3

ListX
1 5 4 0 (6) 2
1 5 4 0 (8) 6 2
1 5 4 0 8 6 2 (3)
1 5 4 0 8 6 2 (7) 3

Table 2. Run of the algorithm after inserted block 0 in Btree treex. The inorder traversal results
of treex are listed in column TreeX.

#
1
4
5
2

Comparisons
A0
A0, R1
A4, R1
B4, R0

TreeX
(1) 0
1 (4) 0
1 (5) 4 0
1 5 4 0 (2)

#
6
8
3
7

Comparisons
R4, R0, A2
R4, A6, R0
R4, B6, R2
R4, R6, R2, A3

TreeX
1 5 4 0 (6) 2
1 5 4 0 (8) 6 2
1 5 4 0 8 6 2 (3)
1 5 4 0 8 6 2 (7) 3

Fig. 3. the Btree treex (a) after block 3 and (b) block 7 was inserted, respectively. The newly
inserted node is in shade. Please note that after block 7 was inserted, the tree rotated to keep
balanced.

Experiments on all the MCNC benchmark 1 circuits and the some of the GSRC
benchmark2 circuits are performed in comparison with the generation routine from
Parquet [13] on running time. We first generate the placements of the benchmarks
with the Simulated Annealing algorithm using the LCS evaluation algorithm [18], and
save the placements and their corresponding sequence pairs. Then we take the
placements as input and generate their sequence pairs as output with the programs
respectively. The accumulative running time of the generation 1000 times are listed in
1
2

See: http://www.cse.ucsc.edu/research/surf/GSRC/MCNCbench.html
See: http://www.cse.ucsc.edu/research/surf/GSRC/GSRCbench.html

488

M. Huo and K. Ding

Table 3. It can be seen that our algorithms runs much faster than the routine from
Parquet, and the more complex the placement is, the more speed improvement our
program achieves. In addition, as the number of blocks grows larger than 33, the
LogAlgo algorithm with O (n log n) time complexity outperforms the Embedding
evidently. When there are less than 33 blocks, additional time is needed for the
LogAlgo algorithm to keep the tree balanced.
Table 3. Running time in seconds of our programs and Paquet on MCNC and GSRC
benchmarks

Benchmark
apte
xerox
hp
ami33
ami49
n50a
n100a
n200a
n300a

block #
9
10
11
33
49
50
100
200
300

Parquet
0.0580
0.0740
0.0840
0.7369
1.8127
1.7257
7.4579
35.8016
92.4549

Embedding
0.0100
0.0110
0.0120
0.0470
0.0780
0.0830
0.2570
0.8989
1.9057

LogAlgo
0.0120
0.0130
0.0130
0.0440
0.0670
0.0670
0.1380
0.2940
0.4349

4 Conclusions
In this paper, we introduce an improved algorithm named Embedding to generate
Sequence Pair, which is easier to be implemented than the original “Gridding”
method [2], is more elegant than the graph-based algorithm “Fast-Gridding”[15] and
runs faster than the existing implementation from Parquet. The algorithm uses linked
lists to store the block sequence, whose time complexity is O (n2). We also proposed
an algorithm LogAlgo based on balanced binary search trees that costs O (n log n)
running time. When a placement is composed with more than 33 blocks the LogAlgo
reveals its superiority.

References
1. Goto, S., An efficient algorithm for the two-dimensional placement problem in electrical
circuit layout,IEEE Trans. On Circuits and Systems, (1998), 28(1): 12 - 18
2. Murata, H., et al., Rectangle-packing-based module placement. 1995 IEEE/ACM ICCAD.
Digest of Technical Papers, (1995):. 472-479.
3. Kirkpatrick, S., C.D. Gelatt, and M.P. Vecchi, optimization by simulated annealing.
Science, 1983. 220(4598): (1983) 671-680.
4. Otten, R.H.J.M., Automatic floorplan design. ACM IEEE 9th DAC Proceedings, (1982):
261-267.

An Improved Algorithm for Sequence Pair Generation

489

5. Hong, X.L., et al., A non-slicing floorplanning algorithm using corner block list
topological representation, in 2000 IEEE Asia-Pacific Conference On Circuits And
Systems - Electronic Communication Systems. (2000). 833-836.
6. Pei-Ning, G., C. Chung-Kuan, and T. Yoshimura, An O-tree representation of non-slicing
floorplan and its applications. Proceedings 1999 DAC, (1999): 268-273.
7. Nakatake, S., et al., Module packing based on the BSG-structure and IC layout
applications. IEEE TCAD Of Integrated Circuits And Systems, (1998). 17(6): 519-530.
8. Jai-Ming, L. and C. Yao-Wen, TCG: a transitive closure graph-based representation for
non-slicing floorplans. Proceedings of the 38th DAC, (2001): 764-769.
9. Lin, J.M. and Y.W. Chang, TCG-S: Orthogonal coupling of P*-admissible representations
for general floorplans, in 39th DAC, Proceedings. (2002). 842-847.
10. M. Sarrafzadeh and M. Wang, NRG: Global and detailed placement, Proc. IEEE ICCAD ,
1997. (1997):532–537
11. N. Quinn, and M. Breuer, A force-directed component placement procedure for printed
circuit boards, IEEE Trans. CAS, vol.CAS-26, no.1979(6):.377-388
12. Cong, J. and M. Sarrafzadeh, Incremental physical design. Proceedings International
Symposium on Physical Design, 2000. ISPD-2000, (2000): 84-92.
13. Adya, S.N. and I.L. Markov, Fixed-outline floorplanning through better local search.
Proceedings 2001 IEEE ICCD: VLSI in Computers and Processors. 2001, (2001): 328-334.
14. Huo, MX and Ding, KB, A quick generation method of sequence pair for block
placement, COMPUTATIONAL SCIENCE - ICCS 2005, PT 3 3516: 954-957
15. Kodama, C., Fujiyoshi, K. and Koga, T., A novel encoding method into sequence-pair,.
Proceedings ISCAS 2004, 2004 (5): 329 – 332
16. Onodera, H., Y. Taniguchi, and K. Tamaru, Branch-and-bound placement for building
block layout. 28th ACM/IEEE DAC. Proceedings 1991, (1991): 433-439.
17. Murata, H., et al., A mapping from sequence-pair to rectangular dissection. Proceedings of
the ASP-DAC '97. 1997, (1997): 625-633.
18. Xiaoping, T. and D.F. Wong, FAST-SP: a fast algorithm for block placement based on
sequence pair. Proceedings of the ASP-DAC 2001. 2001, (2001): 521-526.
19. D. R. Musser, "Introspective Sorting and Selection Algorithms", Software Practice and
Experience, 1997, 27(8):983

