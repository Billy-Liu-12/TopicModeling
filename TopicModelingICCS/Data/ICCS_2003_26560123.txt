Resettable Zero-Knowledge in the Weak
Public-Key Model
Yunlei Zhao1,3 , Xiaotie Deng2 , C.H. Lee2 , and Hong Zhu3
1

Software School
Fudan University, Shanghai, China
csylzhao@cityu.edu.hk
2
Department of Computer Science
City University of Hong Kong, Hong Kong
{csdeng,chlee}@cityu.edu.hk
3
Department of Computer Science
Fudan University, Shanghai, China

Abstract. A new public-key model for resettable zero-knowledge (rZK)
protocols, which is an extension and generalization of the upperbounded public-key (UPK) model introduced by Micali and Reyzin [EuroCrypt’01, pp. 373–393], is introduced and is named weak public-key
(WPK) model. The motivations and applications of the WPK model are
justiﬁed in the distributed smart-card/server setting and it seems more
preferable in practice, especially in E-commerce over Internet. In this
WPK model a 3-round (optimal) black-box resettable zero-knowledge
argument with concurrent soundness for N P is presented assuming the
security of RSA with large exponents against subexponential-time adversaries. Our result improves Micali and Reyzin’s result of resettable
zero-knowledge argument with concurrent soundness for N P in the UPK
model. Note that although Micali and Reyzin’ protocol satisﬁes concurrent soundness in the UPK model, but it does not satisfy even sequential
soundness in our WPK model.
Our protocol works in a somewhat “parallel repetition” manner to reduce
the error probability and the black-box zero-knowledge simulator works
in strict polynomial time rather than expected polynomial time. The
critical tools used are: veriﬁable random functions introduced by Micali,
Rabin and Vadhan [FOCS’99, pp. 120-130], zap presented by Dwork and
Naor [FOCS’00, pp. 283–293] and complexity leveraging introduced by
Canetti, Goldreich, Goldwasser and Micali [STOC’00, pp. 235–244].

1

Introduction

The strongest notion of zero-knowledge to date, resettable zero-knowledge (rZK),
was recently put forward by Canetti, Goldreich, Goldwasser and Micali [8].
Roughly speaking, an rZK protocol is an interactive system in which a veriﬁer learns nothing (except for the verity of a given statement) even if he can
interact with the prover polynomial many times, each time restarting an interaction with the prover using the same conﬁguration and random tape. rZK
E. Biham (Ed.): EUROCRYPT 2003, LNCS 2656, pp. 123–139, 2003.
c International Association for Cryptologic Research 2003

124

Y. Zhao et al.

enlarges the number of physical ways to implement zero-knowledge protocols
while guaranteeing security is preserved. For example, rZK makes it possible to
implement the zero-knowledge prover by using those devices that may be possibly (maliciously) resetted to their initial conditions or can not aﬀord to generate
fresh randomness for each new invocation. An example of those devices is the
ordinary smart card. rZK is also guaranteed to preserve the prover’s security
when the protocol is executed concurrently in an asynchronous network like the
Internet. Actually, rZK is a generalization and strengthening of the notion of
concurrent zero-knowledge introduced by Dwork, Naor and Sahai [12].
1.1

Previous Results

Under standard complexity assumptions, non-constant-round resettable zeroknowledge proof for N P was constructed in [8,22] by properly modifying the
concurrent zero-knowledge protocol of Richardson and Killian [28]. Unfortunately, there are no constant-round rZK protocols in the standard model, at
least for the black-box case, as shown by Canetti, Killian, Petrank and Rosen
[9]. To get constant-round resettable zero-knowledge protocols Canetti, Goldreich, Goldwasser and Micali [8] introduced an appealingly simple model, the bare
public-key (BPK) model, and presented a 5-round rZK argument for N P in this
model. The round complexity was further reduced to four by Micali and Reyzin
[24].
A protocol in the BPK model simply assumes that all veriﬁers have deposited
a public key in a public ﬁle before any interaction among the users. This public
ﬁle is accessible to all users at all times. Note that an adversary may deposit
many (possibly invalid) public keys in it, particularly, without even knowing
corresponding secret keys or whether such exist. We remark that the BPK model
is a weak version of the frequently used Public-Key Infrastructure (PKI) model,
which underlies any public key cryptosystem or digital signature.
Resettable zero-knowledge protocols also shed hope on ﬁnding ID schemes
secure against resetting attack. Feige, Fiat and Shamir [16,14] introduced a
paradigm for ID schemes based on the notion of zero-knowledge proof of knowledge. In essence, a prover identiﬁes himself by convincing the veriﬁer of knowing
a given secret. Almost all subsequent ID schemes followed this paradigm, and
were traditionally implemented by the prover being a smart card. However, up
to the emergence of rZK all the previous Fiat-Shamir like ID schemes fail to
secure whenever the prover is resettable. Using constant-round rZK protocols
in the BPK model above, Bellare, et al. [3] provided identiﬁcation protocols secure against resetting attack. Unfortunately, there is a main disadvantage of this
rZK-based solution since it only preserves the identity prover’s security but does
not guarantee to preserve any security of the identity veriﬁer when the identiﬁcation protocol is concurrently executed in an asynchronous setting like the
Internet. Actually, if an adversary is allowed to concurrently interact with the
identity veriﬁers then the adversary can easily impersonate the identity prover.
The reason is just that the underlying resettable zero-knowledge protocols in the

Resettable Zero-Knowledge in the Weak Public-Key Model

125

BPK model [8,24] do not guarantee to preserve veriﬁer’s security when they are
concurrently executed.
The various security notions of the veriﬁer in public-key models were ﬁrst
noted and clariﬁed by Micali and Reyzin [24,27]. In public-key models, a veriﬁer
V has a secret key SK, corresponding to its public-key P K. A malicious prover
P ∗ could potentially gain some knowledge about SK from an interaction with
the veriﬁer. This gained knowledge might help him to convince the veriﬁer of a
false theorem in another interaction. In [24] four soundness notions in public-key
models were deﬁned in which each implies the previous one: one-time soundness,
sequential soundness, concurrent soundness, resettable soundness. In this paper
we focus on concurrent soundness which roughly means that a malicious prover
P ∗ can not convince the honest veriﬁer V of a false statement even P ∗ is allowed multiple interleaved interactions with V . As discussed above, resettable
zero-knowledge protocols with concurrent soundness are really desirable in most
smart-card and Internet based applications. Unfortunately, up to now we do
not know how to construct resettable zero-knowledge protocols with concurrent
soundness for N P in the BPK model. In a stronger version of BPK model introduced by Micali and Reyzin [25] in which each public-key of an honest veriﬁer
is restricted to be used at most a priori bounded polynomial times, the upperbounded public-key (UPK) model, Micali and Reyzin gave a 3-round black-box
rZK argument with sequential soundness for N P in the UPK model [25]. And
Reyzin [27] further proved that it also satisﬁes concurrent soundness in the UPK
model.
Regarding the round-complexity of resettable zero-knowledge protocols for
N P in public-key models, Micali and Reyzin [24,25] showed that any (resettable
or not) black-box zero-knowledge protocol in public-key models for a language
outside of BPP requires at least three rounds (using an earlier result of Goldreich
and Kraczwyck [20]). For eﬃcient 4-round zero-knowledge protocols for N P,
readers are referred to [7]. We also note that 2-round public-coin black-box and
concurrent zero-knowledge protocols for N P do exist under the assumption that
the prover is resource bounded [13]. Here, resource bounded prover means that
during protocol execution the prover uses certain limited amount of (say, a-priori
polynomial bounded) time or non-uniform advice.
1.2

Our Contributions

In this paper, we introduce a new public-key model for resettable zero-knowledge
(rZK) protocols, which we name it weak public-key (WPK) model. Roughly
speaking, in the WPK model the public-key of an honest veriﬁer V can be used
by an (even malicious) prover P ∗ for any polynomial times just as allowed in
the BPK model. But for each theorem statement x selected by P ∗ on the ﬂy x
is restricted to be used at most a priori bounded polynomial times with respect
to the same veriﬁer’s public key. Note that if the same veriﬁer’s public-key is
restricted to be used at most a priori bounded polynomial times just as required
in the UPK model then for each common input x selected by P ∗ x is also
restricted to be used at most a priori bounded polynomial times with respect

126

Y. Zhao et al.

to the same veriﬁer’s public key. It means the WPK model is an extension and
generalization of the UPK model. Really, the WPK model just lies between the
BPK model and the UPK model. That is, the WPK model is stronger than the
BPK model but weaker than the UPK model.
The main result of this paper is a 3-round black-box resettable zeroknowledge argument with concurrent soundness for N P in the WPK model.
The round complexity is optimal according to Micali and Reyzin’s result. In
comparison with Micali and Reyzin’s 3-round rZK argument with concurrent
soundness for N P in the UPK model [25], we remark that our protocol in the
WPK model is also an rZK argument with concurrent soundness for N P in
the UPK model since the WPK model is an extension and generalization of the
UPK model. But, the concurrent soundness of Micali and Reyzin’s protocol is
not preserved in our WPK model. The reason is that the concurrent soundness
of Micali and Reyzin’s protocol relies on the restriction that the public-key of
V can not be used by P ∗ more than a priori bounded polynomial times and
without this restriction P ∗ can easily cheat V with non-negligible probability
(even with probability 1). Since this restriction is removed in our WPK model,
it means that Micali and Reyzin’s protocol not only does not satisfy concurrent
soundness in our WPK model but also even does not satisfy sequential soundness in the WPK model. Our protocol can be viewed as an improvement and
extension of Micali and Reyzin’ result.
Motivations, applications, and implementation of the WPK model. As
an extension and generalization of the UPK model, roughly speaking, almost all
the ways to implement the UPK model [25] can also be used to implement our
WPK model. A simple way is to just let the honest veriﬁer to keep a counter
for each common input on which he has been invoked. This is an extension of
the implementation of the UPK model in which an honest veriﬁer keeps a single
counter for all common inputs (selected on the ﬂy by a malicious prover) on
which he has been invoked.
Note that one of the major applications of resettable zero-knowledge is that
it makes it possible to implement zero-knowledge prover by those devices that
may be possibly maliciously resetted to their initial conditions or can not aﬀord
to generate fresh randomness for each invocation. The most notable example of
such devices is the widely used smart card. Also as argued above resettable zeroknowledge provides the basis for identiﬁcation protocols secure against resetting
attacks [3]. Then we consider the distributed client/server setting in which the
clients are implemented by smart cards. We remark that this setting is widely
used in practice, especially in E-commerce over Internet. When a resettable
identiﬁcation protocol is executed in this distributed smart-card/server setting
we view the identity of each smart-card as the common input. An adversary may
hold many (any polynomial number of) smart-cards but in our WPK model we
require that each smart-card can be used by the adversary at most a priori
polynomial times. Note that in practice each smart-card has an expiry date that
corresponds to in some level the a-priori bounded polynomial restriction required

Resettable Zero-Knowledge in the Weak Public-Key Model

127

in our WPK model. We remark that in this distributed smart-card/server setting
there usually exists a central server that may be located in a central bank or
other organizations and plays the veriﬁer’s role. In practice the central server
keeps a record for each smart card and dynamically updates its information. It
is easy for this central server to keep a counter in each record to remember how
many times the corresponding smart-card has been used. We stress that in this
distributed smart-card/server setting since the server (veriﬁer) may be invoked
and interacted concurrently with many smart-cards, the design of rZK protocols
with concurrent soundness in the WPK model is really desirable.
1.3

Organization of This Paper

In Section 2, we recall the tools we will use in this paper. In Section 3, we provide
the formal description of the WPK model. In Section 4, we present the 3-round
black-box resettable zero-knowledge argument with concurrent soundness for
N P in the WPK model.

2

Preliminaries

In this section, we present some main tools used in this paper. However, one
critical tool, zap presented in [11], is absent from this section and is provided in
Section 3 together with the deﬁnition of resettable witness indistinguishability.
We remark that all these tools can be constructed assuming the security of RSA
with large prime exponents against subexponential-time adversaries.
Deﬁnition 1 (one-round perfect-binding commitments). A one-round
perfect-binding commitment scheme is a pair of probabilistic polynomial-time
(PPT) algorithms, denoted (C, R), satisfying:
– Completeness. ∀k, ∀v, let c = Csv (1k , v) and d = (v, sv ), where C is a
PPT commitment algorithm while using sv as its randomness and d is the
R
corresponding decommitment to c, it holds that Pr[(c, d) ←− C(1k , v) :
R(1k , c, v, d) = YES] = 1, where k is security parameter.
– Computational hiding. For every v, u of equal p(k)-length, where p is a positive polynomial and k is security parameter, the random variables Csv (1k , v)
and Csu (1k , u) are computationally indistinguishable.
– Perfect binding. For every v, u of equal p(k)-length, the random variables
Csv (1k , v) and Csu (1k , u) have disjoint support. That is, for every v, u and
m, if Pr[Csv (1k , v) = m] and Pr[Csu (1k , u) = m] are both positive then
u = v and sv = su .
A one-round perfect-binding commitment scheme can be constructed based
on any one-way permutation [17].
Deﬁnition 2 (Pseudorandom Functions PRF [19]). A pseudorandom
function family is a keyed family of eﬃciently computable functions, such that

128

Y. Zhao et al.

a function picked at random from the family is indistinguishable (via oracle access) from a truly random function with the same domain and range. Formally,
a function PRF: {0, 1}n × {0, 1}∗ → {0, 1}n is a pseudorandom function if for
α
all 2n -size adversaries ADV, the following diﬀerence is negligible in n:
Pr P RF Key ←− {0, 1}n : ADV P RF (P RF Key, ·) = 1
R

∗

− Pr F ←− ({0, 1}n ){0,1} : ADV F (·) = 1
R

The value α is called the pseudorandomness constant.
Deﬁnition 3 (non-interactive zero-knowledge NIZK [2,4]). Let N IP and
N IV be two probabilistic interactive machines, and let N IσLen be a positive
polynomial. We say that < N IT, N IV > is an NIZK proof system for an N P
language L, if the following conditions hold:
– Completeness. For any x ∈ L of length n, any σ of length N IσLen(n),
R
and N P-witness y for x ∈ L, it holds that Pr[Π ←− N IP (σ, x, y) :
N IV (σ, x, Π)
= YES] = 1.
R
– Soundness. ∀x ∈
/ L of length n, Pr[σ ←− {0, 1}N IσLen(n) : ∃ Π s. t.
N IV (σ, x, Π) = YES] is negligible in n.
– Zero-Knowledge. ∃ α > 0 and a PPT simulator N IS such that, ∀ suﬃciently
large n, ∀x ∈ L of length n and N P-witness y for x ∈ L, the following two
α
distributions are indistinguishable by any 2n -gate adversary:
R
[(σ , Π ) ←− N IS(x) : (σ , Π ] and
R
R
[σ ←− {0, 1}N IσLen(n) ; Π ←− N IP (σ, x, y) : (σ, Π)].
The value α is called the NIZK constant.
Non-interactive zero-knowledge proof systems for N P can be constructed
based on any one-way permutation [15] and one-way permutations can be constructed in turn under RSA assumption [18]. An eﬃcient implementation based
on any one-way permutation can be found in [21]. For more recent advances in
NIZK readers are referred to [10].
2.1

Veriﬁable Random Functions

A family of veriﬁable random functions (VRF), ﬁrst introduced in [26], is essentially a pseudorandom function family with an additional property that the
correct value of a function on an input can not only be computed by the owner
of the seed, but also be proven to be the unique correct value. The proof can be
veriﬁed by anyone who knows the public-key corresponding to the seed.
Deﬁnition 4 (Veriﬁable Random Functions). Let VRFGen, VRFEval,
VRFProve and VRFVer be polynomial-time algorithms (the ﬁrst and the last are

Resettable Zero-Knowledge in the Weak Public-Key Model

129

probabilistic, and the middle two are deterministic). Let a : N → N ∪ {0, 1}∗
and b : N → N be any two functions that are computable in time poly(k) and
bounded by a polynomial in k (except when a takes on {0, 1}∗ ).
We say that (VRFGen, VRFEval, VRFProve, VRFVer) is a veriﬁable pseudorandom function (VRF) with input length a(k) and output length b(k) under
a security parameter k if the following properties hold:
1. The following two conditions hold with probability 1 − 2−Ω(k) over the choice
of
R
(V RF P K, V RF SK) ←− VRFGen(1k ):
a) (Domain-Range Correctness):
∀x ∈ {0, 1}a(k) , VRFEval(V RF SK, x) ∈ {0, 1}b(k) .
b) (Complete Probability): ∀x ∈ {0, 1}a(k) , if v = VRFEval(V RF SK, x) and
pf = VRFProve(V RF SK, x), then
Pr[VRFVer(V RF P K, x, v, pf ) = YES] > 1 − 2−Ω(k)
(This probability is over the coin tosses of VRFVer).
2. (Unique Probability) For every V RF P K, x, v1 , v2 , pf1 , pf2 such that v1 = v2 ,
the following holds for either i = 1 or i = 2:
Pr[VRFVer(V RF P K, x, vi , pfi ) = YES] < 2−Ω(k)
(This probability is over the coin tosses of VRFVer).
3. (Residual Pseudorandomness): Let α > 0 be a constant. Let T = (TE , TJ )
be any pair of algorithms such that TE (·, ·) and TJ (·, ·) run for a total of
α
at most 2k steps when their ﬁrst input is 1k . Then the probability that T
α
succeeds in the following experiment is at most 1/2 + 1/2k :
k
a) Run VRFGen(1 ) to obtain (V RF P K, V RF SK).
VRFEval(V RF SK, ·),VRFProve(V RF SK, ·) k
(1 , V RF P K) to obtain the pair
b) Run TE
(x, state).
R
c) Choose r ←− {0, 1}.
– if r = 0, let v = VRFEval(V RF SK, x)
R
– if r = 1, choose v ←− {0, 1}b(k)
VRFEval(V RF SK, ·),VRFProve(V RF SK, ·) k
d) Run TJ
(1 , V RF P K, v, state) to obtain
a guess.
e) T = (TE , TJ ) succeeds if x ∈ {0, 1}a(k) , guess = r, and x was
not asked by either TE or TJ as a query to VRFEval(V RF SK, ·) or
VRFProve(V RF SK, ·).
We call α the pseudorandomness constant.
The above veriﬁable pseudorandom functions can be constructed assuming
RSA with large prime exponents against subexponential-time adversaries [26].
Very recently, a new construction of VRF was provided by Lysyanskaya on an
assumption about groups in which decisional Diﬃe-Hellman is easy, but computational Diﬃe-Hellman is hard [23]. We remark that up to now the ﬁrst application of VRF, as suggested by Micali and Reyzin, is the simple construction of
an rZK argument with one-time soundness for N P in the BPK model [24]. Our
result can be viewed as another major application of VRF.

130

3

Y. Zhao et al.

The Weak Public-Key (WPK) Model

In this section, we present the formal deﬁnitions of resettable zero-knowledge
and concurrent soundness in our WPK model.
3.1

Honest Players in the WPK Model

The WPK model consists of the following:
– F be a public-key ﬁle that is a polynomial-size collection of records
(id, P Kid ), where id is a string identifying a veriﬁer and P Kid is its (alleged) public-key.
– P (1n , x, y, F, id, w) be an honest prover that is a polynomial-time interactive
machine, where 1n is a security parameter, x is an n-bit string in L, y is
an auxiliary input, F is a public-ﬁle, id is a veriﬁer identity, and w is his
random-tape.
– V be an honest veriﬁer that is an polynomial-time interactive machine working in two stages.
1. Key generation stage. V , on a security parameter 1n and a random-tape
r, outputs a public-key P K and remembers the corresponding secret key
SK.
2. Veriﬁcation stage. V , on inputs SK, x ∈ {0, 1}n and a random tape ρ,
performs an interactive protocol with a prover and outputs “accept x”
or “reject x”. We stress that in our WPK model for each common input
x on which the veriﬁcation stage of V has been invoked the honest veriﬁer V keeps a counter in secret with upperbound U (n), a priori bounded
polynomial, to remember how many times the veriﬁcation stage has been
invoked on the same x and refuses to participate in other interactions
with respect to the same x once the counter reading reaches its upperbound U (n). It means that each common input x can not be used (even
by a malicious prover) more than U (n) times with respect to the same
P Kid , where id is the identity of the honest veriﬁer V .
3.2

The Malicious Resetting Veriﬁer and Resettable
Zero-Knowledge

A malicious (s, t)-resetting malicious veriﬁer V ∗ , where t and s are positive
polynomials, is a t(n)-time TM working in two stages so that, on input 1n ,
Stage 1. V ∗ receives s(n) distinct strings x1 , · · · , xs(n) of length n each, and
outputs an arbitrary public-ﬁle F and a list of (without loss of generality)
s(n) identities id1 , · · · , ids(n) .
Stage 2. Starting from the ﬁnal conﬁguration of Stage 1, s(n) random tapes,
w1 , · · · , ws(n) , are randomly selected and then ﬁxed for P , resulting in s(n)3
deterministic prover strategies P (xi , idj , wk ), 1 ≤ i, j, k ≤ s(n). V ∗ is then
given oracle access to these s(n)3 provers, and ﬁnally outputs its “view” of
the interactions (i. e. its random tape and messages received from all his
oracles).

Resettable Zero-Knowledge in the Weak Public-Key Model

131

Deﬁnition 5 (Black-box Resettable Zero-Knowledge). A protocol <
P, V > is black-box resettable zero-knowledge for a language L ∈ N P if there
exists a black-box simulator M such that for every (s, t)-resetting veriﬁer V ∗ ,
the following two probability distributions are indistinguishable. Let each distributions be indexed by a sequence of common distinct inputs x
¯ = x1 , · · · , xs(n) ∈
x) = y1 , · · · , ys(n) :
L ∩ {0, 1}n and their corresponding N P -witnesses aux(¯
Distribution 1. The output of V ∗ obtained from the experiment of choosing
w1 , · · · , ws(n) uniformly at random, running the ﬁrst stage of V ∗ to obtain
F , and then letting V ∗ interact in its second stage with the following s(n)3
instances of P : P (xi , yi , F, idj , wk ) for 1 ≤ i, j, k ≤ s(n). Note that V ∗ can
of P .
oracle access to these s(n)3 instances
∗
Distribution 2. The output of M V (x1 , · · · , xs(n) ).
Remark 1. In Distribution 1 above, since V ∗ oracle accesses to s(n)3 instances
P : P (xi , yi , F, idj , wk ), 1 ≤ i, j, k ≤ s(n), it means that V ∗ may invoke and
interact with the same P (xi , yi , F, idj , wk ) multiple times, where each such interaction is called a session. We remark that there are two versions for V ∗ works
in Distribution 1.
1. Sequential version. In this version, a session must be terminated (either completed or aborted) before V ∗ initiating a new session. That
is, V ∗ is required to terminate its current interaction with the current oracle P (xi , yi , F, idj , wk ) before starting an interaction with any
P (xi , yi , F, idj , wk ), regardless of (i, j, k) = (i , j , k ) or not. Thus, the
activity of V ∗ proceeds in rounds. In each round it selects one of his oracles
and conducts a complete interaction with it.
2. Interleaving version. In this version the above restriction is removed and so
V ∗ may initiate and interact with P (xi , yi , F, idj , wk )s concurrently in many
sessions. That is, we allow V ∗ to send arbitrary messages to each of the
P (xi , yi , F, idj , wk ) and obtain the response of P (xi , yi , F, idj , wk ) to such
message.
However, these two versions are equivalent as shown in [8]. In other words,
interleaving interactions do not help the malicious veriﬁer get more advantages
on learning knowledge from his oracles than he can do by sequential interactions.
Without loss of generality, in the rest of this paper we assume the resetting
malicious veriﬁer V ∗ works in the sequential version.
Deﬁnition 6 (Resettable Witness Indistinguishability rWI). A protocol
< P, V > is said to be resettable witness indistinguishable for an L ∈ N P if
for every pair of positive polynomials (s, t), for every (s, t)-resetting malicious
veriﬁer V ∗ , two distribution ensembles of Distribution 1 (deﬁned in Deﬁnition
5), which are indexed by the same x
¯ but possibly diﬀerent sequence of prover’s
(1)
(1)
(2)
(2)
N P-witnesses : aux(1) (¯
x) = y1 , · · · , ys(n) and aux(2) (¯
x) = y1 , · · · , ys(n) , are
computationally indistinguishable.
In [8] Canetti et al. ﬁrst gave a 4-round rWI for N P. The round-complexity
is drastically reduced to 2 by Dwork and Naor [11], where they named such a
2-round WI a zap.

132

Y. Zhao et al.

Dwork and Naor’s 2-round rWI proof for N P [11]. The prover P has
a private random string s that determines a pseudorandom function fs . Let L
be an N P-Complete language and RL be its corresponding N P relation. Under
a security parameter n, let p be a positive polynomial and x ∈ {0, 1}n be the
common input and y be the corresponding N P-witness (kept in secret by the
prover) for x ∈ L.
Step 1. The veriﬁer V uniformly selects (ﬁxes once and for all) p(n) random
strings RV = (RV1 , RV2 , · · · , RVp(n) ) with length N IσLen(n) each and sends
them to P .
Step 2. Let fs (x, y, RV ) = (r1 , r2 , · · · , rp(n) , RP ), where the length of RP is
also N IσLen(n). For each i, 1 ≤ i ≤ p(n), on x and y, P uses ri as its
randomness to compute an NIZK proof Πi with respect to common random
string RP ⊕ RVi . In the rest of this paper we denote by Πi N IZK(x, RP ⊕
RVi ), 1 ≤ i ≤ p(n). Finally P sends RP along with all the p(n) NIZK proofs
to V .
An interesting property of Dwork and Naor’s 2-round rWI is that RV in Step
1 can be ﬁxed once and for all and applied to any instance of length n [11]. It
means RV can be posted in one’s public key in the public-key model. We will
use this property in our construction later. We also note that using the general
result of existence of zaps for N P (rather than the above speciﬁc NIZK-based
construction) may further simplify the construction of the protocol presented in
Section 4. We will investigate it in a late full version.

3.3

Concurrent Soundness in the WPK Model

For an honest veriﬁer V with public-key P K and secret-key SK, an (s, t)concurrent malicious prover P ∗ in our WPK model, for a pair positive polynomials (s, t), be a probabilistic t(n)-time Turing machine that, on a security
parameter 1n and P K, performs concurrently at most s(n) interactive protocols
(sessions) with V as follows.
If P ∗ is already running i − 1 (1 ≤ i − 1 ≤ s(n)) sessions, it can select
on the ﬂy a common input xi ∈ {0, 1}n (which may be equal to xj for 1 ≤
j < i) and initiate a new session with the veriﬁcation stage of V (SK, xi , ρi )
on the restriction that the same xi can not be used by P ∗ in more than U (n)
sessions, where U (n) is the a priori bounded polynomial indicating the upperbound of the corresponding counter kept in secret by V for xi . We stress that
in diﬀerent sessions V uses independent random-tapes in his veriﬁcation stage
(that is, ρ1 , · · · , ρi (1 ≤ i ≤ s(n)) are independent random strings).
We then say a protocol satisﬁes concurrent soundness in our WPK model
if for any honest veriﬁer V , for all positive polynomials (s, t), for all (s, t)concurrent malicious prover P ∗ , the probability that there exists an i (1 ≤ i ≤
s(n)) such that V (SK, xi , ρi ) outputs “accept xi ” while xi ∈ L and xi is not
used in more than U (n) sessions is negligible in n.

Resettable Zero-Knowledge in the Weak Public-Key Model

4

133

3-Round Resettable Zero-Knowledge Argument for
N P with Concurrent Soundness in the WPK Model

In this section, we present the main result of this paper: a 3-round resettable
zero-knowledge argument for N P with concurrent soundness in the WPK model.
As discussed before, the design of such a protocol is really desirable in practice.
Three tools are crucial to our construction: veriﬁable pseudorandom functions
[26], Dwork and Naor’s 2-round rWI [11] and “complexity leveraging” [8].
4.1

Complexity Leveraging

The “complexity leveraging” is used as follows. Let α be the pseudorandom
constant of a VRF (that is, the output of VRFEval is indistinguishable from
α
random for circuit of size 2k , where k is the security parameter of the VRF).
Let γ1 be the following constant: for all suﬃciently large n, the length of the N Pwitness y for x ∈ L ∩ {0, 1}n is upper-bounded by nγ1 . Let γ2 be the following
constant: for all suﬃciently large n, the length of the NIZK proof Π for an
N P-statement x ∈ L of length poly(n) is upper-bounded by nγ2 . We then set
γ = max{γ1 , γ2 } and ε > γ/α. We use a VRF with a larger security parameter
k = nε . This ensures that one can enumerate all potential N P-witnesses y, or all
γ
potential NIZK proofs for x , in time 2n , which still lesser than the time it would
γ
α
take to break the residual pseudorandomness of the VRF (because 2n < 2k ).
4.2

The VRF Used

Let x be the common input of length n, and U be an a-priori bounded polynomial
indicating the upper-bound of the corresponding counter kept by an honest
veriﬁer for x. That is x is allowed to be used at most U (n) times by a malicious
prover with the same honest veriﬁer. We need a veriﬁable pseudorandom function
with input length n and output length 2U (n) · n2 . We denote by
1
2 2
2
n n
n
VRFEval(V RF SK, x) = R11 R21 · · · R2U
(n) R1 R2 · · · R2U (n) · · · R1 R2 · · · R2U (n) the
output of VRF on input x of length n, where for each i (1 ≤ i ≤ n) and each j
(1 ≤ j ≤ 2U (n)), the length of Rji is n.
4.3

Key Generation of V

Under a system security parameter n, each veriﬁer with identity id, Vid , generates a key pair (V RF SK, V RF P K)id for a VRF with security parameter k. Vid
then uniformly selects p(n) random strings (RV1 , RV2 , · · · , RVp(n) )id to be used
as the ﬁrst message of Dwork and Naor’s 2-round rWI, where p is a positive
polynomial. V RF SKid is Vid ’s secret key and V RF P Kid along with the p(n)
random strings, (RV1 , RV2 , · · · , RVp(n) )id , is its public key. We remark that in
comparison with the key generation stage of Micali and Reyzin’s protocol [25],
the key generation stage of our protocol is greatly simpliﬁed.

134

4.4

Y. Zhao et al.

The Full Protocol

Common input. An element x ∈ L ∩ {0, 1}n . Denote by RL the corresponding
N P-relation for L.
System Security parameter n. (Note that the security parameter of the
VRF is k that is much larger than n).
Public ﬁle. A collection F of records (id, P Kid ), where P Kid = (V RF P Kid ,
(RV1 , RV2 , · · · , RVp(n) )id ).
P private input. An N P-witness y for x ∈ L; V ’s id and the ﬁle F ; and a
random string w that determines a PRF fw .
V private input. A secret key SKid = V RF SKid .
P -step-one
1. Using the PRF fw , P generates RP and (s11 , s12 , · · · , s12U (n) , s21 , s22 , · · · ,
s22U (n) , · · · , sn1 , sn2 , · · · , sn2U (n) ) from the inputs x, y, and P Kid . RP will
be served as the ﬁrst part of the second message of Dwork and Naor’s
2-round rWI and the other 2U (n)·n pseudorandom strings will be served
as the randomnesses used in the one-round perfect binding commitment
scheme deﬁned in Deﬁnition 1.
2. Selects 2U (n) · n arbitrary strings of length 2U (n) · n2 each:
(t11 , t12 , · · · , t12U (n) , t21 , t22 , · · · , t22U (n) , · · · , tn1 , tn2 , · · · , tn2U (n) ). Let Com =
{c(i, j) = Csij (tij ), 1 ≤ i ≤ n and 1 ≤ j ≤ 2U (n)}, where C is the oneround perfect binding commitment scheme deﬁned in Deﬁnition 1.
3. P sends (RP , Com) to V .
V -step one
1
2 2
2
1. Computes V Rx = VRFEval(SKid , x) = R11 R21 · · · R2U
(n) R1 R2 · · · R2U (n)
n
· · · R1n R2n · · · R2U
(n) , and pfx = VRFProve(SKid , x). Note that SKid =
V RF SK. We call each Rji , 1 ≤ i ≤ n and 1 ≤ j ≤ 2U (n), a block with
respect to the pair (x, id).
2. Randomly selects (j1 , j2 , · · · , jn ), where ji , 1 ≤ i ≤ n, is uniformly
distributed over {1, 2, · · · , 2U (n)}. For each i, 1 ≤ i ≤ n, computes
V RRji = VRFEval(SKid , Rji i ) and pfRji = VRFProve(SKid , Rji i ).
i
i
3. V sends (V Rx , pfx , (j1 , j2 , · · · , jn ), (V RRj1 , V RRj2 , · · · , V RRjnn ),
1
2
(pfRj1 , pfRj2 , · · · , pfRjnn )) to the prover P .
1
2
P-step-two
1. Veriﬁes that V Rx is correct by invoking VRFVer(V RF P K, x, V Rx , pfx ).
If not, aborts.
2. For each i, 1 ≤ i ≤ n, veriﬁes that V RRji is correct by invoking
i

VRFVer(V RF P K, Rji i , V RRji , pfRji ). If not, aborts.
i
i
3. Constructs another N P-statement: x =“there exists an N P-witness y
such that (x, y) ∈ RL OR for each i, 1 ≤ i ≤ n, there exists a j ∈
{1, 2, · · · , 2U (n)} and a string sij such that ci, j = Csij (V RRji )”.
i
4. As does in the second round of Dwork and Naor’s 2-round rWI, on the
statement x while using y as the witness P generates and sends to V
p(n) NIZK proofs {N IZK(x , RP ⊕RVi ), 1 ≤ i ≤ p(n)}. The randomness

Resettable Zero-Knowledge in the Weak Public-Key Model

135

used by P is got by applying his PRF fw on the transcript so far. In the
rest of this paper, we denote by {N IZK(x , RP ⊕ RVi ), 1 ≤ i ≤ p(n)} a
p(n)-NIZK-proof sequence.
Veriﬁer’s Decision. If the p(n) NIZK proofs above are all acceptable then
accepts, otherwise, rejects.
Theorem 1. Assuming the security of RSA with large exponents against
subexponential-time adversaries, the above protocol is a 3-round black-box resettable zero-knowledge argument with concurrent soundness for N P in the WPK
model.
Proof. (sketch)
The completeness and the optimal round-complexity of our protocol can
be easily checked. In the rest we focus on proofs of black-box resettable zeroknowledge and concurrent soundness.
(1). Black-Box Resettable Zero-Knowledge
The rZK property can be shown in a way similar to (and simpler than) the
way shown in [8].
Speciﬁcally, for any (s, t)-resetting malicious veriﬁer V ∗ , suppose the outputs
of the ﬁrst stage of V ∗ are: s(n) distinct strings x1 , x2 , · · · , xs(n) ∈ L of length n
each, the public ﬁle F and a list of s(n) identities id1 , id2 , · · · , ids(n) . Intuitively,
if for each block, Rji (1 ≤ i ≤ n and 1 ≤ j ≤ 2U (n)), with respect to (xk , idt ),
1 ≤ k, t ≤ s(n), the simulator can learn the output of VRFEval on Rji before
his commitments in P-step-one then it is easy for the simulator to generate a
transcript that is computationally indistinguishable from the real interactions
between P and V ∗ . That is, the simulator simulates the P-step-one by just
setting tij = VRFEval(V RF SK, Rji ), 1 ≤ i ≤ n and 1 ≤ j ≤ 2U (n). Since for
an (s, t)-resetting veriﬁer V ∗ , there are at most s(n)2 · 2U (n) · n blocks in total,
the simulator works as follows to generate a simulated transcript while oracle
accessing to V ∗ .
The simulator works in s(n)2 · 2U (n) · n + 1 phases. Each phase corresponds
to an attempt to simulate the real interactions between P and V ∗ and so each
phase may consist of multiple sessions. In each phase the simulator uses an
independent random-tape to try to simulate the real interactions between P
and V ∗ except that at the current session V ∗ invokes P on the same x and P Kid
that has been used in a previous session. In this case, the simulator simulates
the P-step-one of current session by just copy the P-step-one messages sent in
the previous session. In each phase, suppose V ∗ invokes P on x and P Kid at
the current session then the simulator simulates the P-step-one of the current
session by committing to the outputs of VRFEval on the blocks with respect
to (x, id) he has learnt previously, together with committing to some garbage
values if he has not yet leant the outputs of VRFEval on all the blocks with
respect to the pair (x, id). We remark that at any point in the simulation if the
simulator detects cheating (e. g. the V-step-one messages do not pass through

136

Y. Zhao et al.

the VRFVer test correctly) then the simulator aborts the simulation and outputs
the transcript so far. It is easy to see that in each phase if V ∗ does not select a
new block in this phase then the simulator succeeds in generating a simulated
transcript that is indistinguishable from the real interactions between P and V ∗
due to the pseudorandomness of the PRF used and the computational hiding
of the commitment scheme and the witness indistinguishability property of the
underlying Dwork and Naor’s 2-round rWI. Otherwise, the simulator will learn
the outputs of VRFEval on at least one new block and in this case the simulator
goes to the next phase. Here we have ignored the probability that a malicious
veriﬁer may give diﬀerent outputs of VRFEval on the same block. But according
to the unique probability of the VRF this probability is indeed exponentially
small.
We stress that in each phase of above simulation the simulator does not
rewind V ∗ and so he can proceed in strict polynomial-time in each phase. Also
note that the total number of phases is also a polynomial. It means that the
black-box simulator works in strict polynomial time rather than expected polynomial time. We remark that this result does not hold for black-box zero-knowledge
in the standard model. Indeed, expected polynomial time is necessary for blackbox zero-knowledge simulation in the standard model [6] and the ﬁrst non-blackbox zero-knowledge argument for N P with strict polynomial time simulation was
presented in [1].
(2). Concurrent Soundness
We ﬁrst note that a computational power unbounded prover can easily convince the veriﬁer of a false statement since he can get the V RF SK if his computational power is unbounded. Hence the above protocol constitutes an argument
system rather than a proof system.
To deal with the soundness of the above protocol in the WPK model we stress
that we should be very careful since our argument system works in a somewhat
“parallel repetition” manner to reduce the error probability. The reason is that
Bellare et al. have proven that for a 3-round argument system if the veriﬁer has
secret information regarding historical transcripts then parallel repetition does
not guarantee to reduce the error probability [5]. Note, however, that in our
argument protocol the veriﬁer indeed has secret information, the SK.
The following proof uses a standard reduction technique. That is, if the above
protocol does not satisfy concurrent soundness in the WPK model then we will
construct a machine T = (TE , TJ ) to break the residual pseudorandomness of
the VRF.
Suppose the above protocol does not satisfy concurrent soundness in the
WPK model then in a concurrent attack issued by an (s, t)-concurrent malicious
prover P ∗ against an honest veriﬁer with identity id, Vid , with non-negligible
probability there exists an i, 1 ≤ i ≤ s(n), such that Vid outputs “accept xi ”
while xi ∈ L and xi has not been used by P ∗ in more than U (n) sessions. Now,
TE ﬁrst guesses this “i” and then simulates the concurrent multiple interactions
between P ∗ and Vid while running P ∗ . Note that in his simulation TE does
not need to rewind P ∗ since he has oracle access to both VRFEval(V RF SK, ·)

Resettable Zero-Knowledge in the Weak Public-Key Model

137

and VRFProve(V RF SK, ·) and the ji , 1 ≤ i ≤ n, in V-step-one is uniformly
distributed over {1, 2, · · · , 2U (n)}. So, TE can simulate the multiple concurrent
interactions between P ∗ and Vid . When it is the time to simulate the i-th session
TE ﬁrst determines whether xi ∈ L or not by just enumerating all the N Pwitnesses of xi . Note that with non-negligible probability this is the case that
/ L since TE can correctly guess the i with non-negligible probability. If
xi ∈
xi ∈
/ L then TE runs P ∗ to get the P-step-one messages from P ∗ . Then TE
uniformly selects (j1 , j2 , · · · , jn ) from {1, 2, · · · , 2U (n)} and computes n blocks
(Rj11 , Rj22 , · · · , Rjnn ) with respect to (xi , id) just as Vid does in V-step-one. Since
xi has been used at most U (n) times and for each i, 1 ≤ i ≤ n, ji is uniformly
distributed over {1, 2, · · · , 2U (n)}, then with probability at least 1 − 2−n TE will
select a new block from all the 2U (n) · n blocks with respect to the pair (xi , id),
on which the output of VRFEval is unknown to P ∗ up to now. Denote by Rjkk ,
1 ≤ k ≤ n, the new block selected. TE then outputs (Rjkk , state), where state is
the historical view of TE .
Now, TJ receives v and TJ ’s job is to ﬁnd whether v is a truly
random value or VRFEval(V RF SK, Rjkk ). For this purpose TJ ﬁrst constructs the new N P-statement x (deﬁned in P-step-two) with respect to
(V RRj1 , V RRj2 , · · · , V RRk−1 ,
1

2

jk−1

v, V RRk+1 , · · · , V RRjnn ). The key observation is that if v is a truly random
jk+1

value then most likely there are no p(n)-NIZK-proof sequences in which the
/ L and the
p(n) NIZK proofs are all acceptable on the statement x since xi ∈
commitment scheme used by P ∗ is perfect binding and v is completely unpredictable for P ∗ . However, if v = VRFEval(V RF SK, Rjkk ), then (according to our
assumption) with non-negligible probability there exists a p(n)-NIZK-proof sequence in which the p(n) NIZK proofs are all acceptable on the statement x .
γ
Note that TJ can enumerate all the NIZK proofs for x in time p(n) · 2n . Then
TJ checks that if there exists a p(n)-NIZK-proof sequence in which the p(n)
NIZK proofs are all acceptable. If ﬁnd such a sequence then TJ decides that
v = VRFEval(V RF SK, Rjkk ), otherwise, TJ decides that v is a truly random
γ
α
value. Note that p(n) · 2n < 2n which violates the residual pseudorandomness
of the VRF.
Acknowledgment. The ﬁrst author is indebted to Leonid Reyzin for his enlightening discussions and numerous kindly clariﬁcations. The ﬁrst author is full
of gratitude to Boaz Barak, Cynthia Dowrk, Yehuda Lindell and Oded Goldreich for their kindly clariﬁcations. Moti Yung referred the ﬁrst author to [23] for
recent advances of VRF. We are grateful to anonymous referees for their many
valuable comments. This research is supported by a research grant of City University of Hong Kong (No. 7001232) and a research grant of Natural Science
Funds of China (No. 60003007).

138

Y. Zhao et al.

References
1. B. Barak. How to Go Beyond the Black-Box Simulation Barrier. In IEEE Symposium on Foundations of Computer Science, pages 106–115, 2001.
2. M. Blum, A. D. Santis, S. Micali and G. Persiano. Non-interactive Zero-Knowledge.
SIAM Journal on Computing, 20(6): 1084–1118, 1991.
3. M. Bellare, M. Fischlin, S. Goldwasser and S. Micali. Identiﬁcation protocols secure
against reset attacks. In B. Pﬁtzmann (Ed.): Advances in Cryptology-Proceedings
of EUROCRYPT 2001, LNCS 2045, pages 495–511. Springer-Verlag, 2001.
4. M. Blum, P. Feldman and S. Micali. Non-interactive Zero-Knowledge and Its
Applications. In ACM Symposium on Theory of Computing, pages 103–112, 1988.
5. M. Bellare, R. Impagliazzo and M. Naor. Does Parallel Repetition Lower the
Error in Computationally Sound Protocols. In IEEE Symposium on Foundations
of Computer Science, pages 374–383, 1997.
6. B. Barak and Y. Lindell. Strict Polynomial-Time in Simulation and Extraction.
In ACM Symposium on Theory of Computing, pages 484–493, 2002.
7. R. Cramer and I. Damgard. Linear Zero-knowledge: A Note on Eﬃcient ZeroKnowledge Proofs and Arguments. In ACM Symposium on Theory of Computing,
pages 436–445, 1997.
8. R. Canetti, O. Goldreich, S. Goldwasser and S. Micali. Resettable Zero-Knowledge.
In ACM Symposium on Theory of Computing, pages 235–244, 2000.
9. R. Canetti, J. Kilian, E. Petrank and A. Rosen. Black-Box Concurrent Zero˜ Rounds. In ACM Symposium on Theory of Computing,
Knowledge Requires Ω
pages 570–579, 2001.
10. A. D. Santis, G. D. Crescenzo, R. Ostrovsky, G. Persiano and A. Sahai. Robust Non-Interactive Zero-Knowledge. In J. Kilian (Ed.): Advances in CryptologyProceedings of CRYPTO 2001, LNCS 2139, pages 566–598. Springer-Verlag, 2001.
11. C. Dwork and M. Naor. Zaps and Their Applications. In IEEE Symposium on
Foundations of Computer Science, pages 283–293, 2000.
12. C. Dwork, M. Naor and A. Sahai. Concurrent Zero-Knowledge. In ACM Symposium on Theory of Computing, pages 409–418, 1998.
13. C. Dwork and L. Stockmeyer. 2-Round Zero-Knowledge and Proof Auditors. In
ACM Symposium on Theory of Computing, pages 322–331, 2002.
14. U. Feige, A. Fiat and A. Shamir. Zero-knowledge Proof of Identity. Journal of
Cryptology, 1(2): 77–94, 1988.
15. U.Feige, D. Lapidot and A. Shamir. Multiple Non-Interactive Zero-Knowledge
Proofs Under General Assumptions. SIAM Journal on Computing, 29(1): 1–28,
1999.
16. A. Fiat and A. Shamir. How to Prove Yourself: Practical Solutions to Identiﬁcation
and Signature Problems. In A. Odlyzko (Ed.): Advances in Cryptology-Proceedings
of CRYPTO’86, LNCS 263, pages 186–194. Springer-Verlag, 1986.
17. O. Goldreich. Foundation of Cryptography-Basic Tools. Cambridge University
Press, 2001.
18. S. Goldwasser and M. Bellare. Lecture Notes on Cryptography. 2001.
19. O. Goldreich, S. Goldwasser and S. Micali. How to Construct Random Functions.
Journal of the Association for Computing Machinery, 33(4):792–807, 1986.
20. O. Goldreich and H. Krawczky. On the Composition of Zero-Knowledge Proof
Systems. SIAM Journal on Computing, 25(1): 169–192, 1996.
21. J. Kilian, E. Petrank. An Eﬃcient Non-Interactive Zero-Knowledge Proof System
for N P with General Assumptions. Journal of Cryptology, 11(2): 24, 1998.

Resettable Zero-Knowledge in the Weak Public-Key Model

139

22. J. Kilian, E. Petrank, R. Richardson. Concurrent and Resettable Zero-Knowledge
in Poly-Logarithmic Rounds. In ACM Symposium on Theory of Computing, pages
560–569, 2001.
23. A. Lysyanskaya. Unique Signatures and Veriﬁable Random Functions from the
DH-DDH Separation. In M. Yung (Ed.): Advances in Cryptology-Proceedings of
CRYPTO 2002, LNCS 2442 , pages 597–612. Springer-Verlag, 2002.
24. S. Micali and L. Reyzin. Soundness in the Public-Key Model. In J. Kilian (Ed.):
Advances in Cryptology-Proceedings of CRYPTO 2001, LNCS 2139, pages 542–565.
Springer-Verlag, 2001.
25. S. Micali and L. Reyzin. Min-Round Resettable Zero-Knowledge in the PublicKey Model. In B. Pﬁtzmann (Ed.): Advances in Cryptology-Proceedings of EUROCRYPT 2001, LNCS 2045, pages 373–393. Springer-Verlag, 2001.
26. S. Micali, M. Rabin and S. Vadhan. Veriﬁable Random Functions. In IEEE
Symposium on Foundations of Computer Science, pages 120–130, 1999.
27. L. Reyzin. Zero-Knowledge with Public Keys. Ph. D Thesis, MIT, 2001.
28. R. Richardson and J. Killian. On the Concurrent Composition of Zero-Knowledge
Proofs. In J. Stern (Ed.): Advances in Cryptology-Proceedings of EUROCRYPT
1999, LNCS 1592, pages 415–423. Springer-Verlag, 1999.

