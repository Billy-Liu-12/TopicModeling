Strengthening Zero-Knowledge Protocols Using
Signatures
Juan A. Garay1 , Philip MacKenzie1 , and Ke Yang2
1
2

Bell Labs – Lucent Technologies, 600 Mountain Ave., Murray Hill, NJ 07974, USA.
{garay,philmac}@research.bell-labs.com
Computer Science Dept., Carnegie Mellon University, Pittsburgh, PA 15213, USA.
yangke@cs.cmu.edu.

Abstract. Recently there has been an interest in zero-knowledge protocols with stronger properties, such as concurrency, unbounded simulation soundness, non-malleability, and universal composability. In this
paper, we show a novel technique to convert a large class of existing
honest-veriﬁer zero-knowledge protocols into ones with these stronger
properties in the common reference string model. More precisely, our
technique utilizes a signature scheme existentially unforgeable against
adaptive chosen-message attacks, and transforms any Σ-protocol (which
is honest-veriﬁer zero-knowledge) into an unbounded simulation sound
concurrent zero-knowledge protocol. We also introduce Ω-protocols, a
variant of Σ-protocols for which our technique further achieves the properties of non-malleability and/or universal composability.
In addition to its conceptual simplicity, a main advantage of this new
technique over previous ones is that it avoids the Cook-Levin theorem,
which tends to be rather ineﬃcient. Indeed, our technique allows for
very eﬃcient instantiation based on the security of some eﬃcient signature schemes and standard number-theoretic assumptions. For instance,
one instantiation of our technique yields a universally composable zeroknowledge protocol under the Strong RSA assumption, incurring an overhead of a small constant number of exponentiations, plus the generation
of two signatures.

1

Introduction

The concept of a zero-knowledge (ZK) proof, as deﬁned by Goldwasser, Micali,
and Rackoﬀ [25], has become a fundamental tool in cryptography. Informally,
if a prover proves a statement to a veriﬁer in ZK, then the veriﬁer gains no
information except for being convinced of the veracity of that statement. In
particular, whatever the veriﬁer could do after the ZK proof, it could have done
before the ZK proof, in some sense because it can “simulate” the proof itself. In
early work, Goldreich, Micali and Wigderson [24] showed that any NP statement
could be proven in (computational) ZK. In another early work, Goldreich, Micali
and Wigderson [23] showed the usefulness of ZK proofs in multiparty protocols,
in particular, in having the parties prove the correctness of their computations.
E. Biham (Ed.): EUROCRYPT 2003, LNCS 2656, pp. 177–194, 2003.
c International Association for Cryptologic Research 2003

178

J.A. Garay, P. MacKenzie, and K. Yang

There has been a great deal of work since then on all properties of ZK proofs.
Here we focus on a few such properties, namely, concurrency, non-malleability,
simulation soundness, and universal composability, with our main goal being to
construct eﬃcient protocols that achieve these properties.
The problem of concurrency was ﬁrst discussed in Dwork, Naor and Sahai
[17]. Informally, the problem arises when many veriﬁers are interacting with a
prover. An adversary controlling all the veriﬁers may coordinate the timing of
their messages so that a simulator would not be able to simulate the execution
of the prover in polynomial time. Canetti et al. [7] showed that without additional assumptions, such as timing constraints or a common reference string,
logarithmic rounds are necessary to achieve concurrent (black-box) ZK. Prabhakaran, Rosen, and Sahai [37] showed that logarithmic rounds suﬃce. On the
other hand, Damg˚
ard [13] showed that concurrent, constant-round ZK protocols
can be achieved in the common reference string model. Furthermore, Barak [1]
showed that by using a non black-box simulator, constant-round, concurrent
protocols can be constructed in the plain model.1
The problem of malleability was ﬁrst pointed out by Dolev, Dwork and Naor
[16]. Roughly speaking, the problem is that an adversary may be able to play a
“man-in-the-middle” attack on a ZK protocol, playing the role of the veriﬁer in
a ﬁrst protocol, and that of the prover in a second protocol, and such that using
information from the ﬁrst protocol he is able to prove something in the second
protocol that he could not prove without that information. A ZK protocol that
does not suﬀer from this problem is said to achieve one-time non-malleability
(since the adversary only interacts with one prover). Dolev, Dwork and Naor give
a construction of a one-time non-malleable ZK protocol that uses a polylogarithmic number of communication rounds. Katz [28] describes eﬃcient protocols
for one-time non-malleable proofs of plaintext knowledge for several encryption
schemes. His protocols work in the common reference string model, and consist
of three rounds and constant number of exponentiations. However, since the witness extractor uses “rewinding,” the resulting protocols were only proven secure
in a concurrent setting with the introduction of timing constraints. Barak [2]
gives a construction of constant-round, one-time non-malleable ZK protocols in
the plain model. His construction uses a non-blackbox proof of security and is
not very eﬃcient. Sahai [40] provides a deﬁnition for one-time non-malleability
in the case of non-interactive ZK (NIZK) proofs. De Santis et al. [15] generalize
this to unbounded non-malleability of NIZK proofs, where even any polynomial
number of simulator-constructed proofs does not help an adversary to construct
any new proof. (As they do, for the remainder of this paper we will simply refer to this property as non-malleability, leaving oﬀ the “unbounded” modiﬁer.)
Their deﬁnition is very strong in that (in some sense) it requires a witness to be
extractable from the adversary. They give two constructions of non-malleable
1

His construction, however, only admits bounded concurrency, meaning that the number of sessions that the protocol can execute concurrently and still retain its zeroknowledge property is at most a ﬁxed polynomial in the security parameter.

Strengthening Zero-Knowledge Protocols Using Signatures

179

ZK proofs for any NP language. In fact, these proofs are non-interactive, and
thus achieve concurrent (constant-round) ZK.
The notion of simulation soundness for NIZK proofs was introduced by Sahai [40] in the context of chosen-ciphertext security of the Naor-Yung [33] encryption scheme. Informally, an NIZK proof is one-time simulation sound if even
after seeing a “simulated proof” (which could be of a false statement) generated
by the simulator, the adversary cannot generate a proof for a false statement.
Sahai notes that the Naor-Yung encryption scheme would be adaptive chosenciphertext secure if it used a one-time simulation-sound NIZK proof. De Santis
et al. [15] further generalized this notion to unbounded simulation soundness. An
NIZK proof is unbounded simulation sound if even after seeing any polynomial
number of simulated proofs, the adversary cannot generate a proof of a false
statement. The non-malleable NIZK protocols given in [15] are also unbounded
simulation sound.
The notions of unbounded simulation soundness and non-malleability extend
naturally to the case of interactive proof systems; we do this in Section 2.
Universal composability is a notion proposed by Canetti [5] to describe protocols that behave like ideal functionalities, and can be composed in arbitrary
ways. Universal composability can be deﬁned in either the adaptive model or
the static model, denoting whether the adversary is allowed to adaptively corrupt parties, or must decide which parties to corrupt before the protocol starts,
respectively. Universal composability is a very strong notion. For example, a
universally composable ZK (UCZK) protocol is both non-malleable (at least in
an intuitive sense) and concurrent.
Canetti [5] proved that UCZK protocols do not exist in the “plain” model,
where there is no assumption about the system set-up. On the other hand,
UCZK is possible in the common reference string model, which is the model we
focus on in this paper. As pointed out by Canetti et al. [8], the non-malleable
NIZK protocols of [15] are also UCZK protocols in the static corruption model.
Since they use non-interactive proof techniques and general NP reductions, these
protocols are not very eﬃcient. Canetti and Fischlin [6] give a construction of
a UCZK protocol for any NP language secure in the adaptive model. Basically,
they use a standard three-round ZK protocol for Hamiltonian Cycle, except that
they use universally composable commitments as a building block. Damg˚
ard and
Nielsen [14] use the same general ZK protocol construction as Canetti and Fischlin, but with a more eﬃcient UC commitment scheme.2 Speciﬁcally, for a security parameter k, their UC commitment scheme allows commitment to k bits
using a constant number of exponentiations and O(k) bits of communication.
Their most eﬃcient UC commitment schemes are based on the p-subgroup assumption [34] or the decisional composite residuosity assumption (DCRA) [35].
Note that even with the more eﬃcient UC commitment scheme, this approach
to constructing UCZK protocols tends to be fairly ineﬃcient, since a general NP
reduction to Hamiltonian Cycle or SAT is used.
2

In a later version of their paper, Damg˚
ard and Nielsen use SAT instead of Hamiltonian Cycle [14].

180

J.A. Garay, P. MacKenzie, and K. Yang

Our results. We show a new technique that allows us to convert certain types
of honest-veriﬁer ZK protocols into ZK protocols with the stronger properties described above, i.e., concurrency, unbounded simulation-soundness, nonmalleability, and/or universal composability, in the common reference string
model. More precisely, we can
1.
transform any Σ-protocol [11] (which are special three-round, honestveriﬁer protocols where the veriﬁer only sends random bits) into an unbounded simulation-sound ZK protocol; and
2.

transform any Ω-protocol (which we introduce in this paper as a variant of Σ-protocols) into a non-malleable ZK protocol, and further into a
universally-composable ZK protocol.
The main transformations (suﬃcient to achieve all results except for UCZK protocols secure in the adaptive model) use a signature scheme that is existentially
unforgeable against adaptive chosen-message attacks [25], which exists if one-way
functions exist [39], as well as a Σ-protocol to prove knowledge of a signature.
Note that one-way functions can be used to construct commitments, and thus if
one-way functions exist, Σ-protocols exist for any NP statement (say, through
a Cook-Levin reduction, and a standard Σ-protocol for Hamiltonian Cycle).
Hence the requirement of our main transformations is the existence of one-way
functions. On the other hand, certain signature schemes, such as the CramerShoup [12] scheme and the DSA scheme [30], admit very eﬃcient Σ-protocols.
Using these schemes (and at the price of speciﬁc number-theoretic assumptions),
we are able to construct strengthened ZK protocols that are more eﬃcient than
all previously known constructions, since we can completely avoid the CookLevin theorem [10,31]. To further achieve a UCZK protocol that is secure in
the adaptive model, we also require a simulation-sound trapdoor commitment
scheme, a new type of commitment scheme that we introduce and which may be
of independent interest. This may be based on trapdoor permutations, but we
are able to construct a more eﬃcient version based on DSA.
We now sketch the intuition behind our technique. We ﬁrst select two signature schemes, the second of which being a one-time signature scheme [20].3
The common reference string will contain a randomly generated veriﬁcation key
vk for the ﬁrst signature scheme, and hence neither the prover nor the veriﬁer
will know the corresponding signing key. We then take an HVZK protocol Π
for an NP statement φ, and we modify it to Π ∗ , which consists of (1) a witness
indistinguishable (WI) proof for the statement
“Either φ is true, or I know the signature for the message vk w.r.t.
veriﬁcation key vk,”
where vk is a freshly generated veriﬁcation key for the one-time signature scheme
that is also sent to the veriﬁer, and (2) a signature on the transcript of the WI
3

The second signature scheme may be the same as the ﬁrst, although for greater
eﬃciency, a signature scheme that is speciﬁcally designed for one-time use may be
employed.

Strengthening Zero-Knowledge Protocols Using Signatures

181

proof using the secret key corresponding to vk . We show that this is an unbounded simulation-sound ZK protocol, and we give some eﬃcient instantiations.
Non-malleability is achieved by replacing the Σ-protocol with an Ω-protocol.
We then show that an non-malleable ZK protocol can be easily augmented to obtain a universally-composable ZK protocol in the static model. Finally, to achieve
a universally-composable ZK protocol in the adaptive model (with erasures), we
start with the augmented non-malleable protocol (based on the Ω-protocol), and
modify it using a simulation-sound trapdoor commitment scheme,

2

Preliminaries and Deﬁnitions

All our results will be in the common reference string (CRS) model, which
assumes that there is a string uniformly generated from some distribution and is
available to all parties at the start of a protocol. Note that this is a generalization
of the public random string model, where a uniform distribution over ﬁxed-length
bit strings is assumed.
For a distribution ∆, we say a ∈ ∆ to denote any element that has non-zero
R
probability in ∆, i.e., any element in the support of ∆. We say a ← ∆ to denote
R
a is randomly chosen according to distribution ∆. For a set S, we say a ← S to
denote that a is uniformly drawn from S.
We will use signatures schemes that are existentially unforgeable against
adaptive chosen-message attacks [26]. However, some of these may only be used
for a single signature, and for these, more eﬃcient one-time signature scheme
constructions may be used [20].
2.1

Zero-Knowledge Proofs and Proofs of Knowledge

Here we provide deﬁnitions related to zero-knowledge proofs and proofs of knowledge. They are based on deﬁnitions of NIZK proofs from [15], but modiﬁed to
allow interaction.
For a relation R, let LR = {x : (x, w) ∈ R} be the language deﬁned by the
relation. For any NP language L, note that there is a natural witness relation
R containing pairs (x, w) where w is the witness for the membership of x in L,
and that LR = L. We will use k as the security parameter.
For two interactive machines A and B, we deﬁne A, B [σ] (x) as the local
output of B after an interactive execution with A using CRS σ, and common
input x. The transcript of a machine is simply the messages on its input and
output communication tapes. Two transcripts match if the ordered input messages of one are equivalent to the ordered output messages of the other, and
vice-versa. We use the notation tr tr to indicate tr matches tr .
For some deﬁnitions below, we need to deﬁne security when an adversary is
allowed to interact with more than one instance of a machine. Therefore it will
be convenient to deﬁne a common wrapper machine that handles this “multisession” type of interaction.4 For an interactive machine A, we deﬁne A to be
4

This is similar to the “multi-session extension” concept in Canetti and Rabin [9].

182

J.A. Garay, P. MacKenzie, and K. Yang

a protocol wrapper for A, that takes two types of inputs on its communication
tape:
(start, π, x, w): For this message A starts a new interactive machine A
with label π, common input x, private input w, a freshly generated random
input r, and using the CRS of A .
(msg, π, m): For this message A sends the message m to the interactive
machine with label π (if it exists), and returns the output message of that
machine.
We deﬁne the output of A to be a tuple (x, tr, v), where x is the common input
(from the start message), tr is the transcript (the input and output messages
A) and v is the output of A. (In particular, if A is a veriﬁer in a zero-knowledge
protocol, this output will be 1 for accept, and 0 for reject.) We say A 1 is the
wrapper of A that ignores all the subsequent start messages after seeing the
ﬁrst one. Eﬀectively, A 1 is a “single-session” version of A.
We say two interactive machines B and C are coordinated if they have a
single control, but two distinct sets of input/output communication tapes. For
four interactive machines A, B, C, and D we deﬁne ( A, B , C, D )[σ] as the
local output of D after an interactive execution with C and after an interactive
execution of A and B, all using CRS σ. Note that we will only be concerned
with this if B and C are coordinated.
We note that all our ZK deﬁnitions use black-box, non-rewinding simulators,
and our proofs of knowledge use non-rewinding extractors.
Deﬁnition 1. [Unbounded ZK Proof ] Π = (D, P, V, S = (S1 , S2 )) is an
unbounded ZK proof (resp., argument) system for an NP language L with witness relation R if D is an ensemble of polynomial-time samplable distributions,
P, V, and S2 are probabilistic polynomial-time interactive machines, and S1 is a
probabilistic polynomial-time machine, such that there exist negligible functions
α and β (the simulation error), such that for all k,
Completeness. For all x ∈ L of length k, all w such that R(x, w) = 1, and all
σ ∈ Dk the probability that P(w), V [σ] (x) = 0 is less than α(k).
Soundness. For all unbounded (resp., polynomial-time) adversaries A, if
R
σ ← Dk , then for all x ∈ L, the probability that A, V [σ] (x) = 1 is less
than α(k).
Unbounded ZK. For all non-uniform probabilistic polynomial-time interactive
machines A, we have that | Pr[ExptA (k) = 1] − Pr[ExptSA (k) = 1]| ≤ β(k),
where the experiments ExptA (k) and ExptSA (k) are deﬁned as follows:
ExptS
A (κ) :
(σ, τ ) ← S1 (1k )

ExptA (κ) :
R
σ ← Dk
Return

P ,A

[σ]

Return

S (τ ) , A

[σ]

where S (τ ) runs as follows on common reference string σ, common input x
and private input w: if R(x, w) = 1, S (τ ) runs S2 (τ ) on common reference

Strengthening Zero-Knowledge Protocols Using Signatures

183

string σ and common input x; otherwise S (τ ) runs Snull , where Snull is an
interactive machine that simply aborts.5
We point out that this deﬁnition only requires the simulator to simulate a
valid proof, which is implemented by having S have access to the witness w and
only invoking S2 when w is valid.6 However, S2 does not access the witness and
will simulate a proof from the input x only.
Deﬁnition 2. [Same-String Unbounded ZK] Π = (D, P, V, S = (S1 , S2 ))
is a same-string unbounded ZK argument system for an NP language L with
witness relation R if Π is an unbounded ZK argument system for L with the
additional property that the distribution of the reference string output by S1 (1k )
is exactly Dk .
We only deﬁne same-string unbounded ZK arguments since, as shown in [15],
any protocol that is same-string unbounded ZK must be an argument, and not
a proof.
The following deﬁnes unbounded simulation-sound zero-knowledge (USSZK).
This has been useful in applications. In particular, as shown in [40], the onetime version suﬃces for the security of a (non-interactive) ZK protocol in the
construction of adaptive chosen-ciphertext secure cryptosystems using the NaorYung [33] paradigm. We directly deﬁne the unbounded version, needed in other
applications such as threshold password-authenticated key exchange [32].
Deﬁnition 3. [Unbounded Simulation-Sound ZK]
Π = (D, P, V, S = (S1 , S2 )) is an unbounded simulation-sound ZK proof (resp.,
argument) system for an NP language L if Π is an unbounded ZK proof (resp.,
argument) system for L and furthermore, there exists a negligible function α
such that for all k,
Unbounded Simulation Soundness
For all non-uniform probabilistic polynomial-time adversaries A = (A1 , A2 ),
where A1 and A2 are coordinated, we have that Pr[ExptA (k) = 1] ≤ α(k),
where ExptA (k) is deﬁned as follows:
ExptA (k) :
(σ, τ ) ← S1 (1k )

(x, tr, b) ← ( S (τ ) , A1 , A2 , V

1

)[σ]

Let Q be the set of transcripts of machines in S (τ )
Return 1 iﬀ b = 1, x ∈ L, and for all tr ∈ Q, tr tr

where S (τ ) runs as follows on CRS σ, common input x and private input
w: S (τ ) runs S2 (τ ) on CRS σ and common input x.
5
6

Without loss of generality, we assume that if the input to P is not a witness for the
common input, P simply aborts.
A must supply a witness, since P is restricted to polynomial time, and thus may
not be able to generate a witness itself. This may seem odd compared to deﬁnitions
of standard ZK that assume an unbounded prover, but it does seem to capture
the correct notion of unbounded ZK, and in particular does not allow A to test
membership in L. See Sahai [40] for more discussion.

184

J.A. Garay, P. MacKenzie, and K. Yang

In the above deﬁnition, we emphasize that S2 may be asked to simulate false
proofs for x ∈ LR , since S does not check whether (x, w) ∈ R. The idea is that
even if the adversary is able to obtain acceptable proofs on false statements, it
will not be able to produce any new acceptable proof on a false statement.
The following deﬁnes non-malleable zero-knowledge (NMZK) proofs (resp.,
arguments) of knowledge. If a protocol is NMZK according to our deﬁnition,
then this implies the protocol is also a NMZK in the explicit witness sense (as
deﬁned in [15]). Moreover, we show that the protocol is also UCZK in the model
of static corruptions. Also note that simulation soundness is implied by this
deﬁnition.
Deﬁnition 4. [Non-malleable ZK Proof/Argument of Knowledge] Π =
(D, P, V, S = (S1 , S2 ), E = (E1 , E2 )) is a non-malleable ZK proof (resp., argument) of knowledge system for an NP language L with witness relation R if Π is
an unbounded ZK proof (resp., argument) system for L and furthermore, E1 and
E2 are probabilistic polynomial-time machines such that there exists a negligible
function α (the knowledge error) such that for all k,
Reference String Indistinguishability. The distribution of the ﬁrst output
of S1 (1k ) is identical to the distribution of the ﬁrst output of E1 (1k ).
Extractor Indistinguishability. For any τ ∈ {0, 1}∗ , the distribution of the
output of V 1 is identical to the distribution of the restricted output of
E2 (τ ) , where the restricted output of E2 (τ ) does not include the ex1
1
tracted value.
Extraction. For all non-uniform probabilistic polynomial-time adversaries A =
(A1 , A2 ), where A1 and A2 are coordinated machines, we have that
| Pr[ExptEA (k) = 1] − Pr[ExptA (k) = 1]| ≤ α(k), where the experiments
ExptA (k) and ExptEA (k) are deﬁned as follows:
ExptEA (k) :
(σ, τ1 , τ2 ) ← E1 (1k )
(x, tr, (b, w))

ExptA (k) :
(σ, τ ) ← S1 (1k )
(x, tr, b)
← ( S (τ ) , A1 , A2 , V

1

)[σ]

← ( S (τ1 ) , A1 , A2 , E2 (τ2 )

1

Let Q be the set of transcripts

Let Q be the set of transcripts

of machines in S (τ ) .
Return 1 iﬀ b = 1 and
for all tr ∈ Q, tr tr

of machines in S (τ1 ) .
Return 1 iﬀ b = 1, (x, w) ∈ R, and
for all tr ∈ Q, tr tr

)[σ]

where S (τ ) runs as follows on CRS σ, common input x and private input
w: S (τ ) runs S2 (τ ) on CRS σ and common input x.
In the above deﬁnition, as in the deﬁnition of USSZK protocols, we emphasize
that S2 may be asked to simulate false proofs for x ∈ LR , since S does not
check whether (x, w) ∈ R. The idea is that even if the adversary is able to obtain
acceptable proofs on false statements, it will not be able to produce any new
acceptable proof for which a witness cannot be extracted.

Strengthening Zero-Knowledge Protocols Using Signatures

2.2

185

Σ-Protocols

Here we overview the basic deﬁnitions and properties of Σ-protocols [11]
First we start with some deﬁnitions and notation. Let R = {(x, w)} be a
binary relation and assume that for some given polynomial p(·) it holds that
|w| ≤ p(|x|) for all (x, w) ∈ R. Furthermore, let R be testable in polynomial
time. Let LR = {x : (x, w) ∈ R} be the language deﬁned by the relation.
Now we deﬁne a Σ-protocol (A, B) to be a three move interactive protocol between a probabilistic polynomial-time prover A and a probabilistic polynomialtime veriﬁer B, where the prover acts ﬁrst. The veriﬁer is only required to send
random bits as a challenge to the prover. For some (x, w) ∈ R, the common
input to both players is x while w is private input to the prover. For such given
x, let (a, c, z) denote the conversation between the prover and the veriﬁer. To
compute the ﬁrst and ﬁnal messages, the prover invokes eﬃcient algorithms a(·)
and z(·), respectively, using (x, w) and random bits as input. Using an eﬃcient
predicate φ(·), the veriﬁer decides whether the conversation is accepting with
respect to x. The relation R, the algorithms a(·), z(·) and φ(·) are public.
We will need to broaden this deﬁnition slightly, to deal with cheating provers.
ˆ R to be the input language, with the property that LR ⊆ L
ˆR,
We will deﬁne L
ˆ
and membership in LR may be tested in polynomial time. We implicitly assume
ˆR.
B only executes the protocol if the common input x ∈ L
All Σ-protocols presented here will satisfy the following security properties:
– Weak special soundness: Let (a, c, z) and (a, c , z ) be two conversations, that
ˆ R . If c = c , then x ∈ LR . The pair of
are accepting for some given x ∈ L
accepting conversations (a, c, z) and (a, c , z ) with c = c is called a collision.
– Special honest veriﬁer zero knowledge (SHVZK): There is a (probabilistic
polynomial time) simulator M that on input x ∈ LR generates accepting
conversations with a distribution that is computationally indistinguishable
from when A and B faithfully execute the protocol on common input x.
The simulator is special in the sense that it can additionally take a random
string c as input, and output an accepting conversation for x where c is the
challenge. In fact, we will assume the simulator has this special property for
ˆR.
not only x ∈ LR , but also any x ∈ L
Some of the Σ-protocols also satisfy the following property.
– Special soundness: Let (a, c, z) and (a, c , z ) be two conversations, that are
accepting for some given x, with c = c . Then given x and those two conversations, a witness w such that (x, w) ∈ R can be computed eﬃciently.
A simple but important fact (see [11]) is that if a Σ-protocol is HVZK, the
protocol is witness indistinguishable (WI) [21].
In our results to follow, we need a particular, simple instance of the main
theorem from [11]. Speciﬁcally, we use a slight generalization of a corollary in [11]
ˆR ×L
ˆR ,
which enables a prover, given two relations (R1 , R2 ), values (x1 , x2 ) ∈ L
1
2
and corresponding 3-move Σ-protocols ((A1 , B1 ), (A2 , B2 )), to present a 3-move

186

J.A. Garay, P. MacKenzie, and K. Yang
prover

veriﬁer
vk

k

(vk , sk ) ← sig gen1 (1 )

✛
s ← sig sign1 (sk , transcript)

✲

Σ R (x) ∨ Σ Rvk (vk )
s

✲
✲
✲ sig verify1 (vk , transcript)

Fig. 1. USSR
[vk] (x): An unbounded simulation-sound ZK protocol for relationship R
with CRS vk (drawn from the distribution sig gen0 (1k )), and common input x. The
prover also knows the witness w such that R(x, w) = 1.

Σ-protocol (Aor , Bor ) for proving the existence of a w such that either (x1 , w) ∈
R1 or (x2 , w) ∈ R2 . We call this the “OR” protocol for ((A1 , B1 ), (A2 , B2 )),
For two Σ-protocols, (A1 , B1 ) and (A2 , B2 ), let (A1 , B1 ) ∨ (A2 , B2 ) denote
the “OR” protocol for ((A1 , B1 ), (A2 , B2 )).

3

Unbounded Simulation-Sound ZK

We are now ready to present the ﬁrst result achieved with our technique: An unbounded simulation-sound zero-knowledge protocol for a relation R = {(x, w)}.
We assume that we have the following building blocks:
1.
Σ R : a Σ-protocol for the binary relation R.
2.

SIG0 = (sig gen0 , sig sign0 , sig verify0 ): a signature scheme secure against
adaptive chosen-message attack.

3.

Rvk = {(m, s) | sig verify0 (vk, m, s) = 1}: a binary relation of messagesignature pairs.

4.

Σ Rvk : a Σ-protocol with the special soundness property for the binary
relation Rvk .

5.

SIG1 = (sig gen1 , sig sign1 , sig verify1 ): a one-time signature scheme secure
against chosen-message attack.
The protocol USSR
[vk] (x) is shown in Figure 1. It assumes the prover and
veriﬁer share a common input x to a Σ-protocol Σ R , and the prover knows w
such that (x, w) ∈ R. The CRS σ is the veriﬁcation key vk of a signature scheme
that is existentially unforgeable against adaptive chosen-message attacks. The
prover generates a pair (vk , sk ) for a one-time signature scheme, and sends
vk to the veriﬁer. After this, vk is the common input to a Σ-protocol Σ Rvk
satisfying special soundness. Then the prover uses the OR construction for Σprotocols to prove that either x ∈ LR or it knows a signature for vk under
veriﬁcation key vk. (Note that since Σ Rvk satisﬁes special soundness, intuitively
it is a proof of knowledge.) Finally, the prover signs the transcript with sk , and
sends the resulting signature to the veriﬁer.
k
Now we must describe S = (S1 , S2 ) for USSR
[vk] (x). S1 (1 ) ﬁrst generates
signature keys (vk, sk) ← sig gen0 (1k ) and outputs (σ, τ ) = (vk, sk). S2 (sk) ﬁrst

Strengthening Zero-Knowledge Protocols Using Signatures

187

ˆ R . If not, it aborts. Otherwise it runs the prochecks that common input x ∈ L
tocol as normal, except generating s ← sig sign0 (sk, vk ), and using knowledge
of s to complete the Σ-protocol Σ R (x) ∨ Σ Rvk (vk ).
Theorem 1. The protocol USSR
[vk] (x) is a USSZK argument.

4

Non-malleable ZK

Our general NMZK construction will be similar to the USSZK construction
above, but with a Σ-protocol replaced by an Ω-protocol, deﬁned here.
4.1

Ω-Protocols

An Ω-protocol (A, B)[σ] for a relation R = {(x, w)} and CRS σ, is a Σ-protocol
for relation R with the following additional properties.
1.
For a given distribution ensemble D, a common reference string σ is drawn
from Dk and each function a(·), z(·), and φ(·) takes σ as an additional
input. (Naturally, the simulator M in the deﬁnition of Σ-protocols may
also take σ as an additional input.)
There exists a polynomial-time extractor E = (E1 , E2 ) such that the reference string output by E1 (1k ) is statistically indistinguishable from Dk .
Furthermore, given (σ, τ ) ← E1 (1k ), if there exists two accepting converˆ R , then
sations (a, c, z) and (a, c , z ) with c = c for some given x ∈ L
E2 (x, τ, (a, c, z)) outputs w such that (x, w) ∈ R.7
Informally, one way to construct Ω-protocols is as follows. Our common reference string will consist of a random public key pk for a semantically-secure
encryption scheme. Then for a given (x, w) ∈ R, we will construct an encryption
e of w under key pk, and then construct a Σ-protocol to prove that there is a w
such that (x, w) ∈ R and that e is an encryption of w.
As with Σ-protocols, we will use the ∨ notation to denote an “OR” protocol,
even if one or both of these protocols are Ω-protocols.
2.

4.2

NMZK Protocol

R
Let Ω[σ
] (x) be an Ω-protocol for a relation R with common reference string σ

R
R
and common input x. Let NMR
[vk,σ ] (x) be the USS[vk] (x) protocol with Σ (x)
R
replaced by Ω[σ
] (x). (For every σ , the resultant protocol is also a Σ-protocol.)
R
R
Let EΩ = (EΩ,1 , EΩ,2 ) be the extractor for Ω[σ
] (x). The protocol NM[vk,σ ] (x) is
shown in Figure 2.
7

Notice that this extraction property is similar to that of weak special soundness
of Σ-protocols, where there exists an accepting conversation even for an invalid
proof, but two accepting conversations guarantees that the proof is valid. Here, the
extractor can always extract something from any conversation, but it might not be
the witness if there is only one accepting conversation. However, having two accepting
conversations sharing the same a guarantees that the extracted information is indeed
a witness.

188

J.A. Garay, P. MacKenzie, and K. Yang
prover
(vk , sk ) ← sig gen1 (1k )

veriﬁer
vk
R
Ω[σ
] (x)

✛
s ← sig sign1 (sk , transcript)

✲

∨ Σ Rvk (vk )

✲
✲
✲ sig verify1 (vk , transcript)

s

Fig. 2. NMR
[vk,σ ] (x): A non-malleable ZK protocol for relationship R with common
reference string (vk, σ ) where σ is drawn from the distribution associated with ΩσR ,
and common input x.
k
We now describe S = (S1 , S2 ) for NMR
[vk,σ ] . S1 (1 ) ﬁrst generates signature
R

keys (vk, sk) ← sig gen0 (1k ) and then sets σ ← Dk , where D is the distribution
R
k
ensemble for Ω[σ
] . Next, S1 (1 ) outputs ((vk, σ ), sk). S2 (sk) ﬁrst checks that
ˆ R . If not, it aborts. Otherwise it runs the protocol as normal,
common input x ∈ L
except generating s ← sig sign0 (sk, vk ), and using knowledge of s to complete
R
Rvk
(vk ).
the protocol Ω[σ
] (x) ∨ Σ

k
Finally, we must describe E = (E1 , E2 ) for NMR
[vk,σ ] (x). E1 (1 ) generates
k
k
signatures keys (vk, sk) ← sig gen0 (1 ), generates (σ , τ ) ← EΩ,1 (1 ), and then
outputs ((vk, σ ), sk, τ ). E2 (τ ) simply runs as V until V outputs a bit b. If
R
b = 1, E2 (τ ) takes the conversation (a, c, z) produced by Ω[σ
] (x), and generates
w ← EΩ,2 (x, τ , (a, c, z)). If b = 0, E2 (τ ) sets w ← ⊥. Then E2 (τ ) outputs (b, w).

Theorem 2. The protocol NMR
[vk,σ ] (x) is an NMZK argument of knowledge for
the relation R.

5

Universally Composable ZK

First we review the framework of universal composability [5]. Then we prove
that any NMZK protocol with certain simple properties can be augmented to be
UCZK in the model of static corruptions. This result implies as a corollary that a
slight generalization of our protocol from the previous section can be augmented
to be UCZK in this model. Then we give a new construction that is UCZK in
the model of adaptive corruptions.
5.1

The Universal Composability Framework

The universal composability paradigm was proposed by Canetti [5] for deﬁning
the security and composition of protocols. To deﬁne security one ﬁrst speciﬁes an
ideal functionality using a trusted party that describes the desired behavior of
the protocol. Then one proves that a particular protocol operating in a real-life
model securely realizes this ideal functionality, as deﬁned below. Here we brieﬂy
summarize the framework as deﬁned in Canetti [5].

Strengthening Zero-Knowledge Protocols Using Signatures

189

A (real-life) protocol π is deﬁned as a set of n interactive Turing Machines
P1 , . . . , Pn , designating the n parties in the protocol. It operates in the presence
of an environment Z and an adversary A, both of which are also modeled as
interactive Turing Machines. The environment Z provides inputs and receives
outputs from honest parties, and may communicate with A. A controls (and may
view) all communication between the parties. We will assume that messages are
authenticated, and thus A may not insert or modify messages between honest
parties.8 A also may corrupt parties, in which case it obtains the internal state
of the party.
The ideal process with respect to a functionality F, is deﬁned for n parties
P1 , . . . , Pn , an environment Z, and an (ideal-process) adversary S. However,
P1 , . . . , Pn are now dummy parties that simply forward (over secure channels)
inputs received from Z to F, and forward (again over secure channels) outputs
received from F to Z. Thus the ideal process is a trivially secure protocol with
the input-output behavior of F.
To formulate the universal composition theorem, Canetti [5] also introduces
a a hybrid model, a real-life model with access to an ideal functionality F. In
particular, this F-hybrid model functions like the real-life model, but where the
parties may also exchange messages with an unbounded number of copies of F,
each copy identiﬁed via a unique session identiﬁer (sid). The communication
between the parties and each one of these copies mimics the ideal process, and
in particular the hybrid adversary does not have access to the contents of the
messages. See Canetti [5] for details of the universal composition theorem.
The zero-knowledge functionality. The (multi-session) ZK functionality is given
in Figure 3. In the functionality, parameterized by a relation R, the prover sends
to the functionality the input x together with a witness w. If R(x, w) holds, then
the functionality forwards x to the veriﬁer. As pointed out in [5], this is actually
a proof of knowledge in that the veriﬁer is assured that the prover actually knows
w. Note the two types of indices: the sid, which, as before, diﬀerentiates messages
R
to FˆZK
from messages sent to other functionalities, and ssid, the sub-session ID,
which is unique per input message (or proof).
Recall that we will be designing and analyzing protocols in the common
D
reference string model, and so they will be operating in the FCRS
-hybrid model,
D
where FCRS is the functionality that, for a given security parameter k, chooses
a string from distribution Dk and hands it to all parties.
5.2

NMZK Implies UCZK

Let Π be an NMZK protocol between a prover and veriﬁer. We say Π is augmentable if the prover sends the ﬁrst message, and this message contains the
common input x, along with auxiliary data aux that may contain any arbitrary
public values. (The reason for aux is discussed below.) We will show how to
8

This feature could be added to an unauthenticated model using a message authentication functionality as described in [5].

190

J.A. Garay, P. MacKenzie, and K. Yang

R
Functionality FˆZK
R
proceeds as follows, running with security parameter k, parties P1 , . . . , Pn ,
FˆZK
and an adversary S:

– Upon receiving (zk-prover, sid, ssid, Pi , Pj , x, w) from Pi : If R(x, w) then send
(ZK-PROOF, sid, ssid, Pi , Pj , x) to Pj and S and halt. Otherwise, ignore.
Fig. 3. The multi-session zero-knowledge functionality (for relation R)

augment Π with additional information in each message to allow it to be used
between two parties in the universal composability framework. This augmented
ˆ and is constructed as follows.
protocol is denoted Π,
ˆ run between parties Pi and Pj , set aux to (ssid, Pi , Pj ),
For an instance of Π
where ssid is deﬁned in the previous section, Pi is the identity of the prover,
and Pj is the identity of the veriﬁer.9 Then the th prover message is formatted as (prv , sid, ssid, Pi , prv-data ), where prv is the label for the th
prover message, and prv-data is the data ﬁeld containing the th message
sent by the prover in Π. Analogously, the th veriﬁer message is formatted as
(ver , sid, ssid, Pj , ver-data ), where ver is the label for the th veriﬁer message,
and ver-data is the data ﬁeld containing the th message sent by the veriﬁer
in Π. Finally, before accepting, the veriﬁer checks that aux corresponds to the
values (ssid, Pi , Pj ) outside the prover data ﬁeld, and that aux was not used
previously.
Theorem 3. Let Π = (D, P, V, SΠ = (SΠ,1 , SΠ,2 ), EΠ = (EΠ,1 , EΠ,2 )) be an
ˆ
augmentable NMZK protocol for a relation R. Then the augmented protocol Π
R
D
ˆ
securely realizes functionality FZK in the FCRS -hybrid model, assuming static
corruptions.
ˆ is a UCZK protocol for R if it securely realizes funcWe say a protocol Π
R
D
in the FCRS
-hybrid model, for some D.
tionality FˆZK
Corollary 1. Let Π be protocol NMR
[vk,σ ] (x) from Figure 2 with the addition
of the common input x and aux = (ssid, Pi , Pj ) in the ﬁrst message. Then the
ˆ is a UCZK protocol for R, assuming static corruptions.
augmented protocol Π
5.3

UCZK: Adaptive Corruptions

Our basic idea to deal with adaptive corruptions is to take the augmentable
version of the NMZK protocol from Corollary 1, denoted NMR
[vk,σ ] (x; aux), and
apply to it the technique proposed by Damg˚
ard [13] and Jarecki and Lysyanskaya [27] in which a trapdoor commitment is used to commit to the ﬁrst message of a Σ-protocol, and then this commitment is opened when sending the
9

This auxiliary data aux is necessary since NMZK allows copying proofs exactly, but
the ZK functionality does not, and thus we need some way to make every proof
distinct.

Strengthening Zero-Knowledge Protocols Using Signatures

191

third message. Informally, a trapdoor commitment is a commitment scheme
with the additional property that there is a secret trapdoor such that knowing the trapdoor allows a committer to decommit to an arbitrary value. More
precisely, TC = (TCgen, TCcom, TCver, TCkeyver, TCfake) is a trapdoor commitment scheme if it satisﬁes the properties of completeness, binding, perfect
secrecy, and trapdoorness. The ﬁrst three properties are the same as in any
unconditionally-hiding commitment scheme. The trapdoor property says (informally) that TCgen(1k ) outputs a secret key (the trapdoor) along with the public
key, and that using this secret key and a commitment/decommitment pair (c, d)
associated with a value v, (i.e., (c, d) ← TCcom(pk, v)), the function TCfake can
for any value v output a decommitment d that is a valid decommitment of c
resulting in v (i.e., TCver(pk, c, v , d ) = 1).
However, for technical reasons, a “plain” trapdoor commitment does not provide the properties we need to deal with adaptive corruptions, and so we deﬁne a
stronger type of trapdoor commitment scheme, which we call a simulation-sound
trapdoor commitment (SSTC) scheme.10 Roughly speaking, an SSTC scheme is
a trapdoor commitment scheme with an extra input id to the commitment protocol, which guarantees that a commitment made by the adversary using input
id is binding, even if the adversary has seen any commitment using input id
opened (using a simulator that knows a trapdoor) once to any arbitrary value,
and moreover, any commitment using id = id opened (again using the simulator) an unbounded number of times to any arbitrary values.
Now let Π be a three move interactive proof protocol with common input
x, auxiliary input aux, witness w, common reference string σ, and prover random bits r. Similarly to Σ-protocols, we use the notation aΠ (·), zΠ (·), and
verifyΠ (·) to denote the algorithms for computing the two messages of the
prover, and verifying the proof, respectively. Using this notation, the protocol
UCR
[pk∗ ,vk,σ ] (x; aux) is shown in Figure 4.
Theorem 4. Let Π be the protocol UCR
[pk∗ ,vk,σ ] (x; aux), where
ˆ securely realizes functionaux = (ssid, Pi , Pj ). Then the augmented protocol Π
R
D
ˆ
ality FZK in the FCRS -hybrid model where erasing is allowed, assuming adaptive
corruptions.

6

Eﬃcient Instantiations

Here we brieﬂy discuss some eﬃcient instantiations of our constructions.
Signature Schemes. First we note that for our constructions we can use a more
general version of the Σ-protocol for proving knowledge of signatures, as follows.
Consider the binary relation Rvk = {(m, s)} for a signature scheme SIG. We say
10

Universally-composable commitments [6,8] would also suﬃce, and can be constructed
using trapdoor permutations. However, this construction is not as eﬃcient as the
SSTC scheme in this paper.

192

J.A. Garay, P. MacKenzie, and K. Yang
prover
(x, aux, a) ← aΠ (x, aux, w, r, σ)
(a∗ , r∗ ) ← TCcom(pk∗ , a, aux)

z ← zΠ (x, aux, w, r, c, σ)
erase(r, w)

veriﬁer
x, aux, a∗

✛

c
z, a, r∗

✲

R

c ← {0, 1}k

✲ TCkeyver(pk∗ , 1k )

TCver(pk∗ , a∗ , a, aux, r∗ )
verifyΠ (x, aux, a, c, z, σ)

Fig. 4. UCR
[pk∗ ,vk,σ ] (x; aux): A UCZK protocol for R with common reference string
(pk∗ , vk, σ ) drawn from Dpk (TC) × Dvk (SIG0 ) × Dσ (Ω R ), common input x, and auxiliary input aux where Π = NMR
[vk,σ ] (x; aux):

a polynomial-time computable function f is a partial knowledge function of SIG,
if there exists a probabilistic polynomial-time machine M such that every m
and vk, {s1 : s1 ← M (m, vk)} and {s1 : s ← sig sign(vk, m); s1 ← f (m, vk, s)}
have the same distribution. Intuitively, a partial knowledge function carries part
of the information about the signature, yet can be eﬃciently sampled without
even knowing one. If a signature scheme SIG has a partial knowledge function
f , then the relation Rvk = {((m, s1 ), s) : (m, s) ∈ Rvk ∧ s1 = f (m, vk, s)} can
R
R
replace Rvk in the constructions for USSR
[vk] , NM[vk,σ ] (x), and UC[pk∗ ,vk,σ ] (x),
with P sending a randomly sampled s1 (partial knowledge) before running the
Σ-protocol Σ R (x) ∨ Σ Rvk (vk , s1 ). We say Rvk is a partial signature relation for
SIG.
It can be shown that the Cramer-Shoup signature scheme [12] and the DSA
signature scheme [30] both admit eﬃcient Σ-protocols for proving knowledge of
signatures using this more general deﬁnition, and thus can be plugged into our
constructions. We discuss the detailed constructions in the full version.
Eﬃcient Ω-Protocols. In the full version we describe an eﬃcient Ω-protocol
for proving knowledge of a discrete logarithm. This protocol is based on the
Decisional Composite Residuosity assumption and the Strong RSA assumption.
In the full version we also describe a generalized version of Ω-protocols, and
an eﬃcient generalized Ω-protocol for proving plaintext knowledge of ElGamal
encryptions.

References
1. B. Barak. How to Go Beyond the Black-box Simulation Barrier. In 42nd IEEE
Symp. on Foundations of Computer Sci., 106–115, 2001.
2. B. Barak. Constant-Round Coin-Tossing With a Man in the Middle or Realizing the
Shared Random String Model. In 43rd IEEE Symp. on Foundations of Computer
Sci., 345–355, 2002

Strengthening Zero-Knowledge Protocols Using Signatures

193

3. N. Bari´c and B. Pﬁtzmann. Collision-free accumulators and fail-stop signature
schemes without trees. In Advances in Cryptology – EUROCRYPT ’97 (LNCS
1233), 480–494, 1997.
4. D. Boneh. The decision Diﬃe-Hellman problem. In Proceedings of the Third Algorithmic Number Theory Symp. (LNCS 1423), 48–63, 1998.
5. R. Canetti. Universally composable security: A new paradigm for cryptographic
protocols. In 42nd IEEE Symp. on Foundations of Computer Sci., 136–145, 2001.
6. R. Canetti and M. Fischlin. Universally composable commitments. In Advances in
Cryptology – CRYPTO 2001 (LNCS 2139), 19–40, 2001.
7. R. Canetti, J. Kilian, E. Petrank and A. Rosen. Concurrent zero-knowledge requires
˜
Ω(log
n) rounds. In 33rd ACM Symp. on Theory of Computing, 570–579, 2001.
8. R. Canetti, Y. Lindell, R. Ostrovsky and A. Sahai. Universally composable twoparty computation. In 34th ACM Symp. on Theory of Computing, 494–503, 2002.
Full version in ePrint archive, Report 2002/140. http://eprint.iacr.org/, 2002.
9. R. Canetti and T. Rabin. Universal Composition with Joint State In ePrint archive,
Report 2002/047, http://eprint.iacr.org/, 2002.
10. S. A. Cook. The complexity of theorem-proving procedures. In 3rd IEEE Symp.
on Foundations of Computer Sci., 151–158, 1971.
11. R. Cramer, I. Damg˚
ard, and B. Schoenmakers. Proofs of partial knowledge
and simpliﬁed design of witness hiding protocols. In Advances in Cryptology –
CRYPTO ’94 (LNCS 839), pages 174–187, 1994.
12. R. Cramer and V. Shoup. Signature scheme based on the strong RSA assumption.
In ACM Trans. on Information and System Security 3(3):161-185, 2000.
13. I. Damg˚
ard. Eﬃcient Concurrent Zero-Knowledge in the Auxiliary String Model.
In Advances in Cryptology – EUROCRYPT 2000 (LNCS 1807), 418–430, 2000.
14. I. Damg˚
ard and J. Nielsen. Perfect hiding and perfect binding universally composable commitment schemes with constant expansion factor. In Advances in Cryptology – CRYPTO 2002 (LNCS 2442), 581–596, 2002. Full version in ePrint Archive,
report 2001/091. http://eprint.iacr.org/, 2001.
15. A. De Santis, G. Di Crescenzo, R. Ostrovsky, G. Persiano and A. Sahai. Robust non-interactive zero knowledge. In Advances in Cryptology – CRYPTO 2001
(LNCS 2139), 566–598, 2001.
16. D. Dolev, C. Dwork and M. Naor. Non-malleable cryptography. SIAM J. on Comput., 30(2):391–437, 2000. Also in 23rd ACM Symp. on Theory of Computing,
542–552, 1991.
17. C. Dwork, M. Naor and A. Sahai. Concurrent zero-knowledge. In 30th ACM Symp.
on Theory of Computing, 409–418, 1998.
18. C. Dwork and A. Sahai. Concurrent Zero-Knowledge: Reducing the Need for Timing Constraints. In Advances in Cryptology – CRYPTO ’98 (LNCS 1462), 442–457,
1998.
19. T. ElGamal. A public key cryptosystem and a signature scheme based on discrete
logarithms. IEEE Trans. on Information Theory, 31:469–472, 1985.
20. S. Even, O. Goldreich, and S. Micali. On-line/Oﬀ-line digital signatures. J. Cryptology 9(1):35-67 (1996).
21. U. Feige and A. Shamir. Witness Indistinguishable and Witness Hiding Protocols.
In 22nd ACM Symp. on Theory of Computing, 416–426, 1990.
22. FIPS 186. Digital signature standard. Federal Information Processing Standards
Publication 186, U.S. Dept. of Commerce/NIST, National Technical Information
Service, Springﬁeld, Virginia, 1994.

194

J.A. Garay, P. MacKenzie, and K. Yang

23. O. Goldreich, S. Micali and A. Wigderson. How to play any mental game or a
completeness theorem for protocols with honest majority. In 19th ACM Symp. on
Theory of Computing, 218–229, 1987.
24. O. Goldreich, S. Micali and A. Wigderson. Proofs that yield nothing but their validity or All languages in NP have zero-knowledge proof systems. J. ACM, 38(3):691–
729, 1991.
25. S. Goldwasser, S. Micali and C. Rackoﬀ. The knowledge complexity of interactive
proof systems. SIAM J. Comput., 18(1):186–208, February 1989.
26. S. Goldwasser, S. Micali and R. Rivest. A digital signature scheme secure against
adaptive chosen-message attacks. SIAM J. Comput., 17:281–308, 1988.
27. S. Jarecki and A. Lysyanskaya. Adaptively Secure Threshold Cryptography: Introducing Concurrency, Removing Erasures. In Advances in Cryptology – EUROCRYPT ’00 (LNCS 1807), 221–242, 2000.
28. J. Katz. Eﬃcient and Non-Malleable Proofs of Plaintext Knowledge and Applications. In ePrint Archive, Report 2002/027, http://eprint.iacr.org/, 2002.
29. J. Kilian and E. Petrank. Concurrent and resettable zero-knowledge in polylogarithmic rounds. In 33rd ACM Symp. on Theory of Computing, 560–569, 2001.
30. D. W. Kravitz. Digital signature algorithm. U.S. Patent 5,231,668, 27 July 1993.
31. L. A. Levin. Universal sorting problems. Problemy Peredaci Informacii, 9:115–116,
1973. In Russian. Engl. trans.: Problems of Information Transmission 9:265–266.
32. P. MacKenzie, T. Shrimpton, and M. Jakobsson. Threshold passwordauthenticated key exchange. In Advances in Cryptology – CRYPTO 2002 (LNCS
2442), 385–400, 2002.
33. M. Naor and M. Yung. Public-key cryptosystems provably secure against chosen
ciphertext attacks. In 22nd ACM Symp. on Theory of Computing, 427–437, 1990.
34. T. Okamoto and S. Uchiyama. A new public-key cryptosystem as secure as factoring. In Advances in Cryptology – EUROCRYPT ’98 (LNCS 1403), 380–318,
1998.
35. P. Paillier. Public-key cryptosystems based on composite degree residue classes. In
Advances in Cryptology – EUROCRYPT ’99 (LNCS 1592), 223–238, 1999.
36. T. P. Pedersen. Non-Interactive and Information-Theoretic Secure Veriﬁable Secret
Sharing. In Advances in Cryptology – CRYPTO ’91 (LNCS 576), 129–140, 1991.
37. M. Prabhakaran, A. Rosen and A. Sahai. Concurrent zero knowledge
with logarithmic round-complexity, In ePrint Archive, Report 2002/055,
http://eprint.iacr.org/, 2002. Also in 43rd IEEE Symp. on Foundations of
Computer Sci., 366–375, 2002.
38. L. Reyzin. Zero-knowledge with public keys. Ph.D. Thesis, MIT, 2001.
39. J. Rompel. One-way functions are necessary and suﬃcient for secure signatures.
In 22nd ACM Symp. on Theory of Computing, 387–394, 1990.
40. A. Sahai. Non-malleable non-interactive zero knowledge and adaptive chosenciphertext security. In 40th IEEE Symp. on Foundations of Computer Sci., 543–
553, 1999.

