A Technique for Code Generation of USN Applications
Based on Nano-Qplus*
Kwangyong Lee1, Woojin Lee2, Juil Kim2, and Kiwon Chong2
1 Ubiquitous

Computing Middleware Team, ETRI, Daejeon, Korea
kylee@etri.re.kr
2 Department of Computing, Soongsil University, Seoul, Korea
{bluewj, sespop}@empal.com, chong@ssu.ac.kr

Abstract. A technique for automatic code generation of USN applications
based on Nano-Qplus is proposed in this paper. Nano-Qplus is a sensor network
platform developed by ETRI. Programs of nodes such as sensors, routers, sinks
and actuators in a sensor network are automatically generated through the technique. Developers can implement USN applications from models of sensor
networks. The execution code is generated by setting attribute values of each
node according to the model through the script proposed in this paper. Through
the technique of this paper, developers can easily implement USN applications
even if they do not know the details of low-level information. The development
effort of USN applications also will be decreased because execution codes are
automatically generated. Furthermore, developers can perform early test
through rapid code generation, so the verified code is generated by correcting
errors in the early development stage.

1 Introduction
Ubiquitous sensor network (USN) is a wireless network which consists of a lot of
lightweight, low-powered sensors. A lot of sensors which are connected to a network
sense geographical and environmental changes of the field. They transmit the sensing
data to a base station and the data is transmitted to users through sensor network
server. Collection of information in USN is performed through this process. Through
USN, things can recognize other things and sense environmental changes, so users
can get the information from the things and use the information anytime, anywhere.
The sensor networks can be used for various application areas such as home, health,
and robot.
However, it is difficult to construct USN applications. Resources of nodes in a sensor network are limited and wireless communication between nodes is unreliable.
Nodes should also perform low-power operations. Developers should consider these
facts, so it is very difficult to construct USN applications. Therefore, it is need to
make developers can simply design USN applications by abstracting the details of
low-level communication, data sharing, and collective operations.
Accordingly, a technique for automatic code generation from a simple design of
USN application is proposed in this paper. Programs of nodes such as sensors,
*

This work was supported by the Soongsil University Research Fund.

V.N. Alexandrov et al. (Eds.): ICCS 2006, Part IV, LNCS 3994, pp. 902 – 909, 2006.
© Springer-Verlag Berlin Heidelberg 2006

A Technique for Code Generation of USN Applications Based on Nano-Qplus

903

routers, sinks and actuators in a sensor network are automatically generated by setting
attribute values of a script proposed in this paper. Therefore, developers can easily
develop USN applications even if they do not know the details of low-level communication, data sharing, and collective operations. The technique of this paper brings
focus to USN application on a sensor network platform known as Nano-Qplus [1, 2].

2 A Technique for Code Generation of USN Applications
A programming model to construct USN applications based on Nano-Qplus is presented in this section. It is compared to the existing programming models for USN
applications. Moreover, the script for the design of an application and the algorithm
for automatic code generation of the application are presented.
2.1 Concepts of the USN Programming
Figure 1 presents the concept of USN programming described in existing works [3, 4,
5, 6, 7, 8]. A modeling is done and a simple program based on the model is written
using the high level language or the simple script. Then the code is automatically generated according to the program. It is important that the program is written using the
high level language or the script. The high level language or the script helps users to
construct applications, even though they do not know the details of low-level information of USN. A specification-level language, a script language, or APIs were proposed
in order to abstract the low-level information in the related works. However, users
should learn the proposed language, the script language or APIs in order to develop
USN applications using these techniques.

Fig. 1. The concept of USN programming in the existing works

A technique to complement the existing techniques for construction of USN applications is proposed in this paper.

Fig. 2. The concept of USN programming in this paper

Figure 2 presents the concept of USN programming proposed in this paper. Developers can implement USN applications by automatically generating execution code of
each node in the sensor networks after they do modeling the sensor networks and set

904

K. Lee et al.

attribute values of each node according to the model. The execution code is automatically generated by setting attribute values of each node through a script. Therefore,
users can construct USN applications without learning a language or APIs.
2.2 The USN Programming Model
Figure 3 shows the USN programming model proposed in this paper. USN model is
designed, and attribute values for sensor nodes, router nodes, sink nodes, and actuator
nodes in the model are set through scripts. Modules and code templates which are
provided by Nano-Qplus are selected according to the attribute values of scripts, so C
codes for each node are automatically generated.

Fig. 3. USN programming model

Nodes in a USN communicate with each other through Store&Forward method.
Templates to generate programs of nodes according to that method are presented in
this paper. Figure 4, 5, 6 and 7 show templates which contain modules provided by
Nano-Qplus in order to generate programs for sensor nodes, router nodes, sink nodes,
and actuator nodes.

Fig. 4. Modules of a sensor node

Fig. 5. Modules of a router node

Four types of nodes contain the same modules generally, but the contents of the
modules are dependent upon the node type. For example, main role of a sensor node

A Technique for Code Generation of USN Applications Based on Nano-Qplus

905

is to send sensing data to other nodes, so the contents of rf_send_data() module are
dependent upon the script setting for the sensor node. Main role of a router node is to
send data received from a node to other nodes, so the contents of rf_net_scheduling()
module are dependent upon the script setting for the router node. Moreover, main role
of a sink node and an actuator node is to process data, so the contents of
rf_recv_data() module are depedent upon the script setting for the sink node and the
actuator node.

Fig. 6. Modules of a sink node

Fig. 7. Modules of a actuator node

2.3 A Script for Generation of USN Applications
To generate the application from the designed model, the script which can easily configure the attributes of each node in USN is proposed. Figure 8 shows the script.
The script has been written as a typical script language [9] which is used for configuring environment in Linux, so most of users can easily use it. If users configure
the attributes of each node using the script, a program code for each node is automatically generated based on the script.

Fig. 8. A script for automatic code generation

The script showed in figure 8 has been written for generating the application on a
sensor network platform known as Nano-Qplus.

906

K. Lee et al.

2.4 An Algorithm for Generation of USN Applications
The following is the process for generating source code to control each node based on
the script.
Step 1 – Read Config_Info(.config) file in order to get the attribute values of a
node.
Step 2 – Parse Config_info(.config) file and find out selected modules. Then read
headers, data and function codes from HashTable_Module according to the selected
modules and save them to the template.
Step 3 – Read main code from HashTable_Main based on selected modules and
save it to the template.

Fig. 9. An algorithm for generating USN application

Fig. 10. HashTable_Module class

Figure 9 presents the algorithm for generating source code of each node. Headers,
data and function codes are generated by calling the functions of HastTable_Module
class according to the type of the target node.

A Technique for Code Generation of USN Applications Based on Nano-Qplus

907

The HashTable_Module class used in the algorithm is presented in figure 10. The
class includes getHeader(), getData() and getFunction() to generate the program for
each node. These functions use the key and the value corresponding to the key defined in a hash table through the getReplaceModule() function in order to get source
codes. HashTable_Module class generates the proper source code using a hash table
dynamically because the codes of headers, data and functions are dependent upon the
type of the node.
Table 1. Structure of hash table
Key
Zigbee_Simple
Zigbee_MAC
Zigbee_MAC_StarMesh
Scheduler_FIFO
Scheduler_PreemptionRR
Sensor_LIGHT
Sensor_GAS
Sensor_Temperature

Value
“&1_Zig_Simple_&2”
“&1_Zig_MAC_&2”
“&1_Zig_StarMesh_&2”
“&1_Sche_FIFO_&2”
“&1_Sche_PreemptionRR_&2”
“&1_Sensor_LIGHT_&2”
“&1_Sensor_GAS_&2”
“&1_Sensor_Temperature_&2”

It is necessary to define many hash tables according to the number of node type if a
static hash table which has the keys and values for one node type is used. Moreover,
the codes to control the hash tables must be written additionally according to the
number of hash tables. It is necessary to define a new hash table and to write the code
to control the hash table if a new type of the node is added.
However, there is no need to define a new hash table when a new type of the node
is added if a dynamic hash table is used. No additional codes are needed such as control codes for hash tables. The structure of dynamic hash table used in the
HashTable_Module class is presented in table 1. The key of the hash table is the name
of a module provided by Nano-Qplus. Strings such as “&1” and “&2” in the key
value are dynamically replaced according to the type of module and node. When the
type of each node is determined, the string “&1” is replaced with the type, and “&2”
is replaced with “H” (means Header), “D” (means Data) or “F” (means Function)
based on the type of required module. Following is an example.
i.e.) If the Zigbee_Simple module for radio frequency communication of a node is
selected, “&1_Zig_ Simple_&2” value is selected from the hash table. Then, the
value is replaced as follows by calling functions of HashTable_Module class.
setType(“SINK”); Æ “SINK_Zig_Simple_&2”
getHeader(“Zig_Simple”) Æ “SINK_Zig_Simple_H”
getFunction(“Zig_Simple”) Æ “SINK_Zig_Simple_F”
“SINK_Zig_Simple_H” is the name of a file which contains header codes of the
ZigBee_Simple module for a sink node, and “Sink_Zig_Simple_F” is the name of
a file which contains function codes of the ZigBee_Simple module for a sink
node.

908

K. Lee et al.

3 Case Study with Gas Monitoring System
An USN application for Gas Monitoring System such as figure 11 has been developed
using the proposed technique in this paper.

Fig. 11. Gas Monitoring System

A USN model was designed for the Gas Monitoring System. In the model, sensor
nodes sense gas data and transmit the data to router nodes. The router nodes receive
the data and transmit it to the sink node. The sink node receives the data, computes it
and transmits it to the actuator node. The actuator node performs an action according
to the threshold value.
The system of figure 11 was developed after the application was automatically
generated using a script based on designed model. Result that applies, sensing data
was forwarded from sensor node to router node and router node sent forwarded data
to sink node. An action command according to a gas value was forwarded from sink
node to router node and router node sent forwarded the action command to actuator.
The figure 12 is an example to set the attribute values of the script in order to generate automatically the program of the sink node. The USN application was automatically generated by setting the attribute values of each node through the script.

Preemption-RR
Scheduler selected !

Star-Mesh Router Selected !
SINK = 0
PAN Cordinator = TRUE
Adjacent Actuator = 1
Default MAC ADDR = 0x1111
Association Range = (1..99)

Fig. 12. An example of attribute values setting using the script

A Technique for Code Generation of USN Applications Based on Nano-Qplus

909

4 Conclusion
The technique for automatic code generation of USN applications based on NanoQplus is proposed in this paper. Developers can implement USN applications by
automatic generation of execution code of each node in the sensor networks after they
make models of the sensor networks and set attribute values of each node according
to the model using the script. The script for automatic code generation of each node is
proposed in this paper. The templates and an algorithm for automatic code generation
are also presented. Through the technique of this paper, developers will easily implement USN applications even if they do not know the details of low-level communication, data sharing, and collective operations. The development effort of USN applications also will be decreased because execution codes are automatically generated.
Furthermore, developers can perform early test through rapid code generation, so the
verified code is generated by correcting errors in the early development stage.

References
1. Kwangyong Lee et al., “A Design of Sensor Network System based on Scalable & Reconfigurable Nano-OS Platform,” IT-SoC2004, October 2004.
2. ETRI Embedded S/W Research Division, “Nano-Qplus,” http://qplus.or.kr/
3. E. Cheong, J. Liebman, J. Liu, and F. Zhao, “Tinygals: a programming model for eventdriven embedded systems,” SAC, 2003.
4. M. Welsh and G. Mainland, “Programming sensor networks using abstract regions,” NSDI,
2004.
5. R. Newton and M. Welsh, “Region streams: Functional macroprogramming for sensor networks,” DMSN, 2004.
6. A. Boulis, C. Han, and M. B. Srivastava, “Design and implementation of a framework for
efficient and programmable sensor networks,” MobiSys, 2003.
7. B. Greenstein, E. Kohler, and D. Estrin, “A sensor network application construction kit
(SNACK),” SenSys, 2004.
8. Ramakrishna Gummadi, Omprakash Gnawali, and Ramesh Govindan, “Macroprogramming Wireless Sensor Networks Using Kairos,” LNCS 3560, pp. 126–140, 2005.
9. Neil Matthew, Richard Stones, “Beginning Linux Programming 3rd Edition,” WROX
PRESS, 2003.

