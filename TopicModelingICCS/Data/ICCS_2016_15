Procedia Computer Science
Volume 80, 2016, Pages 289–300
ICCS 2016. The International Conference on Computational
Science

Assessing metaheuristics by means of random benchmarks
Pablo Rabanal, Ismael Rodríguez, Fernando Rubio∗
Facultad Informática. Universidad Complutense de Madrid. 28040 Madrid, Spain
prabanal@fdi.ucm.es,isrodrig@sip.ucm.es,fernando@sip.ucm.es

Abstract
Typically, the performance of swarm and evolutionary methods is assessed by comparing their
results when applied to some known ﬁnite benchmarks. In general, these metaheuristics depend
on many parameter values and many possible exchangeable sub-steps, which yields a huge
number of possible algorithm conﬁgurations. In this paper we argue that this high setup
versatility lets developers expressively tune the method, in an ad-hoc way, to the target inputs
to be solved, and hence to those in the benchmark under consideration. However, this does
not imply properly solving any other input not considered in the benchmark. Several subtle
ways to support that tuning (which can be consciously noticed by the developer, but can also
be unconscious) are presented and discussed in the paper. Besides, as a possible alternative to
using known ﬁnite benchmarks, we discuss the pros and cons of using random input generators,
and we illustrate how to use such generators in a speciﬁc problem, MAX-3SAT. A general
protocol to support the fair development of comparisons of metaheuristics based on random
input generators is presented.
Keywords: Metaheuristics, benchmarks generation, over-tuning

1

Introduction

In many computational science problems, it is not only diﬃcult to compute optimal solutions,
but also to ﬁnd good approximations. In these cases, metaheuristics are good choices to ﬁnd
reasonable solutions. In swarm and evolutionary optimization metaheuristics, simple entities
iteratively construct a solution by interacting with each other according to some simple rules
and local data [6, 7, 5, 13]. The standard method in the literature to assess the quality of
metaheuristics consists in observing their performance when solving some known sets of problem
instances (benchmarks). This way, the community can compare new proposed methods with old
methods in terms of solutions quality, time performance, or stability for the same sets of library
instances. Although fully checking a scientiﬁc hypothesis may trivially require inﬁnite tests
(and even this might not be enough [16]), method comparisons based on known benchmarks
are assumed to be robust and fair. Unfortunately, as we will argue in this paper, evolutionary
∗ Work

partially supported by projects TIN2012-39391-C04-04, TIN2015-67522-C3-3-R, and S2013/ICE-2731.

Selection and peer-review under responsibility of the Scientiﬁc Programme Committee of ICCS 2016
c The Authors. Published by Elsevier B.V.

doi:10.1016/j.procs.2016.05.321

289

Assessing metaheuristics

Rabanal, Rodr´ıguez and Rubio

and swarm methods are easily customizable, so much as to let developers make them (almost)
perfectly ﬁt into any ﬁnite set of inputs. This problem dramatically aﬀects the utility of
known ﬁnite benchmarks to compare metaheuristics with each other, as a good performance for
some benchmark does not imply, by itself, a good algorithm performance for other instances,
even for similar instances. We will discuss how easily metaheuristics can be customized to
a particular benchmark, we will propose an alternative comparison method based on random
input generation, and we will study its pros and cons compared to known ﬁnite benchmarks.
If we consider the original deﬁnition of some evolutionary or swarm metaheuristic, and also
the subsequent variations of the same method proposed in the literature, then we observe that
it has a handful of parameters and steps where many alternatives can be used. Let us suppose
that we are setting up a genetic algorithm. We can set parameter values such as the mutation
probability; we can choose among dozens of crossover methods proposed in the literature; or we
can even choose our particular way to represent candidate solutions into chromosomes, among
many other possibilities. Moreover, possibilities are not constrained to variations proposed in
the literature: a researcher can use a new crossover method invented by him, just because he
observes that it is good for the problem he is solving. Consequently, algorithm developers have
an inﬁnite set of alternative sub-methods and parameter values to select and adjust.
By properly combining these abundant choices, any generic algorithm can be converted into
a completely ad-hoc solution to handle a speciﬁc set of ﬁnite inputs. This does not necessarily
imply a fraudulent intention: it can just be the undesired result of the legitimate purpose of
improving the algorithm when focusing too much on a particular set of inputs. A similar issue
appeared in other areas, though it was properly tackled long ago. For instance, in machine
learning, instances used during the training process are separated from the instances used to
asses the quality of the results. On the contrary, in the optimization ﬁeld, using the same
benchmark for both steps is customary. It is known that this choice increases the risk of overﬁtting [9, 17, 15] to a very speciﬁc input. Hence, a metaheuristic can be over specialized for a
speciﬁc set of instances by over-tuning it [3].
We propose discarding comparisons based on known ﬁnite set of inputs, and replacing them
by comparisons based on instances created by random input generators for the problem under
consideration. Using a random input generator has got some drawbacks as well. As we will argue
later, random input generators are necessarily biased to some extent. Moreover, comparing the
performance of two metaheuristics might be less straightforward if a random input generator
is used. Some examples and a simple experiment will illustrate these problems. Despite these
drawbacks, we argue that random input generators are probably a better choice to provide a
fair assessment of evolutionary and swarm metaheuristics. In addition, a simple protocol for
guaranteing the fair usage of comparisons based on dynamic benchmark generators is proposed
(basically, it is based on making random generators record and publicly show all benchmarks
that have been served, and to whom).
The rest of the paper is structured as follows. Next, we introduce our arguments against
using ﬁnite ﬁxed benchmarks, and we identify several methods to tune up an algorithm for
a particular input or ﬁnite set of inputs. Then, in Section 3 we discuss the advantages and
disadvantages of using random input generators, we show how to use them in a speciﬁc example
(MAX-3SAT), and we report experimental results. Our conclusions are presented in Section 4.

2

Tuning Parameters to ﬁt into a given ﬁnite benchmark

Several researchers have warned against the risks of over-tuning, in particular to highlight the
necessity of assessing the performance of algorithms with sets of instances diﬀerent to those
290

Assessing metaheuristics

Rabanal, Rodr´ıguez and Rubio

used before to tune up them (see e.g. Chapter 6.1.4. of [3]). However, little has been said
about how easy over-tuning can be if developers push hard to make their algorithms reach good
results for speciﬁc benchmarks. In this section we show how the big variety of parameter values
and step sub-methods can be used to make an evolutionary algorithm ﬁt, in an ad-hoc manner,
into a given ﬁnite set of inputs.
The determination of a metaheuristic designer to ﬁnd competitive results can lead him
to make choices that, in fact, adapt his algorithm to the speciﬁc benchmark inputs under
consideration. Either consciously or just unconsciously (as the result of a mere try and fail
procedure which actually awards good results in the same way as metaheuristics do), designers
can tend to make many choices to adapt their methods to the speciﬁc benchmarks under
consideration, for instance in the following ways:
Way (a): Rules that modify the entities of the metaheuristic from each iteration to the
next one could favor those transformations which speciﬁcally make the method skip many
local optima. In particular, transformations could make candidate solutions skip, more or less,
the distance needed to move from these local optima to near higher values, thus skipping the
local valleys that make these values be local optima. Note that these distances are completely
particular for each instance.
For instance, let us suppose that we want to adapt the mutation and crossover parameters
of a Genetic Algorithm (GA) [5] to make it solve eﬃciently some given instance or instances.
Speciﬁc values of these parameters could make the GA tend to change, at each algorithm
iteration, current solutions by new solutions whose distance to older solutions is, with some
slightly higher probability, similar to the most usual distance letting escape from local optima
and reach some nearby better solutions. Since these distances are speciﬁc for the problem
instance or instances under consideration, these parameters could be useless to eﬃciently solve
other instances.
Way (b): Rules could subtly make solutions evolve towards some predeﬁned values which,
in particular, coincide with the optimal solutions or are near to them.
For instance, let us consider an optimization problem deﬁned in such a way that the optimal
solution is at point ¯
0 = (0, . . . , 0). The arithmetic of transformation rules could make these
rules be slightly biased towards approaching all components of solutions to 0. In this case, the
performance of the method would be good for optimizing functions having the optimal point
at ¯
0 or near to it. Let us suppose that our space solutions is [−d, d]n . If initial solutions are
randomly generated in this space and all points are given the same likeliness to be chosen,
then the center of mass of all points will very likely be near point ¯0. This could make a swarm
algorithm such as Particle Swarm Optimization (PSO) [8, 14] or an evolutionary algorithm such
as GA be biased towards generating more subsequent solutions near ¯0 (regardless of any other
additional consideration like the ﬁtness).
For instance, let us consider a GA crossover operator where each dimension of a child
solution can be given the value of that dimension of some of the parents, but it can also be
computed as the (perhaps ﬁtness-weighted) average of the value for both parents. The latter
choice naturally makes children tend to the center of mass of its parents, so ultimately the whole
GA would be biased towards the center of mass of all initial solutions. Similarly, the mutation
operator could also be used to introduce this kind of bias as well. Note that we can deﬁne the
mutation operator in such a way that it adds a constant (positive or negative) amount to the
value of some dimension, but we can also deﬁne it in such a way that the value is multiplied by
some value slightly greater or lower than 1. In this case, the mere application of the mutation
operator will produce values which are closer to ¯0 with a higher likelihood than values distant
to ¯
0. In the particular case where the optimal value is ¯0 indeed, this kind of biased operators
291

Assessing metaheuristics

Rabanal, Rodr´ıguez and Rubio

could increase the capability of the algorithm to ﬁnd good solutions in a completely ad-hoc way.
Other (more complex) operators could be deﬁned to make algorithms subtly tend towards any
other target point in the solutions space.
Way (c): The codiﬁcation of candidate solutions into the method (e.g. chromosomes in
a genetic algorithm) could be particularly appropriate for dealing with some given problem
instances. Moreover, it could favor (or be against) the kind of behaviors mentioned in (a)
and (b).
For instance, let us suppose that we wish to solve a given optimization problem with a GA
and we measure, for any pair of dimensions of the solutions space, whether these two dimensions
are coupled in terms of ﬁtness, i.e. whether changing only one of them, and keeping the rest
of dimension values, typically provides very diﬀerent ﬁtness values. If they do, then making
both values be inherited together into children solutions most of times is probably a good idea.
Let us suppose that a single-point crossover strategy is used in the GA. If we put both coupled
dimensions near in the chromosome representation, then crossover points will rarely be chosen
between both dimensions, and thus they will unlikely be separated by crossover operations.
Note that ordering the dimensions of chromosomes in terms of this criterion is a very time
consuming task. In order to accurately assess the coupling status for most pairs of dimensions,
a very high number of points has to be checked all along the solution space –probably more than
all points checked by a GA itself during its whole execution. Hence, exhaustively checking the
dimensional coupling before executing the method may lead to an unfair method assessment
if we do not account the computation time of that task in the overall computation time of
the GA. If we are not interested in solving a problem itself but we want to ﬁnd the perfect
representation of chromosomes for solving some problem instances with a GA, then the eﬀort
would be worth. Yet this kind of perfect customization shows nothing about the capability of
the GA to ﬁnd solutions in general –provided that we do not want the algorithm setup phase
take a much longer time than the algorithm itself, which is the case when we are more interested
in the solutions than in showing how the method can reach good solutions.
The previous problem applies to other evolutionary and swarm methods. Let us suppose
that a method is perfectly customized by running a pre-processing phase which requires to
exhaustively check a signiﬁcant part of all points in the solution space. Then the observed
performance of the method for these cases is irrelevant, as these prohibitive pre-processing
phases could dramatically improve the method performance for the particular instances we
wish to solve (but they would be completely useless for other instances).
In addition to the problems (a), (b), and (c), many other ways to adapt a method to a given
benchmark could be used. Regardless of the chosen way to customize a method to some given
set of instances, note that this task is much easier if the designer considers the possibility of
using a diﬀerent suite of parameter values and sub-steps for each instance, as constructing a
perfect independent customization for each particular case would be easier. However, if each of
these customizations for each single instance requires a long try and fail research by the designer,
then any good results of the method for these instances would be irrelevant. Even having to
run the method just twice to set up the parameters and sub-steps would pervert the interest of
the results if that additional execution time to ﬁnd good parameters is not counted –but a good
time consumption is indeed a goal of the method. Any human or automatic pre-processing
eﬀort should be added to the total execution time.1
Now, let us suppose that the designer wants to ﬁnd a ﬁxed set of parameter values and
procedure sub-steps that make his algorithm work ﬁne for all instances of some given ﬁnite
1 Going one step further, a particularly perverted case is when, given a known benchmark set, researchers
only report their good results for some subset of the benchmark, allegedly for the sake of brevity.

292

Assessing metaheuristics

Rabanal, Rodr´ıguez and Rubio

benchmark. Note that this task can be done by using self-adaptation techniques [1] or we could
apply a metaheuristic, or we could even work with hyper-heuristics (see e.g. [4]). That is, given
some set of available choices, we could run an evolutionary or swarm method to automatically
select those parameter values and sub-methods that maximize the number of instances of the
considered benchmark whose optimal solution is found, or minimize the sum of distances to the
optimal solutions, or optimize other similar metric. Let us remark that, even if these parameter
values and sub-methods are found in this way, there is no guarantee that they will also be good
for all possible input instances, in particular those not in the benchmark. Alternatively, rather
than running the method independently for each instance of the benchmark and trying to ﬁnd
a set of parameter values and sub-methods which globally work reasonably well for (most of)
instances, we could create a kind of single composite instance from the original instances of the
benchmark by considering the (single) problem of maximizing the addition of ﬁtness values of
all of these instances.
Note that the previous idea requires a reﬁnement. Let us suppose that some point in the
solutions space has under-the-average ﬁtness values for several instances but a high ﬁtness for
another instance. These values could compensate each other in such a way that the ﬁtness
of that point for the composite instance is just average. However, we want to create a single
composite instance where most of local and global optima from the original instances are so at
the composite instance as well. Note that, if they are so indeed, then ﬁnding good parameter
values and sub-methods for the composite instance could imply ﬁnding good parameters and
sub-methods for escaping from typical local optima for most of the considered instances, as
the hardness of the composite instance would comprise the hardness of all particular instances.
Hence, if a point has a high ﬁtness for some instance, then this point should also have some high
ﬁtness in the composite instance. This can be achieved if we raise the weight of that instance
in the computation of the ﬁtness of that point for the composite instance. In particular, rather
than using the addition of ﬁtness values, we may consider the addition of the k-th power of
these ﬁtness values, for some k ∈ IR with k > 1. Assuming that all ﬁtness values are higher
than 1, this modiﬁcation naturally increases the relative weight of particularly high values in
the composite instance. Moreover, in order to give all original instances the same importance,
we can use diﬀerent exponents ki for each instance Ii , in such a way that all global optima from
all instances have the same (high) value in the composite instance.
More generally, let us consider the diﬃculty of ﬁnding a set of parameter values and substeps such that some method works ﬁne when we use these ﬁxed values and sub-steps for all
(or most of) instances from a given known benchmark. We could argue that the diﬃculty of
this task strongly increases with the number of instances in the benchmark. However, note
that the number of available parameter values and possible sub-steps to play with is arbitrarily
high. On the one hand, parameter values typically range over inﬁnite domains (rationals or
reals) and, moreover, researchers can arbitrarily add new parameters to have a deeper control
of diﬀerent aspects of the algorithm. On the other hand, for any well known evolutionary or
swarm algorithm, there exist in the literature dozens of variants and alternative schemes which
provide researchers with a handful of choices for each sub-step of the algorithm (for instance, as
mentioned earlier, there exist many ways to implement the crossover step of a GA). Moreover,
a researcher can develop his own sub-step variants for ﬁtting better his particular goals, and
typically these variants are considered as an original contribution rather than as an ad-hoc
customization. Thus, we can argue that the number of available parameter values and available
sub-steps can scale up as much as the number of instances in the benchmark –because we can
extend the former arbitrarily, as much as needed. That is, a researcher has an arbitrarily high
capability to customize a method for any given ﬁnite set of instances.
293

Assessing metaheuristics

Rabanal, Rodr´ıguez and Rubio

ϕ := ; //ϕ is the propositional formula under construction.
S := {p0 }; //S is the set of proposition symbols. We will use at least one.
for i:=1 to 2 do
if (random choice with probability p) add a fresh symbol to S;
create random 3-clause c giving all symbols in S the same prob.Literals negated with prob 0.5;
ϕ := ϕ ∧ c;
while (random choice with probability q)
for i:=1 to 3 do
if (random choice with probability p) add a fresh symbol to S;
create random 3-clause c giving all symbols in S the same prob.Literals negated prob 0.5;
ϕ := ϕ ∧ c;
return ϕ;

Figure 1: Random input generator A for MAX-3SAT.

3

Random input generation

Next we study the usage of random input generators for assessing the performance of metaheuristics. Let us suppose that we have designed a new method M2 and we wish to compare
its performance with that of some previously known method M1 . Instead of assessing M2 by
running it for the ﬁnite benchmark that was used in the past to collect the reported results
of M1 , we propose comparing them by considering their results for (diﬀerent) sets of inputs
independently generated by the same random input generator. That is, we do not assess the interest of M2 by running it for the same ﬁxed benchmark as that originally used in the literature
to illustrate the performance of M1 . Instead, we show the interest of M2 by running the same
random input generator as that originally used to construct the benchmark used to assess M1
when it was ﬁrstly proposed, and then the new set of instances generated by that generator is
used to evaluate M2 and compare it with M1 . In this way, we could provide a fair comparison
between M1 and M2 in such a way that the benchmark for M2 is not known in advance.
The previous scheme raises several questions. First, we could argue that researchers claiming
to have followed it could, in fact, ﬁrstly run the random input generator and next tune up their
algorithms for the generated benchmark. Moreover, researchers could say that their benchmarks
were randomly generated, but in fact they could be manually designed ones. In order to cope
with these problems, we propose a simple protocol for random benchmark generation. For many
popular problems (3-SAT, TSP, 0/1 Knapsack, etc), the corresponding random benchmarks
generator should be hosted in a public web. Each time a researcher asks for a benchmark in
the site, the researcher must provide his name and the executable program the researcher is
intended to use later for solving the instances of the requested benchmark. Next, the generator
produces the benchmark and records the following information in a public ﬁle: name of the
researcher, the program ﬁle he is intended to run, the benchmark returned to the researcher,
and the date and hour of the request. By publicly showing these data on the site, any reader
of a paper where this researcher reports his results can check those data and (i) know that the
researcher did not know the benchmark before he ﬁxed his optimization program; (ii) repeat the
experiments and check whether the researcher used the submitted program and the returned
benchmark indeed; and (iii) check whether the researcher only asked for one benchmark, rather
than asking for several ones until one was good for his algorithm. Note that the web does not
need to execute the program of the researcher for the benchmark, it just needs to publicly store
it. Let us discuss the pros and cons of this alternative.
The previous argument (ii) shows that this protocol enables the reproducibility of experiments. However, one could argue that the step of randomly selecting the benchmark is part of
294

Assessing metaheuristics

Rabanal, Rodr´ıguez and Rubio

the experiment itself and cannot be reproduced due to its random nature. Let us remark that
the broader notion of reproducibility does not imply using exactly the same instances. Following the ideas presented in Principle 6 of [11], the main point behind reproducibility in science is
that diﬀerent researchers, applying similar techniques to similar data and using similar tools,
can obtain the same conclusions. In our case, by using similar but diﬀerent input instances
of the same problem, diﬀerent researchers should be able to obtain the same conclusions. In
particular, note that benchmarks obtained from the same random generator should lead to
analogous average performance results, particularly for large enough benchmarks, as we will
discuss later.
The second diﬃculty of using random input generators is that any random input generator
will be biased, in the sense that it will tend to construct inputs of some form with higher
probability than others. This problem is impossible to avoid, as it is not possible to give all
possible inputs the same probability of being generated, since the set of possible inputs is
generally inﬁnite. Moreover, since some bias is unavoidable, any random generator will give
higher probability to smaller inputs in general, because providing a consistent bias towards
bigger inputs is impossible (as their size is not constrained in general).2 However, handling
some known bias over the complete set of possible inputs will provide a less biased comparison
than if we just consider some ﬁnite set of inputs. Note that creating an ad-hoc solution to take
advantage of some probabilistic bias over an inﬁnite domain is harder than creating an ad-hoc
solution for handling some ﬁnite set, which is a kind of extremely biased case indeed (as a few
inputs are considered with 1 probability, whereas the rest have 0 probability).
In order to illustrate this issue, let us formally deﬁne the notion of random input generator.
An example is introduced next.
Deﬁnition 1. Let D be a countable set of inputs. A probability function for D is a function
p : D → IR+ ∪ {0} such that d∈D p(d) = 1.
Given a non-deterministic program P with no input and outputs over D, we say that P is
a random generator producing D with p if, for all d ∈ D, the probability that P produces d is
p(d). We say that P is complete if for all d ∈ D we have p(d) > 0.
Example 1. Let us consider the MAX-3SAT problem, deﬁned as follows: given a propositional
logic formula expressed in conjunctive normal form (CNF) with clauses of three literals, ﬁnd a
valuation of propositional symbols maximizing the number of holding clauses. We propose two
random generators producing suitable inputs for that problem (the interested reader can ﬁnd
many random generators for SAT, for instance in [10]).
Generator A, depicted in Figure 1, randomly constructs a propositional formula ϕ by iteratively deciding whether an additional clause is added. If so, then up to three new symbols can
be added to the set of available symbols, and next a new clause is added. On the other hand,
generator B, shown in Figure 2, initially constructs a kind of skeleton of ϕ where blanks appear
at all locations where a propositional symbol should be. Next, a set of propositional symbols
are created, and ﬁnally they are assigned to blanks in the formula. The probability of adding
a new propositional symbol and a new clause are p and q, respectively, at the corresponding
steps of both generators.
It is easy to see that both generators are complete, that is, they have a non-null probability
of generating any possible 3-CNF instance. However, for each generator, probabilities p and q
can be picked in such a way that the generator probabilistically tends to produce very diﬀerent
kinds of instances. For instance, if we pick these values in such a way that the ratio between
2 A classical example of this issue is Benford’s law [2]: in random numerical samples from real life fulﬁlling
some standard conditions, there are more numbers starting by digit 1.

295

Assessing metaheuristics

Rabanal, Rodr´ıguez and Rubio

ϕ := ; //ϕ is the propositional formula under construction.
S := {p0 }; //S is the set of proposition symbols. We will use at least one.
while (random choice with probability q)
create random 3-clause c but leave blanks at symbol locations.Literals negated with prob 0.5;
ϕ := ϕ ∧ c;
for i:=1 to 3 * number of clauses in ϕ - 1 do
if (random choice with probability p) add a fresh symbol to S;
for all blanks in ϕ do
assign a random propositional symbol from S to the blank;
return ϕ;

Figure 2: Random input generator B for MAX-3SAT.
the number of clauses and the number of propositional symbols is low in the generated formula
ϕ, then ϕ will be easily satisﬁable.3 Moreover, if many valuations satisfy the actual maximum
number of clauses which can be simultaneously satisﬁed (in particular, all of them), then a
GA will very probably reach optimal solutions. Thus, any of the previous generators can
probabilistically tend to produce generally easy instances, or generally hard instances, depending
on the values of p and q. There is also an important diﬀerence between generator A and
generator B. Note that propositional symbols created by generator A during its ﬁrst steps
tend to appear more often along ϕ clauses than the last added symbols. On the contrary, all
symbols have the same likelihood in formulas produced by generator B. As we will observe later
in Section 3.1, fulﬁlling many clauses simultaneously will be easier in formulas generated by B
than in formulas generated by A.
Still, knowing and controlling the (unavoidable) bias of a given complete random input
generator will provide less biased comparisons than if we use a given known ﬁnite benchmark,
which is completely biased towards a tiny part of the whole input domain. Note that any
ﬁnite set of inputs constitutes a 0 proportion of the whole inﬁnite input domain, and thus
comparing methods in terms of known ﬁnite sets lets designers easily tune their algorithms for
these particular inputs.
The third diﬃculty of using random input generators is that comparing the performance of
two methods is less straightforward. Let us suppose that we want to show that our method
M2 is better than some previously known method M1 . We could either focus on experimenting
only with M2 and comparing our results with old known results for M1 , or we could make new
experiments for both M2 and M1 . In the latter case, we could use the generator to randomly
create some suitable inputs, and next use both M1 and M2 to solve the same inputs in order
to show that M2 is better than M1 . In order to be sure that we do not tune up M2 after the
benchmark is ﬁxed, the web based protocol mentioned before could be followed. However, if
we can trust previous reported experimental results on M1 (as it should ideally be), it would
be preferable focusing on performing new experiments only for M2 and comparing both results
afterwards, as repeating experiments for M1 could be a very time-consuming task. Note that
we cannot use the same benchmark as that used in the past for M1 because it would let us
over-tune M1 . On the contrary, providing a fair comparison in this case requires running the
same generator used in the past to generate the benchmark for M1 , this time to create the set
of instances for M2 , and next comparing old results for M1 and new results for M2 in terms
of their respective performance for these diﬀerent sets of inputs. Note that both sets could
include inputs of diﬀerent sizes. We know that this comparison is fair because the same rule
3 3-SAT has an interesting transition phase at the point where the ratio of clauses to propositional symbols
is roughly 4.2 [12]. Most of non-trivial instances are close to that ratio.

296

Assessing metaheuristics
Generator
A
B
A
B
A
B
A
B
A
B

Rabanal, Rodr´ıguez and Rubio
% new var
1%
1%
2.5%
2.5%
5%
5%
10%
10%
15%
15%

Variables
3.84
3.98
7.94
8.57
15.91
15.71
29.58
29.94
44.55
44.86

Clauses
98.09
97.46
93.98
101.31
100.22
94.34
95.50
96.49
97.32
97.80

% optimality
92.52%
93.22%
94.22%
95.31%
96.15%
97.14%
98.07%
99.23%
98.92%
99.77%

Table 1: Experimental results comparing diﬀerent generators and conﬁgurations.
produces the inputs for both methods, although statistically removing the discriminating eﬀect
produced by using diﬀerent sets could require both sets to be big. We may also consider this
alternative: we run the generator for constructing the inputs of M1 , and next we require the
generator to produce random inputs of the same size as those included in the former set, in
order to construct the inputs of M2 .
Example 2. Let us suppose that we want to compare two MAX-3SAT solvers M1 and M2 .
We assume that we have experimental results of the performance of M1 for some random
benchmark set X produced by one of the generators given in Example 1 (say A). Let p and q
be the probabilities used in the generation of X.
We compare methods M1 and M2 as follows. We modify the code of generator A, replacing
any if statement over a random choice with probability p by a deterministic if statement
checking whether the size of ϕ has not reached a given size s yet; if so, then we do the same as
in the original code when we took the random choice with probability p. Next, for each input
in x ∈ X, we run that modiﬁed generator to randomly produce an input x of the same size of
x. Let X be the resulting set of new inputs. Finally, we run method M2 for benchmark X
and we compare its performance with the performance of M1 for benchmark X. Note that the
size of an input might not be the most determinant aspect aﬀecting the diﬃculty of solving it.
Thus, other similar factors could be considered (together or independently) to make X have
inputs of similar diﬃculty as those of X.
If we compare this approach with independently generating the set of inputs for M1 and M2
with the (original) generator A, we have the advantage that we can use smaller benchmarks, as
both sets should have a similar diﬃculty even if they are small. However, a drawback is that
designers could use their own deﬁnition of size or diﬃculty to match their particular necessities
to show that M2 is better than M1 .

3.1

Experiments

In this section we report some experiments where we solved MAX-3SAT instances generated by
running the random input generators A and B. These experiments let us observe the eﬀect of
several generation choices on results. Our simple implementations of these generators write the
generated 3-CNF formulas into a ﬁle, so that this ﬁle can be used later as input of a MAX-3SAT
solver. For each generator, instances were solved with diﬀerent values of parameters p and q.
Expressed as percentages, the value of p ranged between 1 and 15, whereas we set q = 99
to generate instances of around one hundred clauses. We generated 1000 instances with both
generators for each pair of values p and q.
297

Assessing metaheuristics
Generator
A
A
A
A
A
A
A
A
A
A
A
A
A
A
A
A
A
A
A
A
A
A
A
A
A
A
A
A
A
A
A
A
A
A
A

% new var
1%
1%
1%
1%
1%
1%
1%
2.5%
2.5%
2.5%
2.5%
2.5%
2.5%
2.5%
5%
5%
5%
5%
5%
5%
5%
10%
10%
10%
10%
10%
10%
10%
15%
15%
15%
15%
15%
15%
15%

Rabanal, Rodr´ıguez and Rubio
Bench size
10
20
50
100
200
500
1000
10
20
50
100
200
500
1000
10
20
50
100
200
500
1000
10
20
50
100
200
500
1000
10
20
50
100
200
500
1000

Std dev
0.93
0.51
0.31
0.10
0.04
0.02
0.02
0.98
0.43
0.25
0.07
0.04
0.01
0.01
0.61
0.20
0.08
0.07
0.04
0.01
0.004
1.18
0.30
0.13
0.04
0.03
0.005
0.001
0.29
0.04
0.02
0.007
0.008
0.005
0.002

Generator
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B
B

% new var
1%
1%
1%
1%
1%
1%
1%
2.5%
2.5%
2.5%
2.5%
2.5%
2.5%
2.5%
5%
5%
5%
5%
5%
5%
5%
10%
10%
10%
10%
10%
10%
10%
15%
15%
15%
15%
15%
15%
15%

Bench size
10
20
50
100
200
500
1000
10
20
50
100
200
500
1000
10
20
50
100
200
500
1000
10
20
50
100
200
500
1000
10
20
50
100
200
500
1000

Std dev
1.65
0.52
0.23
0.10
0.10
0.04
0.02
2.89
1.22
0.19
0.11
0.02
0.02
0.01
1.29
0.47
0.17
0.06
0.03
0.008
0.008
0.14
0.05
0.04
0.02
0.02
0.004
0.001
0.004
0.005
0.004
0.002
0.007
0.003
0.001

Table 2: Standard deviation for each conﬁguration.

Once the problem instances were created, a standard genetic algorithm (GA) was applied
to solve them. Let us describe this GA. Each solution (chromosome) is codiﬁed as an array of
boolean values where each position represents the value of a propositional symbol. First, the
GA produces an initial random population where each position in the array is set to true or
f alse in a random manner. Next a new population is generated, and a tournament method is
used in order to choose the next generation. In this tournament, the old population is faced
with the new one, and those individuals with better ﬁtness are selected for the next generation.
The ﬁtness in the algorithm is equal to the number of clauses satisﬁed in the formula. Each
new population is created by breeding pairs of individuals (where those whose ﬁtness is greater
are selected with higher probability) and by mutating them. In the breeding process, for each
new individual we randomly choose which parent each array position is inherited from. The
GA was run 10 times for each instance problem with the following parameters: 500 generations
were produced, the population size was set to 20, and the crossover and mutation probability
were set to 80% and 0.5% respectively.
In the experimental results given in Table 1, we show the algorithm selected to generate the
298

Assessing metaheuristics

Rabanal, Rodr´ıguez and Rubio

instances in each case (Generator column); the probability p used for creating new propositional
symbols (% new var column) in the corresponding random input generator; the average number
of variables (Variables) and the average number of clauses (Clauses) in the sets of formulas
created by the generators; and the mean of the percentage of optimality (% optimality) achieved
by the GA when solving them. In order to compute this percentage of optimality, we divided
the number of clauses satisﬁed by the total number of clauses of the formula, and multiplied
the result by 100.
We observe that the form of generated instances signiﬁcantly inﬂuences results. First let
us note that, when the probability of creating new variables (p) is increased, we obtain better
percentages of optimality, as the ratio between clauses and propositional symbols decreases (as
mentioned earlier, this is known to improve the satisﬁability of the formula, see [12]). Besides,
if we compare our two generators A and B, then we observe that generator B creates easier
problem instances than generator A: when the parameters p and q of both generators coincide,
solutions found by the GA for generator B are about 1% better in all cases. Let us remark that
these results are inﬂuenced not only by the maximum number of clauses each formula lets to
simultaneously satisfy but, more interestingly, by the particular capability of our GA to satisfy
many clauses for formulas having these particular forms. We conclude that homogeneously
distributing all used propositional symbols along all clauses generally produces instances where
satisfying more clauses is easier for our GA. Note that this diﬀerence is consistently observed
even in cases when the average formula length (i.e. the number of clauses) of formulas generated
by B was higher (which actually can be observed in the rows of Table 1 where p is, respectively,
2.5 and 10 and, to a lesser extent, 15). This illustrates that, even when the same values of p
and q are used, the size of formulas is not the most signiﬁcant diﬃculty aspect. Moreover, it
supports our idea that, in practice, the performance of two metaheuristics M1 and M2 can be
fairly compared by running them for two diﬀerent sets of instances independently generated by
the same generator, even if the average size of instances in each set is (slightly) diﬀerent.
Let us present a second experiment. In order to assess the usefulness of using generators
for fairly comparing diﬀerent methods, results for diﬀerent benchmarks constructed by the
same generators should have similar performance when using the same conﬁguration in the
generator. In particular, if a new algorithm is to be compared with other algorithms by using
the same generator and conﬁguration, but with diﬀerent instances, the performance results
of each algorithm should not be signiﬁcatively inﬂuenced by the speciﬁc instances under use.
Otherwise, the comparison would not be fair.
We perform the following experiment. For each of the two generators presented before, and
for each of the conﬁgurations shown in Table 1, we created several sets of random instances.
First, we start creating 20 small sets of size 10 (that is, we create 20 random benchmarks, each
of them with 10 random problems), and we ran our GA 10 times for each instance of these
benchmarks, computing the average results obtained by the GA for each instance. Then, we
compare the results obtained by each of the 20 benchmarks, computing the standard deviation.
By doing so, we check whether the obtained results signiﬁcantly depend on the speciﬁc random
benchmark under use or not. After that, we repeat the same process but creating 20 benchmarks
of increasingly larger sizes. In Table 2 we show the standard deviation obtained for each case
when we consider random benchmarks of diﬀerent sizes. It can be seen that the deviation is
quite small in most cases. Hence, even though the benchmarks are somehow random, the results
are basically the same provided that the size of the benchmark is not too small. In particular,
in our case we could safely use a random benchmark of size 50.
299

Assessing metaheuristics

4

Rabanal, Rodr´ıguez and Rubio

Conclusions

We have argued against the usage of known ﬁnite benchmarks to compare the performance of
metaheuristics. Our argument is that these methods support a huge set of parameter values
and sub-steps which provide enough versatility to tune up the method to the particular inputs
to be solved. As an alternative, we have described the pros and cons of using random input
generators, and we have discussed how they should be applied. We have introduced speciﬁc
algorithms to generate these inputs for a well-known NP-hard problem, namely MAX-3SAT,
and we have reported some experimental results. Our experiments, with two diﬀerent random
input generators for MAX-3SAT, show that results do not signiﬁcantly vary when using diﬀerent
instances of the same generator. Hence, random generators can be safely used provided that a
minimum number of instances is used to guarantee statistically signiﬁcant results.

References
[1] T. Back. Self-adaptation in genetic algorithms. In European Conference on Artiﬁcial Life, ECAL
1992, pages 263–271. The MIT Press, 1992.
[2] F. Benford. The Law of Anomalous Numbers. Proceedings of the American Philosophical Society,
78(4):551–572, 1938.
[3] Mauro Birattari. Tuning metaheuristics: a machine learning perspective, volume 197 of Studies in
Computational Intelligence. Springer, 2009.
[4] E. K. Burke, M. Gendreau, M. Hyde, G. Kendall, G. Ochoa, E. Özcan, and R. Qu. Hyperheuristics: A survey of the state of the art. Journal of the Operational Research Society,
64(12):1695–1724, 2013.
[5] K. de Jong. Evolutionary computation: a uniﬁed approach. MIT, 2006.
[6] R.C. Eberhart, Y. Shi, and J. Kennedy. Swarm Intelligence. Morgan Kaufmann, 2001.
[7] A.E. Eiben and J.E. Smith. Introduction to Evolutionary Computing. Springer, 2003.
[8] A. P. Engelbrecht. Particle swarm optimization. In Genetic and Evolutionary Computation Conference, GECCO 2015, pages 65–91. ACM, 2015.
[9] S. Geman, E. Bienenstock, and R. Doursat. Neural networks and the bias/variance dilemma.
Neural computation, 4(1):1–58, 1992.
[10] H.H. Hoos and T. Stützle. SATLIB: An Online Resource for Research on SAT. In SAT2000, pages
283–292. IOS Press, 2000. www.satlib.org.
[11] D. S. Johnson. A theoretician’s guide to the experimental analysis of algorithms. Data structures,
near neighbor searches, and methodology: 5th& 6th DIMACS implementation challenges, 59:215–
250, 2002.
[12] D. Mitchell, B. Selman, and H. Levesque. Hard and easy distributions of SAT problems. In 10th
National Conference on Artiﬁcial Intelligence, pages 459–465. AAAI Press, 1992.
[13] P. Rabanal, I. Rodríguez, and F. Rubio. Testing restorable systems: formal deﬁnition and heuristic
solution based on river formation dynamics. Formal Aspects of Computing, 25(5):743–768, 2013.
[14] P. Rabanal, I. Rodríguez, and F. Rubio. Parallelizing particle swarm optimization in a functional
programming environment. Algorithms, 7(4):554–581, 2014.
[15] P. Rabanal, I. Rodríguez, and F. Rubio. On the uselessness of ﬁnite benchmarks to assess evolutionary and swarm methods. In Genetic and Evolutionary Computation Conference (Companion
Material), GECCO 2015, pages 1461–1462. ACM, 2015.
[16] I. Rodríguez, L. Llana, and P. Rabanal. A general testability theory: classes, properties, complexity, and testing reductions. IEEE Transactions on Software Engineering, 40:862–894, 2014.
[17] V. N. Vapnik. Statistical learning theory. Wiley New York, 1998.

300

