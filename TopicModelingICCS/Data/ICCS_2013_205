Available online at www.sciencedirect.com

Procedia Computer Science 18 (2013) 149 – 158

International Conference on Computational Science, ICCS 2013

Data ﬂow testing in concurrent programs with message passing
and shared memory paradigms
Paulo S. L. Souzaa,∗, Simone S. Souzaa , Murilo G. Rochaa , Rafael R. Pradoa , Raphael
N. Batistaa
a University

of Sao Paulo - SSC/ICMC, P.O. 668, Sao Carlos, 13566-590, Brazil

Abstract
This paper proposes a novel structural test model to capture information about ﬂows of data, control, communication and synchronization of parallel and distributed applications interacting through both message passing and shared memory paradigms.
Our main focus is the data ﬂow among threads of diﬀerent processes, considering the operations of communication and synchronization related to such ﬂow. This inter-process data-ﬂow represents a challenge to the tester, who must consider the
heterogeneity of programming paradigms and languages. The information captured by the test model is used by new testing
criteria, which improve the testing activity quality. The proposed model and criteria were applied to an object-oriented and
distributed application developed in Java. The results suggest that the model and the criteria are able to represent distributed
applications developed with message passing and shared memory paradigms. The main contribution of this paper is to present
a more ﬂexible test model capable of improving the structural test activity related to the data ﬂow on processes and threads
simultaneously.
Keywords: structural testing criterion; concurrent programs; distributed applications; message passing; shared memory

1. Introduction
Parallel and distributed applications have concurrent processes that interact using the message passing or
shared memory paradigms. Both paradigms can also be used simultaneously by such applications. A process,
for instance, receives a message and then requests the creation of threads to attend this message. This scenario
is usual in distributed applications on the Web, where servers receive requests from clients and generate threads
to attend them, and also in parallel applications, in which new threads of a parallel process are created to run in
multi-core processors.
Besides the sequential ﬂow inherent to the sequential applications, distributed applications have two other
dimensions related to communication and synchronization. One dimension represents the distinct processes that
interact with message passing and the other involves threads of a process interacting through shared memory.
Diﬀerent concurrent programming languages oﬀer support to this context and the most of them are structured
or object-oriented. These languages oﬀer speciﬁc primitives that impose distinct semantics to access data that are
local, remote and shared in processes and threads.
∗ Corresponding

author. Tel.: +0-55-16-3373-6623; fax: +0-55-16-3373-8118.
E-mail address: pssouza@icmc.usp.br.

1877-0509 © 2013 The Authors. Published by Elsevier B.V. Open access under CC BY-NC-ND license.
Selection and peer review under responsibility of the organizers of the 2013 International Conference on Computational Science
doi:10.1016/j.procs.2013.05.178

150

Paulo S.L. Souza et al. / Procedia Computer Science 18 (2013) 149 – 158

In this context, distributed applications present interesting ﬂows of control, communication and synchronization, directly aﬀecting the ﬂow of data accessed by processes and their threads. The shared memory paradigm
disassociates communication from synchronization, in which the communication occurs implicitly through the
deﬁnition and use of shared data. Explicit synchronization primitives are used to ensure the semantic when accessing shared data. Some examples of such primitives are lock/unlock, post/wait, and cond wait/cond signal. The
message passing paradigm establishes that communication and synchronization are associated and based on the
explicit use of primitives, such as send and receive. These primitives keep data ﬂow as well as synchronization
ﬂow among processes.
This context makes the parallel/distributed software development more complex, hence the Validation & Veriﬁcation (V&V) activity. The testing of concurrent programs is an important mechanism associated with V&V,
which seeks to ensure quality by revealing unknown errors. However, non-determinism, deadlocks and diﬀerent
communication paradigms are features that make the testing activity for concurrent programs signiﬁcantly more
complex. Many testing problems with sequential programs have been reduced by the introduction of testing criteria and the use of supporting tools. A testing criterion is a predicate to be satisﬁed by a set of test cases that can
be used as a guideline for the generation of test data. Structural criteria, for instance, allow the use of structural
aspects from the source-code to guide the selection of test-cases. They are usually based on a control-ﬂow graph
and the deﬁnition or use of program variables [1].
Previous works have proposed mechanisms to support V&V activities in the context of concurrent programs
[2], [3], [4], [5], [6] and [7]. These works explore diﬀerent aspects, such as programming paradigm, language and
static or dynamic approaches. However, the contributions consider only one paradigm in their test model, compromising the testing activity when the application uses paradigms of both message passing and shared memory.
In this scenario, this paper contributes presenting a new structural test model to capture information about
data, control, communication and synchronization from parallel/distributed applications that interact through both
message passing and shared memory paradigms. The main features of the test model are related to the data ﬂow,
since such ﬂow represents a grand challenge to the tester, who must consider the heterogeneity of programming
paradigms and languages. Our proposal decouples the test model from speciﬁc programming paradigms and
languages, and at the same time, considers diﬀerent and important aspects present in data communication for both
shared memory and message passing. This was made possible because our model is based on main concepts of
inter-process communication (IPC) rather than just on particular languages or one paradigm. This independence
makes it broader and improves the coverage of the structural test in distributed applications.
The information gathered by the test model is used in new structural testing criteria proposed to improve
the testing activity quality by means of the coverage of required elements. The model and criteria proposed were
applied to a distributed application developed in Java. Our results show how to represent the information extracted
from a source code in the model and how the required elements can be generated from this information.
The paper is organized as follows: Section 2 discusses the previous works; the test model and structural criteria
are described in Section 3; Section 4 discusses our results applying the test model and criteria to a Java distributed
application; the conclusions and future works are presented in Section 5.
2. Previous work
The structural testing criteria proposed in [6] are focused on concurrent programs with message passing involving point-to-point, collective, persistent, blocking and non-blocking communication. In this message passing
communication paradigm, the exchange of explicit messages is responsible for both synchronization and communication. The latter establishes a data-ﬂow among distinct processes that do not share a common memory.
To provide support for the criteria, a structural test model extracts data from a source code and represents
them in a Parallel Control Flow Graph - PCFG. Examples of this data are nodes, intra and inter-process edges
(representing, respectively, control and communication ﬂows) and deﬁnition-use of variables. The inter-process
data-ﬂow considers the synchronization edges (s-edges) existent between send and receive nodes. The data recovered from the source code are inserted in sets and used to create required elements, which establish the minimal
information that must be covered to satisfy a testing criterion. However, satisfying a testing criterion is not always
possible, due to the presence of infeasible elements. An element required by a criterion is infeasible if there is no

Paulo S.L. Souza et al. / Procedia Computer Science 18 (2013) 149 – 158

set of values for the parameters, which represent the input and the global variables of the program that execute a
path and cover that element. The determination of infeasible paths is an indeterminate problem [6].
A new set of structural testing criteria for shared memory programs was proposed in [5], extending our previous work. In this new scenario the communication is implicit and decoupled from synchronization. Whereas
the synchronization occurs explicitly through synchronization primitives, as semaphores, the communication occurs implicitly by means of shared variables deﬁned and used by distinct threads of a same process. In [5] the
C language with POSIX Threads (PThreads) is considered. The criteria are supported by a new structural test
model derived from the model proposed in [6]. In this new model the synchronization primitives are mapped
as senders or receivers and the implicit data ﬂow that exist among the distinct threads is recovered dynamically,
using the execution trace ﬁle. All possible deﬁnitions and use of global variables are ﬁrst statically extracted
from the source code; then the coverage of the deﬁnition clear paths among distinct threads is veriﬁed using a
post-mortem and dynamical approaches through a controlled execution. Therefore, a hybrid approach is used; it
employs static methods for the generation of required elements and dynamic methods to verify the coverage of
inter-thread deﬁnition clear paths that represent, in this case, an implicit communication.
S. R. S Souza et al. and F. S. Sarmanho et al., in [6] and [5], show promising results towards improving the
testing coverage in the programs, making it possible to detect typical errors in concurrent programs [8]. One
limitation of these works concerns data ﬂow among distinct processes/threads when dynamic variable allocation
occurs. In our previous research we did not consider variable dynamic allocation in the context of shared memory
programs. When the object-oriented paradigm is considered, another programming style containing features not
explored in our previous test models is used. The next section discusses how to solve this limitation.
Another signiﬁcant limitation of our test models is that they do not consider that a same concurrent program
can be composed of processes and threads. This programming style is common in distributed applications on the
Web, which are developed under an object-oriented paradigm and explore remote multi-core hosts.
3. Test model for concurrent programs
Our test model captures control, data, synchronization and communication ﬂows from concurrent programs. A
concurrent program is deﬁned by a set of np concurrent processes Prog = {p0 , p1 , . . ., pnp−1 }. The model assumes
that np is ﬁxed and known at the initialization of the concurrent application. Each p process may be based on
diﬀerent or identical source codes and each one has a distinct address space.
Each p process is composed of nt concurrent threads Proc = {t0 , t1 , . . . , tnt−1 } sharing a common address space.
The value of nt is also ﬁxed and known for each process. A t thread belonging to a p process is represented by a
CFGp,t and built using the same concepts as traditional sequential software [1]. The CFGp,t is composed of a set
of nodes N p,t and a set of intra-edges Ep,t , where the latter links two successive nodes in a πp,t path. Each node np,t
corresponds to a set of statements that are sequentially executed. A πp,t path in a CFGp,t is an intra-thread path
p,t
p,t
p,t p,t
p,t
and
composed of a ﬁnite sequence of tuples, πp,t = ( np,t
1 , eu , n2 , eu+1 , . . . , nm , eu+w ), where (ni , ni+1 ) ∈ E
eu is u − th event (or node executed) in this path. Events are required because a same node can be re-executed due
p,a
to a repetition structure. In order to exemplify this point, consider the path of thread a πp,a = ( np,a
1 , e1 , n2 , e2 ,
p,a
p,a
p,a
p,b
p,b
p,b
p,b
= ( np,b
np,a
3 , e3 , n1 , e4 , n2 , e5 , n3 , e6 )) and the path of thread b π
4 , e1 , n5 , e2 , n6 , e3 , n4 , e4 ,
p,b
p,b
n5 , e5 , n6 , e6 ). The nodes of threads a and b are executed twice in their respective paths due to a repetition
structure and the event associated with the node is responsible for distinguishing each execution in a path.
Following the proposal in [9], the primitives related to the communication and synchronization are represented
in a set entitled Nsync . These primitives are clustered and classiﬁed according to their semantics when inserted in
Nsync . The grouping of synchronization and communication primitives into clusters reduces the amount of infeasible edges, by allowing the establishment of edges only among primitives related to a same cluster. Classifying
primitives according to their semantics aggregates information about their behaviors, improving the quality of the
testing activity. A set F, where F = {f0 , f1 , . . . fnf −1 } and nf indicates the amount of diﬀerent clusters, supports
cluster primitives (or functions) [9]. The semantics of the primitives are implemented by setting B = { BS , NS ,
BR , NR , BSR , NSR }, for Blocking Sender, Non-blocking Sender, Blocking Receiver, Non-blocking Receiver,
Blocking Sender-Receiver and Non-blocking Sender-Receiver, respectively. A node in Nsync is, therefore, a triple
p,t
p,t
has a synchronization/communication primitive, fg ∈ F and bu ∈ B.
(np,t
i , fg , bu ), where the node ni ∈ N

151

152

Paulo S.L. Souza et al. / Procedia Computer Science 18 (2013) 149 – 158

The executions of each CFGp,t are interdependent due to synchronizations performed through synchronization
primitives. These synchronizations establish the order among the events in the CFG p,t . Interrelationships between
p,t
p
i
, which is composed of intra-process synchronization edges (np,t
, nl j ),
threads in a CFGp are represented by Esync
k
p,t
i
p,t
where np,t
∈ Nsync and nl j ∈ Nsync . Formally, a PCFGp = (N p , Ep ), where N p = nt−1
represents the set of all
t=0 N
k
p
nt−1 p,t
p
nodes of p and E = Esync ∪ t=0 E represents the set of all internal edges of p.
Analogously, the interrelationships among distinct processes are represented by Esync , which is composed of
p ,t
p ,t
inter-process synchronization edges. An Esync is composed of edges (npk i ,t , nl j ), where npk i ,t ∈ Nsync , nl j ∈ Nsync
p
and i j. Based on these concepts we can deﬁne PCFG = (N, E), where N = np−1
p=0 N is the set of nodes of Prog
p
and E = Esync ∪ np−1
p=0 E is the set of edges of Prog.
After deﬁning Esync , it is possible to deﬁne an inter-thread path. Π = (πp1 ,t1 , πp1 ,t2 , πp2 ,t1 , . . . πpk ,tl , S) is an interthread path of a concurrent execution of Prog, where S is the set of synchronization pairs executed, such that if
p ,t
p ,t
( npx i ,tk , e , ny j l , eu ) ∈ S , then (npx i ,tk , ny j l ) ∈ Esync . Observe that the synchronization pairs of S can be used to
p1 ,t1
establish a conceptual path { n1 , eu , np21 ,t1 , eu+1 , . . . , npi 1 ,t1 , eu+v , kjp2 ,t2 , eu+w , . . . , npm1 ,t1 , eu+x } or { k1p2 ,t2 ,
eu , k2p2 ,t2 , eu+1 , . . . , npi 1 ,t1 , eu+v , kjp2 ,t2 , eu+w , . . . , klp2 ,t2 , eu+x }. Such paths contain Esync edges among distinct
threads even though they belong to diﬀerent processes.
All dynamically and statically allocated data of p are represented in our model by a Dp data set. Dynamically
allocated data are represented statically by a label and associated with statements used since their creation. The
same can be done with statically allocated data, which can be represented by their identiﬁers. We can also deﬁne
a special subset of data, Dpshared ⊆ Dp , which corresponds to all data shared in p.
Some challenges arise when it is possible to reference other statically or dynamically allocated data through
a variable. In Java, variables can refer to primitive or object types, of which the latter is always a reference to
an object allocated dynamically. References may change at runtime and the same variable can point to diﬀerent
objects in memory during the execution of the program. Thus, it is not always possible to identify statically
(before the execution of a thread) which objects a variable will point to at runtime. However, possible objects can
be found by pointer analysis (also called alias analysis) [10]. By considering that our test model derives statically
required elements, a conservative approach is employed. In this approach all possible variables pointing to objects
are considered and, consequently, some infeasible required elements may be generated.
This situation impacts on the construction of Dpshared . In Java, for instance, it is possible to deﬁne a static
variable that can be shared by all threads. However, it is also possible to share an object by sending references
to Thread object before its startup, or by sending references at runtime through messages. In order to detect this
dynamic sharing, an eﬀective thread-escape analysis is necessary. An object is thread-escaping if it is reachable
from more than one thread and it is thread-local if it is reachable from at most one thread.
When an object pointed by a variable is changed (i.e. deﬁned), it is not always possible to know which object
is being deﬁned statically. This indeﬁnite deﬁnition might or might not overlap other previous object deﬁnitions.
Therefore, we followed a strategy similar to the one used by Orso et al [10] and made a clear distinction between
deﬁnitions:

• d-def (deﬁnite deﬁnition) is represented by pair np,t , d , such that data d ∈ Dp is deﬁnitely deﬁned at node
np,t .
• i-def (indeﬁnite or possible deﬁnition) is represented by pair np,t , d , such that data d ∈ Dp is possibly
deﬁned at node np,t .
p,t
p,t
p,t
A path πp,t = ( np,t
1 , eu , n2 , eu+1 , ..., nk−1 , eu+v , nk , eu+w ) is deﬁnition clear with respect to (w.r.t.) data d
p,t
p,t
p,t
p,t
p,t
from event np,t
1 , eu to event nk , eu+w or edge (nk−1 , eu+v , nk , eu+w ) if n1 , d is d-def or i-def, and nj , d
is not a d-def for j = 2, ..., k − 1. The concept of a deﬁnition clear path can be applied to inter-thread paths
when a message passing paradigm is considered [6]. Inter-thread definition-clear paths with the shared memory
paradigm are not applicable to our test model, according to the explanation in this section when s-c-use and s-c-use
associations are described.
In addition to traditional computation use (c-use) and predicate use (p-use) [1], we have deﬁned new possible
uses related to shared memory and message passing concurrent programs:

Paulo S.L. Souza et al. / Procedia Computer Science 18 (2013) 149 – 158

• computational use (c-use) is deﬁned by pair np,t , d , such that data d ∈ Dp is deﬁnitely or possibly used in
a computation statement at node np,t . The deﬁnite or possible use of d is a consequence of the last deﬁnition
of d, which can be an d-def or i-def.
p,t
p
• predicative use (p-use) is deﬁned by pair (np,t
1 , n2 ), d , such that data d ∈ D is deﬁnitely or possibly used
p,t p,t
in a predicate statement at edge (n1 , n2 ). As in the c-use, the deﬁnite or possible use of d is a consequence
of the last deﬁnition of d.
• message use (m-use) is deﬁned by pair np,t , d , such that d ∈ Dp is deﬁnitely or possibly used in a messagesender node np,t ∈ Nsync . m-use occurs when a message with data is sent from a thread to another, belonging
to a same or distinct process. Therefore, this data do not have a computational or predicative use, but a
message-use.
• shared computational use (s-c-use) is deﬁned by pair np,t , d , such that data d ∈ Dpshared is deﬁnitely or
possibly used in a computation statement at node np,t . This use is distinct from the c-use because it considers
the implicit communication between threads, in which the pair of deﬁnition-use w.r.t d may occur in distinct
threads.
p,t
p
• shared predicative use (s-p-use ) is deﬁned by pair (np,t
1 , n2 ), d , such that d ∈ Dshared is deﬁnitely or
p,t
p,t
possibly used in a predicative statement at (n1 , n2 ). s-p-use occurs when the thread uses shared data in a
predicative statement.
4. Associations for data ﬂow testing
Similarly to the traditional testing, we have established pairs of deﬁnitions and uses of d. Three types of
associations have been deﬁned to test sequential data ﬂow:
p,t
p,t
p,t
• c-use association is deﬁned by a triple np,t
1 , n2 , d , such that n1 , d is a d-def or an i-def, n2 , d has a
p,t
p,t
c-use of d, and there is a deﬁnition clear path w.r.t. d from n1 to n2 .
p,t
p,t
p,t
p,t
• p-use association is deﬁned by a triple np,t
1 , (n2 , n3 ), d , such that n1 , d is a d-def or an i-def, (n2 ,
p,t
p,t
p,t
n3 ), d is p-use, and there is a deﬁnition clear path w.r.t d from n1 to n2 .
The c-use and p-use associations consider, respectively, the computational and predicative uses of data after
they have been deﬁned in a same thread.
p,t
p,t
• m-use association is deﬁned by a triple np,t
1 , n2 , d , such that n1 , d is a d-def or an i-def, n2 , d is m-use,
p,t
p,t
and there is a deﬁnition clear path w.r.t. d from n1 to n2 . The m-use association considers the use of data
sent in a message after they have been deﬁned in the same thread.

These associations are in a unique thread, considering intra-thread paths. When using message passing communication, the cases in which the deﬁnition and use occur in diﬀerent threads must be considered potentially
belonging to distinct processes. Taking into account that message passing can occur between threads in diﬀerent
processes or in threads of a same process, we have deﬁned the following associations related to message passing
communication:
p,tk
p,tl
p,tl
p,tk
p,tk
k
• intra-m-c-use association is deﬁned by a tuple np,t
1 , (n2 , n3 ), n4 , d1 , d2 such that n1 , n2 , d1 is a
p,tk
p,tl
p
p,tl
p,tl
m-use association, (n2 , n3 ) ∈ Esync and n3 , n4 , d2 is a c-use association.
p,tk
p,tl
p,tl
p,tl
p,tk
p,tk
k
• intra-m-p-use association is deﬁned by a tuple np,t
1 , (n2 , n3 ), (n4 , n5 ), d1 , d2 such that n1 , n2 , d1
p,tl
p
p,tl
p,tl
p,tl
k
is an m-use association, (np,t
2 , n3 ) ∈ Esync and n3 , (n4 , n5 ), d2 is a p-use association.

The intra-m-c-use and intra-m-p-use associations consider the m-use of data before they have been sent by
a message and then the respective c-use and p-use of the same data, after they have been received by the target
thread in a same process.
p ,t

p ,t

• inter-m-c-use association is deﬁned by a tuple np1i ,tk , (np2i ,tk , n3j l ), n4j l , d1 , d2 such that np1i ,tk , np2i ,tk , d1 is
p ,t
p ,t
p ,t
an m-use association, (np2i ,tk , n3j l ) ∈ Esync and n3j l , n4j l , d2 is a c-use association.
p ,t
p ,t
p ,t
pi ,tk
• inter-m-p-use association is deﬁned by a tuple n1 , (np2i ,tk , n3j l ), (n4j l , n5j l ), d1 , d2 such that np1i ,tk , np2i ,tk ,
p
,t
p
,t
p
,t
p
,t
d1 is an m-use association, (np2i ,tk , n3j l ) ∈ Esync and n3j l , (n4j l , n5j l ), d2 is a p-use association.

153

154

Paulo S.L. Souza et al. / Procedia Computer Science 18 (2013) 149 – 158

The inter-m-c-use and inter-m-p-use associations consider the m-use of data before they have been sent by
a message and then the respective c-use and p-use of the same data after they have been received by the target
thread, in a distinct process.
When communication occurs through shared data, the deﬁnition and use of data are not necessarily in the
same thread. As the communication depends on synchronizations at runtime between threads, it is not always
possible to statically determine the associated deﬁnition clear paths. Considering our previous work in [5], we can
solve this situation using a post-mortem approach, which employs timestamps to determine the order of events of
communication and establish deﬁnition-use pairs related to the shared data. Considering these resources, we can
deﬁne the following associations related to the shared memory paradigm:
p,t

p
p,ti
j
i
• s-c-use association is deﬁned by a triple np,t
1 , n2 , d , such that d ∈ DShared , n1 , d is a d-def or an i-def,
p,tj
n2 , d is a c-use and i j.
p,tj
p,tj
p
p,ti
i
• s-p-use association is deﬁned by a triple np,t
1 , (n2 , n3 ), d , such that d ∈ DShared , n1 , d is a d-def or
p,t
p,t
i-def, (n2 j , n3 j ), d is a p-use and i j.

The s-c-use and s-p-use associations consider the c-use and p-use, respectively, w.r.t. shared data after an
implicit communication between two distinct threads of a same process.
Additional associations have been deﬁned for non-blocking sends and non-blocking receives, because these
primitives may lead to unsafe data operations [9]. An example of such operations would be a non-blocking receive
statement followed by a c-use without correctly checking whether the data have been received in fact. In this case,
the data could be outdated or not available yet.
Non-blocking message passing communication primitives present diﬀerent semantics according to the standard or language used. An important diﬀerence is observed when the beginning and the ending of the communication operation is disassociated from the beginning and the ending of the primitive in the source code. The
MPI standard, for example, considers that the MPI Irecv (a non-blocking receiver) only starts the non-blocking communication operation, which can be completed after the primitive has returned. In order to verify if the
communication in the background has been ﬁnalized, an MPI Test or MPI Wait primitive must be executed. The
MPI Test is a non-blocking checker and can return with or without the message, whereas the MPI Wait is blocking
and returns only when the message has arrived and is available. In this case, either the MPI Wait or the MPI Test
will receive the message, whereas MPI Irecv will only start the communication. Other languages or standards may
consider that a non-blocking communication operation ﬁnishes together with the primitive. If the message from a
non-blocking receive is not available until the primitive returns, then the communication operation is ﬁnished and
another call to this receive must be executed if required. In this case such a non-blocking primitive will receive
the message, when it is available. Our test model supports these two semantics of non-blocking message passing.
We have deﬁned two subsets for nodes containing these primitives, namely Nwait nb ⊆ N for nodes that contain
a wait for a non-blocking primitive and Ntest nb ⊆ N for nodes that contain a non-blocking test for a non-blocking
primitive. By considering the non-blocking operations, the following associations can be deﬁned:
p,t
p,t
p,t
• ns-use association is given by a tuple np,t
1 , n2 , d, S , such that n1 is a non-blocking sender node, n2 , d
is either a (d-def or i-def ) or a (c, p, m, s-c or s-p)-use and S is a set of all deﬁnition clear paths w.r.t. d
p,t
from np,t
1 to n2 . This association considers the deﬁnition or uses of data after they have been used by a
non-blocking send [9].
p,t
p,t
• nr-use association is given by a tuple np,t
1 , n2 , d, S , such that node n1 is a non-blocking receiver node,
p,t
p,t
n2 , d is a (c, p, m, s-c or s-p)-use, and S is a set of all deﬁnition clear paths w.r.t. d from np,t
1 to n2 . This
association considers all possible uses of data after they have been deﬁned by a non-blocking receive [9].

5. Structural testing criteria
Finally, we have introduced some structural testing criteria for concurrent programs:
• all-uses criterion: test sets must execute paths that cover all c-use, p-use, m-use , s-c-use and s-p-use
associations.

Paulo S.L. Souza et al. / Procedia Computer Science 18 (2013) 149 – 158
/ ∗ ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ ∗ /
/ ∗ FS program − c l i e n t p r o c e s s
∗/
/∗
main t h r e a d c o d e ∗ /
/∗ process 0 , thread 0
∗/
/ ∗ ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ ∗ /
/ ∗ 00 ∗ / i n t n u m b e r O f P r o d u c t s= I n t e g e r . p a r s e I n t ( a r g s [ 0 ] ) ;
/ ∗ 00 ∗ / S o c k e t s=new S o c k e t ( ” l o c a l h o s t ” , 4 0 0 0 ) ;
/ ∗ 01 ∗ / P r i n t W r i t e r o u t =new P r i n t W r i t e r
( s . getOutputStream ( ) , true ) ;
/ ∗ 01 ∗ / B u f f e r e d R e a d e r i n =new B u f f e r e d R e a d e r
( new I n p u t S t r e a m R e a d e r ( s . g e t I n p u t S t r e a m ( ) ) ) ;
/ ∗ 02 ∗ / o u t . p r i n t l n ( n u m b e r O f P r o d u c t s ) ;
/ ∗ 03 ∗ / S t r i n g p r o d u c e d = i n . r e a d L i n e ( ) ;
/ ∗ 04 ∗ / System . o u t . p r i n t l n ( p r o d u c e d ) ;
/ ∗ 04 ∗ / s . c l o s e ( ) ;

Fig. 1. Main thread of the client process for the FS program.

/ ∗ ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ ∗ /
/ ∗ FS program − f a c t o r y p r o c e s s
∗/
/∗
worker t h r e a d code ∗ /
/∗ process 1 , thread 1
∗/
/ ∗ ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ ∗ /
/ ∗ 00 ∗ / / ∗ v i r t u a l r e c e i v e f r o m T h r e a d . s t a r t ( ) ∗ /
/ ∗ 01 ∗ / s t a r t . a w a i t ( ) ;
/ ∗ 02 ∗ / b o o l e a n f i n i s h e d = f a l s e ;
/ ∗ 03 ∗ / w h i l e ( ! f i n i s h e d ) {
/ ∗ 04 ,05 ∗ / i f ( ! m a t e r i a l . isEmpty ( ) ) {
/ ∗ d e f . and u s a g e o f m a t e r i a l ∗ /
/ ∗ 06 ∗ /
m a t e r i a l . decrement ( 5 0 ) ;
/ ∗ 07 ∗ /
pLock . l o c k ( ) ;
/ ∗ 08 ∗ /
products . increment (50);
/ ∗ 09 ∗ /
pLock . u n l o c k ( ) ;
} else {
/ ∗ 10 ∗ /
f i n i s h e d =true ;
}
/ ∗ 11 ∗ / }
/ ∗ 12 ,13 ∗ / / ∗ v i r t u a l send t o Thread . j o i n ( ) ∗ /

Fig. 2. Worker thread of the factory process for the FS program.

/ ∗ ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ ∗ /
/ ∗ FS program − f a c t o r y p r o c e s s
∗/
/∗
main t h r e a d c o d e ∗ /
/∗ process 1 , thread 0
∗/
/ ∗ ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗ ∗ /
/ ∗ 00 ∗ / S o c k e t s ; P r i n t W r i t e r o u t ;
/ ∗ 00 ∗ / B u f f e r e d R e a d e r i n ; i n t amount ;
/ ∗ 00 ∗ / R e e n t r a n t L o c k pLock=new R e e n t r a n t L o c k ( ) ;
/ ∗ 00 ∗ / C y c l i c B a r r i e r s t a r t =new C y c l i c B a r r i e r ( 2 ) ;
/ ∗ 00 ∗ / S e r v e r S o c k e t s s =new S e r v e r S o c k e t ( 4 0 0 0 ) ;
/ ∗ 01 ∗ / w h i l e ( t r u e ) {
/ ∗ 02 ∗ /
s= s s . a c c e p t ( ) ;
/ ∗ 03 ∗ /
i n =new B u f f e r e d R e a d e r ( new I n p u t S t r e a m R e a d e r
( s . getInputStream ) ) ) ;
/ ∗ 04 ∗ /
o u t =new P r i n t W r i t e r
( s . getOutputStream ( ) , true ) ;
/ ∗ 04 ∗ /
S t o r a g e m a t F a c t o r y , matWorker ;
/ ∗ 04 ∗ /
S t o r a g e p r o d u c t s =new S t o r a g e ( 0 ) ;
/ ∗ 04 ∗ /
Worker w o r k e r=new Worker ( ) ;
/ ∗ 05 ∗ /
amount= I n t e g e r . p a r s e I n t ( i n . r e a d L i n e ( ) ) ;
/ ∗ 06 ∗ /
i f ( amount < 5 0 0 ) {
/ ∗ 07 ∗ /
m a t F a c t o r y =new S t o r a g e ( amount ) ;
/ ∗ 07 ∗ /
matWorker=m a t F a c t o y ;
} else {
/ ∗ 08 ∗ /
m a t F a c t o r y =new S t o r a g e ( amount /2+ amount %2);
/ ∗ 08 ∗ /
matWorker=new S t o r a g e ( amount / 2 ) ;
}
/ ∗ 09 ∗ /
w o r k e r . s e t M a t e r i a l ( matWorker ) ;
/ ∗ 09 ∗ /
w o r k e r . s e t P r o d u c t ( p r o d u c t s , pLock ) ;
/ ∗ 09 ∗ /
worker . s e t S t a r t F l a g ( s t a r t ) ;
/ ∗ 09 ∗ /
S t o r a g e myMaterial=matFactory ;
/ ∗ 10 ∗ /
worker . s t a r t ( ) ;
/ ∗ 11 ∗ /
s t a r t . await ( ) ;
/ ∗ 12 ∗ /
boolean f i n i s h e d = f a l s e ;
/ ∗ 13 ∗ /
while ( ! f i n i s h e d ) {
/ ∗ 14 ∗ /
i f ( ! myMaterial . isEmpty ( ) ) {
/ ∗ 15 ∗ /
myMaterial . decrement ( 1 ) ;
/ ∗ 16 ∗ /
pLock . l o c k ( ) ;
/ ∗ 17 ∗ /
products . increment ( 1 ) ;
/ ∗ 18 ∗ /
pLock . u n l o c k ( ) ;
} else {
/ ∗ 19 ,20 ∗ /
f i n i s h e d =true ;
}
/ ∗ 21 ,22 ∗ / }
/ ∗ 23 ∗ /
worker . j o i n ( ) ;
/ ∗ 24 ∗ /
out . p r i n t l n ( products . getQuantity ( ) ) ;
/ ∗ 25 ∗ /
s . close ( ) ;
/ ∗ 26 ∗ / }

Fig. 3. Main thread of the factory process for the FS program.

• all-shared-uses criterion: test sets must execute paths that cover all s-c-use and s-p-use associations. This
criterion aims to reveal faults in the communication with the shared memory paradigm.
• all-intra-message-uses criterion: test sets must execute paths that cover all intra-m-c-use and intra-m-p-use
associations. This criterion aims to reveal faults in the communication of diﬀerent threads of a same process
with the message passing paradigm.
• all-inter-message-uses criterion: test sets must execute paths that cover all inter-m-c-use and inter-m-p-use
associations. This criterion aims to reveal faults in the communication of diﬀerent threads belonging to
distinct processes with the message passing paradigm.
p,t
• all-nodes-nt: test sets must execute paths that cover every node np,t
i ∈ Nwait nb and ni ∈ Ntest nb at least
twice: the ﬁrst execution must assume that the message has reached the process after the execution of node
np,t
i ; the second execution must assume that the message has reached the process before the execution of
node np,t
i . Controlled execution mechanisms are employed to assure these two executions [9].
• all-ns-uses criterion: test sets must execute paths that cover all ns-use associations.
• all-nr-uses criterion: tests set must execute paths that cover all nr-use associations.
6. Case study
This section illustrates how to collect data-ﬂow information from a distributed application in order to ﬁll in the
main sets of our new test models. Our case study considers a Java concurrent program, called FactorySim (FS),
which uses both message passing and shared memory paradigms to simulate the manufacturing of a ﬁnite amount
of items requested by a client (Figures 1, 2 and 3).
FS is composed of two processes: a Client and a Factory. Factory is composed of two threads responsible for
the production of the requested items whereas Client has only one thread. Client sends a message with the amount

155

156

Paulo S.L. Souza et al. / Procedia Computer Science 18 (2013) 149 – 158

of requested items to the main thread of Factory. Then, Client waits to receive a reply from Factory containing
the total of produced items. PCFG is shown in Figure 4, where the commands associated with each node n are
referenced by comments / ∗ n ∗ / in the source-code of Figures 1, 2 and 3. The communication described above is
1,0
1,0 0,0
represented in PCFG by the following synchronization edges: (n0,0
2 , n5 ) and (n24 , n3 ). The test model represents
the establishment of connections by virtual primitives. For instance, the socket creation primitive on the node n0,0
0
is identiﬁed by a virtual send; the primitive accepting the connection on the node n1,0
is
identiﬁed
by
a
virtual
2
1,0
1,0 1,1
receive. The pair (n0,0
0 , n2 ) makes a sync edge (4). The same happens with the thread creation (n10 , n0 ) and
1,0
ﬁnalization (n1,1
13 , n23 ) primitives.
The main thread of Factory receives the amount of items and then decides which strategy to use in relation
to the raw-material repository (Storage object). There are two possibilities to access the raw-material repository
(n1,0
to n1,0
8 ): if amount of items < 500, then a unique raw-material repository is shared by the threads of factory;
6
otherwise, two distinct raw-material repositories are created, one for each thread, and the amount of raw-material
is divided into them.

Fig. 4. PCFG of the FS program. Some source-code nodes are not showed because they represent sequential ﬂows that are not relevant to the
criteria.

The second thread of Factory is created in n1,0
10 by the worker.start() primitive and labeled as worker in PCFG.
1,1
The start.await() primitive runs a barrier to synchronize the two threads of Factory (n1,0
11 and n1 ). After crossing
the barrier, both threads start their production independently and concurring for the shared data.
An amount of raw material is removed from its repository and an equal amount of produced items is inserted
into the repository of manufactured items. This iterative activity is repeated while there is raw material to be
consumed. Accesses to the repository of manufactured items (a critical region) are properly protected from the
race-conditions by locks primitives; however, the accesses to the raw-material repository are not protected. This

Paulo S.L. Souza et al. / Procedia Computer Science 18 (2013) 149 – 158

intentional defect is used to illustrate the ability of our testing criteria to reveal defects.
This program is small, but it is able to demonstrate a common situation of data sharing, which is diﬃcult to be
statically analyzed by structural testing tools. The raw-material repository is referenced by four diﬀerent pointers.
The Factory main thread references to this repository as matFactory and after as myMaterial. The worker thread
references this raw-material repository as matWorker and then as material. Besides this situation in which distinct
identiﬁers can access the same data in the memory, observe that such data may be shared or not by threads. If they
are shared, all identiﬁers will point to the same set of addresses in the memory. This speciﬁc situation can not
be statically obtained, therefore a conservative approach is adopted using the support of the d-def and i-def sets
described in the previous section.
Table 1 shows the sets generated from our test model, with information about the data ﬂow and synchronization
1,0
edges. From these sets, it is possible to derive associations, such as the s-c-use association n1,0
7 , n15 , d14 , where
d14 is the label to the raw-material repository referenced by both matFactory and matWorker in the Factory process
1,0
0,0
0,0
and the inter-m-c-use association n1,0
17 , (n24 , n3 ), n4 , d11, d5 , where the amount of manufactured products is
sent from Factory to Client by a message (d11 is the data referenced by products in Factory and d5 is the data
referenced by produced in Client).
Table 1. Main sets with synchronization and data ﬂows of the test model for the FS Application.
Sets
d-defs:

i-defs:
c-uses:
p-uses:
m-uses:
s-c-uses:
s-p-uses:
1
Esync
:
Esync :

Values
0,0
1,0
1,0
1,0
0,0
0,0
0,0
0,0
0,0
0,0
0,0
0,0
{ n0,0
0 , d0 , n0 , d1 , n0 , d2 , n1 , d0 , n1 , d3 , n1 , d4 , n2 , d3 , n3 , d4 , n3 , d5 , n4 , d0 , n0 , d6 , n0 , d8 , n2 , d8 ,
1,0
1,0
1,0
1,0
1,0
1,0
1,0
1,0
1,0
1,0
1,0
1,0
1,0
n2 , d9 , n3 d9 , n3 , d10 , n4 , d9 , n4 , d11 , n4 , d12 , n4 , d13 , n5 , d10 , n5 , d7 , n7 , d14 , n8 , d15 , n8 , d16 , n9 , d12 ,
1,0
1,0
1,0
1,0
1,0
1,0
1,1
1,1
1,1
n1,0
10 , d12 , n12 , d17 , n17 , d11 , n20 , d17 , n23 , d12 , n24 , d13 , n25 , d9 , n2 , d18 , n8 , d11 , n10 , d18 }
1,0
1,1
1,1
{ n1,0
,
d14
,
n
,
d15
,
n
,
d14
,
n
,
d16
}
15
15
6
6
0,0
0,0
0,0
0,0
1,0
1,0
1,0
1,0
1,0
1,0
1,0
1,0
{ n0,0
0 , d1 , n1 , d0 , n2 , d3 , n3 , d4 , n4 , d5 , n2 , d8 , n3 , d9 , n4 , d9 , n5 , d10 , n7 , d7 , n8 , d7 , n10 , d12 , n15 , d14 ,
1,0
1,0
1,0
1,0
1,1
1,1
1,1
n15 , d15 , n17 , d11 , n23 , d12 , n23 , d13 , n1,0
25 , d9 , n6 , d14 , n6 , d16 , n8 , d11 }
1,0 1,0
1,0 1,0
1,0 1,0
1,0 1,0
1,0 1,0
1,0 1,0
1,0 1,0
{ (n1,0
, n1,0
7 ), d7 , (n6 , n8 ), d7 , (n13 , n14 ), d17 , (n14 , n15 ), d14 , (n14 , n15 ), d15 , (n14 , n19 ), d14 , (n14 , n19 ), d15 , (n13 , n22 ), d17 ,
6
1,1
1,1 1,1
1,1 1,1
1,1 1,1
1,1 1,1
1,1 1,1
,
n
),
d18
,
(n
,
n
),
d14
,
(n
,
n
),
d16
,
(n
,
n
),
d14
,
(n
,
n
),
d16
,
(n
,
n
),
d18
}
(n1,1
3
4
5
5
5
10
5
10
3
12
6
6
1,0
{ n0,0
2 , d2 , n24 , d11 }
1,0
1,0
1,1
1,1
1,1
{ n15 , d14 , n17 , d11 , n6 , d14 , n6 , d16 , n8 , d11 }
1,0
1,0 1,0
1,1 1,1
1,1 1,1
1,1 1,1
1,1 1,1
{ (n1,0
14 , n15 ), d14 , (n14 , n19 ), d14 , (n5 , n6 ), d14 , (n5 , n6 ), d16 , (n5 , n10 ), d14 , (n5 , n10 ), d16 }
1,0
1,0 1,1
1,0 1,0
1,0 1,1
1,1 1,0
1,1 1,1
1,0 1,1
1,0 1,0
1,0 1,1
1,1 1,0
1,1 1,1
1,1 1,0
(n1,0
,
n
),
(n
,
n
),
(n
,
n
),
(n
,
n
),
(n
,
n
),
(n
,
n
),
(n
,
n
),
(n
,
n
),
(n
0
0
7
18
18
7
9
9
7
10
0
11
11
11 , n1 ), (n1 , n11 ), (n1 , n1 ), (n13 , n23 )
16
16
16
1,0
0,0 1,0
1,0 0,0
(n0,0
0 , n2 ), (n2 , n5 ), (n24 , n3 )

The required elements are generated based on the information in Table 1. For instance, the quantity of required
elements for some criteria are: 63 (all-uses), 15 (all-shared-uses) and 7 (all-inter-message-uses). The program
is executed and the traversed paths are collected so that the coverage of each required element can be evaluated.
Similarly to what occurs in sequential programs, some required elements are infeasible and must be analyzed and
determined by the tester.
The access to the raw-material repository by both threads was not made synchronously (Figure 2, node n1,0
15
and Figure 3, node n1,1
6 ), in order to verify the eﬀectiveness to reveal faults related to synchronization and communication. Consequently, if the raw-material repository is shared between the two threads of Factory, there will be
a race condition to the data, which may lead to inconsistencies. In a test model in data ﬂow that does not consider
the use of distinct references inﬂuencing the deﬁnition and use of data, the data sharing across multiple references
is ignored and can omit failures.
In the FS program, some data referenced by the matFactory label is assigned to myMaterial at node n1,0
9 .
1,0
1,0
Once the previous data ﬂow with relation to matFactory and matWorker in nodes n7 and n8 may result in
data sharing between the threads, deﬁnitions in data referenced by them may lead to data consistence faults. In
Figure 2, the data referenced by the matFactory label are assigned to myMaterial at node n1,0
9 . In other words, in
a test case in which the number of products is greater than or equal to 500, threads do not share the raw-material
repository, therefore there occurs no fault. If the number of products is smaller than 500, both threads share the
same repository, which may lead to problems of data consistency. However, the fault can remain hidden due to
non-determinism.
This fault can be identiﬁed by the all-shared-use and all-uses criteria, which contain the s-c-use associations.
1,1
These criteria require the coverage of the associations, like n1,0
15 , n6 , d14 (d14 is the label for the raw-material
repository), which reveals the fault when there is a test case with a number of requested products smaller than

157

158

Paulo S.L. Souza et al. / Procedia Computer Science 18 (2013) 149 – 158

500. This fault is associated with implicit memory sharing between the threads caused by multiple references to
the same data.
The data ﬂow analysis that considers the relationship between the references and the data allows identifying
the sharing of data by threads, even using distinct references. Therefore associations between deﬁnitions and uses
not considered in previous test models can be covered.
7. Concluding remarks
The main contribution of this paper is related to V&V of distributed/parallel applications that communicate
and synchronize using both shared memory and message passing paradigms. The main focus is on the data
ﬂow that exists among threads of diﬀerent processes. We have related the aspects of control ﬂow and, mainly,
synchronization to this data ﬂow. Diﬀerently from other works, we have considered the sharing of memory data
by distinct threads using distinct references to these same memory data.
In order to oﬀer support to this V&V activity, a novel structural test model has been proposed to capture
information about data, control, communication and synchronization from distributed applications. The test model
considers communication and synchronization faults among threads and also faults related to sequential aspects
of each thread. The information captured by the test model is used for new testing criteria, contributing towards
the testing activity quality and focusing on the coverage of the required elements of each criterion.
Without loss of generality, the proposed model and criteria were analyzed in an object-oriented and distributed
application developed in Java. Our test model is not solely bounded to Java or OO programming, therefore it can
be used in other contexts, as C/MPI with PThreads. It is comprehensive and ﬂexible because it is primarily based
on the concepts related to the communication and synchronization of processes, which are orthogonal to most
concurrent languages.
The evolution of our research in this area is directed towards reaching the following objectives: 1) development
of a distributed supporting tool for the testing criteria (already started); (2) evaluation of the testing criteria with
distinct distributed applications, considering the support of a testing tool and a wider and deeper view and 3)
reduction of the test activity cost by improving the quality of the required elements generated for the criteria.
Acknowledgements
The authors would like to acknowledge the Brazilian funding agencies CAPES and FAPESP, for the ﬁnancial
support provided to this research (processes: 2011/19051-9, 2012/01901-9 and 2012/14285-4).
References
[1] S. Rapps, E. Weyuker, Selecting software test data using data ﬂow information, IEEE Transactions on Software Engineering 11 (1985)
367–375. doi:http://doi.ieeecomputersociety.org/10.1109/TSE.1985.232226.
[2] R. N. Taylor, D. L. Levine, C. Kelly, Structural testing of concurrent programs, IEEE Transaction on Software Engineering 18 (3) (1992)
206–215.
[3] C.-S. D. Yang, L. L. Pollock, All-uses testing of shared memory parallel programs, Software Testing, Veriﬁcation and Reliability (STVR)
13 (1) (2003) 3–24.
[4] O. Edelstein, E. Farchi, E. Goldin, Y. Nir, G. Ratsaby, S. Ur, Framework for testing multi-threaded java programs, Concurrency and
Computation: Practice and Experience 15 (3-5) (2003) 485–499.
[5] F. S. Sarmanho, P. S. L. Souza, S. R. S. Souza, A. S. Sim˜ao, Structural testing for semaphore-based multithread programs, Computational
Science-ICCS 2008 (1) (2008) 337–346.
[6] S. R. S. Souza, S. R. Vergilio, P. S. L. Souza, A. S. Sim˜ao, A. C. Hausen, Structural testing criteria for message-passing parallel programs,
Concurrency and Computation: Practice and Experience 20 (16) (2008) 1893–1916. doi:10.1002/cpe.1297.
[7] S. Hong, J. Ahn, S. Park, M. Kim, M. J. Harrold, Testing concurrent programs to achieve high synchronization coverage, in: Proceedings
of the 2012 International Symposium on Software Testing and Analysis, ISSTA 2012, ACM, 2012, pp. 210–220.
[8] H. Krawczyk, B. Wiszniewski, Classiﬁcation of software defects in parallel programs, Tech. Rep. 2, Faculty of Electronics, Technical
University of Gdansk, Poland (1994).
[9] P. S. L. Souza, S. R. S. Souza, E. Zaluska, Structural Testing for Message-Passing Concurrent Programs: an Extended Test Model,
Concurrency and Computation: Practice and Experience(in press).
[10] A. Orso, S. Sinha, M. J. Harrold, Eﬀects of pointers on data dependences, in: Proceedings 9th International Workshop on Program
Comprehension. IWPC 2001, IEEE Comput. Soc, 2001, pp. 39–49. doi:10.1109/WPC.2001.921712.

