Procedia Computer
Science
Procedia
Computer Science 1 (2012) 2599–2608
Procedia Computer Science 00 (2010) 1–10

www.elsevier.com/locate/procedia

International Conference on Computational Science, ICCS 2010

A tool for eﬃcient execution of SPMD applications on multicore
clusters.
Ronal Muresano1 , Dolores Rexachs1 , Emilio Luque1
Universitat Autonoma de Barcelona
Computer Architecture and Operating System Department, Barcelona, SPAIN, C.P 08293

Abstract
A challenge for parallel programmers is to eﬃciently execute traditional MPI applications, designed to be run
in a cluster of single core nodes, on a multicore cluster. Multicore clusters include communication heterogeneities
which have to be handled carefully to improve eﬃciency and speedup. This research presents an execution tool
developed for SPMD applications which is focused on managing communications heterogeneities, distributing the
workload among cores and enhancing parallel performance on multicore clusters. Our tool has been designed through
using an execution methodology which includes mapping and scheduling strategies. The tool integrates ﬁve modules
which give programmers a method to execute their applications eﬃciently. This tool is centered on improving SPMD
applications designed to use MPI for communications. These applications were selected because they are the most
commonly used in parallel computing. Also, these applications are chosen due to their data synchronization and
communications volumes which can generate communication imbalance issues. The novel contribution of this tool
is to permit programmers to ﬁnd a minimum execution time, while the eﬃciency level is maintained over a deﬁned
threshold. Our tool has been tested in diﬀerent multicore clusters and with a set of scientiﬁc applications. The results
obtained show a considerable improvement in the applications eﬃciency when the tool is applied.

c 2012 Published by Elsevier Ltd. Open access under CC BY-NC-ND license.
⃝

Keywords: Multicore cluster, eﬃcient execution, methodology, performance, SPMD applications.

1. Introduction
The constant evolution of the parallel computing ﬁeld has permitted scientiﬁc applications to be designed with
more complexity and precision. However, these applications need to be executed with high computational power in
order to obtain an improvement in parallel performances. The current trend in high performance computing (HPC)
is to use clusters composed of multicore nodes, and these nodes include heterogeneity levels which have to be handled with case to of improving parallel execution. These computational and communication heterogeneities generate
challenges that parallel programmers have to be prepared to cope with when they wish to enhance the application’s
performance. Also, the programmers have to deal with some issues that multicore architecture can present when
Email addresses: rmuresano@caos.uab.es (Ronal Muresano), dolores.rexachs@uab.es (Dolores Rexachs), emilio.luque@uab.es
(Emilio Luque)
1 Corresponding authors. Tel.: +34-935-81-24-78

c 2012 Published by Elsevier Ltd. Open access under CC BY-NC-ND license.
1877-0509 ⃝
doi:10.1016/j.procs.2010.04.293

2600

R. Muresano et al. / Procedia Computer Science 1 (2012) 2599–2608
R. Muresano et al. / Procedia Computer Science 00 (2010) 1–10

2

Figure 1: Communication of SPMD task on multicore environments

applications are executed. Problems such as: number of cores per chip, data locality, bus interconnection, memory
bandwidth, etc., are becoming more important in order to obtain an eﬃcient execution.
An obstacle that parallel computing is trying to overcome is related to the need to enhance performance in heterogeneous environments, such as multicore clusters. Hence, performance such as: execution time, speedup and efﬁciency are inﬂuenced in a diﬀerent ways when parallel applications are executed in these environments. Because of
these inﬂuences, programmers have to apply strategies with the aim of managing the communication heterogeneities
on these clusters with the goal of improving the parallel execution.
These clusters also include diﬀerent communications speeds and bandwidths [1] and the communication processes
may cause performance issues due to the communication imbalances generated by the diﬀerent communication paths
(Intercore, Interchip and Internode communications) [2][3]. For example, the communication among processes can
be realized through network links using local area networks (Internode), or communications may be established by
internal processor buses (Intercore or Interchip). For this reason, the heterogeneous communications integrated in
these clusters should be handled carefully if we wish to improve eﬃciency and speedup.
Another issue that parallel programmers have to consider is that many traditional MPI (Message Passing Interface)
parallel applications were designed to be executed in clusters comprised of single core nodes, in which communication
within the node is not present. However, when these applications are executed on multicore clusters, the processes
have to exchange their information with other processes that are located in the same node or in diﬀerent nodes.
Also, these MPI applications are designed under a parallel programming paradigm which has a diﬀerent behavior and
communication pattern. Master/worker, SPMD (Single Program Multiple Data), pipeline, divide and conquer, etc. are
examples of parallel paradigms which have a speciﬁc behavior that programmers have to manage in order to enhance
performance.
Despite of these communications issues and the behavior of MPI applications on multicore clusters, we can take
advantage of the computational power which these clusters oﬀer with the objective of running applications faster and
more eﬃciently [4]. Our work considers parallel applications which use MPI libraries for communication and SPMD
as a parallel paradigm. The SPMD paradigm was selected due to its behavior which is to execute the same program in
all processes but with diﬀerent sets of data. Also, the applications selected have to have three characteristics: static,
where the communication process is maintained during all the execution, local, in which applications do not have
collective communications and regular, because communications are repeated for several iterations. Additionally, the
SPMD applications used to test our methodology were 2D grid problems. An example of the problem concerning
of these applications and multicore clusters is shown in ﬁgure 1. This ﬁgure illustrates how a task can be assigned
to each core and what are the inﬂuences in the communications processes. The communication processes have to
wait until the slowest communications link ﬁnishes receiving its information. This problem is presented due to the
heterogeneities between diﬀerent communication paths.
From the problem deﬁned above, we have developed a novel methodology which is composed of four phases:
characterization, a tasks distribution model, mapping, and scheduling [5]. This methodology is centered on ﬁnding the
minimum execution time while the eﬃciency is maintained over a threshold. The main function of this methodology

R. Muresano et al. / Procedia Computer Science 1 (2012) 2599–2608
R. Muresano et al. / Procedia Computer Science 00 (2010) 1–10

2601
3

is to manage the communication imbalances generated by the latencies of the communication links. The methodology
was designed for SPMD applications which allows us to set up a greater number of tasks than cores present on the
multicore clusters. From this methodology, we have designed an eﬃcient execution tool which is composed of ﬁve
main modules, These ﬁve modules allow us to integrate a set of steps in order to execute the SPMD application
eﬃciently. (Figure 2).
The main contribution of this research is to allow the programmers through our tool to execute their applications
on multicore clusters in the minimum execution time while eﬃciency is maintained over a threshold deﬁned by users.
Our tool permits programmers to hide the ineﬃciencies generated by communication links and give a solution for the
workload imbalances factors. Also, it determines the approximate number of cores necessary to achieve a suitable
eﬃcient solution which allows us to obtain the minimum parallel execution time.
The ﬁve modules are divided as follow: characterization, task distribution model, mapping strategy, scheduling
policy and performance evaluation (Figure 2). The characterization module allows us to obtain a description of the
diﬀerent communication links and also gives the computational values in a speciﬁc architecture. This process permits
us to obtain the values necessary to calculate next task distribution module. From this characterization the task distribution module calculates the number of tasks which should be assigned to each core with the aim of overlapping the
internal computation and the edge communication tasks. The tasks in this module are divided in two groups: internal
tasks which communicate with other tasks in the same core and edge tasks, where communications are performed
with tasks allocate in other core.
Once the set of tasks have been calculated, we execute the mapping module which enables us to assign the set of
tasks to each core through core aﬃnity in order to minimize the communications eﬀects. The next step is to execute
the scheduling module which enables us to overlap the internal computation and edge communication tasks. Also,
This process allows us to hide the communication eﬀects and increases the system eﬃciency. Finally, the performance
evaluation module evaluates the performance results in which speedup and eﬃciency are evaluated with the aim of
determining if the methodology has been applied correctly.
This paper is structured as follows: related works are detailed in section 2, a brief description of the methodology
is presented in section 3. The tool description can be found in section 4, section 5 describes experimental evaluation,
and ﬁnally, conclusions are given in section 6.
2. Related Works
There are a number of works focused on developing strategies to improve parallel performance in heterogeneous
environments. Liebrock [6] developed a method that allows programmers to execute applications in hybrid parallel
applications. The main goal of this work was oriented toward improving three speciﬁc performance: adaptability,
scalability and ﬁdelity. This research achieved its objective through mapping, scheduling and synchronization overhead strategies designed for applications with a hybrid architecture using message passing and distribute memory.
However, our research allows us to develop a methodology based on improving speedup and eﬃciency using mapping
and scheduling strategies. Our methodology lets programmers to develop strategies in order to adapt MPI-applications
to multicore environments.
A diﬀerent method to improve performance has been developed by Vikram [7]. This work developed a methodology to map data-parallel tasks onto reconﬁgurable hardware. The main objective was to ﬁnd the maximum speedup
possible for a given conﬁguration. This work used load balancing and scheduling strategies to obtain the minimum
execution time. On the contrary, our approach achieves the maximum speedup, but we also evaluate the application
eﬃciency through our methodology.
Designing an eﬃcient methodology for communication heterogeneous environments is a challenge and this has
been demonstrated by Bearmount et al [8]. This work was oriented towards ﬁnding the best allocation of processes
in communication heterogeneous environments. It centered on designing a minimization of the communication overhead and determined that obtaining eﬃcient strategies for data allocations is a diﬃcult or an NP completeness problem
when heterogeneous networks are used. Additionally, other works have studied the communications issues on heterogeneous environments [1][9]. These researches have proposed strategies to manage the issues presented on multicore
clusters. In this sense, our research allows us to manage the ineﬃciencies generated by communication links using
task distribution models in which a set of tasks are assigned to each core, and through a scheduling policy that enable

2602

R. Muresano et al. / Procedia Computer Science 1 (2012) 2599–2608
R. Muresano et al. / Procedia Computer Science 00 (2010) 1–10

4

Figure 2: Tool modules and methodology phases.

us to execute with an overlapping strategy with the objective of improving the application eﬃciency. These tasks are
divided into edge and internal tasks, and this division is realized through our tool which has been designed using the
methodology phases in order to ﬁnd an eﬃcient execution.
3. Methodology Description
As mentioned previously, our methodology is focused on managing the communications heterogeneities presented
on multicore clusters. This process is realized through four phases which allow us to handle the latencies and communication imbalances created due to the diﬀerent communication paths. The phases deﬁned in our methodology permit
us to accomplish our objective and also enable us to integrate these phases into ﬁve modules of a tool with the aim of
improving performance (Figure 2).
Latencies and imbalance factors also have to be handled with the objective of removing ineﬃciencies generated
by communication links. These latencies generate idle time for diﬀerent reasons such as: tasks communication
when processes are located in diﬀerent processor chips or nodes, communication message size, bottlenecks in the
communication paths, SPMD data synchronization, adaptation of an MPI application designed to be executed in single
core nodes for multicore nodes, etc [6]. The idle time generated decreases the performance, particularly eﬃciency and
speedup. Our methodology, through its phases, can solve the ineﬃciencies generated in these multicore environments
as is described in [5]. This methodology evaluates two possible distributions for SPMD applications: one (X) and two
(X, Y) dimensional blocks [8], which have inﬂuences when a communication heterogeneous environments is used.
3.1. Characterization phase
This phase is responsible for gathering the necessary parameters of SPMD applications and environments in order
to calculate the task distributionmodel. For example, the application allows us to determine how the SPMD application
would behave within multicore clusters. Next, the parallel environment data describes the behavior and allows us to
obtain the communication parameters of the SPMD application on multicore clusters. This characterization process is
run in a controlled and monitored manner, in order to extract the parameters according to our task distributionmodel
needs. This test enables us to determine the number of communication level that an SPMD application has to deal
with in a speciﬁc environment [5]. Also, this phase allows us to obtain the communication (commi ) and computational
(compi ) parameters of each task within the environment.
3.2. task distributionModel phase
Once the user deﬁnes the eﬃciency desired and the characterization phase is ﬁnished, we can calculate the task
distribution model which allows us to determine the number of necessary tasks in order to improve the eﬃciency in
SPMD applications. The results of the model enable us to determine the minimum values for X(i) and Y(i) which are
assigned to each core with the aim of maintaining the application eﬃciency. The X(i) and Y(i) values are the number of
tasks that have to be assigned in X or Y axes for each process, for example in 2D grid applications. Also, these values
permit us to determine the edge and internal computation time (T cpEdge(k)(i) , T cpInt(k)(i) ), where k determines the
iteration number, i deﬁnes the core number and Nbx(i) and Nby(i) represent the edge numbers of each core on the X or
Y axes of the application problem.

R. Muresano et al. / Procedia Computer Science 1 (2012) 2599–2608
R. Muresano et al. / Procedia Computer Science 00 (2010) 1–10

(a) task distributionmodel target.

2603
5

(b) Communications managing.

Figure 3: task distributionmodel and mapping strategy

T cpeEdge(k)(i) = [(X(i) xY(i) ) − [(X(i) − Nbx(i) )x(Y(i) − Nby(i) )]]x(comp(i) )

(1)

T cpInt(k)(i) = [(X(i) − Nbx(i) )x(Y(i) − Nby(i) )]x(comp(i) )

(2)

T cp(k)(i) = (T cpEdge(k)(i) + T cpInt(k)(i) )

(3)

To calculate the computation time, we have to determine the edge and internal computational time through equations 1 and 2 and then we can obtain the computational values through equation 3. These equations are calculated
with the X(i) and Y(i) values obtained according to the eﬃciency deﬁned by the programmer. Both values are achieved
through an optimization process which enables us to minimize the application execution time. To determine these
values, we add a constraint deﬁned in equation 4 which allows us to ﬁnd the values for X(i) and Y(i) through the overlap grade between internal computation and edge communication time (T cpInt(k)(i) , T comm(k)(i) .). An example of the
model is illustrated in ﬁgure 3(a), in which we can observe how the maximum ineﬃciency is allowed in the execution.
Hence, our goal is to achieve a values for X(i) and Y(i) that will be around these targets.
Moreover, ﬁgure 3(a) shows the three possible cases of our constraint in the execution of an SPMD and which of
them we are trying to achieve. For example, if the edge communication is longer than internal computation then the
eﬃciency is decreased, on the contrary if internal computation is longer than edge communication, then the speedup
could be improved. Hence, we search an ideal values for X(i) and Y(i) in order to obtain similar values for internal
computation and edge communication using the desired eﬃciency (Figure 3(a)). Then from these X(i) and Y(i) values,
we can obtain the maximum theoretical speedup using an desired eﬃciency.
((T comm(i) ) − (T cpInt(i) )) ≤ ((T cpInt(i) )x(1 − E f f ic))

(4)

Another factor to consider in the constraint is the communication (T comm(k)(i) ), which is obtained through the
characterization process. The communication values are compared using the message size, the bandwidth in the link,
the MPI latencies, and the link latencies. These values are summed in order to obtain the communication values.
Once the values of X(i) and Y(i) are determined with our model, we can calculated the approximate number of cores
necessary to maintain the eﬃciency. This process is realized through equation 5 in which we divide the number total
of tasks between the values obtained with our model.
n = X/X(i) , m = Y/Y(i)

cores = (n)x(m)

(5)

3.3. Mapping Phase
The objective of this phase is to allocate the set of tasks among the cores which are calculated with the model
deﬁned above with the objective of maintaining the desired eﬃciency. In this phase, we consider that MPI messages
may be communicated through diﬀerent communication paths when a multicore cluster is used, and this communication generates issues due to the link latencies. Diﬀerent communication links have a diverse bandwidths and the

2604

R. Muresano et al. / Procedia Computer Science 1 (2012) 2599–2608
R. Muresano et al. / Procedia Computer Science 00 (2010) 1–10

6

Figure 4: Sheduling Policy: Tasks execution assignment and overlapping strategy

programmers have to evaluate two diﬀerent problems. One of them is that SPMD applications have logical communication in which the information exchange of each task is according to the number of neighbors whit they have to
communicate [5]. The second issue is that all communication is not performed simultaneously through the same links
as the machine analyzed has only one network interface. These problems have to be managed using a communication
order system that allows communication to be performed via diﬀerent links simultaneously and this is included in the
tool.
In order to minimize the communication eﬀects, we have to allocate the tasks with a strategy in which the communication made through the slowest links have to be minimized (Figure 3(b)). This process is achieved when we
can balance the tasks into each core through our mapping strategy and task communication is managed with the objective of minimizing ineﬃciencies. The mapping process is realized through an aﬃnity of the core which allows us
to allocate the tasks inside the correct core. This aﬃnity enables us to minimize the number of communications in the
slowest links.
3.4. Scheduling Phase
The function of this phase is to coordinate the execution order of tasks within the core. This process is realized in
two parts, the ﬁrst is to generate the task execution priorities assignment for each task in which the highest priorities
are established for tasks which have communications through slowest links. The priorities are assigned as follow:
tasks with two external communications have the highest priority which is identiﬁed with 1. Then, tasks with one
external communication are given the priority 2. Finally, the priority 3 is determined for internal tasks as these tasks
will be overlapped with the edge communications (Figure 4).
The second process is to apply the overlapping techniques in which the internal tasks and edge communication
are overlapped. This process allows us to manage the ineﬃciencies generated by communication links, because the
communication is hidden and their eﬀects do not aﬀect the application execution [5]. The last part is to evaluate
the eﬀectiveness of the task distributionmodel. We analyze the execution time, speedup and eﬃciency parameters
obtained during the execution and we compare the results with the initial values deﬁned in characterization phase.
4. Execution tool description
The main target of our tool is to ﬁnd a suitable solution for executing SPMD applications in order to obtain our
goal of achieving the minimum execution time, while the eﬃciency is maintained over a threshold deﬁned by the
programmer. The tool designed has been focused on the four methodology phases, and the description of the tool can
be observe in which has been divided among the ﬁve main modules (Figure 5).
The ﬁrst step is to realize a characterization processes in which, the SPMD application and the parallel environment
are tested. Then, our tool executes the characterization process using two diﬀerent tests, one for the application in
which computation time and communication volume parameters of a task are obtained and evaluated. To realize this
characterization, we execute a set of the application’s SPMD tasks and then we collect inputs related to problem
size, communication volume, computational time of each task, etc. The other characterization is for the parallel

R. Muresano et al. / Procedia Computer Science 1 (2012) 2599–2608
R. Muresano et al. / Procedia Computer Science 00 (2010) 1–10

2605
7

Figure 5: Execution tool description.

environment that allows us to determine the communication behavior within the environment. To obtain these values,
we use a ping-pong communication strategy, in which we assign a process to each core and we begin to communicate
using diﬀerent packet sizes to determine the communication process time. The parameter obtained in this phase can
be used to graph the communication and computation behavior. These communications values enable us to identify
the diﬀerent communication paths. Also, we have to determine the communication processes inside the environment
with the aim of realizing a comparison between the communication volume obtained in the ﬁrst test and the values
from the second test. This last test allows us to determine the saturation of the communication link when all cores
perform a communication. An example of this is when a memory bus is saturated due to the high traﬃc between
the cores. Finally, this characterization module permits us to determine the relationship between computation and
communication of a task which are used in the next module to calculate the task distribution model.
Once the parameters of communication (comm(i) ) and computational (comp(i) ) of a tasks have been obtained, we
use them to calculate the set of tasks that are necessary to maintain the relationship between internal computation
and edge communications. This relationship is made according to the eﬃciency desired by the programmer and
the values obtained through the model which has been explained in last section. The equations were integrated in
a programming module that lets us to determine the tasks necessary to execute the SPMD applications eﬃciently.
This module provides us the values of internal and edge computation, edge communication and execution time. This
process is realized using an evaluation of each value of X(i) and Y(i) until we achieve the minimal diﬀerence among
internal computation and edge communication. Once we have obtained the values of X(i) and Y(i) , we calculate the
theoretical execution values which permit us to apply our mapping strategy.
The next module is mapping, in which we apply a core aﬃnity to assign the set of tasks according to the policy
of minimizing the communications latencies. This core aﬃnity permits us to identify where the processes have to
be allocated and how the tasks can be assigned to each core. Another element included in the mapping module is
the logical distribution of the processes. This distribution process is realized through a Cartesian topology of the
process. This is a logical process which we can identify through the MPI commands in each process. Then, with this
topology each process has two coordinates which enable us to identify the communication neighbors. Then, these two
coordinates identify the cores in which the processes have to be allocated. We can coordinate the communication order
with the objective of minimizing the saturation of the communication paths. Also, we can manage the communication
process which will be used in next scheduling module. At the end of this module, we assign the tasks among the cores
and we establish the tasks priorities in scheduling phase. Also, we obtain the communication order that allows us to

2606

R. Muresano et al. / Procedia Computer Science 1 (2012) 2599–2608
R. Muresano et al. / Procedia Computer Science 00 (2010) 1–10

8

identify and monitor if the tasks assigment has been done correctly.
The scheduling module coordinates the task execution order in which the edge computation tasks are calculated
ﬁrst, and then the internal computation task are overlapped while the edge communication is performed as was shown
in ﬁgure 4. This overlapping process permits us to manage the ineﬃciencies generated by communication links as was
explained previosly. The computational and communication processes are performed until the application ﬁnishes.
This process is realized using two threads, one for the internal computation and the other for edge communication.
The last module evaluates the performance results obtained when the application ﬁnishes. The eﬃciency, speedup
and execution time are evaluated in order to determine the applications improvements. The design of this tool allows
us to oﬀer a solution in which multicore resources can be used eﬃciently and SPMD applications can be adapted to
execute in diﬀerent multicore architectures in an eﬃcient manner.
5. Experimental Evaluation and Discussion
Our experiments were conducted on three diﬀerent multicore cluster conﬁgurations. The ﬁrst one was a DELL
cluster with 5 nodes, each with 2 Quadcore Intel Xeon E5430, 2.66 Ghz processors, 6 MB of L2 cache each shared
by two cores and 12 GB RAM per node. The second one was an IBM cluster of 32 nodes, with 2 Dual-Core Intel(R)
Xeon(R) CPU 5150, 2.66GHz and 4MB cache memory L2 (2x2). The third cluster is an AMD cluster, 8 nodes each
contain an AMD Athlon(tm) 64 X2 Dual Core Processor 3800+ (2GHz), 2Gb RAM, 512Kb L2 cache. All these
clusters have a gigabitEthernet network. To validate our results, we have tested with diﬀerent SPMD applications.
Three of them were: Heat Transfer, Wave equation and Laplace Equation which are used to show the eﬀectiveness
of our tool. The Heat transfer and Laplace applications have been selecte due to they are SPMD applications and the
task communication is performed with four neighbors. Also, these applications have a 2d grid distribution. On the
contrary, the Wave equation application has a diﬀerent behavior due to its communication is with two neighbors and
the distribution is only in one dimension.
The execution tool has been applied to diﬀerent multicore clusters. The ﬁgure 6 shows the communication behavior among diverse communication links. These values have been obtained through the characterization module
integrated in our tool. In this cluster characterization, we can obtain three diﬀerent communication paths in the IBM
cluster (Intercore, Interchip and internode (Figure 6(a)). These paths present diﬀerences which in some cases could be
around one order of magnitude when the same packet size is sent. A similar behavior is presented in the Dell cluster,
this cluster has four diﬀerent communication paths as is shown in ﬁgure 6(b). The communication has been tested
with diﬀerent packet sizes because we noticed that communications do not have a linear relationship with the packet
sizes. In the AMD cluster the communication process is performed in two ways: intercore and internode in which the
diﬀerences could be around one and half order of magnitude depending to the packet sizes.

(a) Communications Behaviour on IBM Cluster

(b) Communications Behaviour on DELL Cluster

Figure 6: Communication links characterization on diﬀerent multicore clusters

Another example that we stat in the characterization module is the relationship between computation and communication within environments. Figure 7 illustrates the behavior of a task among the diﬀerent communication paths and

2607

R. Muresano et al. / Procedia Computer Science 1 (2012) 2599–2608

9

R. Muresano et al. / Procedia Computer Science 00 (2010) 1–10
Table 1: Examples of the task distributionmodel for diﬀerent applications
Application.
Heat Trans
Laplace Equ.
Wave Equ.

Comp.Task
0, 13μsec
0, 54μsec
0, 08μsec

Commu.Task
5, 8μsec
40, 6μsec
131, 3μsec

Problem Size
8500x4000
10000x6000
10800

(a) Heat Transfer Application

X(i)
2125
1250
1350

Y(i)
1000
1500
---

T e je(i) by iteration
0,27 Seg
1,01 Seg
0,000108 Seg

Cluster
DELL
IBM
AMD

Cores
16
32
8

(b) Laplace Equation Application

Figure 7: Communication and computation relationship of an SPMD task in diﬀerent clusters

the computation in each cluster. These ﬁgures show the diﬀerences between computation and communication which
enables us to design our strategies for allocating more tasks in each core. These diﬀerences permit us to generate
strategies to eliminate the delays generated by task communication with the objective of improving the eﬃciency.
Also, these ﬁgures show how each cluster can have more communication paths and these depend on the cluster conﬁgurations. The gaps which are presented in these ﬁgures 7(a) and 7(b) represent that this communications path is not
present for a speciﬁc architecture. The inputs obtained in the characterization module allow us to calculate our model
in order to assign the set of tasks to each core in order to achieve our stated objective.
The model permits us to obtain the values of X(i) and Y(i) which are used in the mapping and scheduling phases.
The examples of applying our tool are shown in ﬁgure 8, in these examples 85% minimun eﬃciency has been deﬁned
to calculate the task distribution model. This eﬃciency enables us to establish the maximun ineﬃciency allowable in
our execution. Hence, the maximum ineﬃciency for these cases is around 15% and this has to be considered when
we calculate the model (Table 1).
Once the model has been calculated, we allocate the tasks to each core. The ﬁgures 8(a) and 8(b) illustrate two
example about how the eﬃciency and speedup are improved for diﬀerent applications and diverse kinds of multicore
clusters. These examples have been calculated with the model and the results are shown in table 1. This analysis
has been obtained through executing SPMD applications which are run on diﬀerent multicore clusters. We realized a

(a) Heat Transfer App. on Dell Cluster

(b) Wave Equation App. on AMD Cluster

Figure 8: Eﬃciency and Speedup of diﬀerent applications over diﬀerent clusters

2608

R. Muresano et al. / Procedia Computer Science 1 (2012) 2599–2608
R. Muresano et al. / Procedia Computer Science 00 (2010) 1–10

10

comparison between the application without using our methodology and when we apply our methodology.
The speedup was calculated considering a reference value of the parallel time of the application without applying
our methodology and divided by the parallel time of the application with our proposed changes. The number of cores
used to test with our tool are ﬁxed and we can observe how the eﬃciency was improved and maintained while the
core number is below to the number of cores calculated through our model (Table 1). Once we applied our tool, we
obtained a considerable improvement in the eﬃciency level. The eﬃciency values were improved by around, 39% for
heat transfer on Dell cluster, 18% for wave equation on the AMD cluster and 36% for Laplace equation on the IBM
cluster. These results demonstrate that communications can be managed in order to enhance application performance,
which is the objective of this work. The error in our model is approximately of 3% of the value obtained. As regards
to speedup metrics, we observe that maximum speedup located near to the eﬃciency threshold which we deﬁned to
calculate our task distributionmodel (Table 1), after these points the eﬃciency and speedup has begun to decrease as
is demostrated in ﬁgure 8.
6. Conclusion and Future works
This paper has presented an execution tool based on an eﬃcient execution methodology [5] which uses characterization, a task distribution model, mapping and scheduling strategies. This tool allows us to execute SPMD applications
on diﬀerent multicore architectures eﬃciently and this has been shown in the experimental evaluation. The maximum
speedup in SPMD applications tested was up to near to the parameters obtained with our task distributionmodel.
Moreover, eﬃciency has been improved the values expected by the model.
Our tool analyzes the diﬀerence between communication paths and these are managed in order to enhanced the
speedup and eﬃciency. This tool can be used in diﬀerent multicore architecture due to the characterization process
which determines the computational and communication parameters of the SPMD application. The characterization
phase allow us to use real values of the architecture and these values enable us to adjust the execution to the multicore
cluster. The mapping and scheduling enable us to hide the ineﬃciencies generated by communication links and also
permit us to take advantage of overlapping strategy
Future works include to adapt our tool to execute SPMD applications on heterogeneous communication and computation environments such as multicluster architecture which integrate diﬀerent multicore clusters.
Acknowledgment
This work has been ﬁnanced by the MEC-Spain under contract TIN2007-64974.
References
[1] F. Trahay, E. Brunet, A. Denis, R. Namyst, A multithreaded communication engine for multicore architectures, Parallel and Distributed
Processing, 2008. IPDPS 2008. IEEE International Symposium on (2008) 1–7doi:http://dx.doi.org/10.1109/IPDPS.2008.4536139.
URL http://dx.doi.org/10.1109/IPDPS.2008.4536139
[2] A. El-Mahdy, H. El-Shishiny, An eﬃcient load-balancing algorithm for image processing applications on multicore processors, Proc. of the
1st international forum on Next-generation multicore technologies (2008) 1–5doi:http://doi.acm.org/10.1145/1463768.1463778.
[3] M. D. Mccool, Scalable programming models for massively multicore processors, Proceedings of the IEEE 96 (5) (2008) 816–831.
[4] G. Mercier, J. Clet-Ortega, Towards an eﬃcient process placement policy for mpi applications in multicore environments, EuroPVM/MPI
(2009) 104–115.
[5] R. Muresano, D. Rexachs, E. luque., How spmd applications could be eﬃciently executed on multicore environment, IEEE International
Conference on Cluster Computing (Cluster 2009).
[6] L. M. Liebrock, S. P. Goudy, Methodology for modelling spmd hybrid parallel computation, Concurr. Comput. : Pract. Exper. 20 (8) (2008)
903–940. doi:http://dx.doi.org/10.1002/cpe.v20:8.
[7] K. Vikram, V. Vasudevan, Mapping data-parallel tasks onto partially reconﬁgurable hybrid processor architectures, IEEE Transactions on Very
Large Scale Integration Systems 14 (9) (2006) 1010.
[8] O. Bearmont, A. Legrand, Y. Robert, Data allocation strategies for dense linear algebra on two-dimensional grids with heterogeneus communication links, Tech. rep., Institut National de Recherche en informatique (2001).
[9] L. C. Pinto, L. H. B. Tomazella, M. A. R. Dantas, An experimental study on how to build eﬃcient multi-core clusters
for high performance computing, 11th IEEE International Conference on Computational Science and Engineering (2008) 33–
40doi:http://dx.doi.org/10.1109/CSE.2008.63.

