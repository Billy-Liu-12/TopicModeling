Available online at www.sciencedirect.com

Procedia Computer Science 4 (2011) 2037–2046

International Conference on Computational Science, ICCS 2011

Performance comparison of designated preprocessing white light
interferometry algorithms on emerging multi- and many-core
architectures
Max Schneidera , Dietmar Feya , Daniel Kapusid , Torsten Machleidtb,c
a Chair

of Computer Science 3 (Computer Architecture), Friedrich-Alexander-University of Erlangen-Nuremberg
b Computer Graphics Group, Technical University of Ilmenau
c GBS mbH, Ilmenau
d ZBS e.V., Ilmenau

Abstract
Parallel computing has been a niche for scientiﬁc research in academia for decades. However, as common industrial applications become more and more performance demanding and raising the clock frequency of conventional
single-core systems is hardly an option due to reaching technological limitations, eﬃcient use of multi-core CPUs has
become imperative. 3D surface analysis of objects using the white light interferometry presents one of such computationally challenging applications. In this article three established preprocessing methods of white light interferometry
data analysis are used to evaluate the suitability of three modern multi-core architectures - generic multi-core CPUs,
GPGPUs and IBM’s Cell BE. The results show that function oﬄoading to GPGPUs, which oﬀer independent memory
and many hundreds of threads running in parallel, yields the highest performance compared to other systems. Furthermore, by outsourcing computational tasks to GPUs, the workload of other system resources, such as CPU or system
memory, is reduced. This allows accelerated execution of other tasks, e.g. acquisition of images with higher frame
rates.
Keywords: White light interferometry, Preprocessing Algorithms, OpenMP, IBM Cell BE, CUDA, GPGPU

1. Introduction
This article is a collaborative eﬀort of groups from multiple disciplines - academic partners on the one hand and
industrial partners incorporated by GBS mbH Ilmenau on the other. The industrial partner develops software and
hardware systems for digital image processing with focus on automation of quality assurance applications in manufacturing industry. Their current solution utilizes the white light interferometry measurement principle. The white
light interferometry scanning is a versatile technology which provides a reliable non-contact, 3D optical measurement
of surface roughness in the nanometer range [1]. In the scanning device, which is usually a Michelson interferometer
equipped with a broadband light source, the emitted white light beam is split into two separate beams. One of the

Email addresses: Max.Schneider@informatik.uni-erlangen.de (Max Schneider), Dietmar.Fey@informatik.uni-erlangen.de
(Dietmar Fey), Daniel.Kapusi@zbs-ilmenau.de (Daniel Kapusi), Torsten.Machleidt@gbs-ilmenau.de (Torsten Machleidt)

1877–0509 © 2011 Published by Elsevier Ltd. Open access under CC BY-NC-ND license.
Selection and/or peer-review under responsibility of Prof. Mitsuhisa Sato and Prof. Satoshi Matsuoka
doi:10.1016/j.procs.2011.04.222

2038

Max Schneider et al. / Procedia Computer Science 4 (2011) 2037–2046

beams is projected onto the object to be measured, while the other beam follows a well deﬁned and constant path
to a reference mirror as shown in Figure 1. Both beams are reﬂected and superimposed, resulting in an interference
pattern of light and dark fringes. This fringe pattern is captured on a CCD camera array and processed in software.
By moving the object closer to the scanning device the path diﬀerence between the two beams and thus the fringe
pattern changes. During a common measurement process the whole interference range (the region where the path
length diﬀerence of reﬂected beams is less than the coherence length of the used white light) is covered [2]. Thereby,
individual time series of interference intensities are recorded by the pixels of a CCD sensor. Figure 2 shows such
a two dimensional series, called correlogram or interferogram, for one pixel. At each pixel, where the optical path
length diﬀerence of both beams is zero, the occurred constructive interferences have reached their maximum value. In
the case that the object is not a ﬂat plane, the maximum interference of each pixel point is obtained in diﬀerent time
steps for each pixel. A 3D map can be derived from the positions of the translation arm, where maximum intensities
are observed, and the distance between those and the start position [3]. Thus, the aim of the white light interferometry
analysis process is to ﬁnd the corresponding maximum interference value for each pixel of the CCD sensor.

Figure 1: Michelson Interferometer

For control and analysis of the entire measurement process GBS mbH uses custom software, which consists of
robust and highly accurate analysis algorithms evolved from extensive research and experience in this area. However,
for practical use as in-line analysis of surface quality in pipelined manufacturing processes, such as mass production of
optical lenses, short runtimes for measurement and analysis are necessary. But the currently used system is not able to
fulﬁll such requirements. This is due to the high number of scans and a computationally intensive processing fashion
of arising measurement data needed for the surface analysis. The camera system employed by the nanopositioning
and nanomeasuring machine (NPMM) of GBS mbH supports frame rates up to 30 frames per second [1]. To ensure
a high resolution of the surface proﬁle not the whole object is captured by the camera, but only a 1 × 1 mm2 large
subarea. The measurement of the whole test object is then done using the so-called stitching process. The scanning
area is partitionized logically in 1 × 1 mm2 regions and those are scanned subsequently. After the scanning process the
measurement results are combined into one surface proﬁle. For in example a 25 × 25 mm2 (the currently by NPMM
supported measuring area) wafer with optical elements the NPMM has to scan 625 partitions. Each subarea requires
several scans for a complete survey of the corresponding height proﬁle. Usually more than 200 frames are necessary
for a complete scan of each subarea and the scan of the whole wafer takes approximately 70 minutes. During this large
time window time-dependent environmental inﬂuences like temperature drift, air turbulence and mechanical vibration
can impair the scanning procedure, which in turn produce invalid results [4]. By employing a high speed camera (e.g.
a camera capable of delivering 100 frames per second in megapixel resolution) the environmental inﬂuence on the
scanning procedure can be reduced. However, to meet industrial timing requirements, the data elaboration process
must not exceed the time needed by NPMM for moving the scanning device from the current scan area to the next
position. Therefore, if a high speed camera is used for the measurement process, the timing requirements become
more restrictive. Thus, not only the measurement, but also the elaboration procedure must be accelerated. This can be
achieved by parallelization of data- and computationally intensive tasks.

Max Schneider et al. / Procedia Computer Science 4 (2011) 2037–2046

2039

In conventional white light interferometry surface analysis, hundreds or thousands interference images may be
necessary for a complete surface analysis. Depending on the color depth, the resolution of the CCD pixel array, and
the number of captured images, generated data amount can be enormous. For example, if the color depth is 16 bit and
the camera resolution is 1024 × 1024 pixels, the resulting data amount per image is 2 MB. For a scanning procedure
with 1000 images the resulting volume would be 2 GB. As each point on object’s surface has a diﬀerent height (except planar objects) the z-positions of the translation arm where interferences arise are diﬀerent for each point, too.
Furthermore, the interference range (IR) spans at most few hundred intensity values and all other intensities captured
by the camera are not relevant for the height map calculation. Thus, a preprocessing step in the white light interferometry analysis is used to reduce the required image data to signiﬁcant regions for the height map calculation. In the
postprocessing stage, the maximum interference for each pixel in the corresponding extracted region is calculated [3].

Figure 2: A synthetic interferogram signal of a pixel

The height map calculation following the measurement process is a computationally intensive task, that cannot be
accomplished by sequential systems in real time. However, because each pixel’s correlogram is elaborated independently from those of the other pixels, the analysis process is well suited for parallel processing. There are diﬀerent
parallel architectures that can be used for this procedure. From these we have chosen IBM PowerXCell 8i architecture
(3.2 GHz) with 16 GB DDR2 memory, NVIDIA Tesla C2050 GPU computing processor with 3 GB GDDR5 memory
released in 2010, and Intel’s Xeon X5650 Hexcore (2.66 GHz) with 24 GB DDR3 memory. In this paper we present
the implementation details and results of three common preprocessing methods, representing the ﬁrst step needed in
the white light interferometry data analysis process.
This paper is structured as follows: Section 2 describes relevant work regarding attempts to use many-core architectures for data analysis processes like those in the white light interferometry. In Section 3 we brieﬂy describe
the algorithms that have been evaluated in our experiments. Section 4 contains the description of the programming
methods used in our application to harvest the performance provided by the three above mentioned architectures. In
the last section we present our results and conclusions.
2. Related Work
The usage of multi-core technology in industrial white light interferometry is gaining more and more attention.
However, the usage of accelerators, such as IBM’s Cell BE or GPUs is not yet common. The ﬁrst attempt to use a
graphical processing unit in surface metrology has been approached by Purde et al. in 2004 [5]. They implemented
analysis algorithms of the so called electronic speckle pattern interferometry on GPUs, allowing the measurement
of surface contours using the High Level Shading Language (HLSL). For some parts of the original algorithm they
achieved acceptable results, but due to the restricted capabilities of the utilized GPUs the overall performance could
not attain a desired performance level. To the best of our knowledge no further GPU implementations of the speckle
pattern interferometry algorithms have been developed since this attempt.

2040

Max Schneider et al. / Procedia Computer Science 4 (2011) 2037–2046

F. Gao et al. presented in September 2010 a solution for imaging processing using GPUs for the wavelength
scanning interferometry [6]. In the wavelength scanning interferometry not the object is translated vertically to the
measurement device, but the wavelength of the used light is varied to get the interference patterns [4]. F. Gao et al.
used a GeForce GTX 280 for the parallelization of the computational intensive data analysis procedure. They achieved
approximately a 30x speed-up, by reducing the elaboration time, needed for evaluation of 300 interferograms with
320 × 320 resolution, from 31.4 seconds to below a second.
J. Wang et al. also investigated performance achievable by GPU utilization for the data analysis procedure of the
wavelength scanning interferometry [7] and presented their results in Oktober 2010. They achieved a performance
speed-up of 10 for elaboration of 112 interferogram images with 768 × 576 resolution.
In September 2010 M. Sylwestrzak et al. presented the application of massively parallel processing of Spectral
Optical Coherence Tomography (SOCT) data using GPUs [8]. The measurement process resembles the one described
in this article. However, the data acquisition in SOCT is carried out by scanning a single vertical line (A-scan) at
a time and not through scanning a whole 2D area at once as in our case. Thus, to obtain the 3D proﬁle of the test
object, not only the translation arm with the object has to be moved, but also the transversal scanner which directs the
examining beam to the corresponding scanning position. Furthermore, the data analysis procedure itself is diﬀerent
to our approach. By utilizing NVIDIA’s GeForce GTX 285 with 2 GB device memory M. Sylwestrzak et al. achieved
overall imaging speed of over 100 fps for 2D tomograms consisting of 1024 A-scans. In the case of 3D imaging nine
perspective pictures per second are generated. Each of those pictures consists of 100 two dimensional planes built up
of 100 A-scans each.
3. Algorithms used for Evaluation
The correlogram signal of each pixel, obtained during the measurement process, consists of a carrier wave modulated on the envelope of the interference signal. To calculate the height data from interferograms the envelope peak has
to be detected [3]. Therefore, in the preprocessing analysis step each pixel’s correlogram is demodulated, separating
the carrier wave from the envelope. The demodulation process can be done by a simple approximation of envelope
values. For this purpose, depending on the surface characteristics and the signal-to-noise ratio of the generated signals, diﬀerent approaches have to be considered [9]. Envelope demodulation serves also as a data reduction step,
because only the interval around the center of the interference is relevant for the postprocessing [1], as can be seen in
Figure 2. The center of interference signal itself can not be seen as the envelope’s peak. Due to noise and the discrete
measurement along the z-axis, the actual maximum could be between two captured intensities or it could be shifted
in some direction away from the measured interference center. Thus, in the demodulation process the center of the interference is determined and a predeﬁned number of intensities left and right from this point is extracted. This is done
parallel to the scanning procedure, so that not all interference images must be stored, but only the relevant regions in
corresponding correlograms. These regions are used in the postprocessing stage to get an approximation of the actual
maximum, as accurate as possible. The approximation can be achieved by ﬁtting a model envelope function to the
detected envelope. This function could be a Gaussian curve, if the spectrum of the light source also has Gaussian
distribution characteristics [2]. In this section a short description of evaluated preprocessing algorithms is given.
As mentioned before there is a range of diﬀerent approaches to demodulate the envelope from the carrier signal.
The simplest way leads to the assumption that the highest intensity I of the pixel p in the average free input signal is
located at the envelope’s peak position [10]. Thus a fast, but rough estimation zˆ0 of the envelope’s center is given by
the absolute maximum of the interferogram, as shown in Eq. (1).
zˆ0 (p) = arg max |Izi (p)|
i

(1)

Where zi is the number of the current translation step. This method is easy to implement, even in real-time enabled
hardware, but also very vulnerable to noise [3]. Due to the resulting high risk of miss-classifying maximum positions,
this method is seldom used in industrial processes. Thus, more robust algorithms were chosen for evaluation. In the
following those methods are brieﬂy described.
3.1. Contrast Method
The ﬁrst evaluated algorithm is the contrast method. For each pixel p it uses the maximum absolute diﬀerence
of successive sampling points I from the input signal as an estimator for the envelope, see Eq. (2). This ﬁlter

2041

Max Schneider et al. / Procedia Computer Science 4 (2011) 2037–2046

becomes maximum where the interferogram oscillations have a maximum gradient, which is approximately around
the maximum of the envelope.
(2)
zˆ0 (p) = arg max |Izi−1 (p) − Izi (p)|
i

This slightly increases the robustness in comparison to the method of the maximum intensity described above.
This results from the high-pass characteristics of the diﬀerence operations where low frequencies of the noise are
suppressed. However, ﬁlter characteristics are not particularly well suited for the noise characteristics, making the
algorithm susceptible to high frequency noise [3].
3.2. Sliding Average
The sliding average is an enhancement to the contrast method and one of the most popular methods for the simple
envelope demodulation. A signiﬁcant increase of robustness is achieved by averaging each pixel’s contrast signal,
deﬁned in Eq. 3, with a low-pass ﬁlter, by summing up a predeﬁned number of subsequent contrasts, as shown in Eq.
4 - 5.
contrasti (p) =

|Izi (p) − Izi+1 (p)|

i ∈ [0, N − 2]

(3)

C−1

sum0 (p) =

contrasti (p)

(4)

i=0

sumk (p) =
zˆ0 (p) =

sumk−1 (p) − contrastk−1 (p) + contrastk−1+C (p)

k ∈ [1, N − C]

arg max sumk (p)

(5)
(6)

k∈[0,N−C]

Where N is the number of captured frames and C the number of contrasts per sum. The sliding average method is
based on the running sum algorithm principle, where the ﬁrst sum (sum0 ) is calculated normally with respect to the
corresponding calculation rule, in our case the Eq. 4. When calculating successive values, a new value is added to the
sum and an old value is subtracted, as shown in Eq. 5, thus a full summation each time is unnecessary [3].
3.3. 5-Bucket Method with Error Correction
This algorithm applies Eq. 7 - 11 to calculate the so called bucket values for each pixel p. Each new bucket of
each pixel can be calculated using contrast values, as deﬁned in Eq. 2, already contained in the preceding bucket.
As discussed in [3] this method oﬀers, besides the high-pass characteristics of the diﬀerence operations, also the best
approximation of the envelope compared to the previous algorithms.
contrast02 (p) =
contrast13 (p) =
contrast24 (p) =
bucketk (p) =
zˆ0 (p) =

Iz+0 (p) − Iz+2 (p)

(7)

Iz+1 (p) − Iz+3 (p)
Iz+2 (p) − Iz+4 (p)
1
contrast13 (p)2 − contrast02 (p) · contrast24 (p)
2
arg max bucketk (p)

(8)
(9)

k∈[0,N−5]

k ∈ [0, N − 5]

(10)
(11)

4. Parallel implementation of the preprocessing methods
Employed cameras in industrial applications use diﬀerent color depths (8 bit / 16 bit). Furthermore, the data
analysis has to be accomplished in single precision or in double precision mode, therefore we decided to employ
template classes, so that all the functionality needed to execute the described algorithms with corresponding parameter
combinations, can be accessed through the same class. The user only has to provide the template parameters during
instantiation. These classes are encapsulated in dynamically linked shared object libraries.
Due to restrictive timing requirements in industrial manufacturing the results of the white light interferometry
scanning process should be obtained as soon as possible after the actual measurement. Furthermore, the complete
scanning process can consists out of thousands of interference images in high resolution, which can exceed the memory capacity of used processing system. Therefore, the preprocessing data analysis step is executed in parallel to the

2042

Max Schneider et al. / Procedia Computer Science 4 (2011) 2037–2046

scanning procedure, by which only the relevant interference images are obtained and stored in system memory. For
this purpose we use multi-buﬀering schemes. Each of these buﬀers stores a predeﬁned number (IR) of interference
images. This number corresponds to the required interference range. As soon as the ﬁrst IR many patterns are captured and stored in the ﬁrst buﬀer, the evaluation process is commenced. While data in the ﬁrst buﬀer is processed,
another buﬀer is used to store further images. After the ﬁrst buﬀer is evaluated and the other buﬀer is ﬁlled with new
data, the evaluation process is applied to the second buﬀer and the ﬁrst buﬀer is used again for data acquisition.
4.1. Exploiting conventional multi-core architectures through OpenMP and SIMD Technics
To harness the whole performance of a multi-core system we use the threading paradigm of OpenMP. Thereby
the partitioning of the acquired image data as well as the assignment of computational tasks executed on this data is
handled automatically [11].
All tests of the parallel algorithm implementations were carried out in a system with two Intel Xeon X5650
Hexcores (2.66 GHz). By appropriately adjusting the algorithms to the cache sizes, data accesses can be accelerated.
In the case of the white light interferometry preprocessing algorithms, a frame-wise processing is established. Thus,
after currently for evaluation selected buﬀer is ﬁlled with interference images, image acquisition is switched to the
next buﬀer, while the CPUs begin the evaluation process of data in the ﬁrst buﬀer. The evaluation process is as follows:
each core gets the ﬁrst cache line of the assigned image partition. After this data is evaluated the pixel data of the next
cache line is fetched. So each image is processed completely before the next image in the current buﬀer.
Besides the thread-level parallelism, modern CPUs oﬀer the means to get more performance by inducing additional
data-level parallelism facilities through vector processing (Single Instruction Multiple Data - SIMD) units. Generally,
SIMD parallelism can be applied, if the data organization and the processing manner obey certain constraints [12].
In our case pixels of the same image are processed independently to others, thus allowing the packing of the pixel
data of each image in 128bit wide SIMD vectors. Accordingly to the color depth used during the scanning procedure,
the number of pixels inserted in a vector varies. If a color depth of 8 bit per pixel is used, the pixel number per
vector is 16. When the CCD array uses a 16 bit color depth the pixel number is 8. The calculation of interference
values is the same for each pixel, which would allow us to gain a 8x or 16x the speed of the scalar implementation
by applying SIMD instructions to the packed pixel data. However, due to the necessary ﬂoating point operations in
single or double precision during calculation of the central fringes, the 8 bit or 16 bit intensity data has to be unpacked
from containing vectors, converted to the appropriate ﬂoating point representation and packed with other pixel data
in corresponding ﬂoating point vectors. Figure 3 shows such a conversion from a 16 bit ﬁxed point data containing
vector to 32 bit ﬂoating point data vectors. This unpacking procedure signiﬁcantly reduces the expected performance.

Figure 3: Conversion of a 16 bit data containing vector to two 32 bit data vectors

4.2. Algorithm oﬄoading to GPUs
Modern GPUs contain hundreds of arithmetic units to provide tremendous acceleration for data- and computationally intensive applications. With the high-level GPU programming language CUDA [13], developed by NVIDIA,
the computational power of GPUs became easily accessible not only to the scientiﬁc ﬁeld, but also for industrial
applications. CUDA’s programming model gives the opportunity of using GPUs computing and memory facilities
through extended library functions in standard C and C++ applications. Keywords designate functions to be run on
these computing devices. Functions called kernel specify the work of a single thread and when a CUDA application
is executed hundreds or even thousands of threads are run in parallel. This processing manner is called SIMT (Single
Instruction Multiple Thread), which is almost the same as the well-known SIMD processing. However, while SIMD

Max Schneider et al. / Procedia Computer Science 4 (2011) 2037–2046

2043

units only allow parallel processing of multiple data in homogeneous way, by applying the same instruction on each
of the data element at the same time, SIMT allows the execution of concurrent threads based on the same code but
with the possibility of taking diﬀerent paths of execution. These threads are grouped in a grid of thread blocks, that
are mapped to multiprocessors in the GPU device. The multiprocessors consist of a group of simple scalar processing
units, each of them executing a program thread. The number of thread blocks and the thread block size is speciﬁed
through language extension at each kernel invocation. Thread blocks are further divided into so called thread warps
- a bunch of 32 threads for the current architecture. Threads of the same warp are scheduled at the same time on the
scalar processors [13].
Not only the threading scheme is organized in hierarchical fashion, but also the used memory model follows
the same concept. There exists a global memory accessible by all multiprocessor units, this allows the inter-thread
communication between threads of diﬀerent multiprocessors. Each multiprocessor has an on-chip shared memory
space, which enables the threads run on the same multiprocessor to communicate with each other. In 2010 NVIDIA
introduced Fermi a new GPU architecture, which contains two times more scalar processing units compared to the
previous generation and induces a uniﬁed 784 KB L2-cache used by all multiprocessors, as well as 64 KB memory
per multiprocessor, which can be used as L1-Cache or explicitly addressable shared memory space [13].
Speciﬁcally, we use NVIDIA’s Tesla C2050 that contains 448 scalar processors, to evaluate the performance of
described algorithms. Currently implemented processing manner do not require the usage of shared memory, thus
the conﬁgurable 64 KB memory space described above is used mainly (48 KB) as L1-Cache, so that data accesses
to global memory are reduced as much as possible. As already mentioned in the beginning of this section, a multibuﬀering scheme is applied for the preprocessing phase running parallel to the scanning process. However, in contrast
to the multi-core implementation the required memory space is not allocated in the main memory but in the global
memory of the GPU. In system memory only a buﬀer with the size of one image is required. This buﬀer is allocated
through a CUDA speciﬁc malloc command (cudaHostAlloc), is pinned (not pageable) and thus allows eﬃcient data
transfers between GPU and host. As soon as a new interference image is captured and stored in main memory, the
image data is linearized, moved to the pinned buﬀer and ﬁnally transfered to the GPU memory using asynchronical
memcopy operations (cudaMemcpyAsync). Thus, the measurement process controlled by the CPU moves on, while
the targeted data is fetched by GPU’s DMA-unit from the main memory and stored in the currently idling GPU
buﬀer. Due to GPU’s exclusive memory all intermediate data needed during the data analysis don’t aﬀect system
performance, as in the case where the complete elaboration process is accomplished by the CPU.
The central fringe calculation kernel is designed so that each thread processes the whole correlogram of a pixel
by accessing the corresponding data in subsequent images. As neighboring threads access data of pixels located
contiguously in the memory the load/store-unit in each multiprocessor is able to fetch this data for a whole thread
warp at once, in a so-called coalesced manner. By coalescing, theoretically a up to 32 times higher performance is
attainable compared to data access from threads of the same warp to scattered memory locations [13]. Due to the
large register set available on the multiprocessors each thread is capable of holding all intermediate values during
processing of each buﬀer data internally on the chip, without spilling them to global memory. Only after the data in
the currently selected buﬀer is completely processed the intermediate values are stored in global memory and accessed
once during the evaluation of the next buﬀer.
4.3. IBM Cell BE Architecture utilization
The Cell BE (Broadband Engine) is a heterogeneous multi-core processor designed by the alliance of Sony,
Toshiba and IBM. It integrates an IBM Power-based processor (Power Processing Element - PPE), eight vector coprocessors called Synergistic Processing Elements (SPE), memory and I/O-interfaces as well as a high-speed Element
Interconnect Bus (EIB), that connects all elements in a ring topology, on a single chip. The PPE’s main role is to
run the operating system and to manage program execution on the SPEs. A SPE consists of a RISC core (SPU), 256
KB Local Store (LS) and a Memory Flow Controller (MFC). The LS can be considered as an explicitly addressable
L1 cache. Data transfers to and from an SPE’s LS are managed entirely by the application through DMA transfers.
Therefore, a DMA-unit is contained in the MFC. A DMA operation can transfer either a single block area of size
from 1 Byte up to 16 KB, or a list of up to 2048 such blocks. No matter how big a single transfer is, each basic DMA
operation transfers at least 128 Bytes. Thus, transfers smaller than 128 Byte per DMA will not eﬃciently utilize the
EIB. Analog to asynchronous memcopy operations the DMA operations are asynchronous to the program execution
in the SPU [14]. This approach allows more eﬃcient use of available memory bandwidth, than it would be possible

2044

Max Schneider et al. / Procedia Computer Science 4 (2011) 2037–2046

with standard prefetching schemes of conventional caches. Besides the LS, each SPE has a large register set, consisting of 128 128 bit wide registers. All SPU instructions are 128-bit SIMD-instructions. The SPU has two execution
pipelines, the ﬁrst (even pipeline) for arithmetic and logical and the second (odd pipeline) for data load/store. Thus,
in each clock cycle up to two instructions are issuable. So, to obtain the highest performance of a Cell Processor,
multiple level of parallelism must be used. The ﬁrst level, the thread-level parallelism, is attainable by employing
all SPEs for parallel processing as in conventional multi-core systems. The second level, the data-level parallelism,
is achieved through pervasive SIMD instruction support in all computational units of the Cell BE. The third level,
instruction level parallelism, can be accessed by micro-architecture aware usage of Cell BE’s ISA, that provides the
means to exploit eﬃciently the underlying architecture. The fourth and last level, is the memory level parallelism,
which allows overlapping of data transfers with computational tasks [15].
Our tests were conducted on a QS22 Cell Blade with two PowerXCell8i processors (3.2 GHz). As the data
acquisition from the measurement device needs to be done in parallel to the execution of the preprocessing algorithms,
we decided to establish a master/worker approach. The master thread runs on the PPE, initializes during the analysis
phase required data structures, spawns threads that execute asynchronously on SPEs and is further responsible for
image data acquisition. Worker threads are executed on the SPEs and provide the processing power of these synergistic
units to the application. In [16] S. R. Alam et al. have shown that if SPE threads are respawned multiple times during
the execution of a program, the overhead arising through the initialization processes accumulates and signiﬁcantly
impairs the program performance. Thus, we decided to instantiate the worker threads only once and manage the
kernel execution through control messages, as in our application also multiple kernel invocations are required, each
time a buﬀer is completely ﬁlled with image data. Therefore, the Cell ISA provides routines to enable the PPE
sending messages to the SPEs. Thus, the processing manner in the Cell is as follows. After the data structures,
required during the analysis phase, are instantiated by the PPE, the SPE threads are invoked. The SPEs also initialize
data structures needed during the calculation and then poll for incoming messages. As soon as the currently selected
buﬀer is completely ﬁlled with image data, the PPE sends a start message to all used SPEs. Due to the SPE’s small 256
KB LS and strict DMA characteristics, the whole image data cannot be processed in one step. Thus, the image data
is not only partitioned into segments assigned to individual SPEs, but each SPEs partition also is further subdivided.
With this a similar processing style to cache blocking is achievable. The PPE transmits the ID of the buﬀer to be
processed together with a start signal. Using this ID, the SPEs calculate their own partition’s oﬀset in the image
data buﬀer. In a loop each SPE accesses the data needed for the current sub-partition, elaborates this data and writes
the results for this partition back to main memory. After the results are written back, the next partition is evaluated.
During elaboration of a sub-partition a double-buﬀering memory transfer scheme is applied. This allows to access
data needed in the next computation step, while data acquired in the last step is processed. After the current buﬀer
is completely processed, the SPEs write a speciﬁc value to main memory using DMA-transfers, by which the PPE is
notiﬁed of the task completion.
5. Results

Figure 4: Performance results for the contrast method (double precision
mode on 16 bit interference data)

Figure 5: Performance results for the sliding average method (double
precision mode on 16 bit interference data)

2045

Max Schneider et al. / Procedia Computer Science 4 (2011) 2037–2046

Figure 6: Performance results for the bucket method (double precision mode on 16 bit interference data)

In Figures 4 - 6 the results for the evaluated preprocessing algorithms, using an experimental setup with 1000
interference images, the color depth of 16 bit and double precision processing mode, are shown. The size of the
buﬀers used in the multi-buﬀering scheme was set to 128 images. As it can be seen the best performing algorithm is
the contrast method, which was expected, as this method uses only one arithmetic instruction to calculate the central
fringe in each interferogram. The obtained results, shown in Figure 4, designate conventional multi-core systems as
best suited architecture for this method. The Tesla C2050 is limited by data transfers from main memory to GPU
memory, as shown in table 1, and cannot compete with the performance given by the multi-core implementation. The
Cell BE performs worse than the other architectures, which is explainable by the additional overhead caused by vector
unpacking and the low computational intensity of the contrast method.
Resolution

640 × 480

800 × 600

1024 × 768

1024 × 1024

Contrast method

23.84

32.69

39.39

53.42

Sliding Average

56.83

88.47

146.86

206.11

Bucket method

46.38

72.72

123.61

189.27

Memory transfer

105.67

163.159

265.64

352.88

Table 1: By calculation process and by memory transfers from main memory to GPU memory required timings (in ms)

In the case of the sliding average method, the employed SIMD operations in conventional multi-core implementations as well as the native exploitation of Cell BE’s ISA provide an additional performance gain, see Figure 5. This
is due to the higher computational intensity, that can be eﬃciently handled by SIMD operations, and the larger data
access required in each calculation step, which can be used to eﬃciently overlap the vector conversion operations.
Nevertheless, for the sliding average clearly the GPUs are the most beneﬁcial architecture. This is due to the higher
memory bandwidth provided by GPUs memory bus, as well as the immense computational power of hundreds of
processing cores. Dependent on the used camera resolution we achieved speed-ups from 2.1 to almost 6 times from
the best performing multi-core implementation. For the computation of the central fringe in each pixel’s correlogram
the gained performance is much higher, but again the data transfers between main memory and GPU memory are the
limiting factor for the GPU performance, as shown in table 1.
Figure 6 shows the performance results obtained for the bucket method. For the Intel Xeon X5650 and the IBM
PowerX8i system no performance gain through SIMD processing is observable, as the data amount assigned to each
core and therefore the computational intensity is low. However, the lesser cores (both in multi-core and in IBM Cell
systems) of a system are used, the bigger is the resulting computational intensity per core. Thus, the overhead caused
by vector conversion operations can be more eﬃciently hidden through overlapping with required data transfers. For
the bucket method also the GPU architecture is the most beneﬁcial one. The achieved performance gain is however
lesser than that of the sliding average method. This is due to in the calculation of the bucket values necessary complex
operations like square root. For execution of speciﬁc functions like square root, cosinus and so on, GPUs use special
function units in each multiprocessor. However, these are in smaller numbers available than the scalar processors and

2046

Max Schneider et al. / Procedia Computer Science 4 (2011) 2037–2046

thus are shared between multiple threads executed by the scalar processors. A further performance limiting factor are
again the data transfers between the main memory and the GPU memory, as shown in table 1.
6. Conclusion and future work
When a data-intensive application has to be implemented, one of the biggest challenges is to chose the right platform and ﬁtting the applications on the underlying architecture. In this paper the presented evaluation of the suitability
of three modern architectures for application in the white light interferometry analysis process. The algorithms were
adjusted to the underlying architecture of the corresponding system and evaluated in a common experimental setup.
It was shown that for the simplest algorithm - the contrast method - conventional multi-core systems are the most
beneﬁcial ones, as these provide a tremendous processing power of multiple independent cores on one die and can
access the data directly without moving them to a separate memory space like in the case of GPUs. However, the
contrast method is susceptible to high frequency noise, thus to ensure the accuracy of the surface proﬁle calculated
by the white light interferometry analysis process the sliding average and the bucket method are of higher importance
for industrial applications. In our evaluation of these methods we have shown that the GPUs provide the highest performance gains compared to other architectures, even with the limiting factor of data transfers between main memory
and GPU memory. However, the separate GPU memory is not only a disadvantage for our application, but provides
also a beneﬁt, as the complete data elaboration process don’t eﬀect the CPUs, the main memory (except the transfer
of interference images to the GPU memory) and the rest of the host system. Therefore, these components can be used
more eﬃciently for other tasks (like data acquisition with higher frame rates) compared to the approach where the
CPUs are used for data elaboration process.
In future work we will extent our approach by parallelization of the remaining steps from the white light interferometry data analysis process. This includes the analysis of each interferograms phase information [3] and the
postprocessing step where a Gauss-Newton ﬁtting is applied to each pixel’s correlogram. For GPUs we expect a
higher performance speed-up compared to other systems, as after the preprocessing for the postprocessing required
data is already in GPU’s memory and each pixel’s interferogram is elaborated again independently from those of other
pixels.
7. References
[1] D. Kapusi, T. Machleidt, White Light Interferometry in Combination with a Nanopositioning- and Nanomeasuring Machine (NPMM), Proceedings of the International Society for Optical Engineering (June 2007).
[2] K. G. Larkin, Topics in multi-dimensional signal demodulation, Ph.D. thesis, The Faculty of Science in the University of Sydney (2000).
[3] M. Hissmann, Bayesian estimation for white light interferometry, Ph.D. thesis, Combined Faculties for the Natural Sciences and for Mathematics of the Ruperto-Carola University of Heidelberg, Germany (2005).
[4] X. Jiang, K. Wang, F. Gao, H. Muhamedsalih, Fast surface measurement using wavelength scanning interferometry with compensation of
environmental noise, Appl. Opt. 49 (15) (2010) 2903–2909. doi:10.1364/AO.49.002903.
[5] A. Purde, A. Meixner, H. Schweizer, T. Zeh, A. Koch, Pixel shader based real-time image processing for surface metrology, in: Instrumentation and Measurement Technology Conference, 2004. IMTC 04. Proceedings of the 21st IEEE, Vol. 2, 2004, pp. 1116 – 1119 Vol.2.
doi:10.1109/IMTC.2004.1351259.
[6] F. Gao, X. Jiang, H. Muhamedsalih, H. Martin, Wavelength scanning interferometry for thin ﬁlm analysis of fusion target, in: 3rd European
Target Fabrication Workshop, Science & Technology Facilities Council, 2010.
[7] J. Wang, K. Wang, S. Zhao, L. Lin, J. Bai, White light interferometry for fast areal surface measurement based on gpgpu, Vol. 7849, SPIE,
2010, p. 784918. doi:10.1117/12.870336.
[8] M. Sylwestrzak, M. Szkulmowski, D. Szlag, P. Targowski, Real-time imaging for spectral optical coherence tomography with massively
parallel data processing, Photonics Letters of Poland Vol. 2 (3).
[9] D. W. Robinson, Interferogram Analysis: Digital Fringe Pattern Measurement Techniques, Institute of Physics Publishing, 1993.
[10] Z. Sarac, R. Gro, C. Richter, B. Wiesner, G. Husler, Optimization of White Light Interferometry on rough Surfaces based on Error Analysis,
Optik - International Journal for Light and Electron Optics 121 (2010) 351–357.
[11] B. Chapman, G. Jost, R. van der Pas, Using OpenMP - Portable Shared Memory Parallel Programming, The MIT Press, 2007.
[12] M. Srivastav, Vectorization: Writing C/C++ Code in VECTOR Format, Tech. rep., Intel Software Network (2009).
[13] NVIDIA, NVIDIA CUDA C Programming Guide 3.2, Tech. rep., NVIDIA (2010).
[14] J. A. Kahle, M. N. Day, H. P. Hofstee, C. R. Johns, T. R. Maeurer, D. J. Shippy, Introduction to the cell multiprocessor, IBM Journal of
Research and Development 49 (4-5) (2005) 589–604.
[15] M. Gschwind, The cell broadband engine: exploiting multiple levels of parallelism in a chip multiprocessor, Int. J. Parallel Program. 35
(2007) 233–262. doi:10.1007/s10766-007-0035-4.
[16] S. R. Alam, J. S. Meredith, J. S. Vetter, Balancing productivity and performance on the cell broadband engine, Cluster Computing, IEEE
International Conference on 0 (2007) 149–158. doi:10.1109/CLUSTR.2007.4629227.

