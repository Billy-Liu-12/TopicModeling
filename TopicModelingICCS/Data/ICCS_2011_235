Available online at www.sciencedirect.com

Procedia Computer Science 4 (2011) 36–45

International Conference on Computational Science, ICCS 2011

A Veriﬁed Bulk Synchronous Parallel ML Heat Diﬀusion Simulation
Julien Tessona , Fr´ed´eric Loulerguea
a LIFO,

Universit´e d’Orl´eans, France

Abstract
Bulk Synchronous Parallel ML (BSML) is a structured parallel functional programming language. It extends
a functional programming language of the ML family with a polymorphic data structure and a very small set of
primitives. In this paper we describe a framework for reasoning about BSML programs using the Coq interactive
theorem prover and for extracting actual parallel programs from proofs. This framework is illustrated through a
simulation application based on heat equation.
Keywords: Bulk synchronous parallelism, functional programming, formal semantics, proof assistant

1. Introduction
Hardware with parallel computing capabilities is now everywhere, and the number of processing elements is
increasing making scalable programs necessary. However parallel programming is not yet as widespread as parallel
machines. Indeed in general, concurrent and parallel programs have a complex semantics and are yet diﬃcult to design
and to reason about. In the same way unstructured sequential programs have progressively disappeared, unstructured
parallel programs using send/receive message passing [1] or low level concurrency primitives such as threads should
be avoided.
Several more structured approaches to parallel programming exist: data parallelism, algorithmic skeletons [2],
bulk synchronous parallelism [3] to cite a few. By restricting the possible forms of parallelism, these models make
parallel programs easier to write and easier to reason about. Their structured nature also helps the design of eﬃcient
libraries and compilers to support them. Parallelism being everywhere, it is very important to be able to prove the
correctness of parallel programs used for example in critical applications, where an extra burden is acceptable as the
need for safety of execution override the race for pure computational performance.
Bulk Synchronous Parallel ML [4] is an extension of the Objective Caml language with bulk synchronous parallel
primitives. It is based on formal semantics and can be used for practical parallel programs development.
It is possible with the Coq proof assistant [5] to extract functional programs from proofs [6]. For example, the
CompCert compiler is extracted from a Coq development where each stage of the compiler is proved correct [7].
However all programs extracted from Coq developments are sequential programs.
Our contribution allows to reason about functional bulk synchronous parallel programs within Coq and to extract
actual BSML programs from the proofs. More precisely, in this paper we present:
Email addresses: Julien.Tesson@univ-orleans.fr (Julien Tesson), Frederic.Loulergue@univ-orleans.fr (Fr´ed´eric Loulergue)
URL: http://www.univ-orleans.fr/lifo/Members/Julien.Tesson (Julien Tesson), http://frederic.loulergue.eu (Fr´ed´eric
Loulergue)

1877–0509 © 2011 Published by Elsevier Ltd. Open access under CC BY-NC-ND license.
Selection and/or peer-review under responsibility of Prof. Mitsuhisa Sato and Prof. Satoshi Matsuokaa
doi:10.1016/j.procs.2011.04.005

Julien Tesson and Frédéric Loulergue / Procedia Computer Science 4 (2011) 36–45

37

• a consistent (with Coq’s logic) axiomatisation of BSML primitives,
• proof of correctness of several parallel programs using this axiomatisation,
• extraction of actual BSML programs from these proofs and execution on a parallel machine for performance
comparisons.
We begin by giving short introductions to parallel programming with BSML (section 2) and to the Coq interactive
theorem prover (section 3). We then present the formalisation in Coq of BSML parallel data structure and operations
(section 4) (together with the proof of correctness of a function of the BSML standard library in Coq) before applying
the framework to the proof of correctness and extraction of BSML code from this Coq development for a simulation
application (section 5). We perform some experiments on a parallel machine with this application (section 6). We end
by related work (section 7), conclusions and future work (section 8).
2. Bulk Synchronous Parallel ML
A bulk synchronous parallel or BSP [3] computer is a homogeneous distributed memory machine with a global
synchronisation unit. This architecture is an abstract one as any general purpose parallel architecture can be mapped
to this view. Most of the time, parts of the BSP abstraction are not hardware but emulated by software: for example
the global synchronisation unit in clusters.
A BSP program consists of a sequence of super-steps. Each super-step has three phases: the asynchronous computation phase where each processor performs some computations using only the data it owns, the communication
phase where processors exchange data, and the synchronisation phase where a barrier synchronises all the processors.
It is only after the synchronisation phase that the data exchanged during the communication phase are guaranteed to
be delivered and can be used by the next asynchronous computation phase.
One can write functional BSP programs with Bulk Synchronous Parallel ML or BSML [4, 8]. BSML is very
diﬀerent from the SPMD paradigm where a program is a parallel composition of sequential programs. BSML oﬀers a
global view of the program: it is similar to a sequential program but provides a parallel data structure and primitives
to work on it. In this respect it is close to data parallel languages. BSML’s parallel data structure is called parallel
vector. A parallel vector has a ﬁxed size p, the number of processors of the parallel machine (this constant is called
bsp p in BSML). Each processor owns a value of the parallel vector. All the components of a parallel vector should
have the same type, and a component of a parallel vector should not be a parallel vector: nesting is forbidden (it can
be guaranteed by a type system [9], but in the current implementation – that is not a full language but a library for the
Objective Caml [10] language – the programmer is responsible for avoiding nesting). The type for a parallel vector
whose elements have type t is t par.
To create a parallel vector, the primitive mkpar should be used. Its signature is ( α → int)→ α par. For example
the following shows the evaluation of an expression in the BSML top-level (in which the user can interactively enter
expressions that are immediately evaluated):
# let this = Bsml.mkpar (fun i → i);;
val this : int Bsml.par = <0, 1, 2, 3>

The ﬁrst line begins with the prompt # of the interactive loop, the second line is its answer: a new value called this
is created, a parallel vector of integers. As we have in this example a 4 processors machine, this vector contains 4
values. As Objective Caml is a higher-order language it is possible to create parallel vectors of functions:
# let vf = Bsml.mkpar (fun i → if i mod 2 = 0 then ( + ) 1 else ( + ) (−1) );;
fun>, <fun>, <fun>, <fun
val vf : (int → int) Bsml.par =

For an inﬁx operator ⊕, the notation ( ⊕ ) is its preﬁx version. Thus ( + ) 1 is the function that adds 1 to its argument.
The parallel vector vf contains this function on even processor and the function that subtracts one from its argument
on the odd processors.
A parallel vector of functions is not a function, so it is not applicable to a parallel vector of values. Therefore
we need a primitive to perform this kind of application. This is the role of the apply primitive whose signature is
( α → β )par→ α par→ β par:

38

Julien Tesson and Frédéric Loulergue / Procedia Computer Science 4 (2011) 36–45

# let v1 = Bsml.apply vf this;;
val v1 : int Bsml.par = <1, 0, 3, 2>

The last primitive of BSML (we omit two other primitives including super [11] as they are not used in this paper)
is a primitive that requests a full super-step to be evaluated. put allows us to write explicit communications. Its
signature is (int→ α )par→ (int→ α )par. At each processor i, the messages to be sent are encoded as a function fi . For
a destination processor j, the message sent from i to j is ( fi j). The received messages in the resulting parallel vector
are encoded in the same way: at processor j the vector contains a function g j , the value (g j i) is the value sent by
processor i to processor j. The values that are the ﬁrst constant case of a sum type are considered to have size 0 and
are actually not sent through the network (however the result of put is as if they were sent). For example, this is the
case for the empty list. The following example shifts the values of a vector to the right in a circular way:
# open Bsml;;
# let replicate x = mkpar(fun pid → x);;
val replicate : α → α Bsml.par = <fun>
# let parfun f v = apply(replicate f) v;;
val parfun : ( α → β ) → α Bsml.par → β Bsml.par = <fun>
# let shift v =
let build messages pid lv dst = if dst=natmod (pid+1) bsp p then [lv] else [] in
let messages to send = apply (mkpar build messages) v in
parfun List.hd (apply (put messages to send)(mkpar(fun pid→ natmod (pid−1) bsp p)));;
val shift : α Bsml.par → α Bsml.par = <fun>
# let = shift v1;;
− : int Bsml.par = <2, 1, 0, 3>

In this example we use [] the empty list to represent empty messages. We ﬁrst build the parallel vector of functions
needed for a call to put. This message to send parallel vector is built using the v parallel vector that contains the values
we want to send. If the destination processor (dst) is equal to the source processor (pid) plus one, then a singleton list
with the local value of v (i.e. the value of v at the current pid processor) is sent. The result of (put messages to send)
is also a parallel vector of functions. For a processor pid this function applied to the processor identiﬁer of its left
neighbour (whose identiﬁer is given by the expression natmod (pid−1) bsp p, that evaluates to bsp p−1 if pid equals
0), returns a singleton list containing the value of parallel vector v at processor pid’s left neighbour.
The BSML standard library contains a module Stdlib.Comm that oﬀers many communication related functions such
as shift. In practice most of the time the programmer uses these functions instead of using put directly. Nevertheless
this primitive exists and makes possible to write any BSP communication pattern.
3. A Short Introduction to the Coq Proof Assistant
The Coq proof assistant [13] is based on the calculus of inductive constructions. This calculus is a higher-order
typed λ-calculus. Theorems are types and their proofs are terms of the calculus. The Coq system helps users to build
the proof terms and oﬀers a language of tactics to do so. We illustrate quickly all these notions on a short example
(ﬁgure 1(a)).
In this example, we deﬁne a new inductive type, the type of natural numbers in the Peano style. nat has type Set
which means it belongs to the computational realm of the Coq language. We also deﬁne the plus recursive function on
naturals. In this recursive deﬁnition we specify the decreasing argument (here n1) as all functions must be terminating
in Coq. For both deﬁnitions, we have to give the type of the entity we want to deﬁne as well as a term of this type.
We then deﬁne a lemma named plus n O which states that ∀n, plus n O = n. If we check (using the Check command
of Coq) the type of this expression, we would obtain Prop meaning that this expression belongs to the logical realm.
To deﬁne plus n O we should provide a term of this type, that is a proof of this lemma. We could write directly such a
term, but it is usually complicated and Coq provides a language of tactics to help the user to build a proof term.
If we give to Coq’s top-level the line of ﬁgure 1(a) beginning with Lemma, we would enter the interactive proof
mode that indicates us that we should prove the following goal:
============================
forall n : nat, plus n O = n

Julien Tesson and Frédéric Loulergue / Procedia Computer Science 4 (2011) 36–45

Inductive nat:Set := O : nat | S : nat →nat.
Fixpoint plus (n1 n2 : nat) {struct n1} : nat :=
match n1 with
| O ⇒n2
| S n ⇒S(plus n n2)
end.
Lemma plus n O : ∀n, plus n O = n.
Proof. induction n.
(∗ case n=0 ∗) simpl. reﬂexivity.
(∗ case n>0 ∗) simpl. rewrite IHn. reﬂexivity.
Qed.

39

Inductive list (A:Type) : Type :=
| nil: list A
| cons: A →list A →list A.
Set Implicit Arguments.
Fixpoint length (A:Type) (l:list A) : nat :=
match l with
| nil ⇒O
| cons head tail ⇒S(length tail)
end.

(a)

(b)
Figure 1: Coq Short Examples

We prove this goal by induction on n using the tactic induction n. The system indicates now two goals to prove:
============================
plus O O = O
subgoal 2 is:
plus (S n) O = S n

The ﬁrst one is proved using the deﬁnition of plus using the tactic simpl which yields the goal 0 = 0 and this case is
ended by the application of the tactic reﬂexivity. The second one is the inductive case:
n : nat
IHn : plus n O = n
============================
plus (S n) O = S n

After simpliﬁcation, we obtain the goal S(plus n O) = S n. We solve it ﬁrst by rewriting plus n O to n using the IHn
hypothesis from the context and then we conclude by reﬂexivity.
Note that ∀n, plus 0 n = n is immediate to prove because plus 0 n can be evaluated to n. Therefore to prove such a
goal, intros; reﬂexivity would be suﬃcient (intros move all premisses from goal to the context).
The diﬀerence between Coq and functional programming languages such as ML or Haskell when dealing with
polymorphic types and functions is that type variables are manipulated explicitly. For example the type of lists and
the function that computes the length of a list could be deﬁned in Coq as shown in ﬁgure 1(b). Note that even if length
has two arguments, the type of the list elements and the list itself, it is applied only to a list in the recursive call. Indeed
the command Set Implicit Arguments makes Coq infer implicit arguments, i.e. arguments that could be deduced from
the latter arguments. In the case of length the type of the elements are given when a concrete list with some elements
is given. With this feature the application of polymorphic functions in Coq is similar to parametric polymorphism in
ML or Haskell.
Mixing logical and computational parts is possible in Coq. For example a function of type A→B with a precondition P and a postcondition Q corresponds to a constructive proof of type: ∀x:A, (P x) →exists y:B →(Q x y). This could
be expressed in Coq using the inductive type sig: Inductive sig (A:Set) (Q:A→Prop) : Set := | exist: ∀(x:A), (Q x) →(sig A Q)
It could also be written, using syntactic sugar, as {x:A|(P x)}.
This feature is used in the following deﬁnition of the function pred:
Deﬁnition pred : ∀n:nat, n<>O→{q:nat|(S q)=n}.
Proof.
intros; destruct n. (∗ case n=0 ∗) elim H. reﬂexivity. (∗ case n>0 ∗) exists n. reﬂexivity.
Deﬁned.

The speciﬁcation of this function is: ∀n:nat, n<>O→{q:nat|(S q)=n} and we build it using tactics. We reason by case on
n (tactic destruct). The ﬁrst case is easily solved because we have the hypothesis O<>O, the second one is trivial.

40

Julien Tesson and Frédéric Loulergue / Procedia Computer Science 4 (2011) 36–45

The command Extraction pred would extract the computational part of the deﬁnition of pred. We could obtain a
certiﬁed Objective Caml implementation of the predecessor function of type nat →nat:
let pred = function | O → assert false (∗ absurd case ∗) | S n0 → n0

4. Shallow Embedding of BSML in Coq
A module type in Coq is a set of deﬁnitions or parameters and axioms, the latter being types without associated
proof terms. It is possible to build functors, i.e. modules that take other modules as arguments. In the Coq developments of our framework, all the modules related to parallelism are functors that take as argument a module which
provides a realization of the semantics of BSML. These semantics are modelled in a module type called PRIMITIVES.
The module type PRIMITIVES contains: the deﬁnition processor of processor names, and associated axioms; the
opaque type par of parallel vectors; the axioms which deﬁne the semantics of the parallel primitives of BSML (here
limited to the three primitives described in the previous section).
A natural bsp p, the total number of processors, is assumed to be deﬁned. It is assumed this natural is strictly
positive: Axiom bsp pNotZero: 0 < bsp p.
The type processor is deﬁned as: Deﬁnition processor := { pid: nat | pid < bsp p }.
The type of parallel vectors is an opaque type Parameter par: Type→Type. It is a polymorphic type thus it has as
argument the type of the values contained in the vectors. To access the members of a parallel vector, i.e. the local
values, a function get having the following speciﬁcation is assumed to be deﬁned:
Parameter get : ∀A: Set, par A →processor →A.

The semantics of the parallel primitives of BSML are then speciﬁed using the get function. It is a quite straightforward translation of the semi-formal semantics presented in ﬁgure 2(b) (where v0 , . . . , v p−1 is the notation for a
parallel vector and λx.e is the usual λ-calculus notation for a function with e as a body and taking an argument x). In
ﬁgure 2(a) instead of giving the result parallel vector as a whole, the Coq modelling describes the formal semantics of
the results of the primitives by giving the values of theirs components.
A term t of type {x:A | P x} is a value of type A and a proof that this value verify the property P. It is possible to get
these two parts using the functions proj1 sig and proj2 sig. Therefore what corresponds to the BSML mkpar function,
i.e. with only a computational content is:
Deﬁnition mkparBSML (A:Set) (f: processor →A) := proj1 sig(mkpar f).

the type of mkparBSML is ∀A : Set, (processor →A) →par A. And the following lemma holds for this function:
Lemma lmkpar: ∀(A:Set)(f:processor →A), ∀(i:processor), get (mkparBSML f) i = f i.
Proof. intros A f; apply(proj2 sig (mkpar f)). Qed.

The Program feature [14] of Coq allows us to use mkparas if it were the mkparBSML function. The lemma can be
rewritten:
Program Lemma lmkpar: ∀(A:Set)(f:processor →A), ∀(i:processor), get (mkpar f) i = f i.
Proof. intros A f; apply(proj2 sig (mkpar f)). Qed.

In this particular case we only need the computational part of mkpar, thus the Program feature simply removes it.
Sometimes we provide only the x part of a value t of type {x:A| P x}, and then the Program feature generates a proof
obligation to allow the use of x instead of t. As a matter of fact, using the tactics language to build the proof term
associated to lmkpar is not the simplest way. It is easier to give it directly:
Program Deﬁnition lmkpar (A:Set)(f:processor →A) := proj2 sig(mkpar f).

We provide these lemmas for all BSML primitives, and some additional deﬁnitions and results about processors, in
a functor BsmlProperties.Make. This module adds the lemmas to a hint base to be used by automated tactics of Coq,
making proof of BSML programs more convenient.

Julien Tesson and Frédéric Loulergue / Procedia Computer Science 4 (2011) 36–45

Parameter mkpar : ∀(A:Set) (f: processor →A),
{ vr: par A | ∀i: processor, get vr i = f i }.
Parameter apply : ∀(A B: Set) (vf: par (A →B)) (vx: par A),
{ vr: par B | ∀i: processor, get vr i = (get vf i) (get vx i) }.
Parameter put : ∀(A:Set) (vf: par (processor →A)),
{ vr: par (processor →A) | ∀(i j: processor), get vr i j = get vf j i }.

41

mkpar f =
apply
put

f 0 , . . . , f (p − 1)
f0 , . . . , f p−1
x0 , . . . , x p−1 =
f0 x0 , . . . , f p−1 x p−1
f0 , . . . , f p−1 =
λi.( fi 0) , . . . , λi.( fi (p − 1))
(b)

(a)
Figure 2: Bulk Synchronous Parallel ML Primitives

Thus from the axioms presented above we obtain three functions that verify the speciﬁcations. These functions
and their properties are used to deﬁne and prove the correctness of BSML programs.
As a small example, we show how to deﬁne a certiﬁed version of the parfun function also deﬁned directly in BSML
in section 2:
Program Deﬁnition parfun(A B: Type)(f:A→B)(v:par A) :
{ vr: par B | ∀(i:processor), get vr i = f (get v i) }:=
apply (replicate f) v.
Next Obligation.
autorewrite with bsml; reﬂexivity.
Deﬁned.

The second line is the speciﬁcation of this function, the third one is the deﬁnition in BSML style (computational part
only) and is identical to the deﬁnition of section 2. The Program feature generates a proof obligation (in this case that
the expression apply (replicate f) v meets the speciﬁcation). Using the hint base bsml, the proof is automatic.
5. An Application: Heat Equation
The diﬀusion of heat in a material (of length 1), in one dimension, is described by the equation:
δu
δ2 u
−γ 2 =0
δt
δ x
where x and t are reals. We assume boundary conditions u(0, t) = l and u(1, t) = r for some constants l and r. To
approximate function u it is possible to discretise this equation with the ﬁnite diﬀerences method. For a time step dt
and a space step dx, the following equation is obtained:
u(x, t + dt) = γ ×

dt
× u(x + dx, t) + u(x − dx, t) − 2 × u(x, t) + u(x, t)
dx2

(1)

To build a simulation program of heat diﬀusion, this equation is further approximated by considering ﬂoating point
numbers instead of real numbers. The speciﬁcation of our program will be thus (1).
1
− 1 values of u in
The ﬁrst step of our program in Coq is to write this speciﬁcation. We store the non-boundary dx
a list. Equation (1) describes the values of the list obtained from u after one simulation step. Moreover we should not
forget the boundary conditions. For x = dx (and similarly for x = 1 − dx), the equation is in fact:
u(x , t + dt) = γ ×

dt
× u(x + dx, t) + l − 2 × u(x , t) + u(x , t)
dx2

For modelling this speciﬁcation we assume to have a type number with binary operations +, −, ∗ and / in the number scope
scope. It is unnecessary to assume anything about their semantics. We just deﬁne the heatEqFormula as the right hand
side of equation (1):
Open Scope number scope.
Deﬁnition heatEqFormula (dt dx gamma uI uIMinusOne uIPlusOne : number) : number :=
gamma ∗ dt / (dx ∗ dx) ∗ ( uIPlusOne + uIMinusOne − uI − uI) + uI.
Close Scope number scope.

42

Julien Tesson and Frédéric Loulergue / Procedia Computer Science 4 (2011) 36–45

The speciﬁcation of one step of our simulation application is then:
Deﬁnition stepSpeciﬁcation (step: number →number →number →number →number →list number →list number): Prop :=
∀(u : list number)(Hu: u<>[])(left right dt dx gamma: number) (i : nat)(Hi:i<length u)(default : number),
nth i (step left right dt dx gamma u) default =
heatEqFormula dt dx gamma (nth i u default) (if i==0 then left else nth (i−1) u default) (nth (i+1) u right).

If u were an array we would write u[i] for its ith element. Here we write nth i u with an additional default argument
returned as result of the call to nth in case i is greater or equal to the length of the list. To manage boundary conditions,
for the left boundary we use a conditional, for the right boundary, using the default argument of nth is suﬃcient.
A sequential program that veriﬁes this speciﬁcation follows:
Fixpoint heatSeq (left right dt dx gamma : number)(u : list number) : list number := match u with
| [] ⇒[]
| uI :: u’ ⇒match u’ with
| [] ⇒[ heatEqFormula dt dx gamma uI left right ]
| uIPlusOne:: ⇒(heatEqFormula dt dx gamma uI left uIPlusOne)::(heatSeq uI right dt dx gamma u’)
end
end.

The proof1 that it indeed meets speciﬁcation stepSpeciﬁcation is done by induction and relies on the following lemma
where last and hd respectively returns the last and ﬁrst element of a list with a default value in case the list is empty,
and ++ is list concatenation:
Lemma heatSeqApp: ∀(left right dt dx gamma : number)(u1 u2: list number),
heatSeq left right dt dx gamma (u1 ++ u2) =
(heatSeq left (hd right u2) dt dx gamma u1) ++ (heatSeq (last u1 left) right dt dx gamma u2).

A parallel version follows (the u argument is implicit as it is also given by the Hu argument):
Program Deﬁnition heatPar (left right dt dx gamma:number)(u:par(list number))(Hu:∀ i,get u i<>nil) : par(list number) :=
let bounds := getBounds left right Hu in apply(parfun2(fun l r⇒heatSeq l r dt dx gamma)(fst bounds)(snd bounds)) u.

At a given processor, the getBounds function sends the ﬁrst (resp. last) element of its list to its left (resp. right)
neighbour. On the ﬁrst (resp. last) processor where nothing is sent from its left (resp. right) neighbour, the boundary
values are used instead. The Coq speciﬁcation of this function is given below (sHead (resp. sLast) returns the ﬁrst
(resp. last) element of a non-empty list), and the BSML code of the direct implementation in ﬁgure 3 (the Coq version
uses an auxiliary function and the whole description would make the paper larger than the page limit: we refer to the
material available on the web):
Program Deﬁnition getBounds (A:Type)(left right : A)(v: par(list A))(H: ∀i, get v i <> nil) :
{ vr : par A | ∀(i:processor), get vr i = if ( i == ﬁrstProcessor ) then left else sLast (get v (i−1)) } ∗
{ vr : par A | ∀(i:processor), get vr i = if ( i == lastProcessor) then right else sHead (get v (min (i+1) lastProcessor)) } := ...

The theorem about the equivalence of the sequential and parallel versions (and hence the correctness of the parallel
version since the sequential version is correct with respect to stepSpeciﬁcation) of one step of simulation is stated as
follows, where listOfPar transforms a parallel vector of lists into a list:
Theorem heatParSeqEq: ∀(left right dt dx gamma:number)(u:par(list number))(Hu:∀ i, get u i<>nil),
heatSeq left right dt dx gamma (listOfPar u) = listOfPar(heatPar left right dt dx gamma Hu).

This theorem is proved with two intermediate lemmas. The ﬁrst states that the list held at processor i after a parallel
step of simulation is the same as the list obtained by applying a step of sequential simulation of the list initially held
by processor i if the boundary conditions are the elements returned at processor i by the getBounds function:
Program Lemma heatParSeqEqAtI: ∀(left right dt dx gamma:number)(u:par(list number))(Hu:∀ i, get u i<>nil)(i:processor),
(get (heatPar left right dt dx gamma Hu) i) = heatSeq (leftBoundAtI left Hu i) (rightBoundAtI right Hu i) dt dx gamma (get u i).

1 The

whole development including all the proofs is available at http://traclifo.univ-orleans.fr/BSML

Julien Tesson and Frédéric Loulergue / Procedia Computer Science 4 (2011) 36–45

43

(∗ val getBounds: (’a→’b)→(’a→’b)→’b→’b→’a Bsml.par→’b Bsml.par ∗ ’b Bsml.par ∗)
let getBounds ﬁrst last l bound r bound u =
let msg = put(Bsml.apply(Bsml.mkpar(fun pid lu dst →
if (dst = (pid + 1)) && (pid <> (bsp p − 1)) then [ last lu ]
else if (dst = (pid − 1)) && (pid <> 0) then [ ﬁrst lu ] else [])) u ) in
(Bsml.apply(Bsml.mkpar(fun pid lmsg→if pid=0 then l bound else List.hd (lmsg (pid−1)))) msg ,
Bsml.apply(Bsml.mkpar(fun pid lmsg→if pid=bsp p−1 then r bound else List.hd (lmsg (pid+1)))) msg )
Figure 3: The BSML getBounds function

where leftBoundAtI is deﬁned as (and rightBoundAtI is deﬁned in a similar way):
Program Deﬁnition leftBoundAtI (left:number)(u:par(list number))(Hu:∀ i,get u i<>nil)(i:processor): number :=
if ( (‘i) == (‘ﬁrstProcessor) ) then left else sLast (get u (i−1)).

The proof of this lemma distinguishes three cases on i: i is the ﬁrst processor, i is the last processor, i is another
processor.
Then the results obtained with heatParSeqEqAtI for all the possible values of i, should be combined. However to be
able to reason by induction, it is necessary to state and prove the following lemma instead of trying to prove directly
the theorem:
Program Lemma heatParSeqEqUpToI: ∀(i:processor)(left right dt dx gamma:number)(u:par(list number))(Hu:∀ i,get u i<>nil),
heatSeq left (rightBoundAtI right Hu i) dt dx gamma (ﬂatten (map (get u) (processorsUpTo i))) =
ﬂatten(map(get(heatEquationPar left right dt dx gamma Hu))(processorsUpTo i)).

where ﬂatten ﬂattens a list of lists into a list and processorsUpTo i is the list of processors from the ﬁrst processor up to
i. This lemma is proved by induction on i (more precisely on proj1 sig i). The theorem can then be proved by applying
the previous lemma to the last processor.
6. Experiments
In the shallow embedding of BSML, processors are represented by Peano naturals together with the proof that they
are smaller than the number of available processors. After extraction in OCaml, the proof is removed and it remains
a Peano natural (type nat), whereas, in the OCaml implementation of BSML, native integer (type int) are used.
Therefore we implement a module providing BSML primitives with Peano naturals as processors index (called
BSMLnat) as requested by the functors extracted from our Coq development. This module has the OCaml module
type corresponding to the extraction of the BsmlSpec.PRIMITIVES Coq module type. To this end we implemented
conversions between Peano naturals and native integers. To avoid computing several times the same conversion from
a Peano natural to a native integer, computed Peano naturals are cached with their corresponding native integers.
The extracted heat equation implementation is encapsulated in a functor taking a module Number as argument
that provides a number type and its operation. For the benchmark, we apply this functor to a module containing ﬂoat
type and its operations. This genericity introduces one level of indirection for each operation on ﬂoats. Furthermore,
it prevents the compiler to use unboxed ﬂoats and thus use much more memory. Therefore we also benchmark a
manually defunctorized version of our code.
We benchmark the extracted version against an OCaml hand-coded unproved version of the heat equation computation and the manually defunctorized version of the extracted one; all three implementations are used to compute the
solution of the equation over lists of increasing size. The computation times given are for 200 iterations of simulation
with a (full major) garbage collection at the end of each iteration. The examples have been launched several times on
the LIFO’s PC cluster called Mirev. The experiments used up to 8 nodes, with 2 quad-core processors per node. All
nodes are connected with a gigabit ethernet network. We use BSML 0.5 compiled with openMPI 1.4.2.
In both ﬁgures 4(a) and 4(b) we can see that there is almost no diﬀerence between defunctorized and directly
implemented version. There is a growing overhead for the extracted, non-defunctorized version timing. It is due
to the garbage collector, which is triggered more often during the computation in this version, due to the memory
consumption overhead.

44

Julien Tesson and Frédéric Loulergue / Procedia Computer Science 4 (2011) 36–45

	







 





































(a)
















 	


	


	


	


	




(b)

Figure 4: Execution Time of Direct and Extracted Implementations with 1 and 16 Processors

7. Related Work
In [15], Gava considered the correctness proofs of BSML programs. The main diﬀerence on the formalisation
of BSML semantics in his work and ours is that we axiomatised the semantics of BSML in a module type which
allows us to implement a module with this type to ensure the consistence of our development with Coq’s logic. We
also heavily rely on the Program mechanism of Coq that was not available in 2003. Finally we applied the updated
framework to develop a new application and to study the performance of the extracted BSML program.
For sequential languages, the traditional way for verifying programs is based on a Veriﬁcation Condition Generator
(VCG). The user annotates the source code with assertions that describe pre and post conditions as well as invariants.
The VCG tool extracts proof obligations from programs with annotations. The program is correct, i.e. it is guaranteed
to satisfy its speciﬁcation, if the proof obligations can be proved correct. The Spec# [16] and Why [17] systems follow
this approach. [18] built on Why with the intent to prove BSP programs similar to C programs with BSPlib [19] calls.
It is also possible to directly use a proof assistant to verify programs. One can rely on a deep embedding: programs syntax and semantics are represented by inductive data-types in the proof assistant. This technique is quite
heavy for proving the correctness of programs, but is adequate for reasoning about the semantical properties of a
programming language. The approach we choose is to use a shallow embedding: the logic of proof assistants is a kind
of programming language. It is thus possible to write both programs and assertions in the same language and prove
the correctness of programs. This is also the approach taken in the CompCert project [7] for the veriﬁcation of an optimising C compiler. However the programming languages of proof assistants have limitations. For example it is not
possible to write programs with eﬀects. Ynot [20] relies on a dependently-typed monad for describing computations
with eﬀects. Nevertheless the authors indicate in [21]: “However, the pack injectivity axiom contradicts the axiom of
proof irrelevance (which we do not use in any of our developments, but which is popular among Coq users), and it
is an open question in the Coq community whether this axiom is consistent with Coqs logic even by itself.” which is
problematic.
A third approach has been recently developed [22]. From a real programming language source code (here Objective Caml), a logical formula is generated. This logical formula applied to a speciﬁcation gives a suﬃcient condition
for establishing that the program satisﬁes the speciﬁcation.
A last approach is to avoid a posteriori veriﬁcation by building correct-by-construction programs. It is the approach taken in constructive algorithms [23]. An eﬃcient program is derived step-by-step through a sequence of
transformations that preserve the meaning and hence the correctness. Program calculation can be used for writing
parallel programs [24] with suitable data-structures. The program is then implemented using a parallel library of algorithmic skeletons, which is not proved correct: there is a semantical gap between the ﬁnal composition of algorithmic
skeletons obtained by derivation and its implementation. We also experimented with this kind of approach, but without
the drawback, with a new kind of homomorphism and a Coq framework to derive BSML programs from speciﬁcations
through program transformation [25] and then extraction. The present work complements this approach: all BSML
programs cannot be written eﬃciently as an instantiation of this new homomorphism.

Julien Tesson and Frédéric Loulergue / Procedia Computer Science 4 (2011) 36–45

45

8. Conclusion and Future Work
In this paper we present a framework within the Coq proof assistant to develop correct Bulk Synchronous Parallel ML programs. Actual BSML programs can be extracted from the proofs. In particular we develop a simulation
application based on the heat equation, and proved the correctness of both the sequential and parallel versions of the
simulation with respect to the discretised (by ﬁnite diﬀerences) equation. Preliminary results show that the performances of extracted programs are acceptable, even if there is room for improvement.
We are currently working on a certiﬁed implementation of the pure functional subset of the BSML standard
library. We also plan to develop new applications and experiment with them. In the long term we will consider a
veriﬁed compiler for the Bulk Synchronous Parallel ML language. If the correctness of the compilation and execution
of a BSML program cannot be ensured, the eﬀort to prove the correctness of programs is undermined. We will build
this compiler using the MLCompCert compiler [26] for sequential ML.
9. References
[1]
[2]
[3]
[4]
[5]
[6]
[7]
[8]
[9]
[10]
[11]
[12]

[13]
[14]
[15]
[16]

[17]
[18]
[19]
[20]
[21]

[22]
[23]
[24]
[25]

[26]

S. Gorlatch, Send-receive considered harmful: Myths and realities of message passing, ACM TOPLAS 26 (1) (2004) 47–56.
M. Cole, Algorithmic Skeletons: Structured Management of Parallel Computation, MIT Press, 1989.
L. G. Valiant, A bridging model for parallel computation, Comm. of the ACM 33 (8) (1990) 103.
F. Loulergue, F. Gava, D. Billiet, BSML: Modular Implementation and Performance Prediction, in: V. S. Sunderam, G. D. van Albada,
P. M. A. Sloot, J. Dongarra (Eds.), International Conference on Computational Science (ICCS), LNCS 3515, Springer, 2005, pp. 1046–1054.
The Coq Development Team, The Coq Proof Assistant, http://coq.inria.fr.
P. Letouzey, Coq Extraction, an Overview, in: A. Beckmann, C. Dimitracopoulos, , B. L¨owe (Eds.), Logic and Theory of Algorithms, Fourth
Conference on Computability in Europe, CiE 2008, LNCS 5028, Springer, 2008.
X. Leroy, A formally veriﬁed compiler back-end, Journal of Automated Reasoning 43 (4) (2009) 363–446.
doi:10.1007/
s10817-009-9155-4.
The BSML Development Team, The BSML Library version 0.5, https://traclifo.univ-orleans.fr/BSML (august 2010).
F. Gava, F. Loulergue, A Static Analysis for Bulk Synchronous Parallel ML to Avoid Parallel Nesting, Future Generation Computer Systems
21 (5) (2005) 665–671.
X. Leroy, D. Doligez, A. Frisch, J. Garrigue, D. R´emy, J. Vouillon, The Objective Caml System release 3.12, http://caml.inria.fr
(2010).
F. Loulergue, Parallel Superposition for Bulk Synchronous Parallel ML, in: P. M. A. Sloot, al. (Eds.), International Conference on Computational Science (ICCS 2003), LNCS 2659, Springer Verlag, 2003, pp. 223–232.
W. Bousdira, F. Gava, L. Gesbert, F. Loulergue, G. Petiot, Functional Parallel Programming with Revised Bulk Synchronous Parallel ML, in:
K. Nakano (Ed.), First International Conference on Networking and Computing (ICNC 2010), 2nd International Workshop on Parallel and
Distributed Algorithms and Applications (PDAA), IEEE Computer Society, 2010, pp. 191–196. doi:10.1109/IC-NC.2010.57.
The Coq Proof Assistant, http://coq.inria.fr.
M. Sozeau, Un environnement pour la programmation avec types d´ependants, Ph.D. thesis, University Paris East, LRI (2008).
F. Gava, Formal Proofs of Functional BSP Programs, Parallel Processing Letters 13 (3) (2003) 365–376.
M. Barnett, K. R. M. Leino, W. Schulte, The Spec# programming system: An overview, in: G. Barthe, L. Burdy, M. Huisman, J.-L. Lanet,
T. Muntean (Eds.), Construction and Analysis of Safe, Secure, and Interoperable Smart Devices (CASSIS), LNCS 3362, Springer, 2004, pp.
49–69. doi:10.1007/978-3-540-30569-9_3.
J.-C. Filliˆatre, C. March´e, The Why/Krakatoa/Caduceus Platform for Deductive Program Veriﬁcation, in: W. Damm, H. Hermanns (Eds.),
19th International Conference on Computer Aided Veriﬁcation, LNCS, Springer, 2007.
J. Fortin, F. Gava, Bsp-why: an intermediate language for deductive veriﬁcation of bsp programs, in: Proceedings of the fourth international
workshop on High-level parallel programming and applications, HLPP ’10, ACM, 2010, pp. 35–44. doi:10.1145/1863482.1863491.
J. M. D. Hill, B. McColl, D. C. Stefanescu, M. W. Goudreau, K. Lang, S. B. Rao, T. Suel, T. Tsantilas, R. Bisseling, BSPlib: The BSP
Programming Library, Parallel Computing 24 (1998) 1947–1980.
A. Nanevski, G. Morrisett, A. Shinnar, P. Govereau, L. Birkedal, Ynot: dependent types for imperative programs, in: J. Hook, P. Thiemann
(Eds.), 13th ACM SIGPLAN international conference on Functional programming (ICFP 2008), ACM, 2008, pp. 229–240.
A. J. Chlipala, J. G. Malecha, G. Morrisett, A. Shinnar, R. Wisnesky, Eﬀective interactive proofs for higher-order imperative programs, in:
G. Hutton, A. P. Tolmach (Eds.), 14th ACM SIGPLAN international conference on Functional programming (ICFP 2009), ACM, 2009, pp.
79–90. doi:10.1145/1596550.1596565.
A. Charg´eraud, Program veriﬁcation through characteristic formulae, in: P. Hudak, S. Weirich (Eds.), 15th ACM SIGPLAN international
conference on Functional programming (ICFP 2010), ACM, 2010, pp. 321–332. doi:10.1145/1863543.1863590.
R. Bird, O. de Moor, Algebra of Programming, Prentice Hall, 1996.
K. Morita, A. Morihata, K. Matsuzaki, Z. Hu, M. Takeichi, Automatic Inversion Generates Divide-and-Conquer Parallel Programs, in: ACM
SIGPLAN 2007 Conference on Programming Language Design and Implementation (PLDI 2007), ACM Press, 2007, pp. 146–155.
L. Gesbert, Z. Hu, F. Loulergue, K. Matsuzaki, J. Tesson, Systematic Development of Correct Bulk Synchronous Parallel Programs, in: The
11th International Conference on Parallel and Distributed Computing, Applications and Technologies (PDCAT), IEEE Computer Society,
2010, pp. 334–340. doi:10.1109/PDCAT.2010.86.
Z. Dargaye, X. Leroy, A veriﬁed framework for higher-order uncurrying optimizations, Higher-Order and Symbolic Computation 22 (3)
(2009) 199–231.

