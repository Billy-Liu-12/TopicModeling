Available online at www.sciencedirect.com

Procedia Computer Science 18 (2013) 1664 – 1673

International Conference on Computational Science, ICCS 2013

Limits of Instruction-Level Parallelism Capture.
Bernard Goossens, David Parello
DALI, Université de Perpignan Via Domitia 66860 Perpignan Cedex 9 France,
LIRMM, CNRS: UMR 5506 - Université Montpellier 2 34095 Montpellier Cedex 5 France,
bernard.goossens@univ-perp.fr, david.parello@univ-perp.fr

Abstract
We analyse the capacity of diﬀerent running models to beneﬁt from the Instruction-Level Parallelism (ILP). First,
we show where the locks to the capture of distant ILP reside. We show that i) fetching in parallel, ii) renaming
memory references and iii) removing parasitic true dependencies on the stack management are the keys to capture
distant ILP. Second, we measure the potential of a new running model, named speculative forking, in which a run
is dynamically multi-threaded by forking at every function and loop entry frontier and threads communicate to link
renamed consumers to their producers. We show that a run can be automatically parallelized by speculative forking
and extended renaming. Most of the distant ILP, increasing with the data size, can be captured for properly compiled
programs based on parallel algorithms.
Keywords: Automatic parallelization, Instruction-Level Parallelism, distant ILP capture, speculative forking,
memory renaming.

1. Introduction.
Control, stack and heap policies are known locks to parallelization. Functions arguments and results
transmissions and loops controls also build long dependency chains.
Fetch uses a single Instruction Pointer (IP) moving sequentially along the run trace. In an out-of-order
speculative processor, the code portion ranging from a corrected control ﬂow bad prediction and the next
one is dynamically parallelized through its renaming. Wall has measured [14] that in such a limited part of
the trace the available Instruction-Level Parallelism (ILP) is no better than 51 .
The stack and the heap have a sequentializing eﬀect [1] [8] coming from the successions of allocations
and freeings. Functions calls dynamically allocate stack space. This sequentializes the run through dependencies coming both from the stack management and the stack content. The stack management is made of
Read After Write (RAW) depending instructions updating implicitely or explicitely the stack pointer. This
builds a long sequential chain along the run trace. The stack content is written and later read by call/return,
push/pop and store/load pairs. This creates RAW dependencies on the memory accesses. The stack frames
sharings add WAW (Write After Write) and WAR (Write After Read) false dependencies. A similar situation applies to the heap. Eventually, non volatile registers may be saved and restored in the stack upon calls
which creates a parasitic RAW dependency chain per register across the run trace. Moreover, the control
part of an n iteration for loop includes an update of the control variable, mainly i++-like, which yields an
n instructions long dependency chain.
1 Good

model in [14]

1877-0509 © 2013 The Authors. Published by Elsevier B.V. Open access under CC BY-NC-ND license.
Selection and peer review under responsibility of the organizers of the 2013 International Conference on Computational Science
doi:10.1016/j.procs.2013.05.334

Bernard Goossens and David Parello / Procedia Computer Science 18 (2013) 1664 – 1673

Figure 1 shows the ILP reached by 27 benchmarks of the cBench suite [2] in a sequential model of
execution, matching an actual speculative processor enhanced by a perfect branch predictor and an inﬁnite
register renaming capacity (see section 3.3 for details on the model). The average ILP is around 10. This
is too low to expect any substancial beneﬁt from improving the predictor or extending the window size.
Figure 1. 27 cBench benchmarks ILP in the sequential model
cBench ILP
50
sequential
45
40
35

ILP

30
25
20
15
10
5
0

d
_
m
c
p c
d _
a cm
p
d
a
e
a
_
h
h
s
c s e
r i _
c wf el
d
o
l a _
b nd l
j e d
i a _
r nd h
j s
i i
r wf
o
l h
b nt
y
s d
r p2 t
i n
z u
b co
n
t
a
i
i
b
m d
s e a
g fm gb
f
i r
t f2
f w
i b
h
t f2
c
r
f
i d a
t g_ se
e
p g
j in
r
t
s e a
m r
a t
l ks a
j i
i c
d ri
t
a e
p p2
r
i
z 1 e
b rt h
o t
s i
q fd
f e
i _
t an s
s
u _
s an c
s
u _
s an
s
u c
s g_
e
p

j

ILP does exist, as ﬁgure 2 shows (log scale on y axis). It reports the ILP of the same benchmarks in
a parallel execution model only constrained by producer to consumer dependencies. Instructions are run
as soon as their sources have been produced. No control constraint applies, as if the full trace would be
at hand since the start of the run. Any consuming source can be matched with its producing destination
at any time. As the ﬁgure shows, 11 benchmarks have a high ILP (>100, left), 9 have a moderate ILP (>
10, center) and 7 have a low ILP (≤ 10, right) no better than in the sequential model. The high ILP when
present comes from very distant independent instructions.
Figure 2. 27 cBench benchmarks ILP in the parallel model
cBench ILP
10000
sequential
parallel

ILP

1000

100

10

1

d
_
m
c
p c
d _
a cm
p
d
a
e
a
_
h
h
s
c s e
r i _
c wf el
d
o
l a _
b nd el
d
j
i a _
r nd sh
j
i i
r wf
o
l h
b nt
y
s d
r p2 t
i n
z u
b co
n
t
a
i
i
b
m d
s e a
g fm b
f g
i r
t f2 w
f
h
i b
c
t f2
r
f
i d a
t g_ se
e
p g
j in
r
t
s e ra
m
a t
l ks ia
j
i c
d ri
t
a e
p p2
r
i
z 1 e
b rt th
o
s i
q fd e
f
i _
t an s
s
u _
s an c
s
u _
s an
s
u c
s g_
e
p

j

To catch the distant ILP and parallelize the run requires to be able to remove three sets of dependencies:
• Control dependencies (including loop control).
• Data true dependencies for stack management and non volatile registers save and restore.
• Memory false dependencies (including stack and heap accesses).
Figure 3 is a sum reduction C program and ﬁgure 4 is its x86 translation. It has control dependencies
(but no loop) and stack management true dependencies through stack pointer register RSP update. Calls
at the same hierarchical level yield memory WAW false dependencies, as do pushes and the result saving.
Each call is WAR dependent on the preceding return of the same level, as are each push on the preceding
pop of the same level. Eventually, successions of pushes and pops of registers form a chain of RAW true
dependencies across the stack. All these dependencies added to the control sequentialize the run.

1665

1666

Bernard Goossens and David Parello / Procedia Computer Science 18 (2013) 1664 – 1673
Figure 3. A vector parallel sum in C
unsigned l o n g sum { unsigned l o n g t [ ] , unsigned l o n g n ) {
i f ( n==2) r e t u r n t [ 0 ] + t [ 1 ] ;
else r e t u r n sum ( t , n / 2 ) + sum(& t [ n / 2 ] , n / 2 ) ;
}

Figure 4. A vector parallel sum in X86
sum :

pushq
pushq
subq
cmpq
jne
movq

%r b x
%rbp
$8 , %r s p
$2 , %rbp
.L2
8(% r b x ) , %r a x

/ / save t
/ / save n
/ / a l l o c a t e tmp
/ / i f (n!=2)
/ / goto . L 2
/ / a= t [ 1 ]

addq
jmp
shrq
call
movq
leaq

.L2 :

(%r b x ) , %r a x
.L3
%rbp
sum
%rax , 0(% r s p )
(%rbx ,%rbp , 8 ) , %r b x

/ / a+= t [ 0 ]
/ / goto . L 3
/ / n=n / 2
/ / a=sum ( t , n / 2 )
/ / tmp=a
/ / t =& t [ n / 2 ]

.L3 :

call
addq
addq
popq
popq
ret

sum
0(% r s p ) , %r a x
$8 , %r s p
%rbp
%r b x

/ / a=sum(& t [ n / 2 ] , n / 2 )
/ / a+=tmp
/ / f r e e tmp
/ / restore n
/ / restore t
/ / return a

Recently, Sharafeddine, Jothi and Akkary [9] have proposed an architecture able to partition a run into
a few concurrent threads. Fork occurs when the leading thread runs a call instruction.
Figure 5 shows two runs of sum applied on a 16 elements vector. Figure 5(a) shows a parallel run
forking on every call. It creates 15 parallel threads shown on the diﬀerently coloured blocks. The plain
arrows are the inter-paths communications moving partial sums to upper levels. The dashed arrows are the
fork links due to call instructions. The heights of the blocks are related to their estimated run times.
Figure 5. Comparing two runs of the sum reduction on a vector of 16 elements
16
8

0+1+2+3

4

4+5+6+7

16

8+9+10+11
12+13+14+15

4
2

8
2

2

8
2

4
0+1
4

4+5

2+3

4

8+9

4
6+7

10+11

12+13
14+15

p0
33i

p1
15i

p2
5i

p3
22i

p4
15i

p5
5i

p6
5i

p7
29i

p8
15i

p9
5i

p10 p11 p12 p13 p14
22i 15i 5i
5i
5i

(a) Our forking model parallel run

p0
100i

p1
96i

p2
5i

(b) Sharafeddine forking parallel run

Figure 5(b) shows how the same program would be parallelized by the Sharafeddine, Jothi and Akkary
proposal. As only the leading thread may fork, the run is divided into three parallel paths, blue, red and
green (the division in blocks is not meaningful anymore; only the colours are). As a comparison, an actual
core run would form a single block trace with sequentializing stack management instructions.
The trace has 27n/2 − 16 instructions (n is the vector size), run in 8n − 10 cycles when all the dependencies are preserved (sequential run) and in 3(log n − 1) cycles when the dependencies are removed (parallel
run). The sequential ILP is bounded by 27/16 = 1.6875 and the parallel ILP is a function of n/ log n. For
n = 1024, we measured an ILP of 1.68761 for the sequential run and 476.138 for the parallel run.
Figures 6 compares the ILP reached for eight high ILP cBench benchmarks (ILP>100) and the sum
example on ﬁve models. The parallel model removes the three sets of dependencies and the sequential
model preserves them all. The other models are constrained versions of the parallel model. The fetch
model removes two of the three constraints, preserving the control dependencies. The memrename model
preserves the memory WAR and WAW false dependencies. The truedep model preserves the non volatile
registers RAW true dependencies (including RSP). Section 3 details the simulated models.
The parallel model is the optimal ILP when only producer/consumer dependencies schedule the run.
At the opposite the sequential model gives the ILP an actual core has a chance to capture. The three
intermediate models show the ILP improvement when a single source of sequentialization is removed.
As the two leftmost red and green bars of the ﬁgure show, fetch is the main sequentializing factor
(except for sum where it is the true dependencies on the RSP register). However, only removing the control
dependencies still limitates the ILP. For example in qsort1 the ILP is no better than 40 when any of the
three dependencies is left and jumps to over 375 when all are removed.

Bernard Goossens and David Parello / Procedia Computer Science 18 (2013) 1664 – 1673
Figure 6. Sum and 8 cBench benchmarks ILP on 5 models: sequential, fetch, memrename, truedep and parallel
cBench ILP
10000
sequential
fetch
memrename
truedep
parallel

ILP

1000

100

10

1

e
2
p
i
z
b

1
t
r
o
s
q
r
e
h
t
i
d
f
f
i
t

e
_
n
a
s
u
s

s
_
n
a
s
u
s

c
_
n
a
s
u
s

c
_
g
e
p
j

4
2
0
1
m
u
s

The rest of the paper is organized as follows. In section 2 we present a novel running model to dynamically parallelize a computation. Its aim is to i) exhibit the remaining sequentializing locks and ii) to evaluate
the ILP capture potential when the locks are removed. In section 3 we describe an experimental framework
to measure the model potential on the cBench benchmarks suite and we report our experimental results.
We also show that one of the remaining lock to parallelization is the compiler. When the benchmarks
are recoded, the proportional ILP on increasing data sets proves that parallelization in the novel model is
eﬀective. In section 4, we review the main known results on ILP aiming to dynamic parallelization.
2. A model to run a program in parallel.
The proposed new model is called the forking model. It has three parts. First, the fetch is parallelized
by forking calls. Second, the spawned parallel paths rename in parallel. Third, instructions are run in
parallel, following the dependency graph drawn by the parallel renaming phase.
The key points are i) forking on calls propels to very distant parts of the run, allowing to catch distant
ILP, ii) parallel renaming renames fastly all the destinations, allowing to match soon distant dependencies,
iii) writing to a destination starts new consuming computations independent of the overwritten value.
2.1. Removing control dependencies and stack management true dependencies.
In the forking model, when a call is run a second parallel path of computation starts. The two paths are
control independent. Mispredictions in one path do not impact the control ﬂow in the other path.
A path is the set of instructions from a call until the next return, crossing callers to callees frontiers
(diﬀerent from function instructions from entrance to exit).
The part up to the call and its continuation in the callee belong to the same path. Arguments transmissions are local. The part after return is the forked path. Result transmission requires an inter-path
communication. Non volatile registers (among which the stack pointer) are duplicated in both paths at fork
time. Return address and preserved registers are not saved in the stack.
Stack pointer duplication makes both paths manage the stack independently. Inside each parallel path,
true dependencies on the stack pointer when involving a constant are removed by its propagation. Constant
propagation was proposed by Fahs, Rafacz, Patel and Lumetta [3] to remove some RAW dependencies.
Paths are chronologically ordered. Such an order is maintained at fork time. The forked path becomes
the forking path successor. Formally a path successor is ﬁxed according to the following procedure:
• When a path p forks, it allocates a unique new number q for the created fall through path.
• Path p transmits its successor number s to the created path q (q successor is s).
• Path p updates its successor number as the allocated number q (p successor is q).
On ﬁgure 5(a), for any i, path Pi unique successor is path Pi+1 . The sequential trace is recomposed
when travelling from left to right and concatenating the paths in increasing order of their numbers. Path P0

1667

1668

Bernard Goossens and David Parello / Procedia Computer Science 18 (2013) 1664 – 1673

contains the full recursive descent, forking successively paths P7 , P3 and P1 . Hence, path P0 successor is
ultimately path P1 . Path P7 creates successively paths P14 , P10 and P8 . Eventually, path P8 is the successor
of path P7 . Path P8 inherits P10 as a successor when created by P7 (P10 is P7 successor at this time) and it
transmits it to path P9 , thus path P9 is path P8 successor and path P10 is path P9 successor.
2.2. Speculative and non-speculative forks.
A call may fork when it reaches its write-back phase (speculative) or when it reaches its commit phase
(non-speculative). A speculative path may be later conﬁrmed or cancelled. A path only impacts itself or
its successors and never its predecessors, which implies straightforward cancellation. The speculative fork
model consumes more resources than the non-speculative one.
When a path has renamed its last register destination, it is ready to export its registers renamings to
successors. We say it is rre-ready. Independently, when it has renamed its last memory destination, it is
ready to export its memory renamings. We say it is mre-ready.
For any path q we consider the set rrq of adjacent paths preceding q which are rre-ready. When the
predecessor p of the ﬁrst path in rrq becomes rre-ready, set rrq is extended to p and its set rr p . Similarly,
we consider the set mrq of adjacent paths preceding q which are mre-ready.
2.3. Removing false memory dependencies.
Renaming memory removes false memory dependencies. The OS/hardware already renames at the
page size granularity with virtual to physical addresses translations. Moshovos and Sohi proposed memory
renaming in [7], using a predictor to ﬁnd the store renaming a load.
Sources renamings are done in two steps. A local renaming is tried ﬁrst. If it fails, a global search of
the producing path follows, i.e. the one holding the most recent renaming as illustrated on ﬁgure 7.
Part (a) shows two independent local renamings in paths P1 and P6 . Part (b) (non related to part (a))
shows two global renamings and imports (a global renaming triggers an import request; the imported data
is sent by the producing path when available). P6 imports from P4 (because P5 does not hold a) and P1
imports from P0 independently. The imported values are the good ones because they belong to the rri set
(resp. mri ) of importing path i, even though previous paths are not rre-ready (resp. mre-ready) (e.g. P1 ).
Part (c) illustrates two diﬀerent situations. First, P1 imports a which is not set in P0 (no path in mrP1 writes
to a, i.e. path P0 does not write to a). The value is read from memory. Second, P6 references a but no
path in mrP6 (i.e. paths P2 to P5 ) holds any a. P6 leaves this renaming (but continues next renamings) and
retries each time set mrP6 is extended. In the shown example, when P1 becomes mre-ready, P6 renames a
and either import it from P1 (if P1 updates a) or read it from memory (if P1 does not write to a).
Figure 7. Parallel renamings
(a) parallel local imports
rre/mre ready

(b) parallel global imports

(c) memory import and import wait

p0

p1

p2

p3

p4

p5

p6

p7

p0

p1

p2

p3

p4

p5

p6

p7

y

n

y

y

y

y

n

n

y

n

y

y

y

y

n

n

a=0
...
a++

a=0
...
a++

a=0 a++

a=0 a++ −

a++

M

p0

p1

p2

p3

p4

p5

p6

p7

y

n

y

y

y

y

n

n

−

b=a

−

−

−

−

a++
wait(p1)

3. Experimental framework.
We have simulated the forking model on the cBench suite. The aim was to discover possible remaining
sequentializing factors and, after some modiﬁcations, to get as close as possible to the parallel model.
All experiments were based on the PerPI (Performance et Parallélisme d’Instructions) tool [4] we have
developed to analyse ILP distribution. The PerPI tool is an open source simulator downloadable at url
http://perso.univ-perp.fr/david.parello/perpi/. It is brieﬂy described in the next subsection 3.1.
The experiments were run on a cluster of 15 Intel(R) Xeon(R) 5148 dual core processors with a 64bit Linux Red Hat 3.4.6-3 (kernel 2.6.9-55)2 . The cBench benchmarks were run on datasets presented in
subsection 3.2. The compiler used was gcc version 3.4.6 with -O3 optimization level.
2 We used a distant server available in our university. The installed compiler version is three-years old. It does impact the brute
results but not the observations and conclusions of this work

Bernard Goossens and David Parello / Procedia Computer Science 18 (2013) 1664 – 1673

Subsection 3.3 describes the conditions set to simulate the various models. Subsection 3.4 gives the
speciﬁc constraints implemented to simulate the forking model. Subsection 3.5 reports and discusses the
ILP reached by the forking model on the original cBench codes. Subsection 3.6 describes a modiﬁed qsort
and shows that some easy sources modiﬁcations increase the forking model ILP to bring it closer to the
parallel model ILP. Subsection 3.7 explains why speculative forking should be favoured.
3.1. The PerPI simulator.
PerPI is a PIN-based tool [6]. A PIN tool interacts with the real processor to instrument the running
code with a tool-deﬁned analysis routine. This routine uses PIN observation primitives. These primitives
are called by the tool to maintain statistic counters along the run.
The PerPI analysis routine computes the number of instructions run in the analyzed code. It also determines at which cycles the next analyzed instruction can be fetched, renamed, issued, executed, its results
can be written back and eventually committed. These cycles are computed according to parameterized constraints (e.g. fetch in the same cycle as the preceding instruction if it belongs to the same basic block or in
the next cycle otherwise). When no constraint applies as in the parallel model, an instruction is fully treated
(from fetch to commit) in the cycle following the latest source byte production (cycle 1 if the instruction
has no source). The largest computed cycle is the duration of the run. At the end of the analysis, the ratio
of the number of instructions run over the number of cycles of the run gives the ILP.
3.2. The cBench benchmark suite and the choosen data sets.
Table 1. List of the benchmarks and their data sets
name
bitcount
qsort1
susan c
susan e
susan s
bzip2d
bzip2e
jpeg c
jpeg d

#instructions
53363281
17804639
251780961
470180952
1107439475
547447796
976496565
322907133
698020895

data set
12
16
12
6
14
6
7
15
3

name
lame
tiﬀ2bw
tiﬀ2rgba
tiﬀdither
tiﬀmedian
dijkstra
patricia
rsynth
stringsearch

#instructions
462281279
772934542
759074613
1225711010
697312196
1254296629
1075956266
5854942453
238298343

data set
12
11
11
11
11
10
20
3
4

name
blowﬁsh d
blowﬁsh e
rijndael d
rijndael e
sha
adpcm c
adpcm d
crc
gsm

#instructions
867818630
863039814
397502848
404450625
201771939
318315630
269869436
543014422
1016605701

data set
4
4
4
4
4
2
2
2
20

Table 1 gives the list of the 27 benchmarks in the cBench suite with the associated data set3 . The data
set giving the closest to 1G instructions trace was choosen. Each benchmark was run only once (cBench
iteration factor ﬁxed at 1), leading to the run length shown (from 17M instructions to 5.8G instructions).
3.3. Simulation of the various models.
PerPI computes the run cycle of next instruction, applying diﬀerent constraints (shown on table 2)
according to the model. Run latency is one cycle (perfect caches and single cycle functional units).
A write to register byte rb (resp. memory byte mb ) updates a matching integer w[rb ] (resp. w[mb ]) in
the simulator. w[rb ] (resp. w[mb ]) holds the last write cycle to rb (resp. mb ). A read from mb updates r[mb ]
in the simulator. r[mb ] holds the last read cycle from mb .
The nvtd (non volatile register true dependency) constraint means that any instruction reading a non
volatile register rb last written at w[rb ] is run at cycle w[rb ] + 1. When the constraint partially applies, PerPI
saves the w[rb ] entry upon call and restores it upon the matching return. As such, the caller path after return
is not RAW-dependent on the callee’s path for non volatile registers.
The mfd (memory false dependency) constraint means that any instruction writing to a memory byte
mb last read at cycle r[mb ] and last written at cycle w[mb ] is run at cycle max(r[mb ], w[mb ]) + 1. When the
constraint does not apply, memory is renamed and memory writes are independent from previous accesses.
The bbf (basic block fetch) constraint means that any instruction is run after its basic block is fetched.
Each taken branch increments the global fetch cycle. When the constraint does not apply, fetch is not
considered (an instruction is run when its last source byte is produced, not considering the control). In the
forking model, it partially applies as explained in the next subsection.
3 The

number matches the data set number used in the cBench distribution.

1669

1670

Bernard Goossens and David Parello / Procedia Computer Science 18 (2013) 1664 – 1673

Table 2. Set of constraints per model: (n) does not apply, (y) applies and (p) partially applies
model
forking
parallel
sequential

nvtd
p
p
y

mfd
n
n
y

bbf
p
n
y

model
fetch
memrename
truedep

nvtd
p
p
y

mfd
n
y
n

bbf
y
n
n

3.4. Simulation of the forking model.
The PerPI simulator was adapted to the forking model. Fetch is constrained as in the sequential model
(bbf constraint partially applies). When a call forks, the forked path starts fetching one cycle after the
call run or commit. In the speculative forking model, fork occurs after the call instruction writes back
(speculative fork). In the non-speculative forking model, fork occurs after the call instruction commits.
The forking model parallel renaming is simulated. A register source in instruction j cannot be renamed
before the destination it reads from in instruction i and all the registers destinations in instructions from i to
j have been renamed. The same constraint applies to memory sources (renaming of the computed address).
3.5. Simulation results.
Figure 8.
cBench ILP

cBench ILP

10000

10000
sequential
non_speculative_fork
speculative_fork
parallel

sequential
non_speculative_fork
speculative_fork
parallel
1000

ILP

ILP

1000

100

100

10
10

1

6

09

_4

4

02

56

_1

rt

so

_q

my
rt

_2

rt

so

_q

my

4

38

so

_q

my

96

16

m.

su

40

m.

24

10

2e

ip

bz

er

th

t1

or

qs

e

di

n_

ff

ti

s

n_

sa

su

c

n_

sa

su

_c

sa

su

4

02

eg

jp

m1

su

m.

su

su

1

(a) sum and 8 cBench benchmarks ILP on the forking and parallel (b) sum and qsort (modiﬁed code) ILP on the forking and paralmodels
lel models for various data sets

Figure 8(a) shows the ILP reached in the forking models compared to the parallel ILP potential for 8
high ILP benchmarks of the cBench suite (and sum). The non-speculative forking model mostly gives an
ILP close to the sequential model. For tiﬀdither, non-speculative forking is worse than a sequential run.
Subsection 3.7 helps to understand why. The speculative forking model gives better results, between the
sequential model and the parallel model, but still far from it.
In these benchmarks, the high parallel model ILP comes either from parallelized function calls or from
parallelized loop iterations. In the parallel model, as the fetch is not considered, calls and loops are equally
parallelized. In the simulator of the forking model, only calls are. From actual gcc translations of loops, it
is not possible to tag loops entrances and to ensure every loop has a single exit. With a compiler organizing
suitable loops, the forking model could fork on each loop entrance, separating in two concurrent threads
the path in the loop and the path after exit. Non suitable loops would be tagged by the compiler not to fork.
Forking on loops has a high parallelizing impact for nested loops with independent iterations. Each
outer iteration runs in a separate thread. A fork occurs when the outer loop is entered, running the full loop
in the forking thread and the code after loop exit in the forked thread. A second fork is done when the inner
loop is entered. The forking thread runs the full inner loop (outer loop ﬁrst iteration) and the forked thread
runs the outer loop second iteration preparation. The next entrance in the inner loop forks again. A new
fork occurs every other cycle, starting a new concurrent outer loop iteration.
3.6. The forking model ILP on modiﬁed codes.
The qsort benchmark should have a high ILP in both parallel and forking models as its parallelism
comes from a divide-and-conquer recursion. However as ﬁgure 8(a) shows, the forking model ILP is less

Bernard Goossens and David Parello / Procedia Computer Science 18 (2013) 1664 – 1673

than 40 when the parallel ILP is over 375. This low ILP is due to the qsort source code which is “optimized”
to remove the 2-branches source recursion and replace it by a “goto” loop. The parallel model is only
constrained by the producer/consumer dependencies and the run is parallelized. However, in the forking
model the basic block fetch constraint applies to the successive branches, sequentializing the run. The
forking model is able to parallelize only when the source code is turned back into a 2-branches recursion.
Figure 8(b) shows the speculative forking model ILP reached for sum and for a modiﬁed qsort program
applied to increasing data sizes (1K, 4K and 16K summed integers for sum and 256, 1K and 4K sorted
integers for qsort). The ILP improvement proportional to the data size indicates that the model parallelizes
the run. In the sum example, the speculation does not increase the ILP. Moreover, the speculative forking
model ILP is slightly less than the parallel model one, due to the fetch constraint. The ﬁnal ILP is related to
the recursive descent depth, involving a branch and a call. These control ﬂow instructions add delay cycles
to the fetch which impacts the run and at the end the ILP. For the qsort program, ﬁgure 8(b) shows that
the speculative forking model is as good as the parallel model. The fetch constraint does not impact the
speculative forking model ILP. The non-speculative forking model also parallelizes as the increasing ILP
shows. However, the ILP is far beyond the speculative forking one as explained in the next section.
The gcc compiler does not help the forking model when it inlines functions or eliminates recursion.
The caller-callee communication protocol used by gcc places the arguments in volatile registers (RSI and
RDI in the x86 ISA). If the arguments should be recovered after return, the compiler saves them in non
volatile registers (RBX and RBP) which are saved on the stack. In the forking model, the ILP would be
improved if the compiler would transmit the arguments directly through the non votatile registers. The
save/restore movements along the registers and through the stack add parasitic RAW dependencies.
3.7. What is the diﬀerence between the speculative forking model and the non-speculative one?
As ﬁgure 8(a) shows, the non-speculative forking model is never able to parallelize, except for the sum
example. Surprisingly, it is able to parallelize a divide-and-conquer sum but not a divide-and-conquer sort.
Figure 9 is a quicksort implementation in C. This example illustrates the diﬀerence between speculative
and non-speculative forking models. The moveleft and moveright functions are not given. They travel along
the partition, from m to n (moveright) or n to m (moveleft) until t[i]>k (moveright) or t[i]<=k (moveleft).
The basic block fetch constraint impacts taken branches and calls. It delays forks. The quicksort code is
a binary tree of partition function calls. The root call partitions the full vector in two (disjoint) sub-vectors.
Level i partitions the 2i sub-vectors in parallel into 2i+1 sub-vectors. In the parallel model, all the partition
calls in the tree start simultaneously at cycle 1. In the forking model, only the root partition starts at cycle
1. Level 1 “left” partition starts after root partition has been fully fetched and “right” partition starts later.
In the forking model, level i is sequentialized after level i − 1 fetch but level i “left” partition is parallelized with level i “right” partition. Due to the basic block fetch constraint, partition is fetched in at least
d cycles, where d is the number of iterations of the longest travel among moveleft and moveright (d ranges
from p/2 to p, with p being the partitioned sub-vector length). The latest partition fork occurs after a
maximum delay D equal to the sum of d lengths along the partition tree descent. D is in [2n − 1, n ∗ log(n)].
Figure 9. C code for qsort
long p a r t i t i o n ( long m, long n , long k ) {
long i , j ;
i f (m>n ) r e t u r n n ;
i = m o v e r i g h t (m, n , t [m] , k ) ;
j = m o v e l e f t ( n ,m, t [ n ] , k ) ;
i f ( i > j ) return j ;
swap ( i , j ) ;
r e t u r n p a r t i t i o n ( i +1 , j − 1 , k ) ;
}

void q u i c k s o r t ( long m, long n ) {
long j ;
i f (m<n ) {
swap ( (m+n ) / 2 ,m) ;
j = p a r t i t i o n (m+1 ,n , t [m ] ) ;
swap (m, j ) ;
q u i c k s o r t (m, j − 1 ) ;
q u i c k s o r t ( j +1 ,n ) ;
}

In each partition call, vector entries may be swapped. Swapping is implemented as memory locations
loads and stores. Thanks to partitioning, a level i load is independent from the stores in level i preceding
partition calls. But it depends on levels 0 to i − 1 stores. Assume a level i load l depends on a level 0 store
s (it was swapped at level 0 and never moved since). The load l address should be renamed with the level
0 matching store s name. However, intermediate stores should also be renamed, i.e. the swaps in the nodes
at the left of load l in the binary tree. Stores are fetched after the partition call they belong to has been

1671

1672

Bernard Goossens and David Parello / Procedia Computer Science 18 (2013) 1664 – 1673

forked. The latest ones are fetched and renamed after a delay D. Hence, load l is also renamed after at least
the same delay D, even though store s has been renamed sooner. Load l cannot be run until store s is done
and all stores from s to l are renamed. In the parallel model, the renaming constraint does not delay load l
as all the renamings are done before start. In the forking model, the delay is up to D.
If load l controls moveright loop, its late renaming impacts the comparison instruction run cycle which
impacts the commit cycle of the conditional branch b ending moveright. Thus, in the non-speculative
forking model (fork at call commit) the level i calls fork only after the delay D. In the speculative forking
model (fork at call write-back), the level i calls fork after run, i.e. in the same cycle they are fetched as
they depend on no source. Level i “left” partition call occurs one cycle after the basic block ended by b is
fetched. This fetch is not related to the comparison output. Only the conditional branch run is.
Hence in the speculative forking model, the second half of the run (right sub-tree) starts with a delay
d related to the level 0 moveleft/moveright travel (d < n). In the non-speculative model, the second half of
the run starts with a delay D related to the latest store renaming in the ﬁrst half of the run (D < n ∗ log(n)).
In the non-speculative forking run of tiﬀdither, some memory renamings are so much delayed that some
accesses occur later than in the sequential model run in which these accesses are only constrained by the
previous reads or writes to the same locations (no memory renaming in the sequential model).
The sum program run contains very few stores (partial sum saving in the stack) which are not involved in
the control. On the other hand, the qsort program run is made of stores controlling the partitioning process.
As ﬁgure 8(b) shows, the sum run is not sensitive to the speculation and the qsort run is. Speculative
forking model is closer to the parallel model because by forking sooner, it is closer to the parallel model
starting point assuming a computed full trace and a full renaming of the destinations. In the speculative
forking model, we quickly spawn speculative traces among which resides the ﬁnal trace. The correct trace
selection is based on speculation rather than computation. In the non-speculative forking model, we only
follow the single correct trace, relying on the computation to control it.
Speculative forking model is like speculative branches in out-of-order speculative cores. Speculative
execution uselessly consumes functional units every time a branch is mispredicted by running the wrongly
predicted path. However, non-speculative execution results in poor out-of-order running performance. In
the same manner, non-speculative forking does not parallelize. Speculative forking should be preferred,
even though it would uselessly consume cores and bandwidth every time a branch is mispredicted.
4. Related works on the route to automatic parallelization.
In the 70’s, the focus was on a single basic block parallelization. Machines with very few available registers led to highly dependent instructions. False register dependency removal was introduced by Tomasulo
in [13] with reservation stations. This helped to parallelize the register computations of independent expressions within a basic block. In 1970, Tjaden and Flynn [12] proposed a decoding algorithm to separate
independent ready instructions from dependent non issuable ones. This was the basis of renaming.
In the 80’s, researchers tried to parallelize beyond the basic block frontier. Branch predictors would
naturally extend the parallelized code portion up to the next incorrect prediction. In 1985, Smith and
Pleszkun in [10] introduced the reorder buﬀer to allow both speculative execution and precise interrupt
management. In 1987, Sohi in [11] combined reservation stations, a reorder buﬀer and a load/store queue
in a dynamically scheduled design. The load/store queue partially renames memory.
In 1990, Wall presented the ﬁrst study centered on ILP[14]. He measured that the available parallelism
a “real” processor ﬁnds in 13 benchmarks (6 from the SPEC89 suite) is 5 on average, ranging from 3
to 45 4 . In an “ideal” processor 5 , ILP ranges from 6 to 60 with an average at 25. From this study, we
know that there is ILP but it seems impossible to catch more than 5 independent instructions per cycle. In
1992, Austin and Sohi [1] measured the SPEC89 suite ILP and analyzed its distribution. They showed that
ILP is arbitrarily distant from the instruction pointer. They also pointed out the serializing eﬀect of the
stack manipulations. It became clear that ILP should be divided into two diﬀerent categories: independent
4 “Good” model with a 2K instructions window size, 64 instructions issued per cycle, 256 renaming registers, a branch predictor
based on an inﬁnite number of 2-bits counters and a perfect memory aliasing desambiguation
5 “Perfect” model enhancing “Good” model with inﬁnite renaming and perfect branch prediction.

Bernard Goossens and David Parello / Procedia Computer Science 18 (2013) 1664 – 1673

instructions close to the instruction pointer (“close” means at a distance ranging from one instruction to a
few hundreds) and farther instructions. The same year, Lam and Wilson [5] studied the impact of control on
ILP. Their measures showed that a processor with a perfect branch predictor could dramatically improve its
performance. As in Austin and Sohi work, distant ILP was detected. To capture this distant ILP, a processor
must be able to speculate on the control ﬂow and use multiple instruction pointers.
In 1999, Postiﬀ, Greene, Tyson and Mudge [8] measured SPEC95 suite ILP. They pointed out that the
stack introduces a lot of parasitic dependencies. To capture distant ILP, the application should be multithreaded, either statically or dynamically. In 2005, Fahs, Rafacz, Patel and Lumetta [3] proposed hardware
improvements to the renaming stage, allowing the renaming of constants in i++ like instructions and the
removal of register to register moves. Constants renaming removes true data dependencies in loop control
which allows to start successive iterations in the same cycle, which acts as an automatic vectorization. In
2012, Sharafeddine, Jothi and Akkary [9] proposed an architecture to partition a run into parallel threads,
forking at call. However, only the leading thread may fork. In the sum example this would lead to fork on
both of the highest levels recursive calls but not on the lower levels ones, not capturing the distant ILP.
5. Conclusion.
Programs implemented from parallel algorithm have a lot of ILP. Their run is sequentialized by the
computing model with the fetch policy, the usage of a stack and the lack of memory renaming. When these
constraints are removed, parallel algorithms lead to parallelizable implementations. The forking model
presented in the paper shows how the run instructions can be parallelized.
The salient features in this model are i) the forking capability at call and loop exit, fastly building many
short threads, ii) the parallel renaming which fastly ﬁxes the communications needs of the threads, and iii)
the fork at call write-back to start parallel threads soon. The speculative forking model captures all the
available ILP shown by the optimal parallel model on the quicksort program.
Extending renaming to memory addresses is the key to distant ILP capture. It opens the road to automatic parallelization, i.e. a dynamic decomposition of a run in thousands parallel threads synchronizing
and communicating according to producer/consumer dependencies. An algorithm is the expression of the
parallelism. Its implementation in any high-level language and translation with an ad hoc compiler give a
code that a forking model based running environment can parallelize without the need of any OS primitive.
References
T. M. Austin and G. S. Sohi. Dynamic Dependency Analysis of Ordinary Programs. ISCA’92, 342–351, 1992
url: http://ctuning.org/cbench
B. Fahs and T. Rafacz and S. J. Patel and S. S. Lumetta. Continuous Optimization. ISCA’05, 86–97, 2005.
B. Goossens, P. Langlois, D. Parello and E. Petit, PerPI: A Tool to Measure Instruction Level Parallelism., PARA 2010, LNCS
vol. 7133, 270–281, 2012.
[5] Monica S. Lam and Robert P. Wilson Limits of Control Flow on Parallelism. ISCA’92, 46–57, 1992.
[6] C. Luk, R. Cohn, R. Muth, H. Patil, A. Klauser, G. Lowney, S. Wallace, V. Reddi and K. Hazelwood, Pin: Building Customized
Program Analysis Tools with Dynamic Instrumentation. PLDI ’05, 190–200, 2005.
[7] A. Moshovos and G. S. Sohi Streamlining Inter-Operation Memory Communication via Data Dependence Prediction. Micro’30,
235–245, 1997.
[8] M. A. Postiﬀ and D. A. Greene and G. S. Tyson and T. N. Mudge The Limits of Instruction-Level Parallelism in SPEC95
Applications. Interact-3 workshop, CAN vol. 27-1, 31–34, 1999
[9] M. Sharafeddine and K. Jothi and H. Akkary Disjoint Out-of-Order Execution Processor. TACO Volume 9-3-19, 1–32, 2012
[10] J. E. Smith and A. R. Pleszkun Implementation of Precise Interrupts in Pilelined Processors. ISCA’12, 34–44, 1985.
[11] G. S. Sohi Instruction Issue Logic for High-Performance, Interruptible, Multiple
Functional Unit, Pipelined Computers. WTR704, 1–24, 1987, http://ftp.cs.wisc.edu/pub/techreports/1987/TR704.pdf
[12] G. S. Tjaden and M. Flynn Detection and Parallel Execution of Independent Instructions. IEEE Trans. on Comp., Vol. c-19-10,
889–895, 1970.
[13] R. Tomasulo An Eﬃcient Algorithm for Exploiting Multiple Arithmetic Units. IBM JRD, vol. 11-1, 25–33, 1967.
[14] David W. Wall Limits of Instruction-Level Parallelism. WRL TN-15, 1990, http://www.hpl.hp.com/techreports/CompaqDEC/WRL-TN-15.pdf.
[1]
[2]
[3]
[4]

1673

