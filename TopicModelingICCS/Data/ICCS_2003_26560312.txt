Concealment and Its Applications to
Authenticated Encryption
Yevgeniy Dodis1 and Jee Hea An2
1

Department of Computer Science, New York University, USA. dodis@cs.nyu.edu
2
SoftMax Inc., San Diego, USA. jeehea@cs.ucsd.edu

Abstract. We introduce a new cryptographic primitive we call concealment, which is related, but quite diﬀerent from the notion of commitment. A concealment is a publicly known randomized transformation,
which, on input m, outputs a hider h and a binder b. Together, h and b
allow one to recover m, but separately, (1) the hider h reveals “no information” about m, while (2) the binder b can be “meaningfully opened” by
at most one hider h. While setting b = m, h = ∅ is a trivial concealment,
the challenge is to make |b|
|m|, which we call a “non-trivial” concealment. We show that non-trivial concealments are equivalent to the
existence of collision-resistant hash functions. Moreover, our construction of concealments is extremely simple, optimal, and yet very general,
giving rise to a multitude of eﬃcient implementations.
We show that concealments have natural and important applications in
the area of authenticated encryption. Speciﬁcally, let AE be an authenticated encryption scheme (either public- or symmetric-key) designed
to work on short messages. We show that concealments are exactly the
right abstraction allowing one to use AE for encrypting long messages.
Namely, to encrypt “long” m, one uses a concealment scheme to get h
and b, and outputs authenticated ciphertext AE(b), h . More surprisingly, the above paradigm leads to a very simple and general solution to
the problem of remotely keyed (authenticated) encryption (RKAE) [12,13].
In this problem, one wishes to split the task of high-bandwidth authenticated encryption between a secure, but low-bandwidth/computationally
limited device, and an insecure, but computationally powerful host. We
give formal deﬁnitions for RKAE, which we believe are simpler and more
natural than all the previous deﬁnitions. We then show that our composition paradigm satisﬁes our (very strong) deﬁnition. Namely, for authenticated encryption, the host simply sends a short value b to the device
(which stores the actual secret key for AE), gets back AE(b), and outputs AE(b), h (authenticated decryption is similar). Finally, we also
observe that the particular schemes of [13,17] are all special examples of
our general paradigm.

1

Introduction

Authenticated Encryption. The notions of privacy and authenticity are well
understood in the cryptographic community. Interestingly, until very recently
E. Biham (Ed.): EUROCRYPT 2003, LNCS 2656, pp. 312–329, 2003.
c International Association for Cryptologic Research 2003

Concealment and Its Applications to Authenticated Encryption

313

they have been viewed and analyzed as important but distinct building blocks
of various cryptographic systems. When both were needed, the folklore wisdom
was to “compose” the standard solutions for two. Recently, however, the area
of authenticated encryption has received considerable attention. This was caused
by many related reasons. First, a “composition” paradigm might not always
work [7,19,2], at least if not used appropriately [2,25]. Second, a tailored solution
providing both privacy and authenticity might be noticeably more eﬃcient (or
have other advantages) than a straightforward composition [16,26,31,2,6]. Third,
the proper modeling of authenticated encryption is not so obvious, especially
in the public-key setting [2,3]. Finally, viewing authenticated encryption as a
separate primitive may conceptually simplify the design of complex protocols
which require both privacy and authenticity.
Our Main Question. Despite the recent attention to authenticated encryption, the area is so new that many fundamental questions remain open. In this
work, we study and completely resolve one such fundamental question, which
has several important applications. Speciﬁcally, assume we have a secure authenticated encryption (either symmetric- or public-key) AE which works on
“short” messages. How do we build a secure authenticated encryption AE on
“long” messages out of AE? (Throughout, we should interpret “short” as having very small length, like 256 bits; “long” stands for ﬁxed, but considerably
larger length, possibly on the order of gigabytes.) While our question was not
previously studied in the context of authenticated encryption, it clearly has rich
history in the context of many other cryptographic primitives. We brieﬂy review
some of this work, since it will suggest the ﬁrst solutions to our problem too.
First, in the context of regular chosen plaintext secure (CPA-secure) encryption, we can simply split the message into blocks and encrypt it “block-by-block”.
Of course, this solution multiplicatively increases the size of the ciphertext, so
a lot of work has been developed into designing more eﬃcient solutions. In the
public-key setting, the classical “hybrid” encryption solution reduces the problem into that in the symmetric-key setting. Namely, one encrypts, using the
public-key, a short randomly chosen symmetric key τ , and uses τ to symmetrically encrypt the actual message m. As for the symmetric-key setting, one
typically uses one of many secure modes of operations on block ciphers (such
as CBC; see [22]), which typically (and necessarily) add only one extra block of
redundancy when encrypting a long message m. For authentication, a diﬀerent
ﬂavor of techniques is usually used. Speciﬁcally, a common method is to utilize a
collision-resistant hash function [14] H 1 which maps a long input m into a short
output such that it is hard to ﬁnd a “collision” H(m0 ) = H(m1 ) for m0 = m1 .
Then one applies the given authentication mechanism for short strings to H(m)
to authenticate much longer m. This works, for example, for digital signatures
(this is called “hash-then-sign”), message authentication codes (MACs), and
pseudorandom functions (for the latter two, other methods are possible; see [5,
4,11,1] and the references therein).
1

Or, when possible, a weaker class of hash functions, such as various types of universal
hash functions.

314

Y. Dodis and J.H. An

First Solution Attempt. One way to use this prior work is to examine generic
constructions of authenticated encryption using some of the above primitives,
and apply the above “compression” techniques to each basic primitive used.
For example, in the symmetric-key setting we can take the “encrypt-then-mac”
solution [7] for authenticated encryption, the CBC mode for encryption, the
CBC-MAC [5] for message authentication, and build a speciﬁc authenticated
encryption on long messages using only a ﬁxed-length block cipher. Even better,
in this setting we could utilize some special purpose, recently designed modes
of operation for authenticated encryption, such as IACBC [16] or OCB [26].
Similar techniques could be applied in the public-key setting using the “hybrid”
technique for encryption, “hash-then-sign” for signatures, and any of the three
generic signature/encryption compositions presented by [2].
In other words, prior work already gives us some tools to build “long” authenticated encryption, without ﬁrst reducing it to “short” authenticated encryption.
Why Solving Our Problem Then? The ﬁrst reason is in its theoretical
value. It is a very interesting structural question to design an elegant ampliﬁcation from “short” to “long” authenticated encryption, without building the
“long” primitive from scratch. For example, in the public-key setting especially,
it is curious to see what is the common generalization of such diﬀerently looking
methods as “hybrid” encryption and “hash-then-sign” authentication. Indeed,
we shall see that this generalization yields a very elegant new primitive, certainly
worth studying on its own. The second reason is that it gives one more option to
designing “long-message” authenticated encryption. Namely, instead of solving
the problem by using other “long-message” primitives, and implementing these
separately, we directly reduce it to the same, but “short-message” primitive, and
implement it separately. And this may bring other advantages (e.g. eﬃciency,
ease of implementation, etc.), depending on its application and implementation.
Consider, for example, the public-key setting, where authenticated encryption
is usually called signcryption [31]. With any of the generic signature-encryption
compositions [2], signcryption of a long messages will eventually reduce to a
regular signature plus a regular encryption on some short messages. With our
paradigm, it will reduce to a single signcryption on a short message, which can
potentially be faster than doing a separate signature and encryption. Indeed,
this potential eﬃciency gain was the main motivation of Zheng [31] to introduce
signcryption in the ﬁrst place! Finally, our technique has important applications
on its own. In particular, we show that it naturally leads to a very general, yet
simple solution to the problem of remotely keyed authenticated encryption [12,
20,13] (RKAE), discussed a bit later. None of the other techniques we mentioned
seem to yield the solution to this problem.
Our Main Construction and a New Primitive. In our solution method,
we seek to amplify a given “short” authenticated encryption AE into a “long”
AE as follows. First, we somehow split the long message m into two parts
(h, b) ← T (m), where |b|
|m|, and then deﬁne AE (m) = AE(b), h . Which
transformations T suﬃce in order to make AE a “secure” authenticated encryption if AE is such? We completely characterize such transformations T , which

Concealment and Its Applications to Authenticated Encryption

315

we call concealments. Speciﬁcally, we show that AE is secure if and only if T is
a (relaxed) concealment scheme.
Our new notion of concealments is remarkably simple and natural, and deﬁnes
a new cryptographic primitive of independent interest. Intuitively, a concealment
T has to be invertible, and also satisfy the following properties: (1) the hider h
reveals no information about m; and (2) the binder b “commits” one to m in a
sense that it is hard to ﬁnd a valid (h , b) where h = h. Property (2) has two
formalizations leading to the notions of regular and relaxed concealment schemes.
Relaxed concealments suﬃce for the composition purposes above, but we will
need (strong) regular concealments for the problem of RKAE, brieﬂy mentioned
earlier and discussed shortly. We remark that concealments look very similar to
commitment schemes at ﬁrst glance, but there are few crucial diﬀerences, making
these notions quite distinct. This comparison will be discussed in Section 2.
Finally, we are left with the question of constructing concealment schemes.
First, we show that non-trivial (i.e., |b| < |m|) concealment schemes are equivalent to the existence of collision-resistant hash functions (CRHFs). In particular,
our construction from CRHFs is very simple, eﬃcient and general, giving rise to
many optimal implementations. Speciﬁcally, |h| ≈ |m|, while |b| is only proportional to the security parameter. In fact, one special case of our construction looks
very similar to the famous Optimal Asymmetric Encryption Padding (OAEP) [8].
Our construction replaces two random oracles G and H used in this variant of
OAEP by a pseudorandom generator and a collision-resistant hash function, respectively. Thus, having a well established goal in mind, we essentially found
an application of (slightly modiﬁed) OAEP, where we can provably eliminate
random oracles in the analysis. More from a theoretical point of view, we also
give a useful, but slightly less eﬃcient construction of relaxed concealments from
a somewhat weaker notion of universal one-way hash functions (UOWHF) [24].
In principle, this shows that relaxed concealments can be constructed even from
regular one-way functions [27], thus separating them from regular concealments
by the result of Simon [30].
Remotely Keyed Authenticated Encryption: History. The problem of
“remotely keyed encryption” (RKE) was ﬁrst introduced by Blaze [12] in the
symmetric-key setting. Intuitively, RKE is concerned with the problem of “highbandwidth encryption with low bandwidth smartcards”. Essentially, one would
like to store the secret key in a secure, but computationally bounded and low
bandwidth Card, while to have an insecure, but powerful Host perform most
of the operations for encryption/decryption. Of course, the communication between the Host and the Card should be minimal as well. The original work of
Blaze lacked formal modeling of the problem, but inspired a lot of subsequent
research. The ﬁrst formal modeling of RKE was done by Lucks [20], who chose
to interpret the question as that of implementing a remotely key pseudorandom
permutation (or block cipher), which we will call RKPRP. Lucks’ paper was
further improved —both in terms of formal modeling and constructions— by
an inﬂuential work of Blaze, Feigenbaum and Naor [13]. For one thing, they
observed that the PRP’s length-preserving property implies that it cannot be

316

Y. Dodis and J.H. An

semantically secure when viewed as encryption. Thus, in addition to RKPRP,
which they called a “length-preserving RKE”, they introduced the notion of a
“length-increasing RKE”, which is essentially meant to be the notion of remotely
keyed authenticated encryption, so we will call it RKAE. In other words, the informal notion of “RKE” was really formalized into two very distinct notions of
RKPRP and RKAE, none of which is really a plain encryption. Blaze et al. [13]
gave formal deﬁnitions and constructions of RKAE and RKPRP, and the latter’s
construction was subsequently improved by [21].
While the RKAE deﬁnition of [13] was an important and the ﬁrst step towards
properly formalizing this new notion (as opposed to the notion of RKPRPs), their
deﬁnition is convoluted and quite non-standard (it involves an “arbiter” who can
fool any adversary). For example, it looks nothing like the formal, universally
accepted notion of regular (not remotely keyed) authenticated encryption [18,10,
7]. Of course, this has a very objective reason in that the above formal deﬁnition
appeared after the work of [13]. Additionally, at the time Blaze et al. perhaps
tried to make their deﬁnition of “length-increasing RKE” look as close as possible
to their deﬁnition of “length-preserving RKE” (i.e., RKPRP) also studied in that
paper, since the latter was the previously considered notion. Still, we believe that
the deﬁnition of RKAE should be based on the deﬁnition of regular authenticated
encryption, rather than try mimicking the deﬁnition of a somewhat related, but
diﬀerent concept. Thus, we will give what we feel is a simpler and more natural
such deﬁnition, which looks very close to the deﬁnition of regular authenticated
encryption. Additionally, we naturally extend the whole concept of RKAE to the
public-key setting, since it is equally applicable in this case too.2 Notice, in this
setting the notion of RKPRP makes no sense, which additionally justiﬁes our
choice to base our deﬁnition on that of regular authenticated encryption.
To ﬁnish oﬀ with the related work, we ﬁnally mention the work of Jakobsson
et al. [17], who also eﬀectively studied the problem of RKAE (even though still
calling it RKE despite considering authentication as part of the requirement).
We note that the deﬁnition of [17] looks much closer to our new formalization.
However, there are still signiﬁcant diﬀerences that make our notion stronger.3
For example, [17] do not support chosen ciphertext attack in its full generality
(i.e., no Card access is given to the adversary after the challenge is received),
and also require the adversary to “know” the messages corresponding to forged
ciphertexts. Finally, we mention that their main scheme uses an “OAEP”-like
transform, and their security analyses critically use random oracles. As we show,
using another simple variant of OAEP for RKAE, we can eliminate random oracles from the analysis.
Our Contribution to RKAE. As we mentioned, we give a simple and natural deﬁnition of RKAE, which we feel improves upon the previous deﬁnitions.
2
3

In this abstract, though, we will restrict ourselves to the symmetric-key setting.
Except both [17] and [13] insist on achieving some kind of pseudorandomness of the
output. Even though our constructions achieve it as well, we feel this requirement is
not crucial for any application of RKAE, and was mainly put to make the deﬁnition
look similar to RKPRPs.

Concealment and Its Applications to Authenticated Encryption

317

In addition, we show that our construction of “long-message” authenticated encryption from that of “short-message” authenticated encryption provides a very
natural, general, and provably secure solution to the problem of RKAE. Recall,
we had AE (m) = AE(b), h , where (h, b) was output by some transformation
T , and |b|
|m|. This immediately suggests the following protocol for RKAE.
The Host computes (h, b) and sends short b to the Card, which stores the secret key. The Card computes short c = AE(b) and sends it to the Host, which
outputs c, h . Authenticated decryption is similar. Again, we ask the question
which transformations T will suﬃce to make this simple scheme secure. Not
surprisingly, we get that concealment schemes are necessary and suﬃcient, even
though in this case we do need regular (“non-relaxed”) concealments. We believe
that our result gives a general and intuitively simple solution to the problem.
Also, it generalizes the previous, so “diﬀerently looking” solutions of [13,17],
both of which can be shown to use some particular concealment and/or “short”
authenticated encryption.
Extensions. All our techniques naturally support authenticated encryption
with associated data [25], which we explain in the sequel. In fact, this distinction
makes our composition paradigm even slightly more eﬃcient. Also, we remark
again that all our results apply to both the public- and the symmetric-key authenticated encryption. The only exception is the following extension that makes
sense only in the symmetric-key setting. We study the question of whether we
can replace our “short” authenticated encryption AE by a (strong) pseudorandom permutation (i.e., a block cipher, since AE is applied on short inputs),
which would enhance the practical usability of our composition even more. We
show that while arbitrary concealments are generally not enough to ensure the
security of thus constructed AE , some mild extra restrictions —enjoyed by our
main concealment constructions— make them suﬃcient for this purpose.

2

Deﬁnition of Concealment

Intuitively, a concealment scheme eﬃciently transforms a message m into a pair
(h, b) such that: (1) (h, b) together reveal m; (2) the hider h reveals no information about m; and (3) the binder b “commits” one to m in a sense that it is hard
to ﬁnd a valid (h , b) where h = h. Below is a formal description.
Syntax. A concealment scheme consists of three eﬃcient algorithms: C =
(Setup, Conceal, Open). The setup algorithm Setup(1k ), where k is the security
parameter, outputs a public concealment key CK (possibly empty, but often
consisting of public parameters for C). Given a message m from the corresponding message space M (e.g., {0, 1}k ), the randomized concealment algorithm
ConcealCK (m; r) (where r is the randomness) outputs a concealment pair (h, b),
where h is the hider of m and b is the binder to m. For brevity, we will usually omit
CK and/or r, writing (h, b) ← Conceal(m). Sometimes we will write h(m) (resp.
b(m)) to denote the hider (resp. binder) part of a randomly generated (h, b). The
deterministic open algorithm OpenCK (h, b) outputs m if (h, b) is a “valid” pair
for m (i.e. could have been generated by Conceal(m)), or ⊥ otherwise. Again, we

318

Y. Dodis and J.H. An

will usually write x ← Open(h, b), where x ∈ {m, ⊥}. The correctness property
of concealment schemes says that OpenCK (ConcealCK (m)) = m, for any m and
CK.
Security of Concealment. Just like commitment schemes, concealment
schemes have two security properties called hiding and binding. However, unlike
commitment schemes, these properties apply to diﬀerent parts of concealment,
which makes a signiﬁcant diﬀerence.
– Hiding. Having the knowledge of CK, it is computationally hard for the
adversary A to come up with two messages m1 , m2 ∈ M such that A can
distinguish h(m1 ) from h(m2 ). That is, h(m) reveals no information about m.
Formally, for any PPT (probabilistic polynomial time) adversary A, which
runs in two stages ﬁnd and guess, we require that the probability below is at
most 12 + negl(k) (where negl(k) denotes some negligible function):
Pr σ = σ
˜

CK ← Setup(1k ), (m0 , m1 , α) ← A(CK, ﬁnd), σ ←r {0, 1},
(h, b) ← ConcealCK (mσ ), σ
˜ ← A(h; α, guess)

where α is some state information. We will also denote this by h(m0 ) ≈
h(m1 ).
– Binding. Having the knowledge of CK, it is computationally hard for the
adversary A to come up with b, h, h , where h = h such that (b, h) and (b, h )
are both valid concealment pairs (i.e., OpenCK (h, b) = ⊥ and OpenCK (h , b) =
⊥). That is, A cannot ﬁnd a binder b which it can open with two diﬀerent
hiders.4
We immediately remark that setting b = m and h = ∅ satisﬁes the deﬁnition
above. Indeed, the challenge is to construct concealment schemes with |b|
|m|
(we call such schemes non-trivial). Since |b| + |h| ≥ |m|, achieving a very good
concealment scheme implies that |h| ≈ |m|.
Relaxed Concealments. We will also consider relaxed concealment schemes,
where the (strict) binding property above is replaced by the Relaxed Binding
property, which states that A cannot ﬁnd binder collisions for a randomly generated binder b(m), even if A can choose m. Formally, for any PPT A, which
runs in two stages ﬁnd and collide, the following probability is at most negl(k):
Pr

h = h ∧ CK ← Setup(1k ), (m, α) ← A(CK, ﬁnd), (h, b) ← ConcealCK (m),
m =⊥
h ← A(h, b; α, collide), m ← OpenCK (h , b)

To justify this distinction, we will see later that non-trivial (strong) concealments
will be equivalent to collision-resistant hash functions (CRHFs), while relaxed
concealments can be built from universal one-way hash functions (UOWHFs). By
the result of Simon [30], UOWHFs are strictly weaker primitives than CRHFs (in
particular, they can be built from regular one-way functions [24]), which implies
4

We could have allowed A to ﬁnd h = h as long as (h, b), (h , b) do not open to distinct
messages m = m . However, we will ﬁnd the stronger notion more convenient.

Concealment and Its Applications to Authenticated Encryption

319

that relaxed concealments form a weaker cryptographic assumption than regular
concealments.
Comparison to Commitment. At ﬁrst glance, concealment schemes look extremely similar to commitment schemes. Recall, commitments also transform m
into a pair (c, d), where c is the “commitment”, and d is the “decommitment”.
However, in this setting the commitment c is both the hider and the binder,
while in our setting b is a binder and h is a hider. This seemingly minor distinction turns out to make a very big diﬀerence. For example, irrespective of
parameter settings, commitment always implies one-way functions, while there
are trivial concealments when |b| = |m|. On the other hand, when |b| < |m|, we
will show that concealments immediately require CRHFs, while quite non-trivial
commitments can be built from one-way functions [23]. Not surprisingly, the two
primitives have very diﬀerent applications and constructions. In particular, commitments are not useful for our applications to authenticated encryption (even
though they are useful for others; see [2]).

3

Constructing Concealment Schemes

In this section, we give very simple and general constructions of strong (resp.
relaxed) concealment schemes based on any family of CRHFs (resp. UOWHFs)
and any symmetric one-time encryption scheme. But ﬁrst we observe the following simple lemma, which shows the necessity of using CRHFs (resp. UOWHFs)
in our constructions. The proof is given in the full version of this paper [15].
Lemma 1. Let C = (Setup, Conceal, Open) be a strong (resp. relaxed) concealment scheme where the binder b is shorter than the message m. Deﬁne a shrinking function family H by the following generation procedure: pick a random r,
run CK ← Setup(1k ), and output CK, r as a description of a random function
H ∈ H. To evaluate such H on input m, run (h, b) = ConcealCK (m; r), and
set H(m) = b (so that |H(m)| < |m|). Then H is a family of CRHFs (resp.
UOWHFs).
In the following, we show the converse of the above observation. Even though
it is quite simple, we will crystallize it even further by splitting it into several
clean steps.
Achieving Hiding. We ﬁrst show how to achieve the hiding property so that
|b|
|m|. Later we will utilize CRHFs/UOWHFs to add strong/relaxed binding
property to any scheme which already enjoys hiding.
Recall that a symmetric encryption scheme SE = (K, E, D) consists of the key
generation algorithm K, encryption algorithm E, and decryption algorithm D.
Of course, if τ ← K(1k ), we require that Dτ (Eτ (m)) = m. For our purposes we
will need the most trivial and minimalistic notion of one-time security. Namely,
for any m0 , m1 we require Eτ (m0 ) ≈ Eτ (m1 ), where τ ← K(1k ) and ≈ denotes
computational indistinguishability. More formally, for any m0 , m1 and any PPT
A, we require
Pr σ = σ
˜

τ ← K(1k ), σ ←r {0, 1}, c ← Eτ (mb ), σ
˜ ← A(c)

≤

1
+ negl(k)
2

320

Y. Dodis and J.H. An

Of course, regular one-time pad satisﬁes this notion. However, for our purposes
we will want the secret key to be much shorter than the message: |τ |
|m|. For
the most trivial such scheme, we can utilize any pseudorandom generator (PRG)
G : {0, 1}k → {0, 1}n where k
n. The secret key is a random τ ∈ {0, 1}k , and
to encrypt m ∈ {0, 1}n we compute Eτ (m) = G(τ ) ⊕ m (to decrypt, compute
Dτ (c) = G(τ ) ⊕ c). Of course, any stronger encryption (possibly probabilistic,
such as any chosen plaintext secure encryption) will suﬃce for our purposes too.
Now, let b = τ and h ← Eτ (m), so that Open(b, h) = Db (h). It is easy to
see that this scheme satisﬁes the hiding (but not yet the binding) property of
concealment, and also that |b|
|m| if a good one-time secure encryption is
used, such as the PRG-based scheme above.
Adding Strong Binding. Assume C = (Setup, Conceal, Open) already achieves
hiding, and let H = {H} be a family of CRHFs (the lengths of inputs and outputs
needed will be clear soon). We turn C into C = (Setup , Conceal , Open ) which
is a full ﬂedged concealment scheme:
– Setup (1k ): run CK ← Setup(1k ), H ← H and output CK = CK, H .
– Conceal (m): let (h, b) ← Conceal(m), h = h, b = b H(h), and output
h ,b .
– Open (h , b ): parse b = b t, h = h and output ⊥ if H(h) = t; otherwise,
output m = Open(h, b).
We remark that H should have input size equal to the hider size |h|. Recall
that in our schemes we will always have |h| ≈ |m| (in fact, exactly equal in the
PRG-based scheme). And the output size should be small (say, O(k), where k is
the security parameter), as it directly contributes to the binder length which we
aim to minimize. The proof of the following lemma is given in the full version of
this paper [15].
Lemma 2. If C satisﬁes the hiding property and H is a CRHF, then C is a
(strong) concealment scheme.
Adding Relaxed Binding. Assume C = (Setup, Conceal, Open) already
achieves hiding, and let H = {H} be a family of UOWHFs (the lengths
of inputs and outputs needed will be clear soon). We turn C into C =
(Setup , Conceal , Open ) which is a full ﬂedged relaxed concealment scheme:
– Setup = Setup.
– Conceal (m): pick H ← H, compute (h, b) ← Conceal(m), set h = h, b =
b H(h) H, and output h , b .
– Open (h , b ): parse b = b t H, h = h and output ⊥ if H(h) = t; otherwise, output m = Open(h, b).
We see that the construction is similar to the CRHF-based construction, except
we pick a new hash function per each call, and append it to the binder b . This
ensures that H is always selected independently of the input h it is applied to,
as required by the deﬁnition of UOWHFs. Unfortunately, it also means that the

Concealment and Its Applications to Authenticated Encryption

321

construction is less attractive than the previous, more economical CRHF-based
construction. Thus, the value of this construction is mainly theoretical, since
it shows that eﬃcient relaxed concealments, unlike strong concealments, can be
built from regular one-way functions. In practice, one should certainly use the
more economical CRHF-based construction. The proof of the following lemma is
given in the full version of this paper [15].
Lemma 3. If C satisﬁes the hiding property and H is a UOWHF, then C is a
relaxed concealment scheme.
As earlier, H should have input size equal to the hider size |h|, which is
roughly |m|. Also, the output size should be small (say, O(k), where k is the
security parameter), as it directly contributes to the binder length which we
aim to minimize. Now, however, we also need the description of a UOWHF H
to be small, as it is also part of the binder. Unfortunately, the best known
constructions of UOWHFs for long messages [9,28] have |H| ≈ O(k log |m|), where
k is the security parameter and |m| ≈ |h| is the length of the input to H. While
the logarithmic dependence on the message length is not bad in theory — in
particular, we still get |b |
|m| — this is a big drawback as compared to the
previous CRHF-based construction, which achieved |b | = O(k) in addition to its
stronger binding property.
Collecting pieces together. Unifying the previous discussion, and noticing
that the existence of CRHFs or UOWHFs implies the existence of a one-time
secure symmetric encryption [24], we get:
Theorem 1. Non-trivial strong (resp. relaxed) concealment schemes exist iﬀ
CRHFs (resp. UOWHFs) exist.
In terms of a particular simple and eﬃcient construction, we get h ← Eτ (m),
b = τ H(h), where H is a CRHF, and E is any one-time symmetric encryption.
Speciﬁcally, if we set Eτ (m) = G(τ )⊕m, where G is a PRG, we get a construction
which looks amazingly similar to the famous Optimal Asymmetric Encryption
Padding (OAEP) [8], but we do not need to assume G and H as random oracles
in the analyses.

4

Applications to Authenticated Encryption

We now study applications of concealment to authenticated encryption. Recall,
the latter provides means for private, authenticated communication between the
sender and the receiver. The intuitive idea of using concealments for authenticated encryption is simple. If AE is an authenticated encryption working on short
|b|-bit messages, and (h, b) ← Conceal(m), we can deﬁne AE (m) = AE(b), h .
Intuitively, sending the hider h “in the clear” preserves privacy due to the hiding
property, while authenticated encryption of the binder b provides authenticity
due to the binding property.
We formalize this intuition by presenting two applications of the above
paradigm. First, we argue that it indeed yields a secure authenticated encryption

322

Y. Dodis and J.H. An

on long messages from that on short messages. And this holds even if relaxed
concealments are used (in fact, they are necessary and suﬃcient). Second, we
show that this paradigm also gives a very simple and general solution to remotely
keyed authenticated encryption. Here, the full power of (strong) concealments is
needed.
We remark that our applications hold for both the symmetric- and the publickey notions of authenticated encryption (the latter is historically called signcryption [31]). In terms of usability, the long message authenticated encryption
is probably much more useful in the public-key setting, since signcryption is
typically expensive. However, even in the symmetric-key setting our approach is
very fast, and should favorably compare with alternative direct solutions such as
“encrypt-then-mac” [7]. For remotely keyed setting, both public- and symmetrickey models seem equally useful and important. In fact, symmetric-key is perhaps
more relevant, since smartcards are currently much better suited for symmetrickey operations.
4.1

Deﬁnition of Authenticated Encryption

We remark that formal modeling of authenticated encryption in the public-key
setting is somewhat more involved than that in the symmetric-key setting due
to issues such as multi-user security and “identity fraud” (see [2]). However, the
proofs we present are really identical despite these extra complications of the
public-key setting. Intuitively, the point is that we are constructing the same
primitive on longer messages as the primitive we are given on shorter messages.
Thus, whatever (complicated) security properties were present, will remain to
be present in our composition scheme. For conciseness, we chose to concentrate
on a simpler symmetric setting for the remainder of this abstract.
Syntax. An authenticated encryption scheme consists of three algorithms:
AE = (KG, AE, AD). The randomized key generation algorithm KG(1k ), where k
is the security parameter, outputs a shared secret key K, and possibly a public
parameter pub. Of course, pub can always be part of the secret key, but this
might unnecessarily increase the secret storage. In the description below, all the
algorithms (including the adversary’s) can have access to pub, but we omit this
dependence for brevity. The randomized authencryption (authenticate/encrypt)
algorithm AE takes as input the key K and a message m from the associated
message space M, and internally ﬂips some coins and outputs a ciphertext c;
we write c ← AEK (m) or c ← AE(m), omitting the key K for brevity. The deterministic authdecryption (verify/decrypt) algorithm AD takes as input the key
K, and outputs m ∈ M ∪ {⊥}, where ⊥ indicates that the input ciphertext c is
”invalid”. We write m ← ADK (c) or m ← AD(c) (again, omitting the key). We
require that AD(AE(m)) = m, for any m ∈ M.
Security of Authenticated Encryption. Fix the sender S and the receiver
R. Following the standard security notions [7], we deﬁne the attack models and
goals of the adversary for both authenticity (i.e. sUF-CMA)5 and privacy (IND5

Meaning “strong unforgeability against chosen message attack.”

Concealment and Its Applications to Authenticated Encryption

323

CCA2)6 as follows. We ﬁrst model our adversary A. A has oracle access to the
functionalities of both S and R. Speciﬁcally, it can mount a chosen message
attack on S by asking S to produce a ciphertext C of an arbitrary message m,
i.e. A has access to the authencryption oracle AEK (·). Similarly, it can mount
a chosen ciphertext attack on R by giving R any candidate ciphertext C and
receiving back the message m (where m could be ⊥), i.e. A has access to the
authdecryption oracle ADK (·).
To break the sUF-CMA security of the authenticated encryption scheme, A
has to be able to produce a “valid” ciphertext C (i.e., ADK (C) = ⊥), which was
not returned earlier by the authencryption oracle.7 Notice, A is not required to
“know” m = ADK (C) when producing C. The scheme is sUF-CMA-secure if for
any PPT A, Pr[A succeeds] ≤ negl(k).
To break the IND-CCA2 security of the authenticated encryption scheme, A
ﬁrst has to to come up with two messages m0 and m1 . One of these will be
authencrypted at random, the corresponding ciphertext C ∗ ← AEK (mσ ) (where
σ is a random bit) will be given to A, and A has to guess the value σ. To succeed
in the CCA2 attack, A is only disallowed to ask R to authdecrypt the challenge
C ∗ .8 The scheme is IND-CCA2-secure if for any PPT A, Pr[A succeeds] ≤ 12 +
negl(k). We also remark that IND-CPA-security is the same, except A is not given
access to the authdecryption oracle.
4.2

Authenticated Encryption of Long Messages

Assume AE = (KG, AE, AD) is a secure authenticated encryption on |b|-bit messages. We would like to build an authenticated encryption AE = (KG , AE , AD )
on |m|-bit messages, where |m|
|b|. More speciﬁcally, we seek to employ the
following canonical composition paradigm. The key K for AE is the same as
that for AE. To authencrypt m, ﬁrst split it into two pieces (h, b) (so that the
transformation is invertible), and output AEK (m) = AEK (b), h . The question
we are asking is what are the necessary and suﬃcient conditions on the transformation m → (h, b) so that the resulting authenticated encryption is secure?
In this section we show that the necessary and suﬃcient condition is to have the
transformation above be a relaxed concealment.
More formally, assume C = (Setup, Conceal, Open) satisﬁes the syntax, but
not yet the security properties of a concealment scheme. We assume that CK ←
Setup(1k ) forms a public parameter pub of AE . We deﬁne AE as stated above.
Namely, AE (m) outputs AE(b), h , where (h, b) ← Conceal(m), and AD (c, h)
outputs Open(h, AD(c)). The proof of the following theorem is given in the full
version of this paper [15].
6
7
8

Meaning “indistinguishability against chosen ciphertext attack.”
A slightly weaker notion of UF-CMA requires C to correspond to “new” message m
not submitted to AEK (·).
[2] deﬁne a slightly weaker but more syntactically sound notion of gCCA2 attack.
Our results apply here as well.

324

Y. Dodis and J.H. An

Theorem 2. If AE is secure, then AE is secure if and only if C is a relaxed
concealment scheme.
4.3

Remotely Keyed Authenticated Encryption

Syntax. A one-round remotely-keyed authenticated encryption (RKAE) scheme
consists of seven eﬃcient algorithms: RKAE = (RKG, Start-AE, Card-AE,
Finish-AE, Start-AD, Card-AD, Finish-AD) and involves two parties called the Host
and the Card. The Host is assumed to be powerful, but insecure (subject to
break-in by an adversary), while the Card is secure but has limited computational power and low bandwidth. The randomized key generation algorithm
KG(1k ), where k is the security parameter, outputs a secret key K, and possibly
a public parameter pub. In the description below, all the algorithms (including
the adversary’s) can have access to pub, but we omit this dependence for brevity.
This key K is stored at the Card. The process of authenticated encryption is
split into the following 3 steps. First, on input m, the Host runs probabilistic
algorithm Start-AE(m), and gets (b, α). The value b should be short, as it will be
sent to the Card, while α denotes the state information that the Host needs to
remember. We stress that Start-AE involves no secret keys and can be run by anybody. Next, the Card receives b, and runs probabilistic algorithm Card-AEK (b),
using its secret key K. The resulting (short) value c will be sent to the host. Finally, the host runs another randomized algorithm Finish-AE(c, α) and outputs
the resulting ciphertext C as the ﬁnal authencryption of m. Again, Finish-AE
involves no secret keys. The sequential composition of the above 3 algorithms
induces an authencryption algorithm, which we will denote by AEK .
Similarly, the process of authenticated decryption is split into 3 steps as well.
First, on input C, the Host runs deterministic algorithm Start-AD(C), and gets
(u, β). The value u should be short, as it will be sent to the Card, while β denotes
the state information that the Host needs to remember. We stress that Start-AD
involves no secret keys and can be run by anybody. Next, the Card receives
u, and runs deterministic algorithm Card-ADK (u), using its secret key K. The
resulting (short) value v will be sent to the host. We note that on possible value
for v will be ⊥, meaning that the Card found some inconsistency in the value
of u. Finally, the host runs another randomized algorithm Finish-AD(v, β) and
outputs the resulting plaintext m if v = ⊥, or ⊥, otherwise. Again, Finish-AD
involves no secret keys. The sequential composition of the above 3 algorithms
induces an authdecryption algorithm, which we will denote by ADK . We also
call the value C valid if ADK (C) = ⊥.
The correctness property states for any m, AD (AE (m)) = m.
Security of RKAE. As we pointed out, RKAE in particular induces a regular
authenticated encryption scheme, if we combine the functionalities of the Host
and the Card. Thus, at the very least we would like to require that the induced
scheme AE = (RKG, AE , AD ) satisﬁes the IND-CCA2 and sUF-CMA security
properties of regular authenticated encryption. Of course, this is not a suﬃcient
guarantee in the setting of RKAE. Indeed, such security only allows the adversary

Concealment and Its Applications to Authenticated Encryption

325

oracle access to the combined functionality of the Host and the Card. In the
setting of RKAE, the Host is anyway insecure, so the adversary should have oracle
access to the functionality of the Card. Speciﬁcally, we allow our adversary A
to have oracle access to the Card algorithms Card-AEK (·) and Card-ADK (·).
Just like regular authenticated encryption, RKAE has security notions for
privacy and authenticity, which we denote by RK-IND-CCA and RK-sUF-CMA,
respectively.
To break the RK-sUF-CMA security of RKAE, A has to be able to produce a
“one-more forgery” when interacting with the Card. Namely, A tries to output
t + 1 valid ciphertexts C1 . . . Ct+1 after making at most t calls to Card-AEK (·)
(where t is any polynomial in k). Again, we remark that A is not required
to “know” the plaintext values mi = ADK (Ci ). The scheme is RK-sUF-CMAsecure if for any PPT A , Pr[A succeeds] ≤ negl(k). We note that this is the
only meaningful authenticity notion in the setting of RKAE. This is because the
values c ← Card-AEK (b) returned by the Card have no “semantic” meaning of
their own. So it makes no sense to require A to produce a new “valid” string c.
On the other hand, it is trivial for A to compute t valid ciphertexts C1 . . . Ct with
t oracle calls to Card-AE, by simply following to honest authencryption protocol
on arbitrary messages m1 . . . mt . Thus, security against “one-more forgery” is
the most ambitious goal we can try to meet in the setting of RKAE.
To break the RK-IND-CCA security of RKAE, A ﬁrst has to come up with
two messages m0 and m1 . One of these will be authencrypted at random, the
corresponding ciphertext C ∗ ← AEK (mσ ) (where σ is a random bit) will be
given to A , and A has to guess the value σ. To succeed in the CCA2 attack,
A is only disallowed to call the Card authdecryption oracle Card-ADK (·) on the
well-deﬁned value u∗ , where we deﬁne Start-AD(C ∗ ) = (u∗ , β ∗ ) (recall, Start-AD
is a deterministic algorithm). The latter restriction is to prevent A from trivially
authdecrypting the challenge. The scheme is RK-IND-CCA-secure if for any PPT
A , Pr[A succeeds] ≤ 12 + negl(k). We brieﬂy remark that RK-IND-CPA-security
is the same, except we do not give A access to the Card authdecryption oracle.
Canonical RKAE. A natural implementation of RKAE would have the Card
perform regular authenticated encryption/decryption on short messages, while
the Host should do the special (to be discussed) preprocessing to produce the
short message for the Card from the given long message. Speciﬁcally, in this case
we start from some auxiliary authenticated encryption AE = (KG, AE, AD) which
works on “short” |b|-bit messages, and require that Card-AE = AE, Card-AD =
AD. Moreover, we would like the Card to authdecrypt the same value c that
it produced during authencryption. In our prior notation, u = c and v = b,
where c ← AEK (b). Finally, it is natural to assume that the Host outputs c as
part of the ﬁnal (long) ciphertext. Putting these together, we come up with the
following notion of canonical RKAE.
First, the Host runs Start-AE(m), which we conveniently rename Conceal(m),
and produces (h, b), where h will be part of the ﬁnal ciphertext and b is “short”.
Then it sends b to the Card, and gets back c ← AEK (b). Finally, it outputs C =
c, h as the resulting authencryption of m. Similarly, to authdecrypt C = c, h ,

326

Y. Dodis and J.H. An

it sends c to the Card, gets b = ADK (c), and outputs Finish-AD(h, b), which we
conveniently rename Open(h, b). Thus, the canonical RKAE is fully speciﬁed by
an auxiliary authenticated encryption AE and a triple C = (Setup, Conceal, Open)
(where Setup is run at key generation and outputs the key which is part of pub).
The fundamental question we address is this: what security properties of
Conceal and Open are needed in order to achieve a secure canonical RKAE (provided the auxiliary AE is secure)? As we show, the necessary and suﬃcient
condition is to employ a secure (strong) concealment scheme. We remark that
the ﬁnal induced scheme AE we construct is exactly the composition scheme we
discussed in Section 4.2. However, in that application the entire authenticated
encryption was performed honestly — in particular, b was chosen by properly
running Conceal(m), — so relaxed concealments were suﬃcient. Here, an untrusted Host can ask the Card to authencrypt any value b it wishes, so we need
the full binding power of strong concealments.
The following theorem states this more formally. Its proof is given in the full
version of this paper [15].
Theorem 3. If AE is secure, and a canonical RKAE is constructed from AE
and C, then RKAE is secure if and only if C is a (strong) concealment scheme.
Comparison to Previous RKAEs. We brieﬂy compare our scheme with those
of [13,17]. First, both schemes could be put into our framework by extracting
appropriate concealment schemes. In fact, the concealment we extract from [13]
is essentially the same as our construction b = τ H(h), h = Eτ (m) (they model
one-time encryption slightly diﬀerently, but this is minor)! On the other hand,
instead of applying arbitrary authenticated encryption to the value of b, they
build a very speciﬁc one based on block ciphers and pseudorandom functions. To
summarize, the construction of [13] is quite good and eﬃcient, but focuses on a
speciﬁc ad-hoc implementations for both concealment and authenticated encryption. We believe that our generality provides many more options, as well as gives
better understanding towards designing RKAE, since our general description is
much simpler than the speciﬁc scheme of [13]. As for the scheme of [17], one can
also extract an “OAEP”-like concealment out of it, making it a special case of
our framework too. However, the speciﬁc choices made by the authors make it
very hard to replace the random oracles by some provable implementation. On
the other hand, our “OAEP”-like construction (based on a PRG and a CRHF) is
equally simple, but achieves provable security without the random oracles.

5

Extensions

Using A Block Cipher in Place of AE. First, we brieﬂy touch upon ampliﬁcation paradigm of the form AE (m) = PK (b), h , where P is a (strong) PRP.
Namely, we replace the “inner” authenticated encryption by a block cipher. Although this is applicable only in the symmetric setting, it is likely to be quite
useful in practice, where PRP is typically the main building block of most other
primitives. We note that a strong PRP is “almost” an authenticated encryption

Concealment and Its Applications to Authenticated Encryption

327

except it does not provide semantic security (but gives at least one-wayness). We
ask the same question as before: what are the conditions on the transformation
m → (h, b) for AE to be secure? In the following, we just state our results,
leaving the proofs to the full version [15].
It turns out that four conditions are needed, the ﬁrst two of which are subsumed by any relaxed concealment. The last two conditions are stated as follows:
(1) for any h, Prb [Open(h, b) = ⊥] = negl(k). This is needed to prevent a “lucky”
forgery of the form v, h , where v is arbitrary. This condition always holds for
our speciﬁc concealments, since the value of b corresponding to any h includes
H(h). Thus, the chance that a random b will include the same string as H(h) is
negligible, since the output of a CRHF (i.e. H) must be suﬃciently long to avoid
easy collisions. (2) having oracle access to Conceal(·), it is hard to ever make
it output the same value b. This is needed to ensure the authencryption oracle
never evaluates the PRP on the same input, since the adversary will notice it.
Again, this is trivially true for our concealments, since the value b always includes a random key τ for one-time encryption. By birthday bound, the chance
of collision after q queries is at most q 2 /2|b| , which must be negligible. To summarize, PK (τ H(h)), h = Eτ (m) is a secure authenticated encryption. We also
note that here PK does not need to be a strong PRP; a regular PRP suﬃces.
Finally, we brieﬂy argue when using a strong PRP suﬃces for our RKAE
−1
application. Here the adversary has direct oracle access to both PK and PK
,
so we need at least a strong PRP. It turns out that the following two conditions
should hold on the concealment scheme in addition to its regular hiding and
binding properties (and properties (1)-(2) above). (1’) given a random string b,
it is hard to ﬁnd h such that Open(h, b) = ⊥. This is needed to prevent the
adversary from getting a forgery v, h , where it previously learned Ps−1 (v) = b.
In our case, b includes H(h), so one needs to “invert” H on a random string
b. It is easy to see that any CRHF with |H(h)| < |h| − ω(log k) must satisfy
the needed property. As for the second condition, it states: (2’) for any m, if
(h, b) ← Conceal(m), then it is hard to recover the value b when given only
m and h. This is needed so that the adversary cannot determine the value b
corresponding to the challenge, and then check its guess using an oracle call to
Ps (·). In our case, given Eτ (m) and m, it should be hard to ﬁnd the correct value
of key τ . This property is false for general one-time encryptions (i.e., for one-time
pad), but holds for the ones we have in mind here. In particular, if Eτ (m) =
G(τ ) ⊕ m, where G is a PRG, ﬁnding τ involves inverting G(τ ) on a random
τ . And it is well known that a PRG is a one-way function provided |G(τ )| >
|τ | + ω(log k). To summarize, the following scheme is safe to use for RKAE,
provided |G(τ )| > |τ | + ω(log k), |H(h)| < |h| − ω(log k) and P is a strong PRP:
AE (m) = PK (τ H(h)), G(τ ) ⊕ m . This remarkably simple scheme means
that we can let the Card perform a single block cipher operation per call!
Associated Data. Finally, we brieﬂy discuss extensions to supporting associated data [29,25]. Intuitively, associated data allows one to “bind” a public label
to the message. Viewing the label as part of the message is a possible solution,
but the generalized view can bring non-trivial eﬃciency gains, as was shown

328

Y. Dodis and J.H. An

by [25]. This extension is presented in more detail in the full version of this
paper [15].

References
1. J. An and M. Bellare, “Constructing VIL-MACs from FIL-MACs: Message
authentication under weakend assumptions,” In Crypto ’99, pp. 252–269, LNCS
Vol. 1666, 1999.
2. J. An, Y. Dodis, and T. Rabin, “On the Security of Joint Signature and Encryption,” In Eurocrypt ’02, pp. 83–107, LNCS Vol. 2332, 2002.
3. J. Baek, R. Steinfeld, and Y. Zheng, “Formal proofs for the security of
signcryption,” In PKC ’02, pp. 80–98, LNCS Vol. 2274, 2002.
4. M. Bellare, R. Canetti and H. Krawczyk, “Keying hash functions for message authentication,” In Crypto ’96, pp. 1–15, LNCS Vol. 1109, 1996.
5. M. Bellare, J. Kilian and P. Rogaway, “The security of the cipher block
chaining message authentication code,” In Journal of Computer and System Sciences, pp. 362–399, Vol. 61, No. 3, Dec 2000.
6. M. Bellare, T. Kohno, C. Namprempre, “Provably Fixing the SSH Binary
Packet Protocol,” In Proc. 9th CCS, pp. 1–11, ACM, 2002.
7. M. Bellare and C. Namprempre, “Authenticated Encryption: Relations
among Notions and Analysis of the Generic Composition Paradigm,” In Asiacrypt
’00 , pp. 531–545, LNCS Vol. 1976, 2000.
8. M. Bellare and P. Rogaway, “Optimal asymmetric encryption – How to encrypt with RSA,” In Eurocrypt ’94, pp. 92–111, LNCS Vol. 950, 1994.
9. M. Bellare and P. Rogaway, “Collision-Resistant Hashing: Towards Making
UOWHFs Practical,” In Crypto ’97, pp. 470–484, LNCS Vol. 1294, 1997.
10. M. Bellare, P. Rogaway, “Encode-Then-Encipher Encryption: How to Exploit
Nonces or Redundancy in Plaintexts for Eﬃcient Cryptography,” In Asiacrypt ’00,
pp. 317–330, LNCS Vol 1976, 2000.
11. J. Black, S. Halevi, H. Krawczyk, T. Krovetz and P. Rogaway, “UMAC:
Fast and secure message authentication,” In Crypto ’99, pp. 216–233, LNCS Vol.
1666, 1999.
12. M. Blaze, “High-Bandwidth Encryption with Low-Bandwidth Smartcards,” In
Fast Software Encryption (FSE) ’96, pp. 33–40, LNCS Vol. 1039, 1996.
13. M. Blaze, J. Feigenbaum, M. Naor, “A Formal Treatment of Remotely Keyed
Encryption,” In Eurocrypt ’98, pp. 251–265, LNCS Vol. 1403, 1998.
14. I. Damg˚
ard, “Collision free hash functions and public key signature schemes,”
In Eurocrypt ’87, pp. 203–216, LNCS Vol. 304, 1987.
15. Y. Dodis and J. An, “Concealment and its applications to authenticated encryption,” Full version of this paper, available via http://theory.lcs.mit.edu/
˜yevgen/academic.html.
16. C. Jutla, “Encryption modes with almost free message integrity,” In Eurocrypt
’01, pp. 529–544, LNCS Vol. 2045, 2001.
17. M. Jakobsson, J. Stern, and M. Yung, “Scramble All, Encrypt Small,” In
Fast Software Encryption (FSE) ’99, pp. 95–111, LNCS Vol. 1636, 1999.
18. J. Katz and M. Yung, “Unforgeable Encryption and Chosen Ciphertext Secure
Modes of Operation,” In FSE ’00, pp. 284–299, LNCS Vol. 1978, 2000.
19. H. Krawczyk, “The Order of Encryption and Authentication for Protecting
Communications (or: How Secure Is SSL?),” In Crypto ’01 , pp. 310–331, LNCS
Vol. 2139, 2001.

Concealment and Its Applications to Authenticated Encryption

329

20. S. Lucks, “On the Security of Remotely Keyed Encryption,” In Fast Software
Encryption (FSE) ’97, pp. 219–229, LNCS Vol. 1267, 1997.
21. S. Lucks, “Accelerated Remotely Keyed Encryption,” In Fast Software Encryption (FSE) ’99, pp. 112–123, LNCS Vol. 1636, 1999.
22. A. Menezes, P. van Oorshot and S. Vanstone, “Handbook of applied cryptography,” CRC Press LLC, 1997.
23. M. Naor, “Bit Commitment Using Pseudorandomness,” In Journal of Cryptology, 4(2):151–158, 1991.
24. M. Naor and M. Yung, “Universal One-Way Hash Functions and their Cryptographic Applications,” In Proc. 21st STOC, pp. 33–43, ACM, 1989.
25. P. Rogaway, “Authenticated-Encryption with Associated-Data,” In Proc. 9th
CCS, pp. 98–107, ACM, 2002.
26. P. Rogaway, M. Bellare, J. Black, and T. Krovetz, “OCB: A Block-Cipher
Mode of Operation for Eﬃcient Authenticated Encryption,” In Proc. 8th CCS,
pp. 196–205, ACM, 2001.
27. J. Rompel, “One-way functions are necessary and suﬃcient for secure signatures,” In Proc. 22nd STOC, pp. 387–394, ACM, 1990.
28. V. Shoup, “A composition theorem for universal one-way hash functions,” In
Eurocrypt ’00, pp. 445–452, LNCS Vol. 1807, 2000.
29. V. Shoup, “A proposal for an ISO standard for public key encryption (version
2.1),” IACR E-Print Archive, 2001/112, http://eprint.iacr.org/2001/112/,
2001.
30. D. Simon, “Finding Collisions on a One-Way Street: Can Secure Hash Functions
Be Based on General Assumptions?,” In Eurocrypt ’98 , pp. 334–345, LNCS Vol.
1403, 1998.
31. Y. Zheng, “Digital Signcryption or How to Achieve Cost(Signature & Encryption)
Cost(Signature) + Cost(Encryption),” In Crypto ’97, pp. 165–179, LNCS
Vol. 1294, 1997.

