Distributed Adaptive Design with Hierarchical
Autonomous Graph Transformation Systems
Leszek Kotulski1 and Barbara Strug2
1

Department of Automatics, AGH University of Science and Technology
Al. Mickiewicza 30, 30 059 Krakow, Poland
2
Department of Physics, Astronomy and Applied Computer Science,
Jagiellonian University, Reymonta 4, Krakow, Poland
kotulski@agh.edu.pl, uistrug@if.uj.edu.pl

Abstract. In this paper a graph transformation system with the parallel derivation is used to model the process of distribution and adaptation
for computer aided design. It is based on earlier research in formal language theory, especially graph grammars, and distributed models. The
motivation for the ideas presented here is given and possible ways of
application are described. A connection to the multi-agent model is also
presented.
Keywords: Graph transformations, grammar systems, design.

1

Introduction

Distributed model of computing is becoming more and more popular, especially
with a rapid development of the Internet and availability of distributed development platforms. Such a model seems to be very useful in the domain of computeraided design. Many design problems can be divided into a number of tasks, each
of them carried out by an autonomous agent either only occasionally exchanging
pieces of information or contributing its capabilities to a common object being
designed. Yet no formal model of such a cooperative distributed design has been
proposed so far.
Real world objects being designed are usually complex and contain a number of diﬀerent sub-elements inter-related in diﬀerent ways. To represent such
complex objects in diﬀerent domains of computer science graphs are very often
used [15]. Their ability to represent the structure of an object as well as the
diﬀerent types of relations between its parts makes them particularly useful in
computer aided design. The process of designing objects requires thus a method
of generating graphs .
A new approach to graph generation in computer aided design domain, proposed in this paper, uses cooperation and distribution as a basis for generating
designs with the application of graph grammars. It is based on earlier research
in the domain of application of the theory of formal languages to the computer
aided design [6,7] and distributed model of computation [5,15,11]. In particular graph grammars [1,6,8,13] and grammar systems [2,3,4] were used as the
inspiration for this research.
Y. Shi et al. (Eds.): ICCS 2007, Part II, LNCS 4488, pp. 880–887, 2007.
c Springer-Verlag Berlin Heidelberg 2007

Distributed Adaptive Design

2

881

Graph Structures in the Design Process

One of the most useful representations in computer aided design systems is based
on graphs. The process of designing can then be seen as generating graphs representing some objects. In such situation introducing a method for the generation
of these graphs is needed. Moreover such a method must guarantee that graphs
it produces are valid in respect to a design problem being solved. In other words
each graph generated by a chosen method must be interpretable as a design.
Usually it must also satisfy some design criteria or constraints. Graph transformations are a method fulﬁlling all above requirements.
In real world problems the object being designed are complex and consist of
many parts which in turn can contain subparts. Thus the graphs representing
such an object can become large structures diﬃcult to maintain, update and analyze. Yet in many situations design decisions dealing with one part of the design
are independent from the rest of it. Thus it seems reasonable to distribute the
graph representing such a design into a number of local graphs, each representing a part of design, and a master graph containing the overall structure of the
design. Each local graph can be generated by its own graph transformation system Graph transformation system can thus be considered a set of autonomous
systems paralelly cooperating with the user (designer) thus behaving itself like
an agent.
Using such an approach, two major problems inherent to graph-based representations in design problems, namely the size of graphs and number of transformation rules, can be reduced.
Moreover there is nothing to prevent local graph representing a part of a
design to be a master one either for other graphs representing subparts of this
part (what introduce hierarchy inside graph) or the common (replicated) part
of the graph structure. The second one will be discussed in the paper in a more
detailed way.
Distribution of the representation solves mentioned problems but also generates new ones. As each graph represents a part of a design then there can
exist elements that can be represented in diﬀerent subgraphs. Thus a need for
synchronization any modiﬁcation of their environment arises. For example in
a house design a system expected to design a ﬂoor layout of a house with the
whole infrastructure and furnishing each room can be considered a valid part of
a design and the master graph would contain the structure of the house layout
and common elements. The way a furniture is placed in one room is independent
from whatever happens to be placed in other rooms, thus each one can be designed by an autonomous agent. Yet some common elements exist. Doors can be
one of such elements as they are shared by two rooms and thus changing their
position must be synchronized inside both graphs representing these rooms, thus
a need for communication between agents arises.
Moreover there are some limited resources to be placed in the house. For example it may be speciﬁed that two TV sets must be placed in the house with

882

L. Kotulski and B. Strug

some additional constraints like: the distance from TV to a seat is at least 2
meters but no more then ﬁve. Thus the master unit broadcasts the resource and
waits for responses from all rooms. Each local agent responds by specifying a
measure of satisfying the constraints and the master unit decides in which room
the TV would be placed, but the exact position is decided by the local system
(agent). Let us, however, note that the centralization of some data and decisions
inside master unit can create bottlenecks eﬀect and decrease the eﬀectiveness
of the system, so we will sketch the possibility of the direct cooperation of the
distributed components. The decision on both the distribution of the design data
structures and the decomposition of the design process generates a need to ﬁnd
a method of synchronizing and negotiating the work on replicated description of
elements and placement of limited resources.
In the paper we use for this purpose the concept of the Derivation Control Environment, presented in the next chapter, that controls the graph transformation
with the help of productions of the grammar associated with it.

3

Derivation Control Environment

The main objectives of introducing the Derivation Control Environment (DCE)
are:
– the support for local derivation of the graph,
– the representation of users reactions,
– the synchronization of both user’s reaction with the proper action on the
local graph and the derivation of the local cooperation.
Thus DCE consist of two types of units: - the local Derivation Control Diagram
(DCD), - local Users Environments (UE). The deﬁnition of the communication
mechanism is one of the most important properties of the distributed environment. We assume that both types of units are able to serve messages in the
form of requests that have a unique name, and carry the values of attributes
associated with this type of request (see [11] for formal deﬁnition).
We demand from the communication environment that the sent request be
delivered to the destination unit in a ﬁnite time. We assume that each request
has at least two attributes deﬁned: sender and time stamp deﬁning appropriately the unit and the time of the generated request. Let RS denote the set
of all possible requests, so any ﬁnite subset of RS will be called a requests
set.
We assume that UE is characterized only by the ability of generating (internal) requests of services to DCD and servicing (external) requests required by
DCDs. DCD unit is responsible both for modifying the maintained local graph
as reaction to the appearance of some requests and generating sequence of requests to other units in order to synchronize its action with other units. So, it
should introduce:

Distributed Adaptive Design

883

1. a notion for describing some constrains in applying the grammar production in a given context (as analogy to the OCL correlated with algebraic
transformation [5]);
2. the ability to synchronize, at the level of the single production, in order to
wait until some speciﬁed sequence of events appears;
3. the ability to designate some sequence of productions associated with the
given event.
Let us start to formalize these demands.
Deﬁnition 1. A derivation control diagram is a sixtuple S = (N, I, F, T, Π,
W ait), where:
– N - is the set of control points,
– I ⊂ N and F ⊂ N are accordingly, the set of starting control points and the
set of ﬁnal control points,
– T is a set of transitions of the form (k, q, P, SF ), where:
• k,q are control points,
• P is either a production or ∅ symbol when no production is associated
with this transition,
• SF is a semantic action described,
– Π = {Πk }, it the set of selectors, ,
– W ait = {W aitk }, is the set of synchronizing functions.
The synchronizing function W aitk awaits evaluation of the selector Πk until
the condition it speciﬁed is fulﬁlled. Selector Πk points: a production, a semantics
action and a destination control point associated with the chosen transition.
Initially activity is associated with each starting point; when the transition is
ﬁred the activity is moved to the destination one. If the source control point
is a starting one then the activity is also replicated to it; if the destination
node is the ﬁnal one the activity is cancelled. We assume that for any k the
successful evaluation of the synchronizing function W aitk and of the selector
Πk is made in the critical section over the graph G and the set of request ω.
These assumptions imply not only the correctness of the sequential evaluation
of the conditions deﬁned inside control point, but also exclude busy form of
waiting during evaluation of the awaiting synchronizing conditions. Like in Ada
language, in the worst case all the synchronizing conditions are evaluated after
any modiﬁcation G or ω. If no transition are ﬁred to modify G or ω the evaluation
is suspended until some new request r appears (ω = {r} ∪ ω)). The semantic
function SF (associated with the transition)
– enriches external request set (requesting some actions either of the designing
system or the user),
– removes the request, that is serviced, from ω,
– evaluate parameters of the right-hand graph of the production P. Production
P is applied to current graph G and new graph H is created

884

L. Kotulski and B. Strug

More intuitively, DCD can be interpreted as a graph connecting control points
(see ﬁg. 1) inside of which both the synchronizing function and selector, choosing
one of the transitions from one control point to another one (drawn as an edge),
are sequentially evaluated. During such a transition both production Pi is applied
and semantic action SFi is executed.

Fig. 1. Illustration of DCD

The Derivation Control Environment (DCE) is responsible for controlling both
the local graphs modiﬁcation and the whole distributed system cooperation.
Let us note that a local graph will be modiﬁed when a new request appears initially from some UE (representing user decision). Next requests can be generated as an eﬀect of semantic actions executed by DCD during the service of these
actions in order to make cooperation between DCDs . There are two particular
reasons for the coordination of local activities:
– ﬁrstly some graph nodes can be replicated in several local graphs (describing
the same element), so any action modifying its state (e.g. adding or removing
any edge) needs cooperation of all these graph environments;
– secondly one can need some information about a global state of the system,
so it has to ask the other DCDs to help in ﬁnding the global answer.
In the next section, these problems will be discussed in the context of adaptation in design.

4

Synchronization and Adaptation in Design

In the approach presented in this paper, we use labelled and attributed graphs to
represent structures of design objects as they allow us to express multi-argument
relations between objects’ parts. Attributing is used to represent features of

Distributed Adaptive Design

885

S

1

S

P

D

2

S

S
=

S
S

=

P
D
P
S

S

S
P
D

S

S

P

D
P

3
S

Fig. 2. Example representing a house layout

objects and relations between them. Attributes represent properties (for example
size, position, colour or material) of elements corresponding to a given node or edge.
The graphs representing designs may be dynamically generated by means
of so called graph grammars [15]. Intuitively, such a grammar is a system of
graph transformations, which consist of formal rules called productions. Each
production is composed of a left-hand side. The left-hand side is replaced by the
right-hand one only if it appears in the graph to be transformed. In each step
a production is applied to a current graph. The sequence of such replacements,
which starts from the initial graph, is called a derivation process.
Yet in real world design problems it is diﬃcult, if not impossible, to deﬁne
such an order of application a priori.
Designing is an incremental process of applying changes, evaluating and correcting designs. Moreover it must adapt to changes in design requirements that
are not always known before the process starts. Note that it is very important
that DCD is able to designate the derivation process by responding to events
rather then following a predeﬁned route. Each event generates one or more requests sent to other DCDs. For example adding a ﬁreplace to a single room may
require moving doors, which belong to two diﬀerent rooms and thus appropriate
requests must be generated; both DCDs (controlling graph representing these
rooms) must react to them. Let consider this example in detail. Figure 2 depicts
a graph representing a part of a house layout during a design process. It consist
of three local graphs, representing three rooms. The replicated (shared) elements
are placed in gray part of each graph and connected by dashed lines (it means
that a connection is established by appropriate attribute(s) used in the request)
Now a designer wants to add a ﬁreplace to a room 2. Such an operation is local
to the room 2 and is done by applying an appropriate production locally. Local
application of productions has been widely and thoroughly presented in other
papers [6] so it will be skipped here. While doing it a designer ﬁnds that the
best location for the ﬁreplace collides with the doors. So a decision is taken to
remove the doors. A production Pr is applied that performs this action (shown

886

L. Kotulski and B. Strug

Padd

Premove

S

S

S

:=

:=

a

b

S
D

D

Fig. 3. Productions for adding and removing doors

in ﬁg. 3a). But the doors are shared by the ”room 2” with the ”room 3”. So the
request remove door(...) must be sent to DCD controlling the graph describing
the room 3. This DCD should react to the appearance of the remove door(...)
request by applying the production Pr to remove the door from the ”room 3”.
In both cases the removed doors can be the only door in the room. Checking the
existence of the correct communication from the room can be made in our model
with help of semantic action. If the communication stays correct than current
thread of control can be moved to the starting point, otherwise it is moved to
the part of DCD’s responsible for negotiation adding diﬀerent doors in other
walls. Such doors are added by applying production shown in ﬁg. 3b.

5

Conclusions

In this paper we have shown that it is possible to decompose a complex design
problem into a number of tasks. These tasks can be performed independently
by agents working according to local grammars and cooperating when a need
for updating shared resources arises. In the presented simple example all three
graphs are derived with the use of the same grammar (thus all agents following
the same rules) but there is no such requirement in the theoretical model we
propose. Thus each graph may be derived by a diﬀerent grammar. Moreover
the grammars may belong to diﬀerent class. The only requirement is that each
grammar contains productions for updating shared elements.
In papers [11,12] it was shown that such an approach can be realized as a
multi-agent system. Each graph transformation system can be considered to be
an agent whose set of possible actions depends on a set of productions of the
given GTS.

References
1. Borkowski A., Grabska E., Nikodem P, and Strug B. Searching for Innovative
Structural Layouts by Means of Graph Grammars and Esvolutionary Optimization,
Proc. 2nd Int. Structural Eng. And Constr. Conf, Rome (2003).
2. E. Csuhaj-Varj´
u, J. Dassow, J. Kelemen and Gh. Paun. Grammar systems. A
grammatical approach to distribution and cooperation. Topics in Computer Mathematics 8. Gordon and Breach Science Publishers, Yverdon, 1994.
3. E. Csuhaj-Varj´
u: Grammar systems: A short survey, Proceedings of Grammar Systems Week 2004, 141-157, Budapest, Hungary, July 5-9, 2004.

Distributed Adaptive Design

887

4. J. Dassow, Gh. Paun, and G. Rozenberg. Grammar systems. In A. Salomaa and
G. Rozenberg, editors, Handbook of Formal Languages, volume 2, chapter 4, pp.
155-213, Springer-Verlag, Berlin-Heidelberg, 1997
5. Ehrig, H and Taentzer. G , Graphical represenation and graph transformations.
ACM Comput. Surv., 31(3):9, 1999.
6. E.Grabska. Theoretical Concepts of Graphical Modelling. Part one: Realization of
CP-graphs. Machine GRAPHICS and VISION, 2(1), pp. 3-38, 1993.
7. E. Grabska. Graphs and designing. Lecture Notes in Computer Science, 776 (1994).
8. E. Grabska, P. Nikodem, B. Strug. Evolutionary Methods and Graph Grammars in
Design and Optimization of Skeletal Structures Weimar, 11th International Workshop on Intelligent Computing in Engineering, Weimar, 2004.
9. E. Grabska, B. Strug, Applying Cooperating Distributed Graph Grammars in Computer Aided Design, Parallel Processing and Applied Mathematics PPAM 2005,
Lecture Notes in Computer Science , Springer 2006
´
10. E. Grabska, K. Grzesiak-Kope´c, J. Lembas, A. Lachwa and G. Slusarczyk,
Hypergraphs in design, Computational Imaging and Vision, Kluwer (to appear)
11. Kotulski, L. A Model of Software Genaration in a Distributted Environment by
Graph Grammars, (in Polish) Habilitation Thesis,. Jagiellonian University Publishing, ISBN 83-233-1391-1, Krakow, 2000
12. Kotulski, L,Supporting Software Agents by the Graph Transformation Systems.
Proc. of International Conference on Computational Science , LNCS 3993, pp887890, Springer 2006
13. P. Nikodem and B. Strug. Graph Transformations in Evolutionary Design, ICAISC
2004, Lecture Notes in Computer Science,vol 3070, pp. 456-461, Springer, 2004.
14. Gh. Paun and A. Salomaa editors, Grammatical models of multi-agent systems.
Gordon and Breach, Amsterdam, 1999.
15. Rozenberg, G. Handbook of Graph Grammars and Computing by Graph. Transformations, vol.1 Fundations, World Scientiﬁc London (1997).

