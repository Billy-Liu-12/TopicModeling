Provenance Provisioning in Mobile Agent-Based
Distributed Job Workﬂow Execution
Yuhong Feng and Wentong Cai
School of Computer Engineering, Nanyang Technological University
Singapore 639798
{YHFeng, ASWTCai}@ntu.edu.sg

Abstract. Job workﬂow systems automate the execution of scientiﬁc
applications, however they may hide how the results are achieved (i.e.,
the provenance information of the job workﬂow execution). This paper
describes the development and evaluation of a decentralized recording
and collection scheme for job workﬂow provenance in mobile agent-based
distributed job workﬂow execution. A performance study was conducted
to evaluate our approach against the one using a centralized provenance
server. The results are discussed in the paper.
Keywords: Distributed Job Workﬂow Execution, Provenance Recording
and Collection, Grid Computing.

1

Introduction

The provenance of some data is deﬁned as the documentation of the process that
led to the data [1]. The necessity of provenance for job workﬂow execution is
apparent since provenance provides a traceable path on how a job workﬂow was
executed and how the resulted data were derived. It is particularly important in
Service Oriented Architecture (SOA) since shared services and data sets might be
used in the course of the job workﬂow execution. Provenance information can be
processed and used for various purposes, for example, for validation of e-Science
experiments [2], credibility analysis of the results of workﬂow execution [3], faulttolerance for service-based applications [4], and data sets regeneration for data
intensive scientiﬁc applications [5].
The provenance information can be generated from the static information
available in the original workﬂow speciﬁcation (e.g., data dependencies) together
with the runtime details obtained by tracing the execution of the workﬂow execution. The trace can be automatically generated by developing either a special
“wrapping service” of the engine [6] or an “engine plugin” [7] to capture and
record provenance related data directly from the workﬂow engine. The workﬂow
trace can also be collected collectively by the services that execute the subjobs [8]
or the services together with the workﬂow engine [9]. But, this puts the responsibility of provenance data recording to the service providers and may also require
service modiﬁcation.
Y. Shi et al. (Eds.): ICCS 2007, Part I, LNCS 4487, pp. 398–405, 2007.
c Springer-Verlag Berlin Heidelberg 2007

Provenance Provisioning

399

No matter how the traces are collected, in general some special provenance services are used in the current systems to store the provenance data and to provide
an interface for users to query the data. Thus, a protocol is needed for various
service providers and the workﬂow engine to communicate with the provenance
services during the provenance collection process [1]. A taxonomy of data provenance techniques can be found in [10], and a comprehensive documentation on
provenance architecture can be found in [11].
Data intensive scientiﬁc applications often involve high volume, and distributed data sets. They can be generally expressed as a workﬂow of a number of
analysis modules, each of which acts on speciﬁc sets of data and performs cross
multidisplinary computations. To reduce the communication overhead caused by
data movement and to provide decentralized control of execution during workﬂow
enactment, the Mobile Code Collaboration Framework (MCCF) is developed to
map the execution of subjobs to the distributed resources and to coordinate the
subjobs’ execution on runtime according to the abstract workﬂow provided by
users [12]. LMA [13] is used in the MCCF for the purpose of separating functional description and executable code. The functional description of LMA is
described using Agent Core (AC). An AC is essentially an XML ﬁle, containing
the job workﬂow speciﬁcation and other necessary information for agent creation
and execution. An AC can be migrated from one resource to another. As for the
executable code, to separate subjob speciﬁc code and common non-functional
code (i.e., code for handling resource selection, subjob execution, agent communication, and AC migration), Code-on-Demand (CoD) [14] is used in the MCCF,
that is, subjob speciﬁc code is downloaded to the computational resource and
executed on demand. This enables an analysis module in the data intensive scientiﬁc applications to be executed at a computational resource close to where
the required data set is. The execution of common non-functional code is carried
out by a group of underlying AC agents (or agents in short).
The MCCF, which does not have a centralized engine, is diﬀerent from the
existing scientiﬁc workﬂow engines (e.g., Condor’s DAGMan1 , and SCIRun2 ).
Hence, the objective of this paper is to develop a provenance recording and
collection algorithm so that mobile agents deployed in the execution of a job
workﬂow can collectively collect a complete set of information about the job
workﬂow execution.

2

Partner Identiﬁcation in the MCCF

Job workﬂows in MCCF are modeled using Directed Acyclic Graph (DAG). A
DAG can be denoted as G = (J , E), where J is the set of vertices representing
subjobs, i.e., J ={J0 , J1 , ..., Jn−1 }. E is the set of directed edges between subjobs.
There is a directed edge from subjob Ji to Jj if Jj requires Ji ’s execution results
as input. Data dependency (denoted as “<”) between two subjobs exists if there
1
2

http://www.cs.wisc.edu/condor/dagman/
http://software.sci.utah.edu/scirun.html

400

Y. Feng and W. Cai
0
0

1

2

1

0

2

1

0

2

1

2
4

4

3

7

5
8

6

4

3

7

5
8

6

9

9

1. assign subjob ID

2. remove edges indicating
indirect successors

(a)

(b)

4

3

7

5
8

6
9

5
8

(c)

“m” edge
“c” edge
“d” edge

9
g0

3. generate a spanning tree

3

6

7

g1

g2

g3

4. group subjobs and label edges
(d)

Fig. 1. Steps of the Preprocessing Algorithm

is a path between the subjobs. It is also assumed that a DAG representing a job
workﬂow always has a unique staring node, J0 , and a unique end node, Jn−1 .
When multiple data independent subjobs can be executed concurrently, replicas of an existing AC will be generated so that there is one AC for each subjob.
MCCF uses a preprocessing algorithm to generate information for determining
when and how to create AC replicas and generate information for the decision of
which AC replica’s agents will be responsible for the resource selection for a common successor [15]. The preprocessing algorithm performs the following steps:
(i) Assign subjob ids: Topological order is used to assign subjob ids from 0 to
n − 1, as shown in Figure 1(a). (ii) Remove indirect successors. Let S(Ji )
denote the successor set of subjob Ji . ∀ Jj1 , Jj2 ∈ S(Ji ), Jj2 is called Ji ’s indirect
successor if Jj1 < Jj2 , otherwise, it is called Ji ’s immediate successor. If Jj is
the indirect successor of Ji , the corresponding edge (Ji , Jj ) will be removed from
the DAG, as shown in Figure 1(b). (iii) Generate spanning tree: A spanning
tree is generated based on a Depth-First Search (DFS)3 on the DAG, as shown
in Figure 1(c). (iv) Group subjobs: A pre-order traversal is applied to the
spanning tree to generate a visit sequence of nodes, and the leaves in this sequence will partition it into a number of groups. For example, the visit sequence
generated for the spanning tree shown in Figure 1(c), < 0, 2, 5, 8, 9, 7, 1, 4, 6, 3 >,
is partitioned into groups: {0, 2, 5, 8, 9}, {7}, {1, 4, 6} and {3}, as illustrated in
Figure 1(d). (v) Label edges: The edges between two subjobs, Ji and Jj , in the
m
same group are labeled “m” (denoted as Ji → Jj ), the edges between subjobs
c
of diﬀerent groups are labeled “c” (denoted as Ji → Jj ), and the edges in the
d

original DAG but not in the spanning tree are labeled “d” (denoted as Ji → Jj ),
as illustrated in Figure 1(d).
The preprocessed information is included in the AC and used during the dynamic job workﬂow execution. Suppose the current subjob is Ji , for one of its
m
outgoing edges, (Ji , Jj ): (i) If Ji → Jj , the AC agents will select the resources
for executing Jj . The AC replica will be migrated for Jj ’s execution after Ji
c
completes its execution. (ii) If Ji → Jj , similar to the last case, the AC agents
will select the resources for executing Jj , but a new AC replica will be created
3

We assume that the depth-ﬁrst search and pre-order traversal algorithms visit child
nodes in the order from right to left.

Provenance Provisioning

401

d

for Jj ’s execution. (iii) If Ji → Jj , the AC agents need to communicate so that
Jj can locate the location of Ji ’s execution result.
The MCCF uses a contact list based agent communication mechanism [16]
for subjob result notiﬁcation. Two agents communicating with each other are
called communication partners (or partners in short). Each AC maintains a list of
partners with their locations (that is, a contact list). Before an AC is migrated
or discarded, its agents will notify its partners so that they can update their
contact lists accordingly. The location of the subjob’s execution result will also
be notiﬁed to the partners. The partner identiﬁcation is carried out dynamically
during the job workﬂow execution. Assume Ed is a set of edges that are marked
with “d” in G = (J , E). Also assume that in the spanning tree generated by the
preprocessing algorithm described above, a sub-tree rooted at Ji is denoted as
TJi . Suppose Ji and Jj are two subjobs that are currently under execution, if
∃(Ji , Jj ) ∈ Ed , and Ji ∈ TJi ∧ Jj ∈ TJj , then the AC agents executing the
subjobs Ji and Jj are partners4 .

3

Provenance Recording and Collection Protocol

Let G(Ji ) be the group id of subjob Ji . It is easy to prove that the grouping
algorithm described in the last section has the following property:
In G, ∀ Ji ∈ J and G(Ji ) > 0, there exists a path p from Ji to Jn−1 ,
where for any two consecutive subjobs, e.g., Jkq and Jkq+1 , on the path
p, we have G(Jkq ) ≥ G(Jkq+1 ).
p is called a propagation path. It is obvious that the AC that is ﬁnally returned
to the user (that is, the original AC created by the user) will contain a complete provenance information for the job workﬂow if partners with higher group
id propagate provenance information to the partners with the lower group ids
during the job workﬂow execution. This forms the basis for the development of
the provenance recording and collection protocol.
Let R(Ji ) denote a subset of Ji ’s successors, where for any subjob Jj ∈ R(Ji ),
m
c
we have either (Ji → Jj ) or (Ji → Jj ). Assuming that subjob Ji is under
execution, the main steps of the protocol are:
– On receiving a communication message from its partner, Ji updates its AC to
include the provenance information and updates its contact list accordingly.
– On completion of Ji ’s execution, Ji ’s corresponding AC agents will record
the location of Ji ’s execution result into Ji ’s AC.
– If R(Ji ) = ∅, as stated in Section 2, for each subjob Jj , Jj ∈ R(Ji ), AC
agents corresponding to Ji will locate resources, that is, the computational
resource, the input data sets from the distributed data repository, and the
code from the code repository, for the execution of Jj . These information
4

More detail about the preprocessing based dynamic partner identiﬁcation algorithm
can be found in [15].

402

Y. Feng and W. Cai

will be recorded in Ji ’s AC. Then, if |R(Ji )| > 1, |R(Ji )| − 1 replicas of Ji ’s
c
AC will be created, one for each subjob Jj , Jj ∈ R(Ji ) and (Ji → Jj ).
– Before Ji ’s corresponding AC is migrated (or discarded if R(Ji ) = ∅), Ji ’s
AC agents will send a communication message to all its partners in the contact list for execution coordination and contact list updating. The message
contains the location of Ji ’s execution result, and the scheduling information
for each Jj , Jj ∈ R(Ji ). The scheduling information for subjob Jj includes:
subjob id, the id of the AC replica to be used to execute the subjob, locations
of the selected computational resource, input data sets, and code for the execution of the subjob. In addition, if the partner has a smaller group id,
provenance information received by Ji from its partners with a larger group
id (recorded in Ji ’s AC replica) during Ji ’s execution is also piggyback on
the message.
Using the above protocol, the provenance information will be recorded in
the AC replicas and propagated along propagation paths during the distributed
execution of job workﬂow. Eventually, the AC that is ﬁnally returned to the
user will contain the complete provenance information about the job workﬂow
execution.

4

Performance Evaluation

As explained in the last section, the provenance information is transmitted along
with the messages for execution coordination and contact list updating. Although
there is no additional message required, the size of message will be increased.
There is no centralized server used during the provenance information recording
and collection.
Execution provenance information can also be collected using a centralized
provenance server which maintains a provenance repository. For each subjob
executed, the AC agents need to notify the centralized server about the provenance information. After a job workﬂow completes its execution, users can then
get the provenance information from the server. In this centralized approach,
additional messages are required for AC agents to communicate with the provenance server. Assuming that there is no need to collect provenance information
for the start and end nodes (since they are assumed to have zero computation
cost), the traﬃc generated in the centralized model can be estimated by:
(n − 2) ∗ msg

(1)

where msg denotes the average size of a provenance message carrying a single
provenance record.
To evaluate the performance of our distributed provenance collection algorithm, randomly generated Task Graphs (TG), that is, job workﬂows, were
executed in the prototype MCCF system [12] on a cluster of computers. Six
pseudo-random TGs were generated using TGFF5 . As stated in Section 2, ∀ Ji ∈
5

http://ziyang.ece.northwestern.edu/tgff/

Provenance Provisioning
0
1
3

5
9

23

8

4
7

3

22 21 20 19

18

28 29 33 32 31 30 27 26 25 24

6

5
8
10
14

34
TG0

11

7

15
TG1

15

9
13

12

7
14

6
13

11

3

2

10
12

9

3

6

8

5

10

3
8

9

17

16

20

19

22

25

7
13

15

24

29

16
TG2

0

1

4

4

5

6

14 13 11 17 16

0

2

1

2
4

10
15 12

0
1

0

0
1

2

403

14

4
12

11

7
9

18

21
28
30

5
6
8

11
23

27

26

10

13

12

2
4

3

5

7

10

8

6
9
11

12
13

14
16

31
14

32
TG3

1
2

TG4

15

17
TG5

Fig. 2. Random Task Graphs

J , 0 < i < (n − 1), J0 < Ji < Jn−1 . Thus, when a TG has multiple subjobs that
have no oﬀspring, a hypothetical subjob is added, with no computation cost, to
serve as the common immediate successor of such subjobs. The generated TGs
are illustrated in Figure 2, where the dotted ﬁlled circles represent the added
hypothetical subjobs, and the dotted edges represent the added edges.
The number of messages for execution coordination and contact list updating
is illustrated in Table 1. These communication messages are required no matter whether decentralized or centralized method is used. During a job workﬂow
execution, the messages that carry the propagated provenance records and the
number of provenance records carried by such message were tracked. For a fair
comparison with the centralized method, assuming that each propagated provenance record is carried by a separate provenance message, the total number of
such messages in the decentralized method would be the summation of the number of propagated provenance records contained in all the tracked messages6 .
Each job workﬂow was executed 3 times, and the average numbers are shown in
Table 1. Note that for the centralized method, formula (1) is used to calculate
the number of messages generated for the provenance collection.
Table 1. Experiment Results
Task Graph Msgs for Execution
Msgs for Provenance
% Improvement
Coordination
Decentralized Centralized
TG0
38
8
33
76%
TG1
5
0
14
100%
TG2
14
0
15
100%
TG3
44
11
31
65%
TG4
12
0
13
100%
TG5
21
7
16
56%

Table 1 also shows the percentage improvement of the decentralized method
over the centralized one. From these results, we observe that the centralized
model always generates higher number of messages for provenance information
recording. Particularly, by recording the provenance information in the workﬂow
6

Note that in general the bandwidth consumed by two or more messages sent separately is larger than that of sending them in a single bundle [17].

404

Y. Feng and W. Cai

speciﬁcation in the AC, provenance record does not always needs to be propagated during a job workﬂows’ execution. For example, no additional provenance
record is propagated during the execution of task graphs TG1, TG2, and TG4
(and thus there is no provenance message required). In the execution of these
task graphs, the agents of the AC replicas created during the runtime are the
partners of the agents of the original AC. Therefore, propagation of provenance
information is not required. In this case, the percentage improvement of the
decentralized model over the centralized model is 100%.

5

Conclusion and Future Work

Mobile agent-based distributed job workﬂow execution hides scientists from the
Grid details, but also hides how the result is achieved (that is, the provenance of
the job workﬂow execution). Since data processing in scientiﬁc computing may
require some level of validation and veriﬁcation, the information on the services
and data sets used during the workﬂow execution is required. The provenance
in many existing scientiﬁc workﬂow engines relies on a centralized provenance
collection server for provenance recording and collection. However, in mobile
agent-based distributed job workﬂow execution, there is no centralized workﬂow
engine and thus naturally the provenance recording and collection should also
be carried out in a distributed manner.
By studying the agent communication in the MCCF and the properties of
the preprocessing algorithm for partner identiﬁcation, a distributed provenance
recording and collection protocol has been developed. The subjob provenance
information is transmitted along the provenance propagation paths. Since provenance information is piggyback with the messages for execution coordination and
contact list updating, there is no additional message required. To evaluate our
approach, experimental study has been carried out on randomly generated job
workﬂows. The results show that our approach has less communication overhead
than the one using a centralized provenance server for provenance information
recording and collection.
In the current algorithm, a subjob’s provenance information might be propagated along multiple propagation paths. As a future work, the shortest and
unique propagation path for a given subjob will be identiﬁed. This will further reduce the communication cost caused by propagation of provenance information. Although currently the execution coordination in the MCCF uses
the contact list based mechanism, the provenance recording and collection protocol proposed in this paper should also work for other message-passing based
execution coordination mechanisms (e.g., mailbox based mechanism [18]).

References
1. Groth, P., Luck, M., Moreau, L.: A protocol for recording provenance in serviceoriented grids. In: 8th Intl Conf on Principle of Distributed Systems (PODIS2004),
Grenoble, France (December 2004) 124–139

Provenance Provisioning

405

2. Wong, S.C., Miles, S., Fang, W.J., Groth, P., Moreau, L.: Provenance-based validation of e-science experiments. In: 4th Intl Semantic Web Conference. Volume
3729., Galway, Ireland (November 2005) 801–815
3. Rajbhandari, S., Wootten, I., Ali, A.S., Rana, O.F.: Evaluating provenance-based
trust for scientiﬁc workﬂows. In: 6th IEEE Intl Symp on Cluster Computing and
the Grid (CCGrid2006), Singapore (May 2006) 365–372
4. Townend, P., Groth, P., Xu, J.: A provenance-aware weighted fault tolerance
scheme for service-based applications. In: 8th IEEE Intl Symp on Object-oriented
Real-time Distributed Computing, USA (May 2005) 258–266
5. Foster, I., Voeckler, J., Wilde, M., Zhao, Y.: Chimera: A virtual data system for
representing, querying, and automating data derivation. In: 14th Intl Conf on
Scientiﬁc and Statistical Database Management. (July 2002) 37–46
6. Rajbhandari, S., Walker, D.W.: Support for provenance in a service-based computing Grid. In: UK e-Science All Hands Meeting 2004, UK (September 2004)
7. Zhao, J., Goble, C., Greenwood, M., Wroe, C., Stevens, R.: Annotating, linking and
browsing provenance logs for e-Science. In: Wksp on Semantic Web Technologies for
Searching and Retrieving Scientiﬁc Data (in conjunction with ISWC2003, CEUR
Workshop Proceedings). Volume 83., Florida, USA (October 2003)
8. Bose, R., Frew, J.: Composing lineage metadata with XML for custom satellitederived data products. In: 16th Intl Conf on Scientiﬁc and Statistical Database
Management, Washington, DC, USA (2004) 275–284
9. Simmhan, Y.L., Plale, B., Gannon, D.: A framework for collecting provenance in
data-centric scientiﬁc workﬂows. In: IEEE Intl Conf on Web Services 2006 (ICWS
2006), Chicago, USA (September 2006)
10. Simmhan, Y.L., Plale, B., Gannon, D.: A survey of data provenance in e-Science.
SIGMOD Record 34(3) (September 2005) 31–36
11. Groth, P., Jiang, S., Miles, S., Munrow, S., Tan, V., Tsasakou, S., Moreau, L.: An
architecture for provenance systems. Technical report, Electronics and Computer
Science, University of Southampton (October 2006)
12. Feng, Y.H., Cai, W.T.: MCCF: A distributed Grid job workﬂow execution framework. In: 2nd Intl Symposium on Parallel and Distributed Processing and Applications. Volume 3358., Hong Kong, China, LNCS (December 2004) 274–279
13. Brandt, R., Reiser, H.: Dynamic adaptation of mobile agents in heterogeneous environments. In: 5th Intl Conf on Mobile Agents (MA2001). Volume 2240., Atlanta,
USA, LNCS (December 2001) 70–87
14. Fuggetta, A., Picco, G.P., Vigna, G.: Understanding code mobility. IEEE Trans
on Software Engineering 24(5) (1998) 342–361
15. Feng, Y.H., Cai, W.T., Cao, J.N.: Communication partner identiﬁcation in distributed job workﬂow execution over the Grid. In: 3rd Intl Wksp on Mobile Distributed Computing (in conjunction with ICDCS05), Columbus, Ohio, USA (June
2005) 587–593
16. Cabri, G., Leonardi, L., Zambonelli, F.: Coordination infrastructures for mobile
agents. Microprocessors and Microsystems 25(2) (April 2001) 85–92
17. Berger, M.: Multipath packet switch using packet bundling. In: High Performance
Switching and Routing (Workshop on Merging Optical and IP Technologies), Kobe,
Japan (2002) 244–248
18. Cao, J.N., Zhang, L., Feng, X., Das, S.K.: Path pruning in mailbox-based mobile
agent communications. J. of Info Sci and Eng 20(3) (2004) 405–242

