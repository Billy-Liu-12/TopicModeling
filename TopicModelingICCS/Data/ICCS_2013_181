Available online at www.sciencedirect.com

Procedia Computer Science 18 (2013) 280 – 289

International Conference on Computational Science, ICCS 2013

Operator-level GPU-accelerated Branch and Bound algorithms
I. Chakroun and N. Melab
Universit´e Lille 1, LIFL/UMR CNRS 8022 - INRIA Lille Nord Europe
59655 - Villeneuve d’Ascq cedex - France

Abstract
Branch-and-Bound (B&B) algorithms are well-known tree-based exploratory methods for solving to optimality NP-hard
discrete optimization problems. The construction of the B&B tree and its exploration are performed using four operators:
branching, bounding, selection and pruning. Such algorithms are irregular which makes challenging their parallel design and
implementation on GPU accelerators. Among the few existing related works, we have recently revisited on GPU the bounding
operator. The reported results show that speedups up to ×100 can be obtained on recent GPU cards. In this paper, we address
the GPU-based design and implementation of B&B algorithms considering the branching and pruning operators as well as
the bounding one. The proposed template transforms the unpredictable and irregular workload associated to the explored
B&B tree into regular data-parallel kernels optimized for the SIMD-based execution model of GPUs. Thread divergence and
uncoalesced memory accesses are considered in the optimization process. The proposed approach has been experimented on
the Flow-Shop scheduling problem and compared to another GPU-based strategy and to a cluster of workstations (COWs)
based approach. The reported results demonstrate the eﬃciency of the proposed approach over the two other ones. Speedups
up to ×160 are obtained for large problem instances using an Nvidia Tesla C2050 hardware conﬁguration.
Keywords:
Irregular algorithms, GPU Computing, Parallel Branch and Bound, Flow-Shop Scheduling Problem.

1. Introduction
Nowadays, Graphics Processing Units (GPUs) are at the leading edge of many-core parallel computational
platforms in many research ﬁelds. They have evolved into fully programmable architectures designed for highthroughput applications. The massive data processing capability of the GPU is attracting researchers to explore
the use of graphics accelerators for general purpose programming (GPGPU). However, the trend in the GPGPU
scientiﬁc computing community concentrates on designing regular data-parallel programs. Such programs are
easier to schedule on architectures like GPUs which are based on the Simple Instruction Multiple Data (SIMD)
programming model. On the other hand, few insights into exploiting the parallelism of irregular algorithms on
top of GPUs exist. Because they are characterized by irregular kernels in size and behavior, scheduling irregular
applications on top of SIMD-based architectures is more diﬃcult and more likely to lead to imbalanced executions.
In this work, we investigate two diﬀerent approaches for designing irregular tree-based algorithms on top of
GPUs. For experimental study we consider the parallel Branch and Bound (B&B) algorithm widely used for
solving combinatorial optimization problems. B&B algorithms are considered as one of the most challenging
tree-based algorithms in the ﬁeld of parallel computing [1, 7]. Indeed, they perform an irregular and unpredictable
enumeration of all the solutions of a problem. The enumeration is executed by building and exploring a tree which
1877-0509 © 2013 The Authors. Published by Elsevier B.V. Open access under CC BY-NC-ND license.
Selection and peer review under responsibility of the organizers of the 2013 International Conference on Computational Science
doi:10.1016/j.procs.2013.05.191

I. Chakroun and N. Melab / Procedia Computer Science 18 (2013) 280 – 289

represent the solution space of the problem being solved. B&B proceeds in several iterations during which the
search space is built dynamically using four operators: branching, bounding, selection and pruning. During the
execution of the B&B algorithm, the number of new generated nodes and the number of not yet explored but
promising nodes are variable and depend on the level of the tree being explored and on the best solution found so
far. Therefore, due to such unstructured and unpredictable nature of its search tree, designing eﬃcient B&B on
top of GPUs is not straightforward.
The main contribution of this paper is to investigate two diﬀerent approaches for designing irregular B&B
algorithms on top of GPUs. The ﬁrst one is an extension of the model proposed in [2]. This approach consists
in exploring in parallel diﬀerent sub-spaces of the tree. Selected parent nodes from the tree are assigned to
diﬀerent GPU threads which locally execute their own B&B. Each GPU thread locally performs the branching,
bounding and pruning operators and returns back to the host the list of promising nodes that would be explored in
the following iterations. The second approach we propose consists in transforming the irregular tree search into
regular tasks (operations) to be performed in parallel. All GPU threads compute in parallel the same amount of
work on one unique node. Using persistent data structures, the diﬀerent operators are applied in parallel on a pool
of pending nodes. The two approaches have been applied to the permutation Flowshop Scheduling Problem (FSP)
which is an NP-hard combinatorial optimization problem.
The remainder of this paper is organized as follows. Section 2 presents a brief introduction of Branch and
Bound algorithms and the permutation Flowshop Scheduling Problem used as a case study. Section 3 presents
some related works that deal with designing Branch and Bound on top of GPUs. Section 4 details the ﬁrst scheme
based on parallel irregular computations. In Section 5, details are given about the second scheme where the
search process is transformed into iterative parallel regular tasks. Section 6 details the used experimental protocol
and discusses the performances of both approaches. In Section 7, we compare the performance of our eﬃcient
operator-driven GPU algorithm to a highly distributed CPU-based version of the B&B using up to 500 CPU cores.
Some conclusions and perspectives of this work are drawn in Section 8.
2. Branch and Bound algorithm
Branch-and-bound algorithms are one of the most used tools for exactly solving large scale NP-hard combinatorial optimization problems. B&B allows to ﬁnd the optimal solution of a problem and to prove that no better
one exists. B&B are also one the most used tree-based algorithms. The basic idea of the B&B algorithm consists
in an implicit search through the space of all the feasible solutions by dividing the original problem into slightly
easier sub-problems and solving them recursively. Enumerating the solutions of a problem consists in building a
dynamically generated search tree whose nodes are subsets of solutions of the considered problem. Each node of
the Branch and Bound tree corresponds to a distinct sub-problem. The construction of such tree and its exploration
are performed using four operators: branching, bounding, selection and pruning.
The algorithm proceeds in several iterations during which the best solution found so far is progressively improved. At any point during the exploration process, the search space is described by a pool of unexplored nodes
and the best solution found so far. The generated and not yet explored sub-spaces are kept into a list initialized
with the original problem. At each iteration, the selection operator picks a problem from the list of pending nodes.
The branching operator splits the underlying problem into sub-problems through the addition of constraints. For
each of the resulting sub-problems, a lower bound (an estimated solution cost) is computed. The lower bound
value is then used by the pruning operator to decide whether to prune the node or to insert it into the list for future
exploration.
In this work, our focus is on the Branch and Bound algorithm applied to the permutation Flowshop Scheduling
Problem (FSP). FSP is a combinatorial optimization problem and one of the most important problems in the
scheduling theory. Solving FSP consists in scheduling n jobs J1 , J2 , ..., Jn on a set of m machines M1 , M2 , ..., Mm .
The machines are critical resources, i.e. two jobs cannot be assigned to one machine simultaneously and a machine
cannot start processing a job if all the machines located upstream did not ﬁnish their treatment. A job Ji is
composed of m interrupted operations ti1 , ti2 , ..., tim , where ti j corresponds to the jth task of the job Ji processed
by the machine M j. FSP aims to ﬁnd the optimal schedule of n jobs on m machines so that the overall completion
time of all jobs, called makespan, is minimized. For m = 2, an optimal schedule can be found in O(n.log(n))

281

282

I. Chakroun and N. Melab / Procedia Computer Science 18 (2013) 280 – 289

steps using Johnson’s algorithm [8]. However, for more than three machines, minimizing the makespan has been
proven to be NP-hard [6].
Solving permutation scheduling problems is a great challenge for combinatorial optimization because of the
large search space they induce. For a problem of n job the search space is composed of n! permutations. However,
having in mind that the computational requirements for obtaining an optimal solution increase exponentially
with the problem size, for large problem instance like the 200 jobs over 20 machines, the size of the search space
becomes exorbitant (200! schedules for the underlying instance). Due do such complexity, extensive works studied
the use of B&B to solve FSP [5, 10]. Thanks to its bounding operator, B&B allows to signiﬁcantly reduce the
number of nodes to explore avoiding the search in some branches of the search tree. However, applying B&B to
FSP induces a highly irregular workload due on the one hand to the unpredictable number of branches pruned by
the algorithm and on the other hand to the representation of FSP.
Unlike some other combinatorial optimization problems such as the Knapsack problem where the search tree
is binary, the number of generated sub-problems for FSP is variable and diﬀerent from one level to another. For
FSP, an internal node of the search tree corresponds to a partial schedule of some jobs. Regardless of its level in
the tree, each internal node would have two pools of children: the ﬁrst pool of children is obtained by scheduling
jobs at the beginning of the partial schedule while the second results from scheduling jobs at the end of the partial
schedule.
3. Related work
Few insights into exploiting the parallelism of irregular algorithms on top of GPUs exist. As far as the Branch
and Bound algorithm is concerned, apart from our previous contributions [3, 4] only two works [9], [2] deal with
designing Branch and Bound on GPUs. Moreover, our work [3] was the prior work investigating GPU-based B&B
applied to FSP problems.
In [3], a new approach has been proposed. Based on preliminary experiments carried out on some Taillard’s
problem instances [11], a parallel bounding (parallel evaluation of bounds) model has been rethought for GPUs.
The results of the preliminary experiments have shown that the evaluation of lower bounds sub-problems takes on
average between 97% and 98% of the total execution time of the B&B.
In [9], the B&B has been applied to the knapsack problem which is also a well-known combinatorial optimization problem. However, the knapsack unlike other combinatorial optimization problems such as FSP, quadratic
assignment problem QAP, traveling salesman problem TSP, etc. is solved using a binary search tree: at each level
on the tree, a parent node has only two children. Hence, the workload computed by each thread of the device is
the same and no irregular task balancing occurs. The authors have also opted for a breadth search strategy which
means that the pool of nodes that would be oﬀ loaded to the GPU are from the same tree level unless from successive levels. This selection strategy emphasizes the regular amount of the work ﬂow that is assigned to each thread.
In [3] and [2], the depth ﬁrst selection strategy is considered. This latter leads to more unstructured workload than
the breadth ﬁrst one since the sub-problems are picked from diﬀerent levels of the tree. The decomposition and
evaluation of the sub-problems is performed on GPU. The resulting children are moved back to the host which
prunes the non promising nodes.
In [2], the B&B is applied to the traveling salesman problem. In the proposed approach, a pool of nodes is
oﬀ loaded to the GPU where to each thread is assigned a node. Each thread applies the branching and bounding
operators to the underlying node and builds its own local tree. The resulting nodes are moved back to the host
where the promising nodes are inserted into the tree and non promising ones are eliminated.
4. The tree partitioning-driven GPU-accelerated approach
The ﬁrst approach we investigate for designing B&B on GPUs consists in exploring in parallel the generated
search space such as proposed in [2]. The idea is to divide the global search space into disjoint sub-spaces that
are explored in parallel by the GPU threads. However, while the approach proposed in [2] performs the pruning
operator on the CPU side, in the schema considered in this paper we added a further degree of concurrency by
computing the elimination operator on the GPU device. Moreover, in [2] the size of the pool to be oﬀ loaded

283

I. Chakroun and N. Melab / Procedia Computer Science 18 (2013) 280 – 289

to the GPU is determined statically without taking into consideration neither the instance of the problem nor the
underlying hardware conﬁguration. In our approach, the size of the pool to be transfered to the device is calculated
dynamically at runtime depending on the instance being solved and the used GPU conﬁguration. The tunning of
the pool size is done transparently to the user in the ﬁrst iterations of the algorithm.
As explained in Section 2, during the execution of a B&B, the search space is described by a list of unexplored
(pending) nodes and the best solution found so far. In the considered GPU-based schema, a set of parent nodes
is selected from this list according to their depth: deepest pending nodes are the ﬁrst selected. The selected pool
of nodes is oﬀ loaded to the GPU where each thread builds its own local search tree by applying the branching,
bounding and pruning operators to the assigned node. The size of the set of nodes to be oﬀ loaded to the GPU,
is determined using our heuristic, proposed in [4], that dynamically returns the best pool size according to the
problem instance and the underlying hardware.
Algorithm 1 Kernel of the tree partitioning-driven GPU-accelerated Branch and Bound.
Data: Fathers = Parents nodes.
Result: Children = Nodes to be explored in the next iterations.
thread idx = Get thread id() ;
father = fathers[thread idx];
output position = fathers[thread idx - 1];
for j ∈ [ father.limit1 + 1 , father.limit2 ] do
child begin = Generate child Begin(j);
child end = Generate child End(j);
Evaluate Lower Bound(child begin);
Evaluate Lower Bound(child end);
end
if Choose Begin End() == Begin then
Prune End();
Write Begin in Children(output position);
end
else
Prune Begin();
Write End in Children(output position);
end
According to the CUDA threading model, each thread has a unique identiﬁer used to determine its assigned
role, assigns speciﬁc input and output positions and selects work to perform. Therefore, each node (problem)
from the pending list is mapped to a thread to ensure that each sub-space of the solution space will be evaluated
concurrently and will be disjoint from others. As detailed in Algorithm 1, thread i branches the node i, thread i + 1
branches the nodes i + 1 and so on. For each node i from the list, the number of children is calculated using the
formula deﬁned in Equation 1. Based on this number, an output pool is allocated where the generated children
will be written.
nb children = 2 * ( permutation size - node depth )

(1)

As explained in Section 2, each internal FSP sub-problem has two pools of children called Begin and End.
If the generated child corresponds to a schedule of a job at the beginning of the partial permutation, the child is
inserted is the pool Begin otherwise it is put in the pool End. Then, thread i computes the lower bound value for
each child of the node i and writes the resulting nodes into the output pool in the position speciﬁed by its index.
For pruning nodes, thread i compares the value of the bound of each node of the pool Begin and End to the best
solution found so far and decides which pool to move back to the CPU and which pool to delete.

284

I. Chakroun and N. Melab / Procedia Computer Science 18 (2013) 280 – 289

5. A new approach: Operator-driven GPU-accelerated B&B
To identify the best schema for the GPU-accelerated B&B, we performed preliminary experiments to measure
the execution time of each operator of the algorithm. The results for the FSP Taillard’s problem instances [11]
show that the bounding operation takes on average between 97% and 98% of the total execution time of the
algorithm. Therefore, the ﬁrst operator we rethought for GPU was the parallel computation of the lower bounds.
The idea of our reshaped B&B for GPU is to oﬀ load a pool of pending nodes to the GPU where each node is
evaluated in parallel. The branching and pruning steps are performed on the CPU side. However, the execution
time of these latter operators becomes more signiﬁcant due to the pre-treatment and the post-treatment of the pool
to be transfered to the GPU.
Algorithm 2 The template of our GPU-accelerated Branch and Bound based on the parallelization of the branching, bounding and pruning operators.
Create the initial problem;
Inset the initial problem into the tree;
Set the Upper Bound to ∝;
Set the Best Solution to ∅;
while not empty tree() do
Sub Problem = Take sub problem();
if Is leaf ( Sub Problem ) then
Upper Bound = Cost Of( Sub Problem );
Best Solution = Sub Problem;
end
else
if Pool Of Fathers.size() < GPU Pool Size then
Pool Of Fathers.push(Sub Problem);
end
end
Copy Fathers Pool To GPU();
Copy Number Children Pool To GPU();
Branching Kernel<<>>;
Bounding Kernel<<>>;
Pruning Kernel<<>>;
Insert Promising Childs();
GPU Pool Size = Run Heuristic For Tuning Pool Size();
end
Therefore, we again rethought our GPU accelerated Branch and Bound by improving the degree of concurrency. The algorithm, as detailed in Algorithm 2, proceeds as follows: the pool of sub-problems is selected from
the tree and oﬀ loaded to the GPU where the branching operator is applied ﬁrst. Here, it is important to highlight
that we take care of using persistent data structures in order to minimize the data transfers between the CPU and
the GPU. Hence, the generated pool of children is kept in the device memory and used by the second kernel which
implements the parallel evaluation of bounds. Then the evaluated pool of children is again kept in the device
memory (so not moved back to the CPU) where the pruning operator is run in parallel to decide which nodes
should be moved back to the CPU and which nodes should be deleted.

I. Chakroun and N. Melab / Procedia Computer Science 18 (2013) 280 – 289

5.1. The selection operator
The selection operator picks a problem from the list of pending nodes for future exploration. Our selection
strategy in this work is based on the depth of a node in the B&B tree. One of the ﬁrst challenging concerns
of our GPU-accelerated B&B is to rethought the selection operator so that the device is supplied with a large
and appropriate pool of sub-problems. As solution to this issue, we proposed in [4] an empirical heuristic for
auto-tuning parameters at runtime. The main idea of this approach is to adapt the selection operator during the
ﬁrst iterations of the B&B algorithm so that sub-problems are picked from the tree search using diﬀerent-sized
“waves”. The heuristic ﬁrst identiﬁes the characteristics of the underlying hardware conﬁguration. Thanks to this
property, the algorithm becomes highly portable and could easily be run over heterogeneous GPU architectures
transparently to the user. The heuristic automatically and iteratively determines the maximum conﬁguration that
can be used, namely the maximum number of threads and blocks that can run in parallel over the GPU card.
At each iteration, the eﬃciency associated to the used pool size is computed and doubled. When the maximum
number of threads and blocks is reached, the doubling process terminates. The heuristic computes a downwards
and an upwards search around the best pool size found so far. The size of the pool that allows the best eﬃciency
is used for the remaining iterations of the algorithm.
5.2. Parallel decomposition of the parent nodes
In the branching schema used in the tree partitioning-based GPU-accelerated B&B model presented in Section
4, each thread generates all the children of its parent node leading to an unbalanced workload between threads.
For instance, let us consider the example below which is extracted from the template of Algorithm 1 (see 4) and
used in the implementation of the decomposition operator.
for j ∈ [ father.limit1 + 1 ; father.limit2 ] do
child begin = Generate child Begin(j);
child end = Generate child End(j);
end
Let us suppose that the underlying instruction is executed by 32 threads 1 where (father.limit2 - father.limit1)
is equal to 100 for the ﬁrst thread and to 10 for the other 31 threads. Depending on their data, some threads may
execute the code associated with the ”true” condition (j <= father.limit2) and other threads may execute the code
associated with the ”false” condition (j > father.limit2). However, since the instruction decoder can only handle
one branch at a time, diﬀerent branches cannot be executed concurrently and would be executed in sequence.
Hence, the warp serially executes each branch path taken and threads that are not on that path are disabled. When
all paths are completed, the threads converge back to the same execution path. The problem in this case is that no
other warps are allowed to run on that multiprocessor meanwhile because the warp is not completely idle. This
behavior is called thread divergence and often impacts the throughput of the application.
In order to make sure that all threads execute exactly the same amount of work, we redeﬁned the branching
operator so that each active thread generates only one of the children of its parents node. While in the tree
partitioning-based method, the thread i generates all the children of its parent node, in our approach thread i only
generates one child of its parent node according to its unique identiﬁer. A part from the pool of parent nodes,
a pool containing the number of children of each parent node is oﬀ loaded to the device. Compared to the tree
partitioning-based method, our approach for computing in parallel the branching operator prevent from the thread
divergence phenomenon explained above since no conditional instructions occur and all threads execute exactly
the same instructions.
Like thread divergence, coalescing global memory accesses is a key enabler for achieving higher throughput.
Memory coalescing occurs when threads of the same warp read global memory in an ordered pattern. If perthread memory accesses within a warp constitute a contiguous range of addresses, accesses will be coalesced into
a single memory transaction. Otherwise, accessing misplaced locations induces memory divergence and requires
1 The

size of a warp in the used G80 model.

285

286

I. Chakroun and N. Melab / Procedia Computer Science 18 (2013) 280 – 289

the processor to produce one memory transaction per thread. Another major asset of our approach is that it
prevents from the uncoalesced accesses to the global memory of the GPUs since its memory accesses constitute
a contiguous range of addresses. Indeed, thread i writes the generated child node i in the position i (thread with
idx = 1 generates 1 child and write it in the position 1, thread idx = 2 generates 1 child and writes it in the position
2, etc..). In the tree partitioning-based method this is not achieved: thread i writes the generated nodes according
to the number of children of the thread i − 1. For instance, if thread 1 generates 3 children, and thread 2 generates
5 children then thread 2 starts writing in the output array from the position 3 and thread 3 starts writing from the
position 8.
5.3. Parallel evaluation of lower bounds
The parallel evaluation of bounds consists in computing for each of the generated nodes the lower bound
function. In our previous work, [3], this parallel model has been deeply studied. We have particularly investigated
adjusting the pattern of accesses to the GPU device memory and reducing the thread divergence phenomenon
that might occur in the implementation of the lower bound for the FSP. On the other hand, the lower bound
computation usually uses large in size and frequently accessed data structures. Since the GPU is a many-core coprocessor device that provides a hierarchy of memories having diﬀerent sizes and access latencies, the placement
and sharing of these data sets become challenging.
Our major contributions related to parallel evaluation of bounds consist in proposing a new approach for
thread/branch divergence reduction through a thorough analysis of the diﬀerent loops and conditional instructions
of the bounding function. We also deﬁned an optimal mapping of the data structures of the bounding function on
the hierarchy of memories provided in the GPU device through a careful analysis of both the data structures (size
and access frequencies) and the GPU memories (size and access latencies).
5.4. Parallel elimination of unpromising branches
Since the Johnson’s algorithm (used for computing the lower bound of the FSP) proceeds iteratively by assigning jobs at the beginning and at the end of a partial schedule, we deﬁned two pools Begin and End where
threads write the generated and evaluated children. If the generated child corresponds to a schedule of a job at the
beginning of the partial permutation the child is written to the pool Begin else to the pool End.
In the kernel which performs the parallel pruning of nodes, to each thread is assigned a pool of children
corresponding to a same parent node. Using the best solution found so far, threads estimate which of the pools
Begin and End are able to produce more promising nodes. The best pool is moved back to the CPU and inserted
in the list of unexplored nodes, the remaining pool is pruned in the GPU.
6. Experiments
6.1. Parameters settings
The proposed approaches have been implemented using C-CUDA 4.0. The experiments have been carried out
using an Intel Xeon E5520 bi-processor. This bi-processor is 64-bit, quad-core and has a clock speed of 2.27GHz.
It is coupled with an Nvidia Tesla C2050 card which contains 480 CUDA cores (15 multiprocessors with 32 cores
each), a clock speed of 1.15GHz, a 2.8GB global memory and a warp size of 32 threads. In our experiments, we
used the ﬂow-shop instances deﬁned by Taillard [11]. The diﬀerent instances are designated by n × m, where n and
m represent respectively the number of jobs (between 20 and 500) to be scheduled and the number of machines
(20, 10 and 5) to be used.
Problem instance ( Number of jobs × Number of machines )

20×20

50×20

100×20

200×20

Tree partitioning-based approach
Operator-driven approach

42.94
79.42

37.12
128.41

27.59
144.13

12.94
160.41

Table 1. Speedups reported for the two approaches of the GPU-based Branch and Bound.

I. Chakroun and N. Melab / Procedia Computer Science 18 (2013) 280 – 289

6.2. Computation of the speedup
To evaluate the performance of the proposed approaches, we calculate the speedup obtained by comparing the
GPU B&B versions to a sequential B&B version deployed on a single CPU core. Since the used instances are very
hard to solve (optimal solutions for many of these instances are still not known), we used the approach deﬁned
in [10] to run experiments. Employing this method allows to obtain a random list L of sub-problems such as the
resolution of L lasts T cpu minutes with a sequential B&B. To ensure that the sub-problems explored by the GPU
and CPU B&B versions are exactly the same, we initialize the pool of our GPU-based B&B with the same list L
of sub-problems used in the sequential version. If we assume the resolution of the GPU-based B&B lasts T gpu
seconds, the reported speedup of the algorithm will be equal to T cpu/T gpu.
6.3. Performance comparison of the two approaches
The objective of the experimental study presented in this section is to demonstrate that our approach based
on parallel regular computations is more eﬃcient than the tree partitioning-based GPU version. Table 1 reports
the speedups obtained for the diﬀerent problem instances using the two approaches. The rows correspond to the
used approach while the columns correspond to the experimented problem instance deﬁned by (Number of jobs ×
Number of machines).
Compared to a single CPU-based execution, our proposed approach “Operator-driven approach” allows acceleration up to (×160.41) for the 200 × 20 problem instances. The results show also that the obtained speedup with
our approach grows with the size of the problem instance. For a ﬁxed number of machines, the speedup grows
accordingly with the number of jobs. For instance, the speedup calculated with 200 jobs (×160.41) is higher than
the one calculated with 100 jobs (×144.13), 50 jobs (×128.41) and 20 jobs (×79.42). This property is mainly
due to the complexity of the computation of the lower bound which is O(m2 .n.log(n)). Indeed, for large problem
instances the grain size of the kernel executed by each thread is much higher which increases the GPU throughput.
Compared to the tree partitioning-based GPU-accelerated B&B approach, our approach is by far much more
eﬃcient. For example, while our approach reaches speedup of ×160.41 for the instance with 200 jobs on 20
machines, a speedup of a ×12.94 is measured with the tree partitioning-based approach. Moreover, in the tree
partitioning-based GPU B&B the speedups decrease when the problem instance becomes higher. Remember here
that in the tree partitioning-based approach, each thread branches all the children of its parent node. Therefore, the
bigger the size of the permutation is, the bigger the amount of work performed by each thread is and the bigger the
diﬀerence between the workload is. Indeed, let us suppose that for the instance with 200 jobs, the thread 0 handles
a node from the level 2 of the tree and the thread 100 handles a node from the level 170 of the tree. In this case, the
thread 0 generates and evaluates (see Equation 1) 396 nodes while the thread 100 decomposes and bounds only
60 nodes. The problem in this example is that the kernel execution would last until the thread 0 ﬁnishes its work
while the other threads might have ended their works and stayed idle.
In order to further analyze the performance of our approach, we plot in Figure 1 the impact of the parallelization of each of the operators of the Branch and Bound algorithm. Results show that whatever the problem instance
is, the three models based on the parallel regular execution of the operators of Branch and Bound behaves better
than the tree partitioning-based approach. We could also notice in Figure 1 that computing all the operators on
GPU gives the best accelerations. Deeper analysis of the total execution time of each scenario show that computing the branching step on top of GPU reduce the time spent for decomposing the pool on CPU and alleviates the
overhead induced by bringing data back and forth on CPU. On the other hand, computing the pruning operator on
top of GPU reduces the time of transfering the resulting pool from the GPU to the CPU since the non promising
generated sub-problems are kept in the GPU memory and deleted there.
7. Comparison with a Cluster-based B&B
During the last decades, cluster of workstations (COWs) have been widely used as high performance computing platforms for designing large scale parallel algorithms. It is therefore interesting to consider comparing the
performance of our operator-driven GPU-accelerated B&B with other version of the B&B [10] that has successfully been used on such large scaled architectures. The distributed B&B is based on a parallel exploration of the
tree search. From an implementation point of view, the algorithm is based on a distributed master/slave model

287

288

I. Chakroun and N. Melab / Procedia Computer Science 18 (2013) 280 – 289

160

Tree Based parallel approach
Parallel Bounding
Parallel Branching and Bounding
Parallel Branching, Bounding and Pruning

140

Speedups

120

100

80

60

40

20

0

Ta20*20

Ta50*20

Ta100*20

Ta200*20

Flowshop Taillard Intances

Fig. 1. Comparison of the speedups obtained with diﬀerent GPU accelerated versions of the Branch and Bound.

and uses a special coding of the search tree into intervals of work units that are partitioned among distributed
machines. The encoding mechanism allows to optimize the dynamic distribution and check-pointing on the grid,
and to implicitly detect the termination of the algorithm and eﬃciently share the global information. A Myri-10G
Gigabytes Ethernet connects the diﬀerent machines of the COWs.
In order to perform a fair comparison, the diﬀerent architectures must have the same computational power
in term of theoretical peak of ﬂoating-point operations per second (FLOPS). According to NVIDIA [12], the
theoretical double precision ﬂoating-point performance peak of the Nvidia Tesla C2050 is about 515 GFLOPS. For
the cluster-based experimentation, we used up to 63 Intel Xeon E5520 processors which are 64-bit and composed
of 8 cores having each a theoretical double precision ﬂoating-point performance peak of 36.2 GFLOPS [13].
Table 2 reports the speedup of the distributed B&B averaged on some problem instances with the number of
jobs and the number of machines equal to 20. The columns correspond to the number of used CPU cores and
the corresponding theoretical peak in GFLOPS. The rows correspond to the used problem instances. The same
experimental protocol as the for GPU computation is used (see Section 6). The reported speedups are calculated
relatively to a serial B&B on a single CPU core. For a same computational power, our approach is much more
eﬃcient than a parallel version of the B&B running on 15 CPU cores. Indeed, the average acceleration calculated
when using the GPU-based B&B for the instances 20 jobs over 20 machines is ×79.42. For the same category
of instances (20 jobs over 20 machines) and a same computational power of 500 GFLOPS the speedup of the
distributed-based B&B is on average ×7.97. For a computational power equivalent to 50 and 100 CPU cores,
which is respectively equal to 3 and 7 times its computational power, our GPU-based B&B runs almost twice
faster than the distributed version. Hence, using a single GPU is more eﬃcient than using 100 CPU cores which
correspond to 13 octo cores Xeon E5520 machines. For upper computational powers, using the cluster version
of the algorithm becomes more performent than the GPU. Indeed, the performances of the COWs-based B&B
are closely related to the underlying communication time and higher accelerations can be reached as long as the
computing time is not too much dominated by the communication time.
Number of used CPU cores ( Theoretical Peak in GFLOPS )

15 (540)

50 (1800)

100 (3600)

200 (7200)

500 (18000)

Taillard 21
Taillard 22
Taillard 23
Average Speedup

7.13
8.15
8.63
7.97

20.75
24.55
20.34
21.88

37.28
41.13
51.40
43.27

59.09
88.27
109.60
85.65

85.72
104.97
215.00
135.23

Table 2. Speedups for diﬀerent problem instances using a distributed version of the B&B.

I. Chakroun and N. Melab / Procedia Computer Science 18 (2013) 280 – 289

8. Conclusion
In this paper, we addressed the challenging issue of designing irregular B&B algorithms for solving permutationbased combinatorial optimization problems such as FSP on GPU accelerators. The contributions consist in proposing a template of a GPU-accelerated B&B algorithm which is based on the parallelization of three of its operators
namely branching, bounding and pruning. The major asset of our model of GPU-based B&B consists in transforming the unpredictable and irregular workload characterizing such tree-based algorithm into regular data-parallel
kernels that perform well on top of SIMD architectures like GPUs. In order to evaluate the performance of our
approach, we compared to another GPU-based strategy for the B&B which consists in subdividing the tree search
into sub-spaces that are explored in parallel. We also compared our approach to a cluster of workstations-based
distributed version of the B&B run on the up to 500 CPU cores.
Our proposed GPU-accelerated Branch and Bound algorithm proceeds as follows: a pool of pending subproblems is selected from the tree and oﬀ loaded to the GPU where the branching operator is applied ﬁrst. For
the sake of minimizing the data transfers between the CPU and the GPU, we take care of using persistent data
structures. Hence, the generated pool of children is kept in the memory device and used by the second kernel
which implements the parallel evaluation of bounds. Then, the evaluated pool of children is again kept in the
memory device (and not moved back to the CPU) where the pruning operator is run in parallel to decide which
nodes should be moved back to the CPU and which nodes should be deleted.
Compared to a single CPU-based execution, our proposed approach allows accelerations up to (×160) for large
problem instances. Compared to the tree partitioning-based GPU B&B approach, our model is by far much more
eﬃcient. Indeed, while our approach reaches a speedup of ×160 for the instance with 200 jobs on 20 machines, a
speedup of ×12.94 is obtained with the tree partitioning-based approach. Compared to the version experimented
on a COWs, our GPU-based approach was twice more performent than a distributed version of the B&B using
100 CPU cores which corresponds to 13 octo cores Xeon E5520 machines.
With the arrival of GPU resources in clusters and grids and the advent of multicore computing, our next
objective is to extend this work to investigate the design of a heterogeneous multicore GPU-based Branch and
Bound (i.e. the conjunction of GPU, multicore and distributed computing). From application point of view, the
objective is to solve to optimality challenging and unsolved Flow-Shop instances as we did it for one of the 50×20
problem instances using grid computing [10].
References
[1] D. A. Bader , W. E. Hart , C. A. Phillips. Parallel Algorithm Design For Branch and Bound.. Tutorial on Emerging Methodologies and
Applications in Opertations Research. Kluwer Academic Press, 2004. pp. 1-44.
[2] T. Carneiroa, A. Einstein Muritibab, M. Negreirosc, G. Augusto Lima de Campos A New Parallel Schema for Branch-and-Bound
Algorithms Using GPGPU. 2011 23rd International Symposium on Computer Architecture and High Performance Computing.
[3] I.Chakroun, M.Mezmaz, N. Melab, and A.Bendjoudi. Reducing thread divergence in a GPU-accelerated branch-and-bound algorithm.
Concurrency and Computation: Practice and Experience - John Wiley & Sons, In Press.
[4] I. Chakroun and N. Melab. An Adaptive Multi-GPU based Branch-and-Bound. A Case Study: the Flow-Shop Scheduling Problem.
In Proc. of 14th IEEE International Conference on High Performance Computing and Communications, HPCC’12. United Kingdom,
Liverpool, June 24-27, 2012.
[5] M. Drozdowski, P. Marciniak, G. Pawlak, M. PÅaza. Grid Branch-and-Bound for Permutation Flowshop. In LNCS Proc. of 9th Intl.
Conf. on Parallel Processing and Applied Mathematics (PPAM), 2011.
[6] M.R. Garey and D.S. Johnson. Computers and Intractability: A Guide to the Theory of NP-Commpleteness. W. H. Freeman & Co., New
York, NY, 1979.
[7] B. Gendron and T.G. Crainic. Parallel Branch-and-Bound Algorithms: Survey and Synthesis. Operations Research, 42(06):1042–1066,
1994.
[8] S.M. Johnson. Optimal two and three-stage production schedules with setup times included. Naval Research Logistis Quarterly, 1:61-68.
1954.
[9] M. Esseghir Lalami, D. El-Baz. GPU Implementation of the Branch and Bound method for knapsack problems. 2012 IEEE 26th
International ParallelParallel and Distributed Processing Symposium Workshops & PhD Forum.
[10] M. Mezmaz, N. Melab and E-G. Talbi. A Grid-enabled Branch and Bound Algorithm for Solving Challenging Combinatorial Optimization Problems. In Proc. of 21th IEEE Intl. Parallel and Distributed Processing Symp. (IPDPS), Long Beach, California, March 26th-30th,
2007.
[11] E. Taillard. Taillard’s FSP benchmarks. http://mistic.heig-vd.ch/taillard/problemes.dir/ordonnancement.dir/ordonnancement.html.
[12] http://www.nvidia.com/docs/IO/43395/NV DS Tesla C2050 C2070 jul 10 lores.pdf
[13] http://download.intel.com/support/processors/xeon/sb/xeon 5500.pdf

289

