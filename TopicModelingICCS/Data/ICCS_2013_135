Available online at www.sciencedirect.com

Procedia Computer Science 18 (2013) 491 – 500

International Conference on Computational Science, ICCS 2013

Parallel implementations of FGMRES for solving large,
sparse non-symmetric linear systems
Byron DeVries, Joe Iannelli, Christian Trefftz, Kurt A. O’Hearn, Greg Wolffe∗
Padnos College of Engineering and Computing, Grand Valley State University, 1 Campus Dr., Allendale, MI, 49401, USA

Abstract
The Flexible Generalized Minimal Residual method (FGMRES) is an attractive iterative solver for non-symmetric
systems of linear equations. This paper presents several methods for parallelizing FGMRES for a variety of architectures including multi-core CPU, Graphics Processing Units (GPU), and multi-GPU systems. The parallel implementations utilize OpenMP and CUDA kernels, and are organized according to thread scope. The linear systems
employed in this study correspond to the discrete analogues of realistic three-dimensional convection-diffusion
problems, and range in size to nearly 107 linear equations. All of the parallel implementations, particularly the
novel hybrid approach, show a signiﬁcant speedup over the sequential version. Theoretical insight and performance data is provided to allow informed decisions as to the most effective parallelization method for a given
architecture.
Keywords: Sparse matrices; Krylov-space iterative solvers; GMRES; FGMRES; GPU

1. Introduction
The solution of myriad scientiﬁc and industrial problems relies in turn on the core solution of large,
sparse systems of linear equations, such as those generated by the discretization of partial-differentialequation models. These core solvers are generally iterative and computationally expensive [1]. As
models and simulations increase in accuracy the size of the linear systems (i.e. the number of equations)
grows, leading to rapidly increasing execution time. Any reduction in the convergence time of the
solvers naturally results in less time-consuming simulations, thus beneﬁtting all of the applications
that rely on the solution of algebraic linear systems. In this paper, we describe effective and efﬁcient
parallelization strategies for the Flexible Generalized Minimal Residual (FGMRES) solver as applied
to the solution of large sparse linear systems resulting from the discretization of industrially relevant
3-D convection-diffusion problems. These strategies are found to produce a signiﬁcant speedup in
execution time for increasing numbers of equations, tested to date with systems composed of up to 8
million unknowns.
FGMRES and its precursor GMRES are Krylov-space methods that can solve non-symmetric linear
systems. Parallel implementations of a class of these Krylov solvers have been reported in the PETSc
∗ Corresponding

author. Tel.: +1-616-331-2060; fax: +1-616-331-2106.
E-mail address: wolffe@gvsu.edu.

1877-0509 © 2013 The Authors. Published by Elsevier B.V. Open access under CC BY-NC-ND license.
Selection and peer review under responsibility of the organizers of the 2013 International Conference on Computational Science
doi:10.1016/j.procs.2013.05.213

492

Byron DeVries et al. / Procedia Computer Science 18 (2013) 491 – 500

project, including a preliminary version which uses Cusp, a C++ CUDA library for sparse linear systems. According to the PETSc documentation [2], vector and matrix-vector products can be performed
on a Graphical Processing Unit (GPU). This corresponds to the locally-scoped approach described in
this paper. Recently, GMRES has been implemented on a GPU [3] and on a cluster of GPUs [4]; both implementations used a simple preconditioner. FGMRES has also been implemented on a single GPU [5].
The novel contribution of this paper is an implementation of FGMRES on a multi-GPU shared-memory
system.
This paper concentrates on FGMRES because it is a fast Krylov-space iterative solver of linear equations; as its name suggests, it is more ﬂexible than GMRES and is suitable for general non-symmetric
matrices. FGMRES generates a converging solution by minimizing at each iterative cycle the Euclidean
norm of the system residual [6]. It was developed to accelerate the iterative convergence of the classical
GMRES method [7], which is also a Krylov-space residual-minimizing iterative solver. The difference
between FGMRES and GMRES is that FGMRES preconditions the system matrix in an efﬁcient manner by using GMRES itself. Hence this method consists of two iteration phases: an inner iteration that
uses GMRES to precondition the system, and an outer iteration that minimizes the system residual
to generate the solution. As a signiﬁcant advancement in ﬂexibility, the use of GMRES in the inner
iteration intrinsically generates the preconditioning matrix to any desired level of accuracy, without
actually forming it or allocating memory for it, as the preconditioning stage requires only the matrixvector product of the preconditioning matrix and a sequence of basis vectors. Thus, the inner iteration
efﬁciently implements GMRES preconditioning. This ﬂexible nature, along with its advantageous convergence properties, makes FGMRES an attractive iterative solver.
Given the critical role of linear-algebra solvers in modern scientiﬁc applications, it is understandable that development efforts would concentrate on accelerating their execution. Today, this is typically achieved via parallelization, and increasingly, by moving time-consuming computations onto a
GPU. GPUs are massively-parallel devices that support multithreaded programming. They provide
hundreds of compute cores and exhibit a high ratio of computations performed to power consumed.
Thanks to the competitive pressures of the commercial gaming industry, GPUs are also ubiquitous,
inexpensive and becoming easier to program.
However, GPUs are Single-Instruction-Multiple-Data (SIMD) machines, and as such represent a
different programming paradigm than multi-core CPUs. They have several orders of magnitude more
processing cores than a CPU, run best when threads are synchronized (no divergent code), and have
high-bandwidth high-latency memory access. In multi-core CPUs, both task-parallel and coarse dataparallel approaches are common. In contrast, GPUs epitomize the data-parallel approach, in which the
data is partitioned into as many pieces as possible and mapped onto threads.
This paper presents parallel implementations of the FGMRES solver with several different degrees
of scoping, targeted at several different architectures. Section 2 describes the model linear systems
and provides background on the GMRES and FGMRES solvers. Section 3 describes our parallel implementations, including a novel hybrid approach that combines OpenMP for globalally-scoped parallelization and CUDA-based locally-scoped threading, using Uniﬁed Virtual Addressing (UVA) as an
efﬁcient mechanism for GPU to GPU communication. Results of a performance evaluation conducted
on a realistic 3-D convection-diffusion problem are presented and discussed in Section 4. Section 5
concludes with a look at future work.
2. Model Linear Systems and Iterative Solvers
2.1. Target Linear Systems
The target model sparse linear systems represent scientiﬁc and engineering problems that are currently solved by slower implementations. This paper thus focuses on the linear systems generated from
the discretization of the three-dimensional extension of a previously presented two-dimensional generalized convection-diffusion problem [8]. The corresponding parabolic partial differential equation

Byron DeVries et al. / Procedia Computer Science 18 (2013) 491 – 500

493

(PDE) is expressed as
−

∂2 q ∂2 q ∂2 q
∂q ∂q ∂q
+
+
= f (x, y, z) ∈ Ω ⊂ R3 .
+
+
+β
∂x ∂y ∂z
∂x2 ∂y2 ∂z2

subject to Dirichlet boundary conditions on all surfaces of the boundary ∂Ω of Ω, with Ω ≡ (0 ≤ x, y, z ≤
1). In this PDE, β denotes a prescribed constant or function and f (x, y, z) then becomes a known righthand-side expression, which is readily obtained by inserting into the PDE the reference exact solution:
q (x, y, z) = sin (πx) sin (πy) sin (πz)
which also provides the needed boundary condition on ∂Ω. The corresponding sparse linear systems
are the following discrete analogues of the PDE
−

qi−1, j,k − 2qi, j,k + qi+1, j,k qi, j−1,k − 2qi, j,k + qi, j+1,k qi, j,k−1 − 2qi, j,k + qi, j,k+1
+
+
Δx2
Δy2
Δz2
+βi, j,k −

qi−1, j,k + qi+1, j,k qi, j−1,k + qi, j+1,k qi, j,k−1 + qi, j,k+1
−
−
= fi, j,k
2Δx
2Δy
2Δz

as obtained from a centered 2nd order ﬁnite-difference discretization. The unknowns are the discrete
qi, j,k ’s at the discretization nodes (i, j, k) and the values of fi, j,k are known. By numbering the discretization nodes in lexicographic order, these two sets of values are then respectively organized in the single
vectors x and b in the ﬁnal linear system Ax = b, with the matrix A resulting from the various βi, j,k
and the coefﬁcients of qi, j,k . The matrix A is sparse because each equation only couples 6 unknowns,
corresponding to the 6 nearest-neighbor nodes of the node for that equation. The exceptions are the
equations located next to the boundary, that is, the edge of the lattice work, which couple fewer nodes
or involve only 1 unknown. A sequence of test problems is then generated by increasing the number of
nodes in the lattice work.
For all implementations in this study, the sparse matrices are stored using the ELLPACK format
(ELL) [9]. ELL, which stores only the non-zero elements along with a second matrix of reference indices, is well-suited for the sparse linear systems generated from the 3-D convection-diffusion problems
explored in this work.
2.2. FGMRES & GMRES Iterative Solvers
FGMRES [6] and GMRES [7] iteratively solve the linear system
Ax = b,

A ∈ Rn×n ,

x, b ∈ Rn

(1)

where R denotes the real-number ﬁeld, b is the known right-hand-side, x is the unknown vector, and A
is any non-singular matrix, i.e. not symmetric, positive deﬁnite, or diagonally dominant. FGMRES was
developed to accelerate convergence over the baseline GMRES method, a convergence improvement
that is attained by solving a preconditioned system. GMRES directly solves (1), whereas FGMRES
solves (1) by eventually determining x through a generalization of GMRES applied to the solution of
the equivalent pre-conditioned system
AM −1 (Mx) = b
(2)
In this system, M is a “pre-conditioning” matrix that is made to approximate A as closely as possible,
within computational efﬁciency constraints. If M coincides with A, (2) is immediately solved for Mx in
one step. As summarized in this section, FGMRES efﬁciently determines x by using GMRES to achieve
the effect of M A through a sequence of matrices Mi . Signiﬁcantly, this is accomplished without having
to form each matrix Mi or allocate space for it, for all that is required is the matrix vector product Mi vi ,
with vi any vector in Rn .

494

Byron DeVries et al. / Procedia Computer Science 18 (2013) 491 – 500

The iterative process is then established by computing the iterate x
plished by minimizing the Euclidean (L2 ) norm of the system residual
r

+1

= b − Ax

+1

= b − Ax − Axm

+1

= b − Ax − AWm y ,

= x + xm , which is accomxm = Wm y

to determine y ∈ Rm which is a linear combination vector of the columns of Wm , where Wm ∈ Rn×m is a
matrix of m linearly independent basis vectors w j , 1 ≤ j ≤ m, of a Krylov space, Wm ≡ (w1 , . . . , w j , . . . , wm ).
All the norms used in the algorithm are L2 norms.
Based on these considerations, the FGMRES algorithm is expressed as
1.
2.
3.

Select x1 and ε
do r1 = b − Ax1 ,

x = x1 ,

v1 =

for i = 1, 2, . . . , m
Mi wi = vi
for j = 1, 2, . . . , i
hi, j = v j , Awi
end for

r1
r1

i

vi+1 = Awi −

v j hi, j
j=1

vi+1
vi+1
= vi+1

vi+1 =

4.
5.
6.

hi+1,i
end for
y = minm r
y ∈R

+1

= minm b − Ax − AWm y

x +1 = x + Wm y ,
while r +1 > ε

y ∈R

x1 = x

= minm
y ∈R

r1 e1 − Hm y

+1

where e1 and Hm respectively denote the ﬁrst column of the (m + 1) × (m + 1) identity matrix and the
upper Hessemberg matrix of the hi, j values. The algorithm converges provided that A and Hm are
non-singular [6]. With I ∈ Rn×n denoting the identity matrix, the GMRES algorithm corresponds to
the algorithm given above with Mi ≡ I. The distinguishing feature of FGMRES lies in using GMRES
itself, that is, the algorithm given above with Mi ≡ I, x ≡ wi , and b ≡ vi to generate an approximate
solution of Awi = vi , where wi is now the unknown vector and vi is the known right hand side. Since
this is an approximate solution of Awi = vi , it corresponds to an exact solution of Mi wi = vi , where Mi
is intrinsically generated, but not explicitly required, by this GMRES process, with Mi approximating A
more and more accurately, depending on the number m of vectors and iterations used. This process is
thus an inner-iteration phase that intrinsically provides the preconditioning, whereas steps 2–6 in the
algorithm given above constitute the outer-iteration phase that calculates the approximate solution x +1 .
In the current implementation, FGMRES is structured as a two-cycle recursive algorithm.
3. Parallel Implementations
This section describes the use of OpenMP and CUDA kernels to develop several parallel implementations of the FGMRES method. The implementations are organized by scope, a measure of the lexical
duration of each parallel task or thread. The motivation for different scoping levels is the potential
use of different parallel architectures: multi-core CPU, GPU, and multi-GPU systems. Globally-scoped
parallelism involves breaking a problem into several independently executing tasks, typically one per
core on a multi-core CPU. Locally-scoped parallelism is a data-centric approach that creates numerous
tightly-coupled parallel tasks; it can be implemented on either a CPU or a GPU. The hybrid approach
incorporates parallel but independent globally-scoped tasks, each using locally-scoped parallelization
of their component threads. This approach is used to exploit a shared-memory multi-core system with
multiple GPUs.

Byron DeVries et al. / Procedia Computer Science 18 (2013) 491 – 500

495

3.1. Locally-scoped approach
In the locally-scoped approach, each parallelizable matrix operation (or each line in the algorithm
given in Section 2) is independently parallelized. For example, the matrix-vector product computation
is parallelized and (re)used within the code whenever necessary. In the locally-scoped parallel version
of the solver, threads are forked off as needed to compute operations required by the FGMRES function
and joined with the master thread when that operation is complete. All control structures, including
iteration counting, checking of residuals for completion, as well as the least-square minimization are
run sequentially. The parallelized code is implemented in either OpenMP or using CUDA kernels.
3.1.1. OpenMP
Implementing locally-scoped parallelism using OpenMP is achieved by using compiler directives to
designate loops for parallelization. Consider the loop for(int i=0; i<n; i++) x[i] /= b;, which
normalizes an array x of size n by a given value b . It can be parallelized by placing a compiler directive
#pragma omp parallel for on the line preceding it. The compiler partitions the loop among multiple threads, each of which iterates over their portion of the original loop concurrently. This type of
normalization loop is used frequently in the FGMRES algorithm to scale values by a calculated normal
value.
3.1.2. CUDA
The same loop can be parallelized in CUDA using a different approach. CUDA is based on the data
parallel paradigm, in which a large number of threads all perform the same operation, but on different
data. The corresponding CUDA kernel would appear as:
__global__ void scale(float *x, float b, int n) {
int i = blockIdx.x * blockDim.x + threadIdx.x;
if (i<n) x[i] /= b;
}

and would be called by the host computer, as in:
dim3 blockSize(256); dim3 gridSize(n / blockSize.x + 1);
scale<<<gridSize, blockSize>>>(d_x, b, n);

where the array passed in for d x is previously allocated and populated on the GPU. Note that gridSize
is deﬁned as one more than n/blockSize.x since integer division truncates a remainder and n may not
always be evenly divisible by the block size. This also explains the necessity of a boundary condition in
the CUDA kernel, as there may be values of i that are outside the bounds of the given array.
3.2. Globally-scoped approach
In the globally-scoped approach, rather than individually parallelizing each operation, the entire
algorithm is run in parallel by multiple threads. In contrast to the locally-scoped approach, all control structures including iteration counting and checking of residuals for completion are performed in
parallel, using duplicate instantiations of relevant data. Figure 1 illustrates the difference between the
locally-scoped and globally-scoped approaches for a short segment of code. The locally-scoped version
consists of a series of parallel regions; it uses piecewise parallelization, requiring implicit forks and joins
before and after every operation. The globally-scoped version runs completely in parallel, avoiding the
extra forks and joins, using threads of a much longer duration or “lifetime”.
In the globally-scoped OpenMP code below, arrays a and c are scaled by values b and d , respectively.
void scaleFunction(float *a, float b, float *c, float d, int n) {
int min = (n / omp_get_num_threads()) * omp_get_thread_num();
int max = min + (n / omp_get_num_threads());
if (omp_get_thread_num() + 1 == omp_get_num_threads()) max = n;
for (int i=min; i<max; i++) a[i] /= b;
for (int i=min; i<max; i++) c[i] /= d;
}

496

Byron DeVries et al. / Procedia Computer Science 18 (2013) 491 – 500

The function scaleFunction()can be run in parallel using the #pragma omp parallel compiler directive. The term globally-scoped refers to the relative duration of the threads. If there were two threads
executing scaleFunction(), each would scale half of array a , then scale half of array c . If there were
three threads, each would work on one-third of array a , then move on to scale one-third of array c . The
global scoping approach avoids the implicit barriers that exist in the locally-scoped version. However,
since each loop is parallelized individually, the global approach does not take advantage of the fact that
entire loops can be executed in parallel.
(a)
Local Start

(b)
Global
Start

Start
Operation

1/2 of
Operation
1/2 of
Operation

End
Operation

Start
Operation

1/2 of
Operation
1/2 of
Operation

1/2 of
Operation

1/2 of
Operation

1/2 of
Operation

1/2 of
Operation

End
Operation

Local End

Global
End

Fig. 1. (a) Locally-scoped approach; (b) globally-scoped approach.

3.3. Hybrid approach
The novel hybrid-scoping approach uses both global- and locally-scoped methodologies implemented with OpenMP and CUDA. The goal is to allow long-duration threads to run independently
(global scope), but to further parallelize within them each operation that can run on a GPU (local scope),
thus maximizing parallelism.
The code below uses the hybrid approach to scale the arrays a and c by different values b and d .
__global__ void scale(float *x, float b, int min, int max) {
int i = blockIdx.x*blockDim.x+threadIdx.x + min;
if (i < max) x[i] /= b;
}
void scaleFunction(float **a, float b, float **c, float d, int n) {
int min = (n / omp_get_num_threads()) * omp_get_thread_num();
int max = min + (n / omp_get_num_threads());
if (omp_get_thread_num() + 1 == omp_get_num_threads()) max = n;
dim3 blockSize(256); dim3 gridSize((max-min)/ blockSize.x + 1);
scale<<<gridSize, blockSize>>>(a[omp_get_thread_num()], b, min, max);
scale<<<gridSize, blockSize>>>(c[omp_get_thread_num()], d, min, max);
}

Here, scaleFunction()is executed after calling cudaSetDevice(omp get thread num())and issuing
the #pragma omp parallel compiler directive to scale the two arrays in parallel. The two arrays are
multidimensional, implemented as an array of pointers. Each GPU allocates an array within its own
device memory, such that a[0] contains the pointer to the ﬁrst GPUs memory. The entire array, rather
than just a fractional portion, is allocated on each GPU to provide for sufﬁcient space and unchanged
offests in the event of data transfers necessitated by data dependencies.
3.3.1. Memory access: Uniﬁed Virtual Addressing
The FGMRES algorithm is not naturally parallel; there are points in the algorithm at which data
must be transferred between GPUs in the hybrid implementation. Since CUDA 4.0, NVIDIA GPUs
have featured Uniﬁed Virtual Addressing (UVA), providing a single address space for system memory

Byron DeVries et al. / Procedia Computer Science 18 (2013) 491 – 500

497

and all GPU memory. In the hybrid approach, the CUDA kernel uses UVA and peer-to-peer memory
access over the PCI-e bus rather than copying data back to the host and then to another device.
Directional UVA memory access is enabled as in the following code:
cudaSetDevice(destinationDevice);
cudaDeviceEnablePeerAccess(sourceDevice, flags);

which allows transparent memory access across two GPUs by simply referencing a memory location.
Using the inherent data dependencies in the FGMRES algorithm, each GPU creates a list of required
data that is not among the data allocated for that particular GPU. A separate CUDA kernel is called to
process the list and transfer the necessary data. Because the purely local and global scope approaches
both make use of shared memory, their memory access time is uniform. However, the multiple GPU
systems implementing the hybrid approach experience a non-uniform memory access time as it takes
longer to access memory on a different GPU. Therefore, a major concern in the hybrid approach is
minimizing the cost of transferring data.
4. Experimental Results and Discussion
This section describes details of the experimental platform and presents results.
4.1. Experimental platform
All experiments were performed on a server with dual Intel Xeon X5690 3.47 GHz processors (12
cores total) with 12 MB of cache, 96 GB of 1333 MHz ECC Registered RAM, and a 1 TB SATA hard drive.
The system includes four Tesla M2090 GPUs which run at 1.30 GHz, each with 512 stream processors
and 6 GB of GDDR5 memory. The operating system is Linux version 2.6 with GCC version 4.4.6 and
the CUDA 5.0 runtime.
4.2. Results
All results are for double precision data, and have been veriﬁed to have reached the expected exact
solution within a tolerance of 10−6 . FGMRES was conﬁgured to use 10 basis vectors with a residual
of 10−6 in the outer phase, and 4 basis vectors with a residual of 10−11 and two iterations in the inner
(preconditioning) phase.
4.2.1. Local scoping
As seen in Figure 2(a), locally-scoped parallelization implemented with CUDA on a GPU exhibits a
signiﬁcant speedup (refer to Table I for the exact values used to produce these graphs). Compared to
the sequential version of the code running on a single CPU core, the parallel version running on a GPU
executes over 18 times faster for large problem sizes. Due to the massively multi-threaded data parallel
nature of CUDA programming, the x-axis here represents the number of equations (i.e. the size of the
linear system) solved.
A notable characteristic of the CUDA-based locally-scoped version is its scalability, as seen in Figure
2(b). Execution time grows manageably as the size of the problem grows to 8 million equations, indicating excellent efﬁciency with this approach (additional data points are used to better illustrate the shape
of the curve). The limitation of the locally-scoped CUDA version is the amount of memory present on
the GPU. The test platform with 6 GB/GPU should be able to accommodate a linear system of over 9
million equations.
As seen in Figure 3(a), the local scope method of parallelization using OpenMP on a multi-core CPU
provides a modest speedup, which is typical for this type of application. The parallel version is generally two to three times faster than the sequential code, but speedup does not scale with larger matrices.
Note also the dropoff with 13 threads. In this case, the number of threads exceeded the number of
parallel processing elements (12 cores), and the code exhibited the expected effect of additional (and
wasted) overhead.

498

Byron DeVries et al. / Procedia Computer Science 18 (2013) 491 – 500

Fig. 2. (a) Speedup of the locally-scoped approach: CUDA; (b) Scalability of the locally-scoped approach: CUDA.

Fig. 3. (a) Speedup of the locally-scoped approach: OpenMP; (b) Speedup of the globally-scoped approach: OpenMP.

4.2.2. Global scoping
The global scope approach parallelizes FGMRES with OpenMP on a multi-core CPU and performs
similarly to the locally-scoped approach with respect to the number of equations. As seen in Figure
3(b), the speedup is 2–3 times faster, but slightly less than with OpenMP-based local scoping of threads.
This result indicates that the beneﬁt of parallelizing each individual matrix operation (as in the locallyscoped approach) exceeds the cost of additional forking and joining of threads. That is, sequential code
redundantly executed in parallel limits the speedup of the globally-scoped version.
Like the locally-scoped version, globally-scoped OpenMP code does not scale well with increasing
number of equations.
4.2.3. Hybrid approach
The hybrid approach is designed to maximize parallelism by combining globally-scoped OpenMP
threads with locally-scoped CUDA threads. For large problems, it produces the best speedup performance among all parallel approaches, as seen in the results graphed in Figure 4(a).
An important facet of the hybrid approach is the need to handle data dependencies by transferring data values between GPUs. At some threshold problem size, the beneﬁt of increased parallelism

Byron DeVries et al. / Procedia Computer Science 18 (2013) 491 – 500

499

Fig. 4. (a) Speedup of the hybrid approach; (b) Effect of communication costs on the hybrid approach.

GPU 1

embodied by multiple GPUs overcomes the increased communication overhead of the data transfer, as
seen in Figure 4(b). Speedup is obviously affected by the ratio of computational work to communication
cost, therefore the hybrid approach works best for large problems.
The diagram in Figure 5 illustrates this principle. It presents an 8 x 8 2-D convection-diffusion
problem, wherein each linear equation is represented by a circle. Each linear equation is dependent on
the equations it is adjacent to. Dividing the equations into two groups, in order to allow one GPU to
solve each submatrix, creates a line that deﬁnes a communication barrier. Solving the equations directly
on that barrier requires data communication from one GPU to another.
1

2

3

9

10

11 12 13 14 15 16

4

5

6

7

8

17 18 19 20 21 22 23 24
25 26 27 28 29 30 31 32

GPU 2

33 34 35 36 37 38 39 40
41 42 43 44 45 46 47 48
49 50 51 52 53 54 55 56
57 58 59 60 61 62 63 64

Fig. 5. Two-dimensional lattice representing a system of linear equations.

Now consider the three-dimensional model of the convection-diffusion problem: n x n x n, with
n3 total equations. Each equation is dependent only on the equations directly adjacent to it in the
three-dimensional lattice. To partition the test matrix between two GPUs, that space must be divided
into two sets of equations, i.e. an n x n plane must be cut through the three-dimensional lattice. The
equations just above that plane depend on the equations below that plane and vice versa. Therefore, for
every division of the set of equations there are O(n2 ) pieces of data that must be transferred. For some
threshold value of n it is clear that n3 will be larger, and eventually much larger, than cn2 where c is a
constant representing the communication cost.
4.2.4. Accuracy and precision
The FGMRES algorithm requires a reduction step, and parallel reductions perform operations that
may involve rounding in a different order than sequential reduction or even other parallel reductions.

500

Byron DeVries et al. / Procedia Computer Science 18 (2013) 491 – 500

The various parallel implementations have been tested using sequential reductions to show convergence results identical to the sequential method. This ensures each of the methods presented here is
identical in functionality outside of the parallel reductions, and accurate to the machine precision of the
data types.
4.3. Results summary
For reference, the sequential version of the code takes well over 1.5 hours to solve a system of linear
equations with 8 million unknowns. The hybrid OpenMP/CUDA version reduces execution time for
the same problem to a little over 4 minutes. Table 1 gives the speedup of each parallel method as
compared to the sequential code.
Table 1. Timing results: speedup.
Number of equations
Globally-scoped OpenMP
10,648
2.60
103,823
3.11
1,000,000
2.24
8,000,000
2.26

Locally-scoped OpenMP
2.73
3.18
2.38
2.39

Locally-scoped CUDA
4.44
9.15
17.26
18.54

Hybrid approach
3.05
7.79
18.37
22.63

5. Conclusion and Future Work
This paper presented several methods for parallelizing the FGMRES algorithm, including a novel
hybrid approach. The targeted architectures included multi-core CPU, GPU, and multiple GPU systems. Realistically, any computer used for solving large numbers of linear equations will include at
least one of these architectures. All of the methods showed a signiﬁcant speedup, with the GPU version
performing 18 times faster than a single CPU. The multiple GPU system, using the hybrid parallel approach, performed faster than a single GPU for problems large enough such that available parallelism
exceeded communication overhead.
For the future, adding additional matrix representations suitable for different problem types would
enable direct comparative studies with existing published GPU-based sparse matrix iterative solvers.
In addition, several open questions are still of interest. The relationship between problem size and
communication cost in the hybrid approach depends heavily on the sparse matrix being solved. Generalized analytical models for predicting communication costs and methods for optimizing the grouping
of equations in order to reduce data transfers would be beneﬁcial. An optimization study of preconditioning parameters and their effect on algorithm behavior might be of theoretical interest.
References
[1] R. Barrett, M. Berry, T. Chan, J. Demmel, J. Donato, J. Dongarra, V. Eijkhout, R. Pozo, C. Romine, H. Van der Vorst, Templates
for the Solution of Linear Systems: Building Blocks for Iterative Methods, Society for Industrial Mathematics, 1987.
[2] V. Minden, B. Smith, M. Knepley, Preliminary implementation of PETSc using GPUs, Proceedings of the 2010 International
Workshop on GPU Solutions to Multiscale Problems in Science and Engineering.
[3] R. Couturier, S. Domas, Sparse systems solving on GPUs with GMRES, The Journal of Supercomputing 59 (3) (2012) 1504–
1516.
[4] J. Bahi, R. Couturier, L. Khodja, Parallel GMRES implementation for solving sparse linear systems on GPU clusters, Proceedings of the 2011 High-performance Computing Symposium.
[5] H. Sudan, H. Klie, R. Li, Y. Saad, High performance manycore solvers for the reservoir simulation, Proceedings of the 12th
European Conf. on the Mathematics of Oil Recovery.
[6] Y. Saad, A ﬂexible inner-outer preconditioned GMRES algorithm, SIAM Journal on Scientiﬁc Computing 14 (2) (1993) 461–
469.
[7] Y. Saad, M. Schultz, GMRES: A generalized minimal residual algorithm for solving nonsymmetric linear systems, SIAM
Journal on Scientiﬁc and Statistical Computing 7 (3) (1986) 856–869.
[8] H. Van der Vorst, C. Vuik, GMRESR: a family of nested GMRES methods, Numerical Linear Algebra with Applications 1 (4)
(1994) 369–386.
[9] N. Bell, M. Garland, Efﬁcient sparse matrix-vector multiplication on CUDA, NVIDIA Corporation, NVIDIA Technical Report
NVR-2008-004.

