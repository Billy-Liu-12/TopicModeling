Available online at www.sciencedirect.com

Procedia Computer Science 9 (2012) 1930 – 1939

Reducing Library Overheads through Source-to-Source Translation
Alden King, Scott Baden
University of California, San Diego

Abstract
Object oriented application libraries targeted to a speciﬁc application domain are an attractive means of reducing
the software development time for sophisticated high performance applications. However, libraries can have the
drawback of high abstraction penalties. We describe a domain speciﬁc, source-to-source translator that eliminates
abstraction penalties in an array class library used to analyze turbulent ﬂow simulation data. Our translator eﬀectively
ﬂattens the abstractions, yielding performance within 75% of C code that uses primitive C arrays and no user-deﬁned
abstractions.

1. Introduction
Over the past few decades, advances in computational infrastructure and numerical methods have delivered simulations of unprecedented ﬁdelity and accuracy, leading to new scientiﬁc discovery. However, a side eﬀect of this
“computational revolution” is the prodigious output of simulation data that challenges our ability to infer the relevant
science. For example, there are important applications where the dynamics may be dominated by coherent structures
and patterns, but these may be diﬃcult to deﬁne, let alone understand. While visualization is an important tool for
understanding pattern evolution, the process is subjective, not scalable to the study of populations of structures and
patterns, and does not directly quantify the contribution of coherent structures to ﬂow properties.
By and large, the CFD community relies on ad-hoc analysis tools that are customized to a speciﬁc application and
must be painstakingly recoded for each new usage pattern. While there do exist some publicly available tools [1], they
present the user with predeﬁned or “canned” primitives. When a new need arises, there may be no way to optimize
user-authored extensions since the existing framework is designed to optimize only built-in functionality.
We previously developed Saaz, a C++ library for authoring extensible analysis tools for study of turbulent ﬂow
simulations [2]. We attached Saaz to running simulations and were eﬀectively able to increase the time resolution of
ﬂow analysis by ﬁltering data based on user-speciﬁed criteria, reducing the rate at which simulated data was committed
to disk. Saaz’s performance was not an issue because the domain scientists did not need to analyze every time step of
the simulation: the cost of Saaz’s authored analyses was just 10% of the execution time of the simulator.
When we look at oﬄine datasets, however, the picture changes. With oﬄine analysis, there is no simulator to overwhelm the cost of analysis in Saaz. We determined that Saaz incurs overheads from its use of class abstractions that
1 This

work was supported by NSF contract OCE-0835839.
Email addresses: apking@cs.ucsd.edu (Alden King), baden@cs.ucsd.edu (Scott Baden)

1877-0509 © 2012 Published by Elsevier Ltd. Open access under CC BY-NC-ND license.
doi:10.1016/j.procs.2012.04.211

Alden King and Scott Baden / Procedia Computer Science 9 (2012) 1930 – 1939

1931

are ubiquitous to C++ class libraries. In this paper, we discuss these sources of overhead and our custom source-tosource translator, called Tettnang, that rewrites Saaz applications to eliminate most of the library overheads. Tettnang
enables users to beneﬁt from Saaz’s abstractions without incurring unacceptable performance penalties.
Tettnang treats the Saaz library as an Embedded Domain Speciﬁc Language. This approach separates correctness
and eﬃciency: the library takes responsibility for correctness, the translator handles eﬃciency. This separation lets
users continue to author applications using robust high level APIs while still beneﬁting from the performance of
an implementation tuned to their speciﬁc problem(s). With Tettnang, users of the Saaz library can utilize its highlevel abstractions essentially for free. While the Tettnang translator is specialized to the Saaz library, other libraries
introduce overheads similar to those in Saaz. Tettnang demonstrates a technique which we believe can be applied to
other libraries. Some optimizations (identiﬁed in Section 4.2) are quite generic and can be applied to other libraries.
In the next section we introduce the Saaz library and the requirements it imposes on implementations. Section 3
illustrates how the requirements of Saaz inﬂuence its organization and how the class abstractions used impose penalties
on performance. Section 4 introduces Tettnang as the solution to library overheads, followed by performance metrics
in Section 5. Finally, we present related work in Section 6 and conclude with future work in Section 7.
2. The Saaz Library
Saaz was designed to study turbulent ﬂow simulations. Such simulations are diﬃcult to characterize because there
is no universal deﬁnition of turbulent structures, known as vortex cores. Accordingly, there are several popular vortex
core eduction methods [2]. Existing ﬂow analysis tools are largely ad-hoc. As requirements change, the tools must be
recoded, sometimes at great cost. Relational databases have failed to gain general acceptance by the CFD community
because they disrupt locality in tightly wound loop nests [3], and there have been few inroads [1].
Saaz enables the domain scientist to utilize mathematical rules to identify features that are posited to be dynamically important. This approach fundamentally changes the discovery process; instead of asking “do these data ﬁt the
model?” we ask: “what kinds of models explain the data?” This change of viewpoint is important: an outstanding
diﬃculty in studying turbulent ﬂow is that algorithms used to understand data are themselves subject to revision. This
imposes on Saaz a requirement to support not a ﬁxed interface, but ad hoc queries.
By providing reusable primitives rather than a ﬁxed set of operations, Saaz enables domain scientists to revise
queries and even issue ad hoc queries without becoming entangled in tedious implementation details. With Saaz
they can formulate a new vortex eduction formula without having to entirely rewrite their analysis infrastructure.
Computational science requires experimentation in analysis as much as in simulation. Despite being the status quo in
most existing tools, a ﬁxed set of predetermined primitives is not appropriate for CFD research. To support the search
for mathematical formulas, Saaz must support customized queries. Customized queries are supported in Saaz through
the use of extensive composition of basic array operations. This composition must be eﬃcient and must not incur high
runtime overheads.
A common approach to eﬃcient composition which avoids runtime overheads is demonstrated by Expression
Templates [4]. Expression templates make use of the fact that C++ templates are Turing-complete, using a C++
compiler to build trees of operations within the template parameters of user-deﬁned types. Aggressive inlining can
then yield very eﬃcient composition of these operations, even moving them within loops, ﬂattening many nested
function calls into a sequence of basic operations. This sort of template programming, however, remains a poor tool for
addressing sequences of operations which are not composed. Optimizing call-sequences requires deferring evaluation
until sequences can be refactored (typically by a runtime [5]). Furthermore, code using expression templates can
exhibit context-dependent compile-time errors deep in the call stack and far removed from the original user’s code
which caused it. If the wrong object is passed into a function, an error may not arise until it is passed through many
other functions, and ﬁnally to a function which actually uses a non-existent attribute (method, data-type, or datamember) of that object. The users of Saaz are domain scientists who do not have extensive programming experience
with templates. Their ability and willingness to track down these kinds of errors, let alone understand them, is limited
at best. An error reporting that an object does not have a particular attribute does not help the domain scientist realize
he accidentally used the wrong variable.
Saaz supports a simple data model: the multidimensional array. Unlike conventional languages, we index a Saaz
array with a multidimensional point-valued object, i.e. A[p]. A point corresponds to an ordered tuple of indices

1932

Alden King and Scott Baden / Procedia Computer Science 9 (2012) 1930 – 1939

traditionally used to reference arrays. This notation simpliﬁes subscript expressions [6] [7] [8] and enables the user to
write dimension-independent loop bodies, enhancing code reuse.
A Saaz array is a set of elements, all of the same type, deﬁned over a bounding box called the domain of the
array. Each point in the domain of an array is mapped to a stored value (element). Notably, Saaz supports arrays with
diﬀerent in-memory layouts, such as row-major and column-major orders. By comparison, traditional approaches
impose a ﬁxed storage layout, which can be heavily optimized. For example, Matlab and FORTRAN use columnmajor order, while C and C++ use row-major order. Relaxing the assumption of a ﬁxed data layout introduces high
overheads both in translating a point-valued subscript into a memory oﬀset, and in iterating over the elements of an
array. Still, we found this capability to be useful in ﬂow analysis as it facilitates interoperability, that is, sharing of
data products and analysis tools. We were able to take existing analysis code and without modiﬁcation, run it over
another group’s dataset which used diﬀerent conventions.
Despite the apparent overheads of Saaz, we were able to use knowledge about how users formulate queries to
eliminate most of the overheads, improving user productivity signiﬁcantly. We next discuss the overheads in detail,
and following that, our translation solution, Tettnang.
3. Overheads
To better understand the performance diﬀerences between code written with Saaz and code written as Vanilla C
(that is, C with C-style 3D arrays and without user-deﬁned abstractions), we categorize diﬀerent kinds of overhead.
Our Saaz example exhibits these overheads, but these categories are not unique to Saaz. Overheads are consequences
of building abstractions, particularly with classes, and exist in all other libraries, although their relative costs may vary
with implementations and usage patterns. Overheads are determined not solely by what a library provides, but also
how it provides it: the library’s interface. Our categories are encapsulation, generalization, and isolation:
C1. Encapsulation refers to the movement of data into objects (or structures) and the outlining of code into functions or methods. This can introduce function call overhead, pointer arithmetic, inlining issues, duplication of
metadata, loss of cache beneﬁts, and indirection.
C2. Generalization refers to features which may not be needed in all cases, but are used at diﬀerent times and in different combinations. This typically introduces extra checks for assumptions, branches for diﬀerent capabilities,
or extra arithmetic operations.
C3. Isolation occurs when encapsulation prevents both the compiler and user-code from making global decisions.
Code behind a class interface cannot take advantage of global patterns to simplify its calculations. Such code
often has to recompute values known to other objects or other parts of the program.
Each of Saaz’s abstractions carries a cost. Saaz focuses on usability for domain scientists. As mentioned before,
Saaz avoids techniques such as compile-time evaluation with templates that are unreasonable for domain-science
focused programmers. A well-designed library must balance usability and performance. If a library is too diﬃcult
for use by its intended audience, then it will not be adopted. Yet, if that library is too ineﬃcient, it may still not be
adopted. Our goal is to balance these concerns, and we believe that our solution of employing a custom source-tosource translator to mediate the penalties of abstraction in an application library has done so.
Our approach is based on the following observation: high-level abstractions do not necessarily have ineﬃcient
implementations; by carrying information about the operation being performed, they enable domain speciﬁc optimizations. In these cases, much of the application overhead can be between these specialized calls, when data formats
must be changed or user-deﬁned operations are implemented manually. One of the goals of Tettnang is to show how
to optimize call-sequences and manually-implemented operations. Saaz tries to be general enough that it can express
more complex, problem-speciﬁc functions. As a consequence, individual operations in Saaz must be composed or
chained together in sequence to express more sophisticated operations. Because each operator in Saaz has a restricted
view (C3), it is not able to specialize its operations in the same way that other libraries can (C2). We have therefore designed Tettnang to obtain a global view of operations and target not just the overhead composed calls, but the
overheads of call-sequences and their side-eﬀects.

Alden King and Scott Baden / Procedia Computer Science 9 (2012) 1930 – 1939

1933

3.1. Array Layout
When we index a multidimensional array, we need to map the multidimensional index onto a scalar oﬀset, a
process called linearization. The oﬀset corresponds to the position of the indexed data item within the array’s storage
area. In conventional languages such as FORTRAN, arrays have an assumed layout, and the functional form of the
mapping is known by the compiler. However, since Saaz allows the user to specify the layout at runtime and at the
granularity of individual arrays, the compiler does not know what function performs the linearization. To support this
generalization (C2), the runtime ultimately sets a function pointer to perform the linearization. Invoking a function
pointer is costly, however, and increases the cost of an array reference by about a factor of 10.
Fortunately, the overhead of this abstraction is frequently unnecessary. Linearization is a function of an array’s
layout, and the domain on which it is deﬁned. Saaz does not permit layouts to change, or domains to change shape. In
many analysis codes, queries written with Saaz involve conforming arrays, that is, arrays which have the same layout
and are deﬁned over the same domain. Special-casing the linearization operation (C2) for these arrays makes it cheaper
and can eliminate expensive common subexpressions (C3). Tettnang performs this specialization automatically.
3.2. Domain Objects
Domain objects are a form of metadata in Saaz. They encapsulate (C1) the index set for an array, and thus
the bounds for looping iterators. While domains are a convenient means of organizing data, storing data in objects
still introduces overhead (C1 and C3). Compilers could, in theory, get around this overhead, but in practice the
requisite analysis is too expensive, and so compilers can optimize accesses only under certain circumstances. While
the individual cost of each operation can be small, the cumulative eﬀect is large when many accesses are made within
loops. Using stack-local variables instead of object data-members can increase performance. Hand-implemented code
typically contains bounds on the stack, either as local variables, or as function parameters.
3.3. Iterators
Saaz uses iterators to make loops rank independent and order agnostic. Figure 1 illustrates a simple
summation; note that the rank of the array, domain,
Figure 1: A simple example illustrating a Saaz iterator.
and iterator is hidden. Saaz uses function calls instead of integer comparisons to evaluate iteration bounds and to increment the iterator, adding encapsulation overhead
(C1). Compared to Vanilla C, the iterator does not add comparisons or operations other than a function call.
Perhaps the most signiﬁcant cost of iterators is that they inhibit compiler optimizations (C1). C++ compilers such
as those from GNU and Intel will not vectorize loops over iterator objects. Loops over integers that have well-deﬁned
bounds (even if not constant, but an integral variable), can be vectorized by the compiler or parallelized with OpenMP.
Tettnang’s loop transformations convert loops over iterators to loops over integers, thus enabling these optimizations.
Domain dmn ; i n t sum = 0 ;
f o r ( I t e r a t o r p = dmn . b e g i n ( ) ; p != dmn . end ( ) ; ++p )
{ sum += a r r a y [ p ] ;
}

4. The Tettnang Translator
Our translator, Tettnang, was built using the Rose source-to-source translator [9] from Lawrence Livermore National Laboratory. The Rose compiler framework is a convenient means of tuning libraries to speciﬁc program requirements. Rose is a member of the family of language processors that support semantic-level optimizations including
Telescoping languages [10] [11] and Broadway [12]. It has previously been used to produce promising results in
realizing semantic-level optimizations of C++ class libraries [13] [14]. Tettnang uses Rose to parse C++ source code
and manipulate it before unparsing it and passing the unparsed C++ source code to a general-purpose C++ compiler.
Which code transformations can be performed by a compiler will largely be a function of the information the compiler has about the program. Keywords such as restrict give the compiler information about how pointers behave.
We incorporate information about the semantics of Saaz into Tettnang. This means Tettnang does not have to perform
interprocedural analysis of Saaz, because it already knows what side eﬀects may or may not occur. Furthermore,
Tettnang knows how objects are aliased, and so does not have to view the heap as an “anything goes” zone, as other
compilers such as Intel and GNU do. In the future it may be possible to avoid incorporating Saaz-speciﬁc semantics
by using an annotation language such as that in Broadway.

1934

Alden King and Scott Baden / Procedia Computer Science 9 (2012) 1930 – 1939

Several Saaz design choices greatly simplify the need for analysis on the part of Tettnang. Of particular importance
is the fact that domains, the domains arrays are deﬁned over, and the layouts of each array are all constant. This greatly
reduces the amount of side-eﬀect analysis which must be performed.
This section discusses how we designed Tettnang to utilize information about common use cases of the Saaz
library to reduce library overheads. While performance is a big motivation for the transformations, those we discuss
here speciﬁcally address the overhead introduced by abstractions and not general performance improvements [15]
[16]. Tettnang does not, for example, optimize for cache or perform other classic optimizations. These are out of the
scope of Tettnang and are assumed to be performed independently.
4.1. Index Linearization
Recall that because Saaz does not have a ﬁxed convention for array layout, that the linearization function for
each array object can be diﬀerent. Because the choice of the linearization function is hidden behind a class interface,
general-purpose compilers cannot determine what that choice will be (C2). Tettnang is able to examine the array
constructors to identify layout, and thus inline the function call, overcoming Encapsulation (C1) to address the cost of
Generalization (C2). For example, if Tettnang can determine the layout of an array, A, to be row-major, and its domain
to be [x lo : x hi] × [y lo : y hi] × [z lo : z hi], then it can save the cost of the expensive function pointer call by
rewriting A.LinearIdx(i,j,k) as follows:
(k − z lo) + (( j − y lo) + (i − x lo) ∗ (y hi − y lo + 1)) ∗ (z hi − z lo + 1)
(1)
In addition to the cost of the function pointer, these expressions contain two expensive integer multiplies and seven
additions and subtractions. The costs of these calculations can easily overwhelm the cost of accessing the desired
array element, especially for simpler kernels. Multiple array references involving conforming arrays will linearize
identically (Figure 2a). Tettnang can therefore consolidate the common linearization expressions and perform them
only once (Figure 2b). This will cut running time of Figure 2a in half. With this technique, Tettnang addresses the
eﬀects of Isolation (C3), eliminating the common expressions from the linearization operations.
4.2. Domain Objects & Iterators
Encapsulation also increases the cost of obtaining the bounds of a domain, in this case, the cost of the accessor
function. While modern compilers can inline accessor function calls, there still remains the extra cost of accessing
member variables. Tettnang can determine a domain’s bounds by analyzing the domain’s construction. Consider, for
example, the case of Domain3 dmn(x lo,y lo,z lo, x hi,y hi,z hi) (Figure 2a and b). Tettnang can replace calls
to dmn.Min(0) or accesses to dmn.x min with accesses to the stack-local variable x lo that was passed to the domain
constructor. If Tettnang is unable to evaluate the expression as a variable, it performs the next optimization.
Accessing member variables in an object is still more expensive than accessing them from the stack. In our
experiments with the GNU and Intel (v12) compilers, we found that the encapsulation of values into member variables
seemed to discourage the compiler from placing the values in registers, despite frequent use. Tests indicate it might be
because such values live on the heap, although the exact reason for this diﬀerentiation is under investigation. Copying
member variables onto the stack also increases cache locality with other frequently used variables which may not
be adjacent on the heap. In the case where a domain’s constructor is not available (for example, if it was created in
another function or read from disk) or a constructor parameter is an expression instead of a variable or constant, we
can still create new local variables to store the value of the member variable. Henceforth, function calls to read that
bound can be rewritten as references to the new local variable (Figure 2c). Other transformations generate member
accesses for the data which this optimization caches, so it is important to save this transformation until the end. This
method of copying member variables onto the stack can be applied to other libraries that frequently access member
variables through accessor functions.
Identiﬁcation of domain bounds is especially eﬀective when translating iterators. A single loop over an iterator
can be replaced with the corresponding triple-nested loops over integers (Figure 2c to Figure 2d).

Alden King and Scott Baden / Procedia Computer Science 9 (2012) 1930 – 1939

1935

Domain3 dmn ( x l o , y l o , z l o , x h i , y h i , z h i ) ;
A r r a y 3 A( dmn , L a y o u t : : RowMaj ) , B( dmn , L a y o u t : : RowMaj ) ;
f o r ( I t e r a t o r 3 p = dmn . b e g i n ( ) ; p != dmn . end ( ) ; ++p ) {
unsigned long o f f s e t = A. L i n e a r I d x ( p ) ;
Domain3 dmn ( x l o , y l o , z l o , x h i , y h i , z h i ) ;
A. Elements ( o f f s e t ) = B. Elements ( o f f s e t ) ;
A r r a y 3 A( dmn , L a y o u t : : RowMaj ) , B( dmn , L a y o u t : : RowMaj ) ;
f o r ( I t e r a t o r 3 p = dmn . b e g i n ( ) ; p != dmn . end ( ) ; ++p ) }
A[ p ] = B[ p ] ;

(a) A simple example illustrating Saaz’s abstractions.

(b) When A and B are conforming, Tettnang can consolidate their
linearization operations, making only one call to LinearIdx.

Domain3 dmn ( x l o , e x p r 1 , e x p r 2 , x h i , e x p r 3 , z h i ) ;
i n t y min = dmn . Min ( 1 ) , y max = dmn . Max ( 1 ) , z m i n = dmn . Min ( 2 ) ;
A r r a y 3 A( dmn , L a y o u t : : RowMaj ) , B( dmn , L a y o u t : : RowMaj ) ;
f o r ( I t e r a t o r 3 p = dmn . b e g i n ( ) ; p != dmn . end ( ) ; ++p ) {
u n s i g n e d l o n g o f f s e t = ( p . z−z m i n ) + ( ( p . y−y min ) + ( ( p . x− x l o ) ∗ ( y max −y min +1) ) ) ∗ ( z h i −z m i n +1) ;
A. Elements ( o f f s e t ) = B. Elements ( o f f s e t ) ;
}

(c) Tettnang creates local variables to cache the values of member variables which are unknown to it. Expressions which
Tettnang cannot analyze are shown as expr1, expr2, and expr3. LinearIdx is expanded as in Equation 1.
Domain3 dmn ( x l o , e x p r 1 , e x p r 2 , x h i , e x p r 3 , z h i ) ;
i n t y min = dmn . Min ( 1 ) , y max = dmn . Max ( 1 ) , z m i n = dmn . Min ( 2 ) ;
A r r a y 3 A( dmn , L a y o u t : : RowMaj ) , B( dmn , L a y o u t : : RowMaj ) ;
f o r ( i n t i = x l o ; i <= x h i ; ++ i ) {
f o r ( i n t j = y min ; j <= y max ; ++ j ) {
f o r ( i n t k = z m i n ; k <= z h i ; ++k ) {
u n s i g n e d l o n g o f f s e t = ( k−z m i n ) + ( ( j −y min ) + ( ( i − x l o ) ∗ ( y max −y min +1) ) ) ∗ ( z h i −z m i n +1) ;
A. Elements ( o f f s e t ) = B. Elements ( o f f s e t ) ;
} } }

(d) Tettnang is able to convert the iterator loop to nested loops with integral bounds. Note that accesses to the member
variables of the composite index p have been replaced with the new loop variables (i, j, and k).
Figure 2: Our code example with progressively more Tettnang transformations applied.

5. Results
5.1. Queries
To validate Tettnang, we applied it to seven queries authored in Saaz (Table 1). These queries were obtained
from the CFD group at UCSD that helped develop Saaz initially [2]. They perform correlations and derivatives along
diﬀerent axes, thus demonstrating the three categories addressed in Section 3.
We divide the queries into two types: those that take derivatives, and those that do not. The ﬁrst query, a crosscorrelation of velocity, does not take derivatives: we denote it by PlanarAveragey (u v ), where the · notation signiﬁes
normalization, and PlanarAveragey (·) is the planar average taken along the y-axis (Figure 4 shows an example result
and the pseudo-code for it). Normalization entails subtracting, from each point, the average value of the ﬁeld variable
in the containing plane normal to the y-axis. Since stratiﬁcation causes diﬀerent energy levels for each plane, we use
normalization to get the same baseline for each plane. This query measures the prevalence of coherent ﬂow structures:
it computes a planar average of the point-wise product of the two normalized ﬁeld variables, u, and v (in 3D). Thus,
the cross-correlation uses a two-level loop, the outer loop iterating along the y-axis, and the inner loop computing
the sums of the products within each plane. This is an extension of the planar average operation itself. The turbulent
transport queries are mathematically similar, and measure the transfer of energy in certain directions.
Dissipation is the second type of query, and it takes derivatives. Dissipation measures the loss of energy due to
turbulence, and is thus important for understanding turbulent systems. Regions with more dissipation tend not to form
coherent structures, as the dissipative energies move the ﬂuid apart more than similar velocities move it together.
5.2. Experimental Setup
To evaluate Tettnang, we wrote several diﬀerent variants of each query. The ﬁrst variant is written in Vanilla C, C
code using C-style 3D arrays and no user-deﬁned abstractions. The second variant was written in Saaz; the rest are
the result of passing the Saaz code through Tettnang with various levels of optimization. All tests ran on a two-socket

1936

Alden King and Scott Baden / Procedia Computer Science 9 (2012) 1930 – 1939

Figure 3: (Left) Conﬁguration of the temporally evolving shear layer. Two streams of ﬂuid are shown, one moving in the positive
x direction and the other in the negative x direction. The streams are separated by the y = 384 mid-plane. Stratiﬁcation (mean
density variation) is in the z direction, which is shown by the constant density gradient, dρ/dz. (Right) Simulation data for the u
velocity in the yz-plane.
	


	







	
		

1
2
3
4
5
6
7

ua := PlanarAverage y(u, domain of u))
va := PlanarAverage y(v, domain of v))
∀ Planes p in domain of u
∀ Points q in p
uv[p]+ = ((u[p ⊕ q] − ua [p])∗ (v[p ⊕ q] − va [p]))
uv[p] := uv[p]/size(p)
return uv

	

Figure 4: An example query: the velocity cross-correlation with normalization inlined. ⊕ represents the gather from a 1D and 2D
point into a 3D point.

3.0 GHz quad-core Intel Xeon processor (X5450, or “Harpertown”) with 2x6MB of L2 cache and 32GB of main
memory. All code was compiled using the GNU compiler suite v4.2 and command line options -O2, although both
later versions and the Intel compiler exhibit similar characteristics.
5.3. Optimizations
Tettnang currently implements six optimizations, described previously. These optimizations deal solely with
eliminating overheads of abstraction and are not optimizations in the traditional sense. Tettnang does not implement
traditional loop-based optimizations such as blocking for cache, loop fusion, loop ﬁssion, or vectorization [16]. Such
optimizations are orthogonal to Tettnang’s and are out of the scope of this paper.
We applied Tettnang’s optimizations incrementally to all seven queries (Table 1). Because all arrays are conforming, their linearization functions are identical. The ﬁrst four queries apply pointwise multiplication to combine
array arguments. Since each array is indexed at the same point, their respective linearization computations are all
identical, and can be combined. The remaining queries access adjacent points in a stencil operation to compute ﬁnitediﬀerences. The patterns of memory accesses (strides) are diﬀerent, and depend on the direction the derivatives are
taken. For example the diﬀerentiation operation ∂ x (u ) incurs a unit stride, while ∂z (u ) incurs a much larger stride:
the size of a plane.
Our No Iterators optimization transforms loops using Saaz iterators into ordinary loops over integers. While the
Saaz iterators do not themselves have signiﬁcant overhead, traditional compilers cannot optimize code using Saaz
iterators as they would a traditional loop over integers (C1). Vectorization and parallelization (via OpenMP), for
example, require knowing how loops are bounded and advanced - facts that an iterator object obscures. As Figure
5a shows, our ﬁrst optimization on its own yields only a minor performance improvement, but it is required for later
compiler optimizations.
Because diﬀerent Saaz arrays can have diﬀerent layouts, each array reference incurs the cost of linearization (C3).
By comparison, code written in Vanilla C (or FORTRAN) performs this calculation once per layout, instead of once
per array reference. Our second optimization, Combine Oﬀsets, performs common subexpression elimination on
linearization calls when referencing multiple conforming arrays. Thus, the cost of an array access is more a function

1937

Alden King and Scott Baden / Procedia Computer Science 9 (2012) 1930 – 1939

Description (Name)

Kernel

Velocity Cross-Correlation (UV)
Turbulent Transport X (UUV)
Turbulent Transport Y (VVV)
Turbulent Transport Z (WWV)

uv
uuv
vvv
wwv

xz-Dissipation (S13)

(0.25 × (∂z (u ) + ∂ x (w )))2

yz-Dissipation (S23)
zz-Dissipation (S33)

0.25 × (∂z (v ) + ∂y (w ))
(0.25 × (2 ∗ ∂z (w )))2



!










Table 1: Sample query kernels. The ﬁrst four do not take
derivatives, the last three do. The full query is the planar
average of the result of the calculation in the column labeled
“Kernel” [2]. ∂z (A) represents the ﬁnite-diﬀerence derivative
Z]
.
of A taken along the z dimension: u[p+Z]−u[p−
Δz





2








	



	

			





	





(a) First 3 Transformations







	


		
























(b) Second 3 Transformations

Figure 5: Performance of the various queries with incrementally more of Tettnang’s transformations applied. Our fourth optimization, Inline Oﬀsets, signiﬁcantly improved performance, requiring a change in scale between the left and right graphs.

of the number of layouts than the number of array references - users pay only for the compatibility functionality if
they need it (C2).
Three of the ﬁrst four queries beneﬁt signiﬁcantly from combining oﬀsets (Figure 5). Because they access two
arrays, their running time is cut approximately in half. (For k conforming arrays, the cost drops to 1/k.) The VVV
query (Turbulent Transport Y) doesn’t beneﬁt from combining oﬀsets because there is only one array access. The
small performance gain is due to an inline performed to set up for combining (apparently non-existent) oﬀsets. The
last three queries don’t beneﬁt either, but for a diﬀerent reason. These queries take derivatives: although they index
conforming arrays, they do so at diﬀerent points. The computed oﬀsets will diﬀer, and so the index calculations
cannot be shared. The Inline Oﬀsets optimization addresses this issue. For reasons of space, we omit a discussion of
the Inline Point Promotion optimization.
The information Tettnang gathered to combine oﬀsets also identiﬁes the linearization function (pointed to by
LinearIdx). Tettnang will inline this function and eliminate common subexpressions which had previously been
obscured (Inline Oﬀsets). The result of inlining the index calculation and combining non-identical oﬀsets is the most
signiﬁcant speedup of any of our optimizations: a speedup of around a factor of ten, hence the diﬀerence in scales
between Figure 5a and b. Performance has now approached that of the Vanilla C version.
Our two remaining optimizations, Inlining Function Accessors and the Local Variable Cache, are not speciﬁc to
Saaz and address overheads of data encapsulation (C1). Domain objects hold integer values for their upper and lower
bounds in each dimension. Loop iterations and linearization operations both need to check domain bounds. Many
accessor function calls are exposed through the inlining performed by previous optimizations. Tettnang translates
accessor calls to the corresponding object member references. We can go further by extracting these values into stacklocal variables as a sort of cache. This encourages the compiler to place them in registers, or, when that is not possible
(such as in the case of complex kernels), to access them with a single stack oﬀset. This is cheaper than accessing the
member through its object.
After applying all of our optimizations, performance is now 75% of Vanilla C, and 27 times faster than the original

1938

Alden King and Scott Baden / Procedia Computer Science 9 (2012) 1930 – 1939

Saaz code. If we run all of these queries as a typical query suite, our total time is 74 seconds on a warm ﬁle cache.
A cold cache adds 122 seconds. While there is still room for improvement, it is now more important to batch queries
than to further improve Tettnang’s optimizations.





5.4. Multicore Parallelization
Tettnang also generates OpenMP code to enable

Saaz queries to run on multicore processors. Since
Saaz is intended for data-intensive applications, large

shared memory machines designed for such applications are the target of this capability. Our queries cur
rently ﬁt into traditional server nodes, but we will discuss larger scale parallelism in the future [17].

OpenMP has a very restricted set of forms for the
loops that it will parallelize [18]. Not until version

3.0 did OpenMP support stl iterators. Tettnang ef






fectively extends OpenMP’s capability by adding sup	
	
	
	
	
port for Saaz’s new iterator datatype: it translates loops
Figure 6: Performance of the various queries with diﬀerwith the Saaz iterator to loops over integers, and then
ent numbers of OpenMP threads. “Tettnang Serial” refers to
inserts the appropriate pragmas. Without any extra efthe Tettnang-processed code with all the optimizations applied
fort on the part of the Saaz programmer, Tettnang is
(“Local Var Cache” from Figure 5).
able to parallelize serial code.
Figure 6 shows the timings for various thread counts using OpenMP directives that have been inserted by Tettnang.
These tests are all run on our previously described SMP node. There are some small super-linear speedups which
we are still investigating. The last three queries involve derivatives and thus more memory accesses. They also
involve more FLOPS and more integer adds and multiplies from the extra oﬀset computations. Because they are more
compute-intensive, they see better speedup on more cores.

6. Related Work
In contrast to many other systems that focus on optimizing transformations, the transformations in Tettnang focus
largely on removing library overheads. One of the early libraries similarly addressed was the A++/P++ library [19].
In [14], an earlier version of the Rose compiler was used to perform transformations. Unlike Tettnang, which has
built-in information, these translators use annotations to identify certain library constructs. Their transformations
consist mainly of converting whole-array operations to nested loops. Loop fusion is also performed. Saaz’s use of
looping constructs instead of whole-array operations makes this transformation less important. Tettnang does not
address loop transformations, although the data it gathers would make such transformations straightforward. Many
Tettnang transformations would still be applicable after these loop transformations.
Telescoping languages [10] analyze libraries and construct a compiler to optimize them. Their optimizations see
most of their gains from adding static-types to dynamically-typed languages such as Matlab. The closest to our work is
the Broadway compiler [12] which seeks to address a wide variety of domains through library annotation. Inlining and
rewrite transformations are library-speciﬁc, since trade-oﬀs can be signiﬁcant. Such optimizations can be conditioned
on object properties established and modiﬁed through dataﬂow analysis. Broadway does not address call-sequences
or accessing object members, but focuses on functions, making it inappropriate for addressing isolation overheads
(C3). In contrast to Tettnang, Broadway cannot consolidate oﬀset computations across multiple arrays, build some
oﬀsets from others, or build a cache of local variables on the stack. Such contextual and inter-expression optimizations
provide a signiﬁcant portion of Tettnang’s improved performance.
The power of Tettnang lies is its ability to resolve, at compile time, certain control ﬂow decisions that drastically
impact performance. Expression Templates [4] [20] have been able to address composition through aggressive inlining of template methods. In particular, the physics library OpenFoam [21] uses heavily-templatized C++ to write
simulators. Template metaprogramming, however, remains a poor tool for addressing call-sequences or annotating
objects with state. There has been some work in delayed evaluation libraries [22] [5] which can handle call-sequences.

Alden King and Scott Baden / Procedia Computer Science 9 (2012) 1930 – 1939

1939

Template-based libraries are typically harder to write, harder to use, and much harder to debug than conventional libraries. Template error messages which are legalistically accurate may not provide information in a way that a domain
scientist can understand. We consider our technique more intuitive and more user-friendly for domain scientists.
7. Conclusion and Future Work
We have identiﬁed a bottleneck in scientiﬁc data analysis and eliminated it. Saaz provides abstractions to increase
programmer productivity, while Tettnang optimizes use of those abstractions to achieve performance comparable to a
low-level Vanilla C implementation. The Tettnang translator uses facts about Saaz’s semantics to gather knowledge
about library use and specialize the otherwise generic library code. Ultimately, Saaz’s support for interoperability and
focus on higher-level abstractions paid oﬀ: Saaz queries which have been optimized by Tettnang achieve performance
within 75% of Vanilla C. By customizing a translator, we have enabled the Saaz library to utilize high levels of
abstraction with little performance cost.
We leave as future work optimizations that deal with the memory hierarchy, e.g. blocking for cache and loop
fusion. Tettnang’s infrastructure gathers suﬃcient information to enable us to perform the analysis required to implement such optimizations, potentially enabling us to overtake Vanilla C. Tettnang’s analyses gather enough information
to detect a number of array indexing errors, but currently issue no warnings. Tettnang can also be extended to support
additional Saaz features such as other array layouts and sparse iteration spaces.
References
[1] E. Perlman, R. Burns, Y. Li, C. Meneveau, Data exploration of turbulence simulations using a database cluster, in: Proceedings of the
ACM/IEEE SC2007 Conference, SC, ACM, New York, NY, USA, 2007, pp. 1–23.
[2] A. King, E. Arobone, S. Sarkar, S. B. Baden, The saaz framework for turbulent ﬂow queries, in: Proceedings of the 2011 IEEE conference
on e-Science, IEEE, 2011.
[3] Y. Li, E. Perlman, M. Wan, Y. Yang, C. Meneveau, R. Burns, S. Chen, A. Szalay, G. Eyink, A public turbulence database cluster and
applications to study lagrangian evolution of velocity increments in turbulence, arXiv.org (2008) 1–31.
[4] T. Veldhuizen, Expression Templates, SIGS Publications, Inc., New York, NY, USA, 1996, pp. 475–487.
[5] A. R. Craig Chambers, F. Perry, S. Adams, R. R. Henry, R. Bradshaw, N. Weizenbaum, Flumejava: Easy, eﬃcient data-parallel pipelines, in:
Proceedings of the 2010 ACM SIGPLAN conference on Programming language design and implementation, PLDI, ACM, New York, NY,
USA, 2010, pp. 363–375.
[6] P. N. Hilﬁnger, P. Colella, FIDIL: A Language for Scientiﬁc Programming, SIAM, 1989.
[7] S. J. Fink, S. B. Baden, S. R. Kohn, Eﬃcient run-time support for irregular block-structured applications, Journel of Parallel and Distributed
Computing 50 (1998) 61–82.
[8] K. Yelick, L. Semenzato, G. Pike, C. Miyamoto, B. Liblit, A. Krishnamurthy, P. Hilﬁnger, S. Graham, D. Gay, P. Colella, A. Aiken, Titanium:
a high-performance java dialect, Concurrency: Practice and Experience 10 (11-13) (1998) 825–836.
[9] D. Quinlan, D. Miller, B. Philip, M. Schordan, Treating a user-deﬁned parallel library as a domain-speciﬁc language, in: Proceedings of the
16th international Parallel and Distributed Processing Symposium, Vol. 2 of IPDPS, IEEE Computer Society, Washington, DC, USA, 2002.
[10] K. Kennedy, B. Broom, A. Chauhan, R. Fowler, J. Garvin, C. Koelbel, C. McCosh, J. Mellor-Crummey, Telescoping languages: A system
for automatic generation of domain languages, Proc. IEEE (2005) 387–408.
[11] B. Broom, R. Fowler, K. Kennedy, Kelpio: A telescope-ready domain-speciﬁc i/o library for irregular block-structured applications, in: Proc.
First IEEE/ACM International Symposium on Cluster Computing and the Grid, IEEE, 2001, pp. 148–155.
[12] S. Z. Guyer, C. Lin, An annotation language for optimizing software libraries, ACM SIGPLAN Notices.
[13] D. J. Quinlan, M. Schordan, Q. Yi, B. R. de Supinski, A c++ infrastructure for automatic introduction and translation of openmp directives,
in: Proceedings of the OpenMP applications and tools 2003 international conference on OpenMP shared memory parallel programming,
WOMPAT, Springer-Verlag, Berlin, Heidelberg, 2003, pp. 13–25.
[14] D. Quinlan, M. Schordan, R. Vuduc, Q. Yi, Annotating user-deﬁned abstractions for optimization, in: Parallel and Distributed Processing
Symposium, 2006. IPDPS 2006. 20th International, 2006, p. 8.
[15] M. E. Wolf, M. S. Lam, A loop transformation theory and an algorithm to maximize parallelism, IEEE Transactions on Parallel and Distributed
Systems (1991) 452–471.
[16] R. Allen, K. Kennedy, Optimizing Compilers for Modern Architectures, Morgan Kaufmann for Academic Press, London, UK, 2002.
[17] A. King, The saaz library and compiler, Ph.D. thesis, University of California, San Diego, La Jolla, CA, USA (2012).
[18] L. Dagum, R. Menon, Openmp: An industry-standard api for shared-memory programming, IEEE Computational Science and Engineering
5 (1998) 46–55.
[19] R. Parsons, D. Quinlan, A++/p++ array classes for architecture independent ﬁnite diﬀerence computations, in: Proceedings of the Conference
on Object-Oriented Numerics, OONSKI, 1994, pp. 408–418.
[20] J. de Guzman, D. Marsden, T. Heller, Boost::phoenix.
ˇ
[21] H. Jasak, A. Jemcov, Zeljko
Tukovi´c, Openfoam: A c++ library for complex physics simulations, in: Coupled Methods in Numerical
Dynamics, 2007, pp. 1–20.
[22] M. Isard, M. Budiu, Y. Yu, A. Birrell, D. Fetterly, Dryad: Distributed data-parallel programs from sequential building blocks, in: Proceedings
of the 2nd ACM SIGOPS/EuroSys European Conference on Computer Systems, Eurosys, ACM, 2007, pp. 59–72.

