Aggregate and Veriﬁably Encrypted Signatures
from Bilinear Maps
Dan Boneh1 , Craig Gentry2 , Ben Lynn1 , and Hovav Shacham1
1

2

Stanford University,
{dabo,blynn,hovav}@cs.stanford.edu
DoCoMo Labs USA, cgentry@docomolabs-usa.com

Abstract. An aggregate signature scheme is a digital signature that
supports aggregation: Given n signatures on n distinct messages from n
distinct users, it is possible to aggregate all these signatures into a single short signature. This single signature (and the n original messages)
will convince the veriﬁer that the n users did indeed sign the n original
messages (i.e., user i signed message Mi for i = 1, . . . , n). In this paper we introduce the concept of an aggregate signature, present security
models for such signatures, and give several applications for aggregate
signatures. We construct an eﬃcient aggregate signature from a recent
short signature scheme based on bilinear maps due to Boneh, Lynn, and
Shacham. Aggregate signatures are useful for reducing the size of certiﬁcate chains (by aggregating all signatures in the chain) and for reducing
message size in secure routing protocols such as SBGP. We also show
that aggregate signatures give rise to veriﬁably encrypted signatures.
Such signatures enable the veriﬁer to test that a given ciphertext C is
the encryption of a signature on a given message M . Veriﬁably encrypted
signatures are used in contract-signing protocols. Finally, we show that
similar ideas can be used to extend the short signature scheme to give
simple ring signatures.

1

Introduction

Many real-world applications involve signatures on many diﬀerent messages generated by many diﬀerent users. For example, in a Public Key Infrastructure
(PKI) of depth n, each user is given a chain of n certiﬁcates. The chain contains
n signatures by n Certiﬁcate Authorities (CAs) on n distinct certiﬁcates. Similarly, in the Secure BGP protocol (SBGP) [17] each router receives a list of n
signatures attesting to a certain path of length n in the network. A router signs
its own segment in the path and forwards the resulting list of n + 1 signatures
to the next router. As a result, the number of signatures in routing messages is
linear in the length of the path. Both applications would beneﬁt from a method
for compressing the list of signatures on distinct messages issued by distinct parties. Speciﬁcally, X.509 certiﬁcate chains could be shortened by compressing the
n signatures in the chain into a single signature.
An aggregate signature scheme enables us to achieve precisely this type of
compression. Suppose each of n users has a public-private key pair (PKi , SKi ).
E. Biham (Ed.): EUROCRYPT 2003, LNCS 2656, pp. 416–432, 2003.
c International Association for Cryptologic Research 2003

Aggregate and Veriﬁably Encrypted Signatures from Bilinear Maps

417

User ui signs message Mi to obtain a signature σi . Then there is a public aggregation algorithm that takes as input all of σ1 , . . . , σn and outputs a short
compressed signature σ. Anyone can aggregate the n signatures. Moreover, the
aggregation can be performed incrementally. That is, signatures σ1 , σ2 can be
aggregated into σ12 which can then be further aggregated with σ3 to obtain σ123 .
When aggregating signatures in a certiﬁcate chain, each CA can incrementally
aggregate its own signature into the chain. There is also an aggregate veriﬁcation
algorithm that takes P K1 , . . . , P Kn , M1 , . . . , Mn , and σ and decides whether the
aggregate signature is valid. Intuitively, the security requirement is that the aggregate signature σ is declared valid only if the aggregator who created σ was
given all of σ1 , . . . , σn . Precise security deﬁnitions are given in Sect. 3.2. Thus, an
aggregate signature provides non-repudiation at once on many diﬀerent messages
by many users.
We construct an aggregate signature scheme based on a recent short signature due to Boneh, Lynn, and Shacham (BLS) [7]. This signature scheme works
in any group where the Decision Diﬃe-Hellman problem (DDH) is easy, but the
Computational Diﬃe-Hellman problem (CDH) is hard. We refer to such groups
as gap groups [7,25]. Recently there have been a number of constructions using
such gap groups [7,18,8,4]. Surprisingly, gap groups are insuﬃcient for constructing eﬃcient aggregate signatures. Instead, our construction uses a pair of groups
G1 , GT and a bilinear map e : G1 × G1 → GT where CDH is hard in G1 . Joux
and Nguyen [16] showed that the map e can be used to solve DDH in G1 , and
so G1 is a gap group. It is the extra structure provided by the bilinear map that
enables us to construct an eﬃcient aggregate signature scheme. We do not know
how to build eﬃcient aggregate signatures from general gap groups. Thus, our
construction is an example where the bilinear map provides extra functionality beyond a simple algorithm for solving DDH. Bilinear maps were previously
used for three-way Diﬃe-Hellman [16], Identity-Based Encryption (IBE) [5], and
Hierarchical IBE [15,13].
Aggregate signatures are related to multisignatures [19,24,23,4]. In multisignatures, a set of users all sign the same message and the result is a single signature. Recently, Micali et al. [19] deﬁned a security model for multisignatures
and gave some constructions and applications. Multisignatures are insuﬃcient
for the applications we have in mind, such as certiﬁcate chains and SBGP. For
these applications we must be able to aggregate signatures on distinct messages.
We note that recently Boldyreva [4] showed that general gap groups are suﬃcient for constructing multisignatures from BLS signatures. As noted above, to
obtain aggregate signatures, one needs the extra structure provided by bilinear
maps.
Our application of aggregate signatures to compressing certiﬁcate chains is
related to an open problem posed by Micali and Rivest [20]: Given a certiﬁcate
chain and some special additional signatures, can intermediate links in the chain
be cut out? Aggregate signatures allow the compression of certiﬁcate chains
without any additional signatures, but a veriﬁer must still be aware of all in-

418

D. Boneh et al.

termediate links in the chain. We note that batch RSA [9] also provides some
signature compression, but only for signatures produced by a single signer.
As a further application for aggregate signatures we show in Sect. 4 that certain aggregate signature schemes give rise to simple veriﬁably encrypted signatures. These signatures enable user Alice to give Bob a signature on a message M
encrypted using a third party’s public key and Bob to verify that the encrypted
signature is valid. Veriﬁably encrypted signatures are used in optimistic contract signing protocols [1,2] to enable fair exchange. Previous constructions [1,
26] require zero knowledge proofs to verify an encrypted signature. The veriﬁably
encrypted signatures in Section 4 are short and can be validated eﬃciently. We
note that the resulting contract signing protocol is not abuse-free in the sense
of [10].
As a third application of these ideas we construct in Sect. 5 a simple ring
signature [27] using bilinear maps. As above, the construction using a bilinear
map is simpler and more eﬃcient than constructions that only make use of gap
groups.

2

Signature Schemes Based on Co-gap Diﬃe-Hellman

We ﬁrst review a few concepts related to bilinear maps and Gap Diﬃe-Hellman
signatures [7]. Throughout the paper we use the following notation:
1.
2.
3.
4.

G1 and G2 are two (multiplicative) cyclic groups of prime order p;
g1 is a generator of G1 and g2 is a generator of G2 ;
ψ is a computable isomorphism from G1 to G2 , with ψ(g1 ) = g2 ; and
e is a computable bilinear map e : G1 × G2 → GT as described below.

The isomorphism ψ is mostly needed for the proofs of security. To keep the
discussion general, we simply assume that ψ exists and is eﬃciently computable.
When G1 , G2 are subgroups of the group of points of an elliptic curve E/Fq , the
trace map on the curve can be used as this isomorphism (we assume G1 ⊆ E(Fqr )
and G2 ⊆ E(Fq )).
Throughout the paper, we consider bilinear maps e : G1 × G2 → GT where
all groups G1 , G2 , GT are multiplicative and of prime order p. One could set
G1 = G2 . However, we allow for the more general case where G1 = G2 so that our
constructions can make use of certain families of non-supersingular elliptic curves
deﬁned by Miyaji et al. [21]. These curves give rise to very short signatures [7].
This will lead in turn to short aggregate signatures, ring signatures, etc. To
handle the case G1 = G2 we deﬁne the co-CDH and co-DDH problems [7].
When G1 = G2 , these problems reduce to the standard CDH and DDH problems.
Hence, for the remainder of the paper, although we handle arbitrary G1 , G2 , for
simplicity, the reader may assume G1 = G2 , g1 = g2 , and ψ is the identity map.
With this setup we obtain natural generalizations of the CDH and DDH problems:
Computational Co-Diﬃe-Hellman. Given g1 , g1a ∈ G1 and h ∈ G2 compute
ha ∈ G 2 .

Aggregate and Veriﬁably Encrypted Signatures from Bilinear Maps

419

Decision Co-Diﬃe-Hellman. Given g1 , g1a ∈ G1 and h, hb ∈ G2 output yes if
a = b and no otherwise. When a = b we say that (g1 , g1a , h, ha ) is a co-DiﬃeHellman tuple.
When G1 = G2 and g1 = g2 , these problems reduce to the standard CDH and
DDH. Next we deﬁne co-GDH gap groups to be group pairs G1 and G2 on which
co-DDH is easy but co-CDH is hard.
Deﬁnition 1. The groups G1 and G2 are, together, decision groups for coDiﬃe-Hellman if the group action on G1 , the group action on G2 , and the map ψ
from G1 to G2 can be computed in one time unit, and Decision co-Diﬃe-Hellman
on G1 and G2 can be solved in one time unit.
Deﬁnition 2. The advantage of an algorithm A in solving the Computational
co-Diﬃe-Hellman problem in groups G1 and G2 is
Adv co-CDHA = Pr A(g1 , g1a , h) = ha : a ← Zp , h ← G2
def

R

R

.

The probability is taken over the choice of a, h and A’s coin tosses. An algorithm A (t, )-breaks Computational co-Diﬃe-Hellman on G1 and G2 if A runs
in time at most t, and Adv co-CDHA is at least . Groups G1 and G2 are, together, (t, )-co-GDH groups if they are decision groups for co-Diﬃe-Hellman
and no algorithm (t, )-breaks Computational co-Diﬃe-Hellman on them.
2.1

Bilinear Maps

Let G1 and G2 be two groups as above, with an additional group GT such that
|G1 | = |G2 | = |GT |. A bilinear map is a map e : G1 × G2 → GT with the
following properties:
1. Bilinear: for all u ∈ G1 , v ∈ G2 and a, b ∈ Z, e(ua , v b ) = e(u, v)ab .
2. Non-degenerate: e(g1 , g2 ) = 1.
These properties imply two more: for any u ∈ G1 , v1 , v2 ∈ G2 , e(u, v1 v2 ) =
e(u, v1 ) · e(u, v2 ); for any u, v ∈ G1 , e(u, ψ(v)) = e(v, ψ(u)).
Deﬁnition 3. Two groups G1 and G2 are, together, bilinear groups if the group
action on either can be computed in one time unit, the map ψ from G1 to G2
can be computed in one time unit, a bilinear map e : G1 × G2 → GT exists, and
e is computable in one time unit.
Deﬁnition 4. Two groups G1 and G2 are, together, (t, )-bilinear groups for
co-Diﬃe-Hellman if they are bilinear groups and no algorithm (t, )-breaks Computational co-Diﬃe-Hellman on them.

420

D. Boneh et al.

Joux and Nguyen [16] showed that an eﬃciently-computable bilinear map e
provides an algorithm for solving the decision co-Diﬃe-Hellman problem. For a
tuple (g1 , g1a , h, hb ) we have
a = b mod p

⇐⇒

e(g1 , hb ) = e(g1a , h).

Consequently, if two groups G1 and G2 are together, (t, )-bilinear groups for
co-Diﬃe-Hellman, then they are also (t/2, )-co-GDH groups. The converse is
probably not true.
2.2

The Co-GDH Signature Scheme

We review the signature scheme of [7], which can be based on any gap group. It
comprises three algorithms, KeyGen, Sign, and Verify, and uses a full-domain
hash function h : {0, 1}∗ → G2 , viewed as a random oracle [3].
R

Key Generation. Pick random x ← Zp , and compute v ← g1x . The public key
is v ∈ G1 . The secret key is x ∈ Zp .
Signing. Given a secret key x and a message M ∈ {0, 1}∗ , compute h ← h(M ),
where h ∈ G2 , and σ ← hx . The signature is σ ∈ G2 .
Veriﬁcation. Given a public key v, a message M , and a signature σ, compute
h ← h(M ) and verify that (g1 , v, h, σ) is a valid co-Diﬃe-Hellman tuple.
A co-GDH signature is a single element of G2 . On certain elliptic curves these
signatures are very short: they are half the size of DSA signatures with similar
security. Theorem 1 of [7] proves the existential unforgeability of the scheme
under a chosen message attack [14] in the random oracle model assuming G1 and
G2 are co-gap groups for Diﬃe-Hellman.

3

Aggregate Signatures

We deﬁne aggregate signatures and describe an aggregate signature scheme based
on co-GDH signatures. Unlike the co-GDH scheme, aggregate signatures require
the existence of a bilinear map. We deﬁne security models and provide proofs of
security for aggregate signatures.
Consider a set U of users. Each user u ∈ U has a signing keypair (PKu , SKu ).
We wish to aggregate the signatures of some subset U ⊆ U. Each user u ∈ U
produces a signature σu on a message Mu of her choice. These signatures are
then combined into a single aggregate σ by an aggregating party. The aggregating
party, who can be diﬀerent from and untrusted by the users in U , has access to
the users’ public keys, to the messages, and to the signatures on them, but not to
any private keys. The result of this aggregation is an aggregate signature σ whose
length is the same as that of any of the individual signatures. This aggregate
has the property that a veriﬁer given σ along with the identities of the parties
involved and their respective messages is convinced that each user signed his
respective message.

Aggregate and Veriﬁably Encrypted Signatures from Bilinear Maps

3.1

421

Bilinear Aggregate Signatures

We describe a bilinear aggregate signature scheme based on the co-GDH scheme
presented above. Individual signatures in the aggregate signature scheme are
created and veriﬁed precisely as are signatures in the co-GDH scheme (Sect. 2.2).
Aggregate veriﬁcation makes use of a bilinear map on G1 and G2 .
The aggregate signature scheme allows the creation of signatures on arbitrary
distinct messages Mi ∈ {0, 1}∗ . An individual signature σi is an element of G2 .
The base groups G1 and G2 , their respective generators g1 and g2 , the computable isomorphism ψ from G1 to G2 , and the bilinear map e : G1 × G2 → GT ,
with target group GT , are system parameters.
The scheme comprises ﬁve algorithms: KeyGen, Sign, Verify, Aggregate, and
AggregateVerify. The ﬁrst three are as in ordinary signature schemes; the last
two provide the aggregation capability. The scheme employs a full-domain hash
function h : {0, 1}∗ → G2 , viewed as a random oracle.
R

Key Generation. For a particular user, pick random x ← Zp , and compute
v ← g1x . The user’s public key is v ∈ G1 . The user’s secret key is x ∈ Zp .
Signing. For a particular user, given the secret key x and a message M ∈
{0, 1}∗ , compute h ← h(M ), where h ∈ G2 , and σ ← hx . The signature is
σ ∈ G2 .
Veriﬁcation. Given user’s public key v, a message M , and a signature σ, compute h ← h(M ); accept if e(g1 , σ) = e(v, h) holds.
Aggregation. For the aggregating subset of users U ⊆ U, assign to each user an
index i, ranging from 1 to k = |U |. Each user ui ∈ U provides a signature σi ∈
G2 on a message Mi ∈ {0, 1}∗ of his choice. The messages Mi must all be
k
distinct. Compute σ ← i=1 σi . The aggregate signature is σ ∈ G2 .
Aggregate Veriﬁcation. We are given an aggregate signature σ ∈ G2 for an
aggregating subset of users U , indexed as before, and are given the original
messages Mi ∈ {0, 1}∗ and public keys vi ∈ G1 for all users ui ∈ U . To verify
the aggregate signature σ,
1. ensure that the messages Mi are all distinct, and reject otherwise; and
2. compute hi ← h(Mi ) for 1 ≤ i ≤ k = |U |, and accept if e(g1 , σ) =
k
i=1 e(vi , hi ) holds.
A bilinear aggregate signature, like a co-GDH signature, is a single element of
G2 . Note that aggregation can be done incrementally.
The intuition behind bilinear aggregate signatures is as follows. Each user ui
has a secret key xi ∈ Zp and a public key vi = g1xi . User ui ’s signature, if correctly
formed, is σi = hxi i , where hi is the hash of the user’s chosen message, Mi . The
aggregate signature σ is thus σ = i σi = i hxi i . Using the properties of the
bilinear map, the left-hand side of the veriﬁcation equation expands:
e(g1 , σ) = e g1 ,

i

hxi i =

i

e(g1 , hi )xi =

i

e(g1xi , hi ) =

i

e(vi , hi ) ,

which is the right-hand side, as required. It remains to prove security of the
scheme.

422

3.2

D. Boneh et al.

Aggregate Signature Security

Informally, the security of aggregate signature schemes is equivalent to the nonexistence of an adversary capable, within the conﬁnes of a certain game, of existentially forging an aggregate signature. Existential forgery here means that the
adversary attempts to forge an aggregate signature, on messages of his choice,
by some set of users.
We formalize this intuition as the aggregate chosen-key security model. In this
model, the adversary A is given a single public key. His goal is the existential
forgery of an aggregate signature. We give the adversary power to choose all
public keys except the challenge public key. The adversary is also given access
to a signing oracle on the challenge key. His advantage, Adv AggSigA , is deﬁned
to be his probability of success in the following game.
Setup. The aggregate forger A is provided with a public key PK1 , generated
at random.
Queries. Proceeding adaptively, A requests signatures with PK1 on messages of his choice.
Response. Finally, A outputs k − 1 additional public keys PK2 , . . . , PKk .
Here k is at most N , a game parameter. These keys, along with the
initial key PK1 , will be included in A’s forged aggregate. A also outputs
messages M1 , . . . , Mk ; and, ﬁnally, an aggregate signature σ by the k
users, each on his corresponding message.
The forger wins if the aggregate signature σ is a valid aggregate on messages M1 , . . . , Mk under keys PK1 , . . . , PKk , and σ is nontrivial, i.e., A did
not request a signature on M1 under PK1 . The probability is over the coin
tosses of the key-generation algorithm and of A.
Deﬁnition 5. An aggregate forger A (t, qH , qS , N, )-breaks an N -user aggregate
signature scheme in the aggregate chosen-key model if: A runs in time at most t;
A makes at most qH queries to the hash function and at most qS queries to the
signing oracle; Adv AggSigA is at least ; and the forged aggregate signature is by
at most N users. An aggregate signature scheme is (t, qH , qS , N, )-secure against
existential forgery in the aggregate chosen-key model if no forger (t, qH , qS , N, )breaks it.
A potential attack on aggregate signatures. The adversary’s ability in the chosenkey model to generate keys suggests the following attack, previously considered
in the context of multisignatures [19,4]. Alice publishes her public key vA . Bob
x
generates a private key xB and a public key vB = g1 B , but publishes as his
public key vB = vB /vA , a value whose discrete log he does not know. Then
h(M )xB veriﬁes as an aggregate signature on M by both Alice and Bob. Note
that in this forgery Alice and Bob both sign the same message M .
One countermeasure is to require the adversary to prove knowledge of the
discrete logarithms (to base g1 ) of his published public keys. For example,
Boldyreva, in her multisignature scheme [4], requires, in eﬀect, that the adversary disclose the corresponding private keys x2 , . . . , xk . Micali et al. [19] discuss

Aggregate and Veriﬁably Encrypted Signatures from Bilinear Maps

423

a series of more sophisticated approaches based on zero-knowledge proofs, again
with the eﬀect that the adversary is constrained in his key selection. These
defenses apply equally well to our aggregate signature scheme. For aggregate
signatures, though, there is a simpler defense.
A simple defense for aggregate signatures. In the context of aggregate signature
we can defend against the attack above by simply requiring that an aggregate
signature is valid only if it is an aggregation of signatures on distinct messages.
This restriction, codiﬁed in Step 1 of AggregateVerify, suﬃces to prove the security of the bilinear aggregate signature scheme in the chosen-key model. There
is no need for zero-knowledge proofs or the disclosure of private keys.
The requirement that all messages in an aggregate be distinct is naturally
satisﬁed for the applications to certiﬁcate chains and SBGP we have in mind.
Even in more general environments it is easy to ensure that all messages are
distinct: The signer simply prepends her public key to every message she signs
prior to the application of the hash function h. The implicit preﬁx need not be
transmitted with the signature, so signature and message length is unaﬀected.
The next theorem shows that this simple constraint is suﬃcient for proving
security in the chosen-key model. The proof is given in the full version of this
paper [6].
Theorem 1. Let G1 and G2 together be (t , )-bilinear groups for co-DiﬃeHellman, of order p, with respective generators g1 and g2 , with an isomorphism ψ
computable from G1 to G2 , and with a bilinear map e : G1 × G2 → GT . Then
the bilinear aggregate signature scheme on G1 and G2 is (t, qH , qS , N, )-secure
against existential forgery in the aggregate chosen-key model, where t ≤ t −
2cC (lg p)(qH + qS + N + 2), ≥ 2e · (qS + N − 1) , and cC is a small constant
(less than 2). Here e is the base of natural logarithms.
Aggregate veriﬁcation time. Let σ be an aggregate of the n signature σ1 , . . . , σn .
The time to verify the aggregate signature σ is linear in n. In the special case
when all n signatures are issued by the same public key v, aggregate veriﬁcation is
n
faster. One need only verify that e(g2 , σ) = e( i=1 h(Mi ), v), where M1 , . . . , Mn
are the signed messages.

4

Veriﬁably Encrypted Signatures

Next, we show an application of aggregate signatures to veriﬁably encrypted
signatures. Veriﬁably encrypted signatures are used in applications such as online
contract signing [1,2]. Suppose Alice wants to show Bob that she has signed a
message, but does not want Bob to possess her signature of that message. (Alice
will give her signature to Bob only when a certain event has occurred, e.g.,
Bob has given Alice his signature on the same message.) Alice can achieve this
by encrypting her signature using the public key of a trusted third party, and
sending this to Bob along with a proof that she has given him a valid encryption
of her signature. Bob can verify that Alice has signed the message, but cannot

424

D. Boneh et al.

deduce any information about her signature. Later in the protocol, if Alice is
unable or unwilling to reveal her signature, Bob can ask the third party to
reveal Alice’s signature. We note that the resulting contract signing protocol is
not abuse-free in the sense of [10].
We show that a variant of the bilinear aggregate signature scheme allows the
creation of very eﬃcient veriﬁably encrypted signatures.
4.1

Veriﬁably Encrypted Signature Security

A veriﬁably encrypted signature scheme comprises seven algorithms. Three,
KeyGen, Sign, and Verify, are analogous to those in ordinary signature schemes.
The others, AdjKeyGen, VESigCreate, VESigVerify, and Adjudicate, provide the
veriﬁably encrypted signature capability. The algorithms are described below.
We refer to the trusted third party as the adjudicator.
Key Generation, Signing, Veriﬁcation. As in standard signature schemes.
Adjudicator Key. Generate a public-private key pair (APK, ASK) for the adjudicator.
VESig Creation. Given a secret key SK, a message M , and an adjudicator’s
public key APK, compute (probabilistically) a veriﬁably encrypted signature ω on M .
VESig Veriﬁcation. Given a public key PK, a message M , an adjudicator’s
public key APK, and a veriﬁably encrypted signature ω, verify that ω is a
valid veriﬁably encrypted signature on M under key PK.
Adjudication. Given an adjudicator’s keypair (APK, ASK), a certiﬁed public
key PK, and a veriﬁably encrypted signature ω on some message M , extract
and output σ, an ordinary signature on M under PK.
Besides the ordinary notions of signature security in the signature component, we require three security properties of veriﬁably encrypted signatures: validity, unforgeability, and opacity. We describe these properties in the single user
setting.
Validity requires that veriﬁably encrypted signatures verify, and that adjudicated veriﬁably encrypted signatures verify as ordinary signatures, i.e., that
VESigVerify(M, VESigCreate(M )) and Verify(M, Adjudicate(VESigCreate(M ))
hold for all M and for all properly-generated keypairs and adjudicator keypairs.
(The keys provided to the algorithms are here omitted for brevity.)
Unforgeability requires that it be diﬃcult to forge a valid veriﬁably encrypted
signature. The advantage in existentially forging a veriﬁably encrypted signature
of an algorithm F, given access to a veriﬁably-encrypted-signature creation oracle S and an adjudication oracle A, along with a hash oracle, is


VESigVerify(PK, APK, M, ω) = valid :
R


(PK, SK) ← KeyGen,
def


Adv VSigFF = Pr 
 .
R

(APK, ASK) ← AdjKeyGen, 
R

(M, ω) ← F S,A (PK, APK)

Aggregate and Veriﬁably Encrypted Signatures from Bilinear Maps

425

The probability is taken over the coin tosses of the key-generation algorithms,
of the oracles, and of the forger. The forger is additionally constrained in that
its forgery on M must be nontrivial: It must not previously have queried either
oracle at M . Note that an ordinary signing oracle is not provided; it can be
simulated by a call to S followed by a call to A.
Deﬁnition 6. A veriﬁably encrypted signature forger F (t, qH , qS , qA , )-forges
a veriﬁably encrypted signature if: Algorithm F runs in time at most t; F makes
at most qH queries to the hash function, at most qS queries to the veriﬁablyencrypted-signature creation oracle S, at most qA queries to the adjudication
oracle A; and Adv VSigFF is at least . A veriﬁably encrypted signature scheme
is (t, qH , qS , qA , )-secure against existential forgery if no forger (t, qH , qS , qA , )breaks it.
Opacity requires that it be diﬃcult, given a veriﬁably encrypted signature, to
extract an ordinary signature on the same message. The advantage in extracting
a veriﬁably encrypted signature of an algorithm E, given access to a veriﬁablyencrypted-signature creation oracle S and an adjudication oracle A, along with
a hash oracle, is


def

Adv VSigEE = Pr 




Verify(PK, M, σ) = valid :



 .
(APK, ASK) ← AdjKeyGen, 
R

(PK, SK) ← KeyGen,
R

R

(M, σ) ← E S,A (PK, APK)
The probability is taken over the coin tosses of the key-generation algorithms, of
the oracles, and of the forger. The extraction must be nontrivial: the adversary
must not have queried the adjudication oracle A at M . (It is allowed, however,
to query S at M .) Veriﬁably encrypted signature extraction is thus no more
diﬃcult than forgery in the underlying signature scheme.
Deﬁnition 7. An algorithm E (t, qH , qS , qA , )-extracts a veriﬁably encrypted
signature if E runs in time at most t, makes at most qH queries to the hash
function, at most qS queries to the veriﬁably-encrypted-signature creation oracle S, at most qA queries to the adjudication oracle, and Adv VSigEE is at least
. A veriﬁably encrypted signature scheme is (t, qH , qS , qA , )-secure against extraction if no algorithm (t, qH , qS , qA , )-extracts it.
4.2

Aggregate Extraction

Our veriﬁably encrypted signature scheme depends on the assumption that given
an aggregate signature of k signatures it is diﬃcult to extract the individual
signatures.
Consider the bilinear aggregate signature scheme on G1 and G2 . We posit
that it is diﬃcult to recover the individual signatures σi given their aggregate σ,
the public keys, and the message hashes. In fact, we posit that it is diﬃcult to

426

D. Boneh et al.

recover an aggregate σ of any proper subset of the signatures. This we term the
k-element aggregate extraction problem.
We formalize this assumption as follows. Let G1 and G2 be, together, bilinear
groups for co-Diﬃe-Hellman of order p, with respective generators g1 and g2 , a
computable isomorphism ψ : G1 → G2 such that g2 = ψ(g1 ), and a computable
bilinear map e : G1 × G2 → GT .
Consider a k-user aggregate in this setting. Each user has a private key xi ∈
Zp and a public key vi = g1xi ∈ G1 . Each user selects a distinct message Mi ∈
{0, 1}∗ whose hash is hi ∈ G2 and creates a signature σi = hxi i ∈ G2 . Finally,
the signatures are aggregated, yielding σ = i σi ∈ G2 .
Let I be the set {1, . . . , k}. Each public key vi can be expressed as g1xi ,
each hash hi as g2yi , each signature σi as g2xi yi , and the aggregate signature σ
as g2z , where z = i∈I xi yi . The advantage of an algorithm E in extracting a
subaggregate from a k-element aggregate is


(
xi yi )
(I
I) ∧ (σ = g2 i∈I
) :
def

(
xi yi ) 
R
Adv k-ExtrE = Pr 
x1 , . . . , xk , y1 , . . . , yk ← Zp , σ ← g2 i∈I
, .
(σ , I ) ← E g1x1 , . . . , g1xk , g2y1 , . . . , g2yk , σ
R

The probability is taken over the choices of all xi and yi , and the coin tosses of
E.
Deﬁnition 8. An algorithm E (t, k, )-extracts a subaggregate from an k-element
bilinear aggregate signature if E runs in time at most t and Adv k-ExtrE is at least
. An instantiation of the bilinear aggregate signature scheme is (t, k, )-secure
against aggregate extraction if no algorithm (t, k, )-extracts it.
We will be particularly concerned with the case k = 2. In this case, the
aggregate extraction problem reduces to this one: given g1a , g1b , g2u , g2v , and
g2au+bv , calculate g2au . (If the extractor outputs g2bv instead, we may recover
g2au as g2au+bv/g2bv .)
4.3

Veriﬁably Encrypted Signatures via Aggregation

We motivate our construction for veriﬁably encrypted signatures by considering
aggregate signatures as a launching point. An aggregate signature scheme can
give rise to a veriﬁably encrypted signature scheme if it is diﬃcult to extract
individual signatures from an aggregate, but easy to forge existentially under
the adjudicator’s key. Consider the following:
1. Alice wishes to create a veriﬁably encrypted signature, which Bob will verify;
Carol is the adjudicator. Alice and Carol’s keys are both generated under
the underlying signature scheme’s key-generation algorithm.
2. Alice creates a signature σ on M under her public key. She forges a signature σ on some random message M under Carol’s public key. She then
combines σ and σ , obtaining an aggregate ω. The veriﬁably encrypted signature is the pair (ω, M ).

Aggregate and Veriﬁably Encrypted Signatures from Bilinear Maps

427

3. Bob validates Alice’s veriﬁably encrypted signature (ω, M ) on M by checking that ω is a valid aggregate signature by Alice on M and by Carol on M .
4. Carol adjudicates, given a veriﬁably encrypted signature (ω, M ) on M by
Alice, by computing a signature σ on M under her key, and removing σ
from the aggregate; what remains is Alice’s ordinary signature σ.
In the bilinear aggregate signature scheme, it is diﬃcult to extract individual signatures, under the aggregate extraction assumption. Moreover, existential
forgery is easy when the random oracle hash function is set aside: Given a public key v ∈ G1 and r ∈ Zp , ψ(v)r is a valid signature on a message whose hash
is ψ(g1 )r = g2r . Below, we formalize and prove the security of the veriﬁably
encrypted signature scheme created in this way.
4.4

The Bilinear Veriﬁably-Encrypted Signature Scheme

The bilinear veriﬁably encrypted signature scheme is built on the bilinear aggregate signature scheme of the previous section. It shares the key-generation
algorithm with the underlying aggregate scheme. Moreover, the adjudicator’s
public and private information is simply an aggregate-signature keypair. The
scheme comprises the seven algorithms described below:
Key Generation. KeyGen and AdjKeyGen are the same as KeyGen in the
co-GDH scheme.
Signing, Veriﬁcation. Sign and Verify are the same as in the co-GDH scheme.
VESig Creation. Given a secret key x ∈ Zp a message M ∈ {0, 1}∗ , and an
adjudicator’s public key v ∈ G1 , compute h ← h(M ), where h ∈ G2 , and
σ ← hx . Select r at random from Zp and set µ ← ψ(g1 )r and σ ← ψ(v )r .
Aggregate σ and σ as ω ← σσ ∈ G2 . The veriﬁably encrypted signature is
the pair (ω, µ). (This can also be viewed as ElGamal encryption of σ under
the adjudicator’s key.)
VESig Veriﬁcation. Given a public key v, a message M , an adjudicator’s
public key v , and a veriﬁably encrypted signature (ω, µ), set h ← h(M );
accept if e(g1 , ω) = e(v, h) · e(v , µ) holds.
Adjudication. Given an adjudicator’s public key v and corresponding private
key x ∈ Zp , a certiﬁed public key v, and a veriﬁably encrypted signature
(ω, µ) on some message M , ensure that the veriﬁably encrypted signature is
valid; then output σ = ω/µx .
(If the adjudicator does not ﬁrst validate a purported veriﬁably encrypted signature, a malicious user can trick him into signing arbitrary messages under his
adjudication key.)
It is easy to see that validity holds. A veriﬁably encrypted signature correctly
validates under VESigVerify, which is simply the aggregate signature veriﬁcation
algorithm. Moreover, for any valid veriﬁably encrypted signature, e(g1 , ω/µx ) =
e(g1 , ω) · e(g1 , µ)−x = e(v, h) · e(v , µ) · e(v , µ)−1 = e(v, h), so the output of
Adjudicate is a valid signature on message M under the key v.
The next two theorems prove the unforgeability and opacity of the scheme.
The proofs are given in the full version of this paper [6].

428

D. Boneh et al.

Theorem 2. Let G1 and G2 be cyclic groups of prime order p, with respective generators g1 and g2 , with a computable bilinear map e : G1 × G2 → GT .
Suppose that the co-GDH signature scheme is (t , qH , qS , )-secure against existential forgery on G1 and G2 . Then the bilinear veriﬁably encrypted signature
scheme is (t, qH , qS , qA , )-secure against existential forgery on G1 and G2 , where
t ≤ t − 4cF (lg p)(qS + qA + 1), qH ≤ qH , qS ≤ qS , qA is at most qS , and cF is
a small constant (at most 2).
Theorem 3. Let G1 and G2 be cyclic groups of prime order p, with respective generators g1 and g2 , with a computable bilinear map e : G1 × G2 → GT .
Suppose that the bilinear aggregate signature scheme on G1 and G2 is (t , 2, )secure against aggregate extraction. Then the bilinear veriﬁably encrypted signature scheme is (t, qH , qS , qA , )-secure against extraction on G1 and G2 , where
t ≤ t − 2cA (lg p)(qH + 3qS + qA + 2), ≥ 2e · qA , and cA is a small constant
(at most 2). Here e is the base of natural logarithms.
4.5

Observations on Veriﬁably Encrypted Signatures

We note some extensions of the veriﬁably encrypted signature scheme discussed
above. Some of these rely for security on the k-element aggregate extraction
assumption with k > 2.
– Anyone can convert an ordinary unencrypted signature to a veriﬁably encrypted signature. The same applies to unencrypted aggregate signatures.
– An adjudicator’s private key can be shared amongst n parties using k-of-n
threshold cryptography [12,11], so that k parties are needed to adjudicate a
veriﬁably encrypted signature.
– A message-signature pair in the co-GDH signature scheme is of the same
form as an identity–private-key pair in the Boneh-Franklin Identity-Based
Encryption Scheme [5]. Thus the veriﬁably encrypted signature scheme can
potentially be modiﬁed to yield a veriﬁably encrypted encryption scheme
for IBE private keys. Veriﬁably encrypted private keys have many applications [26].

5

Ring Signatures

Rivest, Shamir and Tauman deﬁne ring signature schemes and construct some
using RSA and Rabin cryptosystems [27]. Naor deﬁnes the closely-related notion
of deniable ring authentication and proposes such a scheme that relies only on
the existence of a strong encryption function [22]. We shall see that co-GDH
signatures give natural ring signatures.
5.1

Ring Signatures

Consider a set U of users. Each user u ∈ U has a signing keypair (PKu , SKu ). A
ring signature on U is a signature that is constructed using all the public keys

Aggregate and Veriﬁably Encrypted Signatures from Bilinear Maps

429

of the users in U , and a single private key of any user in U . A ring signature
has the property that a veriﬁer is convinced that the signature was produced
using one of the private keys of U , but is not able to determine which one. This
property is called signer-ambiguity [27]. Applications for ring signatures include
authenticated (yet repudiable) communication and leaking secrets [27].
Zhang and Kim [28] devised a bilinear ring signature in an identity-based setting. Our scheme diﬀers from theirs, as our goal is to extend co-GDH signatures
to obtain eﬃcient ring signatures; the system parameters and key generation
algorithm in our system are identical to those of the co-GDH scheme.
5.2

Bilinear Ring Signatures

The ring signature scheme comprises three algorithms: KeyGen, RingSign, and
RingVerify. Recall g1 , g2 are generators of groups G1 , G2 respectively, and e :
G1 × G2 → GT is a bilinear map, and a computable isomorphism ψ : G1 → G2
exists, with ψ(g1 ) = g2 . Again we use a full-domain hash function h : {0, 1}∗ →
G2 . The security analysis views h as a random oracle.
R

Key Generation. For a particular user, pick random x ← Zp , and compute
v ← g1x . The user’s public key is v ∈ G1 . The user’s secret key is x ∈ Zp .
Ring Signing. Given public keys v1 , . . . , vn ∈ G1 , a message M ∈ {0, 1}∗ , and
a private key x corresponding to one of the public keys vs for some s, choose
R
random ai ← Zp for all i = s. Compute h ← h(M ) ∈ G2 and set
σs ←

viai

h/ψ

1/x

.

i=s

For all i = s let σi ← g2ai . Output the ring signature σ = σ1 , . . . , σn ∈ Gn2 .
Ring Veriﬁcation. Given public keys v1 , . . . , vn ∈ G1 , a message M ∈ {0, 1}∗ ,
and a ring signature σ, compute h ← h(M ) and verify that e(g, h) =
n
i=1 e(vi , σi ).
Using the bilinearity and nondegeneracy of the pairing e, it is easy to show
that a signature produced by the RingSign algorithm will verify under the
RingVerify algorithm.
5.3

Security

There are two aspects a security analysis for ring signatures must consider.
Firstly, signer ambiguity must be ensured. We ﬁrst show that the identity of the
signer is unconditionally protected.
Theorem 4. For any algorithm A, any set of users U , and a random u ∈ U ,
the probability P r[A(σ) = u] is at most 1/|U |, where σ is any ring signature on
U generated with private key SKu .

430

D. Boneh et al.

Proof. The theorem follows from a simple probability argument: for any h ∈ G2 ,
R
and any 1 ≤ s ≤ n, the distribution {g2a1 , . . . , g2an : ai ← Zp for i = s, as
n
ai
chosen such that i=1 g2 = h} is identical to the distribution {g2a1 , . . . , g2an :
n
ai
i=1 g2 = h}, since the value of any one of the ai ’s is uniquely determined by
the values of the other ai ’s.
Secondly, we need to examine the scheme’s resistance to forgery. We adopt the
security model of Rivest, Shamir and Tauman [27]. Consider the following game
played between an adversary and a challenger. The adversary is given the public
keys v1 , . . . , vn of a set of users U , and is given oracle access to h and a ringsigning oracle. The adversary may work adaptively. The goal of the adversary is
to output a valid ring signature on U of a message M subject to the condition
that M has never been presented to the ring-signing oracle. An adversary A’s
advantage Adv RingSigA in existentially forging a bilinear ring signature is the
probability, taken over the coin tosses of the key-generation algorithm and of
the forger, that A succeeds in creating a valid ring signature in the above game.
The proof of the following security theorem is given in the full version of this
paper [6].
Theorem 5. Suppose F is a (t , )-algorithm that can produce a forgery of a
ring signature on a set of users of size n. Then there exists an (t, )-algorithm
that can solve the co-CDH problem where t ≤ 2t + c(lg p)nqH for some constant
c and ≥ ( /e(1 + qS ))2 , where F issues at most qS ring-signature queries and
at most qH hash queries.
5.4

Observations on Ring Signatures

Any ring signature scheme restricts to an ordinary signature scheme when
n = 1. Our scheme restricts to a short signature scheme similar to the co-GDH
scheme [7]. In this modiﬁed co-GDH scheme, σ equals h1/x rather than hx , and
one veriﬁes that e(g1 , h) = e(v, σ) rather than that e(g1 , σ) = e(v, h).
However, bilinear ring signatures have interesting properties that do not appear to be shared by ring signatures in general. For any set of users U with
u ∈ U , anyone can convert a modiﬁed co-GDH signature by u into a ring signature by U . Speciﬁcally, to convert a modiﬁed co-GDH signature σ1 on M
for public key v1 into a ring signature σ = σ1 , . . . , σn on M for public keys
R
n
v1 , . . . , vn , we choose ri ← Zp for 2 ≤ i ≤ n, and set σ1 ← σ1 i=2 ψ(viri ) and
σi ← ψ(v1−ri ) for 2 ≤ i ≤ n. More generally, anyone can further anonymize a
ring signature by adding users to U .

6

Conclusions

We introduced the concept of aggregate signatures and constructed an eﬃcient
aggregate signature scheme based on bilinear maps. Key generation, aggregation,
and veriﬁcation require no interaction. We proved security of the system in a

Aggregate and Veriﬁably Encrypted Signatures from Bilinear Maps

431

model that gives the adversary his choice of public keys and messages to forge.
For security, we introduced the additional constraint that an aggregate signature
is valid only if it is an aggregation of signatures on distinct messages. This
constraint is satisﬁed naturally for the applications we have in mind.
We gave several applications for aggregate signatures. For example, they
can be used to reduce the size of certiﬁcate chains and reduce communication
bandwidth in protocols such as SBGP. We also showed that our speciﬁc aggregate
signature scheme gives veriﬁably encrypted signatures and veriﬁably encrypted
private keys.
Previous signature constructions using bilinear maps [7,18,8,4] only required
a gap Diﬃe-Hellman group (i.e., DDH easy, but CDH hard). The signature
constructions in this paper require the extra structure provided by the bilinear
map. These constructions are an example where a bilinear map provides more
power than a generic gap Diﬃe-Hellman group.
Acknowledgments. The authors thank Leonid Reyzin, Liqun Chen, and Cynthia Dwork for helpful discussions about this work. The ﬁrst author is supported
by darpa, the Packard foundation, and an nsf career award. The third and
fourth authors are supported by darpa and nsf.

References
1. N. Asokan, V. Shoup, and M. Waidner. Optimistic fair exchange of digital signatures. IEEE J. Selected Areas in Comm., 18(4):593–610, April 2000.
2. F. Bao, R. Deng, and W. Mao. Eﬃcient and practical fair exchange protocols with
oﬄine TTP. In Proceedings of IEEE Symposium on Security and Privacy, pages
77–85, 1998.
3. M. Bellare and P. Rogaway. The exact security of digital signatures: How to sign
with RSA and Rabin. In Proceedings of Eurocrypt ’96, volume 1070 of LNCS,
pages 399–416. Springer-Verlag, 1996.
4. A. Boldyreva. Eﬃcient threshold signature, multisignature and blind signature
schemes based on the gap-Diﬃe-Hellman-group signature scheme. In Proceedings
of PKC 2003, volume 2567 of LNCS, pages 31–46. Springer-Verlag, 2003.
5. D. Boneh and M. Franklin. Identity-based encryption from the Weil pairing. In
Proceedings of Crypto 2001, volume 2139 of LNCS, pages 213–29. Springer-Verlag,
2001.
6. D. Boneh, C. Gentry, B. Lynn, and H. Shacham. Aggregate and veriﬁably
encrypted signatures from bilinear maps. Cryptology ePrint Archive, Report
2002/175, 2002. http://eprint.iacr.org/.
7. D. Boneh, B. Lynn, and H. Shacham. Short signatures from the Weil pairing.
In Proceedings of Asiacrypt 2001, volume 2248 of LNCS, pages 514–32. SpringerVerlag, 2001. Full paper: http://crypto.stanford.edu/˜dabo/pubs.html.
8. Y. Dodis. Eﬃcient construction of (distributed) veriﬁable random functions. In
Proceedings of PKC 2003, volume 2567 of LNCS, pages 1–17. Springer-Verlag,
2003.
9. A. Fiat. Batch RSA. In Proceedings of Crypto ’89, pages 175–185, 1989.

432

D. Boneh et al.

10. J. Garay, M. Jakobsson, and P. MacKenzie. Abuse-free optimistic contract signing.
In Proceedings of Crypto ’99, volume 1666 of LNCS, pages 449–466. SpringerVerlag, 1999.
11. P. Gemmel. An introduction to threshold cryptography. RSA CryptoBytes, 2(3):7–
12, 1997.
12. R. Gennaro, T. Rabin, S. Jarecki, and H. Krawczyk. Robust and eﬃcient sharing
of RSA functions. J. Cryptology, 13(2):273–300, 2000.
13. C. Gentry and A. Silverberg. Hierarchical ID-based cryptography. In Proceedings
of Asiacrypt 2002, volume 2501 of LNCS, pages 548–66. Springer-Verlag, 2002.
14. S. Goldwasser, S. Micali, and R. Rivest. A digital signature scheme secure against
adaptive chosen-message attacks. SIAM J. Computing, 17(2):281–308, 1988.
15. J. Horwitz and B. Lynn. Toward hierarchical identity-based encryption. In Proceedings of Eurocrypt 2002, volume 2332 of LNCS, pages 466–81. Springer-Verlag,
2002.
16. A. Joux. A one round protocol for tripartite Diﬃe-Hellman. In Proceedings of
ANTS IV, volume 1838 of LNCS, pages 385–94. Springer-Verlag, 2000.
17. S. Kent, C. Lynn, and K. Seo. Secure border gateway protocol (Secure-BGP).
IEEE J. Selected Areas in Comm., 18(4):582–92, April 2000.
18. A. Lysyanskaya. Unique signatures and veriﬁable random functions from the DHDDH separation. In Proceedings of Crypto 2002, volume 2442 of LNCS, pages
597–612. Springer-Verlag, 2002.
19. S. Micali, K. Ohta, and L. Reyzin. Accountable-subgroup multisignatures (extended abstract). In Proceedings of CCS 2001, pages 245–54. ACM Press, 2001.
20. S. Micali and R. Rivest. Transitive signature schemes. In Proceedings of RSA 2002,
volume 2271 of LNCS, pages 236–43. Springer-Verlag, 2002.
21. A. Miyaji, M. Nakabayashi, and S. Takano. New explicit conditions of elliptic
curve traces for FR-reduction. IEICE Trans. Fundamentals, E84-A(5):1234–43,
May 2001.
22. M. Naor. Deniable ring authentication. In Proceedings of Crypto 2002, volume
2442 of LNCS, pages 481–98. Springer-Verlag, 2002.
23. K. Ohta and T. Okamoto. Multisignature schemes secure against active insider
attacks. IEICE Trans. Fundamentals, E82-A(1):21–31, 1999.
24. T. Okamoto. A digital multisignature scheme using bijective public-key cryptosystems. ACM Trans. Computer Systems, 6(4):432–441, 1998.
25. T. Okamoto and D. Pointcheval. The gap problems: A new class of problems for
the security of cryptographic primitives. In Proceedings of PKC 2001, volume 1992
of LNCS, pages 104–118. Springer-Verlag, 2001.
26. G. Poupard and J. Stern. Fair encryption of RSA keys. In Proceedings of Eurocrypt
2000, volume 1807 of LNCS, pages 172–89. Springer-Verlag, 2000.
27. R. Rivest, A. Shamir, and Y. Tauman. How to leak a secret. In Proceedings of
Asiacrypt 2001, volume 2248 of LNCS, pages 552–65. Springer-Verlag, 2001.
28. F. Zhang and K. Kim. ID-based blind signature and ring signature from pairings.
In Proceedings of Asiacrypt 2002, volume 2501 of LNCS, pages 533–47. SpringerVerlag, 2002.

