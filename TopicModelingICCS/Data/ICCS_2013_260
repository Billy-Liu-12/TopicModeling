Available online at www.sciencedirect.com

Procedia Computer Science 18 (2013) 702 – 711

International Conference on Computational Science, ICCS 2013

Improving communication patterns for distributed cluster-based
individual-oriented ﬁsh school simulations
Roberto Solara , Francisco Borgesa,∗, Remo Suppia , Emilio Luquea
a Department

of Computer Architecture & Operating Systems Universitat Autonoma de Barcelona, Bellaterra,08193, Barcelona, Spain

Abstract
Parallel discrete event simulation (PDES) have shown to be an useful paradigm for simulating complex and large-scale
models. An individual-oriented approach allows modelers capture complex emerging global behaviors generated by simple
local interaction, like observed in self-organized systems. Usually, this type of simulations are highly expensive in terms of
computing and communications. One one hand, we can reduce the computing involved in individual interactions by means
of developing a robust partitioning method. On the other hand, we have to be able to eﬃciently handle a huge number
of individuals interacting with other individuals stored in memory of remote processors. In this work we will analyze and
compare three communication strategies: synchronous and asynchronous message passing (via MPI) and bulk-synchronous
parallel (BSP) for our distributed cluster-based individual-oriented ﬁsh school simulator. In this type of simulations, the main
contributions of our work are: a) we showed that distributed time-driven simulations do not always improve the performance
when using synchronous communication strategies, b) we show asynchronous communications strategies are more eﬃcient.
In addition, we have veriﬁed that the bulk-synchronous parallel method is a scalable.
Keywords: parallel distributed simulation, individual-oriented models, data clustering, ﬁsh schooling, high performance
distributed simulation;

1. Introduction
Ecologists have been using discrete models to study global patterns that emerge through local interaction
by computational simulation. Individual-oriented modeling is a powerful tool to understand the functionality of
complex systems in which system-level properties emerge from individual-level interaction. Individual-oriented
systems can be seen in many research areas such as: ecology and biology [1],[2],[3],[4],[5], military strategies [6],
sociology [7],[8],[9], physics [10],[11], health care [12], vehicular traﬃc [13], ﬁre suppression strategies [14], etc.
There are two strategies for modeling population dynamics: equation-oriented and individual-oriented modeling. In equation-oriented models, system-level properties are obtained by solving or evaluating a set of math
equations (e.g. Lotka-Volterra equations, also known as prey-predator equations). In individual-oriented models,
system-level properties emerge from individual-level interaction, i.e. local interaction between individuals implicitly spreads information through the system producing an emergent phenomena. Nevertheless, it is very diﬃcult to
analytically solve an individual-oriented model whereby it is necessary using computing simulation for observing
how the system under study evolves over time.
∗ Corresponding

author. Tel.: +34-93-581-1990 / 2198.
E-mail address: francisco.borges@caos.uab.es (Francisco Borges).

1877-0509 © 2013 The Authors. Published by Elsevier B.V. Open access under CC BY-NC-ND license.
Selection and peer review under responsibility of the organizers of the 2013 International Conference on Computational Science
doi:10.1016/j.procs.2013.05.234

Roberto Solar et al. / Procedia Computer Science 18 (2013) 702 – 711

Over the last years, we have identiﬁed two key factors that may aﬀect the individual-oriented simulations
performance. On one hand, the level of complexity of models - close-to-reality models require high computing
power for evaluating interaction between individuals. On the other hand, the workload - large-scale simulations
require a huge memory space for storing individuals. Now, distributed environments provide to us the hardware
and software to develop models as close to reality as possible and execute large-scale simulations. Nevertheless,
as we increase the number of processors in order to obtain faster simulation results, the network it becomes a
bottleneck. The number of processors increasing produces an execution time decreasing but also produces negative
eﬀects in communication times. Therefore, it is necessary establishing eﬃcient communication strategies in order
to reduce the communication times and, consequently, obtaining a gain in terms of speedup close to linear.
During the last few years, we have been researching about individual-oriented models in high performance
time-driven simulation with the purpose of decreasing the total execution time and ,consequently, providing closeto-reality simulation results. As show [3], we had developed a distributed ﬁsh school simulator based on a complex
model in order to understand how increasing the level of complexity of models aﬀects to the performance of the
distributed simulation. After that, our group has improved the scalability of our distributed ﬁsh school simulator
by means of a cluster-based partitioning method [15]. Our group has developed a robust cluster-based partitioning method by using of covering radius criterion and Voronoi diagrams. Our partitioning method decreased the
sequential algorithm complexity from O(n2 ) to O(nm). Furthermore, one of the main features of our partitioning method is to limit the interaction between individuals that are far away from each other and, consequently,
decreasing the required computing. In addition [16], we have presented a proximity load balancing strategy for
our distributed cluster-based individual-oriented simulator. We have used a proximity criterion in order to distribute individuals on the distributed architecture. The proximity load balancing strategy was proposed in order to
maintain the distributed simulation performance as the time progresses.
All previous experiments have shown that our simulator achieves good speedup, scalability and a decreased
computing time. However an important question has arisen regarding our simulator: is it eﬃcient? We believe
we can improving the eﬃciency in our distributed simulator. Communication has been a problem in our ﬁsh
schooling simulator because it is a communication-consumer parallel application. Therefore, we have to decrease
the communication time between processors to get more eﬃcient results. In this way we should understand and
analyze communication in time-driven simulations. Then, which is the best communication strategy in time-driven
simulation? Asynchronous, synchronous or both? These are the questions that lead this work.
In this paper we will compare three communication strategies that were implemented in our time-driven simulator: asynchronous and synchronous message passing and bulk-synchronous parallel. Our ﬁrst distributed
individual-oriented simulator was developed by using an asynchronous communication strategy. All previous
works shown in section 2 were developed by using this strategy. We will also evaluate the synchronous communication strategy by using openMPI library and bulk-synchronous parallel by using BSPonMPI. We have noticed
that time-driven simulations tend to have synchronous behavior. BSPonMPI is widely used implementation of
bulk synchronous parallel (BSP) computing model. By reviewing the literature [17] [18] we have veriﬁed that
the BSP computing model can be an alternative to improve performance of parallel applications. Nevertheless,
in this ﬁrst stage we will only analyze communication features of the BSP model. Our distributed simulator is a
comunication-consumer application, so we will analyze how the communication of the BSP model can bring some
beneﬁt and how this communication strategy inﬂuences on our distributed simulation performance (e.g. scalability, eﬃciency, etc). That is why we will begin by analyzing communication strategies and we will not implement
the BSP model completely for now.
In subsection 2 we present an overview of individual-oriented models speciﬁcally our ﬁsh schooling simulator
and brief resume of previous contributions in distributed individual-oriented simulations. In section 3 we talk
about communications strategies and related works. The experimental results, analysis and comparison between
asynchronous and synchronous strategies are presented in section 4. Finally, in section 5 the conclusions and
future work are proposed.
2. Individual-oriented models
Using simulation, ecologist have used discrete models to understand, how global patterns emerge from individual interactions in ecosystems. These models called individual-oriented models (IoM) are developed in order to

703

704

Roberto Solar et al. / Procedia Computer Science 18 (2013) 702 – 711

understand the dynamic behavior of a system. These models consist of a ﬁxed number of autonomous individuals,
interaction rules, individual attributes, which are maintained through time, and an environment where interactions
occur.
Individual-oriented models also allow us to include diﬀerent types of individuals within the same model, to
deﬁne individuals with two levels of heterogeneity (behavioral rules and attributes values), to model interactions
between individuals and its environment and to represent learning mechanisms. Some individual-oriented models
are also spatially-explicit, i.e. the individuals are associated with a location in geometrical space. Furthermore,
some spatially-explicit individual-oriented models can also show motion patterns, i.e. the individuals can change
their relative position in geometrical space. There are many studies of spatially-explicit individual-oriented simulation in the literature thus far, such as: bird ﬂocks [2] [19], insect swarms [20] [21][14], mammal herds [22] and
ﬁsh schools [23] [24] [25] [26] [27].
2.1. Fish school model and the simulator
Our distributed cluster-based individual-oriented ﬁsh schooling simulator is based on the biological model
described in [23] and [1]. Fish Schools are one of the most frequent social groups in the animal world [23].
This social aggregation shows complex emergent properties, such as: strong group cohesion and high level of
synchronization. In order to describe the ﬁsh behavior the model considers that each ﬁsh changes its position and
orientation in discrete step of time (time-driven simulation) and the new ﬁsh’s position and orientation depends
on the position and orientation of a ﬁxed number of nearest-neighbors. The neighbor’s inﬂuence on a single ﬁsh
depends on its space-time position. In order to select appropriately the neighbors’s inﬂuence the model identiﬁes
three vision areas: attraction, repulsion and parallel orientation, see Figure 1.

Fig. 1. Neighbor inﬂuences areas.

Depending on the spatial-temporal position of its neighbors, the ﬁsh chooses between three behavior patterns:
repulsion - collision avoidance between ﬁsh of the same group (turning the ﬁsh’s orientation minimum-angle
rotation so the ﬁsh’s orientation and its neighbor’s orientation are perpendicular, Figure 2(a)), parallel orientation
- the group moves in the same direction (matching the ﬁsh’s orientation with its neighbor’s orientation, Figure
2(b)) and attraction - to maintain the cohesion of the group (steering the ﬁsh’s orientation towards its neighbor’s
position, Figure 2(c)).

Fig. 2. (a) Repulsion behavior pattern. (b) Parallel orientation behavior pattern. (c) Attraction behavior pattern.

2.2. High performance parallel simulation
During the last few years, we have been researching in the area of high performance simulation with purpose of
providing faster simulation results for individual-oriented models. We think we have made important contributions

Roberto Solar et al. / Procedia Computer Science 18 (2013) 702 – 711

705

in this speciﬁc area. In [3] we have presented comparative results of two versions of a distributed individualoriented ﬁsh school simulator: a basic model - based on the Huth and Wissel model, and, an enhanced model based on the Huth and Wissel model including external inﬂuences, such as: prey-predator interaction, cylindrical
obstacles and an environment description. In this work we were able to demonstrate how a model’s level of
complexity increasing can provide us: scalability (close to ideal speedup) and close-to-reality simulation results.
Furthermore, we noticed that a development of low-level abstraction models in order to provide a close-to-reality
point of view of the system under study. Simulation results are important when we are trying to understand the
behavior of some specie under speciﬁc circumstances, such as: the behavior of a ﬁsh school during predator
attacks.
In [15], we have presented a cluster-based partitioning approach focused on solving spatially-explicit individualoriented simulations. Distributing individuals through the architecture is an important problem in distributed simulation. Individual-oriented systems can be implemented in a distributed fashion by making each node responsible
for a ﬁxed portion of the problem domain. This ﬁxed portion can be assigned using either a grid-based or a clusterbased approach. The cluster-based approach consists of assigning each node a ﬁxed set of individuals. Each set can
be determined by individuals grouping into clusters of similar/near members. Similarity is determined according
to a distance measure.
Our approach was based on strategies for partitioning a metric space, such as: Voronoi diagrams and covering
radius criterion. Given some number of objects in the space, their Voronoi diagram divides the space according to
the nearest-neighbor rule [28]. The covering radius criterion consists of trying to bound the area by considering a
sphere centered that contains all the objects of the problem domain that lie in the area [29]. Our idea is formulated
on the basis of the following preconditions: individuals are associated with a position in the three-dimensional
euclidean space and the vision sensor is modeled by the euclidean distance. Therefore, meeting both preconditions implies generating a metric space. This allow us introducing concepts of similarity or proximity within
the distributed spatially-explicit individual-oriented simulation. Our partitioning method has helped to reduce the
interaction between individuals that are too far away. We deﬁne the cluster radius in function of the maximum
ﬁsh vision area so that individuals belonging to a cluster only interact with individuals belonging to their nearestneighbors clusters. Besides that we have proved that employing a robust partitioning method we can obtain either
a sequential and distributed execution times reduction.
In [16], we dealt with the motion patterns of the ﬁsh school model and its inﬂuence over our distributed
simulation. We have presented a dynamic load balancing strategy for our distributed cluster-based individualoriented ﬁsh school simulator. Our load balancing strategy was based on re-conﬁgurating and re-distributing the
local workload. The re-conﬁguration process consists of re-grouping clusters into meta-clusters with size close to
the mean. Experimentally, we have increased the number of individuals proportional to the number of processors
in order to show how our load balancing method works in diﬀerent scenarios. Furthermore, we have shown how
our proximity load balancing dynamically adjusts the workload as the simulation progresses. Main conclusion of
this work is demonstrating that it is possible improving the performance of our distributed simulations by means
of a dynamic load balancing strategy.
3. Asynchronous and synchronous communication
An important issue in discrete simulation is the mechanism in which the state variables change as simulation
time evolves. There are two types of time-advance approaches: and event-driven. Time-driven approach consists
of dividing the simulation time in a sequence of equal-sized steps, and the simulation clock is advanced from
one time step to the next[30]. Event-driven approach consists of increasing the simulation clock when a event is
processed. Events are marked with a timestamp and the simulation clock is advanced from a timestamp to the
next. Furthermore, it is necessary to consider the time management protocol because this will ensure that the
execution of the distributed simulation is properly synchronized.
Time management algorithms can be classiﬁed into conservative and optimistic [30]. In conservative algorithms, the process is blocked until all execution conditions are satisﬁed. In optimistic algorithms, the process
will continue even if some execution condition is not fulﬁlled. Usually, optimistic algorithms include mechanisms
which allow to recover from causality issues (e.g. rollbacks).

706

Roberto Solar et al. / Procedia Computer Science 18 (2013) 702 – 711

We have implemented a time-driven time-advance mechanism because the individual-oriented model used in
this work describes the motion of a ﬁsh school in discrete time steps, i.e. each ﬁsh moves at the same time. Furthermore, we implement a conservative time-management protocol because each logical process requires exchanging
information from adjacent logical processes before starting the next simulation step.
Typically, in PDES, the kernel of simulation is the Logical Process (LP). In our distributed simulations, each
LP uses an independent-implemented communication layer responsible for individuals’ exchanging between LPs.
Communication routines, such as: distribution, migration and neighbors exchanging are developed on the basis of
this communication layer. We have implemented three communication strategies: synchronous and asynchronous
message passing and bulk-synchronous parallel. Another important feature of our simulator is that all individual
execute similar operations in each steps.
3.1. Asynchronous and synchronous MPI strategy
The MPI library has point-to-point communication routines that enable the programmer to use asynchronous
and synchronous communication patterns. The fundamental diﬀerence between these two strategies is that asynchronous has non-blocking execution while synchronous has blocking execution. The blocking operations have a
strong impact in communication time. When process A wants to send a message in synchronous mode to process
B, for example, the process A has to wait until the process B is ready to receive the message. The process A will
return after the message sent has been received by process B. On the other hand, non-blocking sends operations
returns immediately, which allows process to continue doing computations while communication with another
process is still pending. In this it is way, it is possible that computations and communications are overlapped.
In synchronous communication when a process sends a data the other process have to be ready to receive the
data, so the Send and Receive functions should be executed in short time-slices otherwise the solution will waste
time waiting. In time-driven simulation is important that all processors have the same workload in order to all
processors reach the synchronization barrier together. In fact, time-driven simulations with conservative timemanagement algorithms have a synchronization barrier in each simulation step. This suggest that the synchronous
MPI and BSP communication would be more eﬃcient.
3.2. Bulk-synchronous parallel strategy
There are a lot of BSP implementation but we use BSPonMPI because it is a small communications library
for bulk-synchronous parallel programming which consists of only 20 basic operations on top of MPI. The BSP
computing model decouples communication and synchronization. A BSP computation consists of a sequence of
parallel supersteps. Each superstep is subdivided into three ordered phases consisting of[18] [17]:
• simultaneous local computation in each process, using only values stored in the memory of its processor;
• communication actions amongst the processes, causing transfers of data between processors; and
• a synchronization barrier, which waits for all of the communication actions are completed, and then makes
any data transferred visible in the local memories of the destination processes.
The BSP model allows the cost of program to be determined. A BSP program is composed by a lot of
supersteps and each one is the sum of three terms: the maximum cost of the local computations on each processor,
the cost of the global communication, and the cost of the synchronization barrier at the end of the superstep. So,
the standard cost model can be deﬁned by:
cost o f superstep = w + hg + l

(1)

where w is a maximum over computation times, and the synchronization barrier must wait for the slowest
process; g is total number of local operations performed by all processors by total number of words delivered by
the communications network; h is a maximum over fan-in and fan-out of data; and and l is the synchronization
overhead. Other cost models are shown in [17].
The BSP computation model has an important characteristic: it does not deﬁne how the communication and
computing have to be implemented. The library that implement BSP will be responsible to deﬁne how to do the
implementation of communication and computing.

707

Roberto Solar et al. / Procedia Computer Science 18 (2013) 702 – 711

MPI and BSP paradigms were designed for the development of scalable and portable parallel applications.
In [18] is considered that the MPI’s huge library makes eﬃcient implementation far more problematic. On the
other hand, BSP is more concise and consistent; this is why it is more easy to develop eﬃcient parallel programs.
Furthermore, BSP exposes a simple cost model (see eq. 1) for the transmission of bulked messages.
The MPI communication routines used in this work are based on pairwise sends and receives. Deadlocks in
synchronous routines are possible and have to be treated because this solution does not provide a message buﬀer.
In asynchronous communication routines it is possible to do computing while a process is receiving a message,
but it is necessary to treat the race condition. In the BSP model explicit receives are not necessary because a
synchronization barrier implies the end of all communication operations. However the data is available to process
after the synchronization process has ﬁnalized.
4. Experimental results
The execution environment used for testing our distributed simulator has the following characteristics: Cluster
IBM - 32 nodes 2 x dual-core Intel(R) Xeon(R) CPU 5160@ 3.00GHz, 12GB fully buﬀered DIMM, Integrated
dual Gigabit Ethernet and hot-swap SAS controller Disk. Experimental results were obtained from the average
of 250 simulation steps. The simulator was developed by using C++ (gcc 4.3.2), STL (c++ standard template
library), MPI namespace (openmpi 1.4.1) and BSPonMPI (v0.2).
The simulation experiments were carried out by using 1, 2, 4, 8, 16, 32 and 64 cores. The data input were
formed by three ﬁles containing 131.072, 262.144 and 524.288 individuals. These input data were synthetically
generated using a uniform distribution and ﬁltered by a function that gives them a spatial distribution of a ﬁsh
school. This adaptation is necessary to adapt the input and obtain data group cohesion in all experiments. In
relation to the output data and validation between the three algorithms, we have used a replication method to
generate output data and relative values of the magnitudes under study.
Dynamic load balancing strategy is invoked depending on the following load imbalance thresholds: 10%,
20%, 30%, 40% and 50%. Experimental results help us to choose which is the best conﬁguration (load imbalance
threshold) that we will use for analyzing communication strategies. The dynamic load balancing algorithm used
in this work was implemented in [16]. This algorithm deﬁnes T as the load imbalance threshold. The number of
individuals per core is bounded by:
MIN = MEAN ∗ (1 − T )

(2)

MAX = MEAN ∗ (1 + T )

(3)

and

, where
MEAN = Ni/Nc(number of individuals/number of cores)

(4)

If the number of individuals stored in a speciﬁc core is out of bounds then the load balance algorithm is
invoked. So, when we say load imbalance threshold is equal to 30% it means T = 30%.
We have implemented three diﬀerent communication layers: asynchronous and synchronous message passing
(via MPI) and bulk-synchronous parallel.
We can see in Fig. 3, there are variations in terms of communication times for the same communication
strategy by means of using diﬀerent load imbalance thresholds. In the following analysis we have considered
a 10% as load imbalance threshold. Fig. 3 shows that the asynchronous communication strategy has the best
performance in terms of communication times in comparison with other.
In Fig. 4, we can not observe variation in term of speedup for all communication strategies by using from 2 to
8 cores. On the other hand, there are more signiﬁcant speedup variations in terms of communication times for all
communication strategies by using 32 and 64 cores. These variations are a result of the amount of communication
between LPs. Furthermore, the eﬃciency and behavior of each communication strategies are more evident. In the
asynchronous communication strategy almost all processors have higher speedup. Thus, interesting behaviors can
be seen in the BSP communication strategy. We can verify that the BSP communication strategy tends to increase

708

Roberto Solar et al. / Procedia Computer Science 18 (2013) 702 – 711

Fig. 3. (a) Communication time: load balance x number of ﬁshes x communication strategies (32 cores); (b) Communication time: load
balance x number of ﬁshes x communication strategies (64 cores).

the speedup by using 32 and 64 cores with workloads of 262.144 and 524.288 individuals. Consequently, we
believe that if we increase the number of individuals by using 32 and 64 cores the BSP communication strategy
will be able to give us an acceptable total execution times. Additionally, when the simulation is performed with
524.288 individuals, the BSP gain in terms of speedup is similar to the asynchronous speedup by using 32 cores.
Moreover, Fig. 4 conﬁrms that our distributed simulator is scalable because the speedups of the communication
strategies: asynchronous, synchronous BSP, and synchronous MPI were, respectively, 23.54, 21.60 and 20.79
by means of using 64 cores and 523.288 individuals. Besides that we can see the scalability of simulator into
BSP strategy by using 64 cores with workloads of 131.072, 262.144 and 523.288 individuals, its speedups were,
respectively 12.39, 16.30 and 21.60.

Fig. 4. Speedup of each communication strategy in diﬀerent contexts. Each data set that has diﬀerent number of ﬁshes was executed in varied
number of cores.

The Fig. 5 and Fig. 6 show the computing time and communication time of each communication strategies
by using 16, 32 and 64 cores with workloads of 131.072, 262.144 and 524.288 individuals and load imbalance
factor of 10%. It is easy to understand the gain in terms of speedup when we analyze the relation between
computing and communication, see Fig.5 and Fig.6. We have developed a distributed simulator in order to solve
large-scale models. It has no sense analyzing communication strategies when we are using a reduced number
of cores because it does not give us relevant information. Therefore, we only will show experimental results by
using 16, 32 and 64 cores. Experimental results show that the computing time obtained by using a asynchronous
communication strategy is higher than the other communication strategies. If this it occurs, then the synchronous

Roberto Solar et al. / Procedia Computer Science 18 (2013) 702 – 711

message passing and BSP strategies would be a viable solution if we could decrease communication time of
these strategies. In asynchronous communication strategy we can observe that computing times tend to increase
whereas communication times tend to decrease. On the other hand, the computing times of the synchronous
message passing and the BSP strategies tends to stabilize whereas communication times tend to increase as the
number of ﬁsh and cores are incremented.

Fig. 5. (a) Computing time and communication time x communication strategies (131.072 ﬁshes and load balance factor 10%); (b) Computing
time and communication time x communication strategies (262.144 ﬁshes and load balance factor 10%)

Fig. 6. Computing time and communication time x communication strategies (524.288 ﬁshes and load balance factor 10%).

Clearly, in Fig. 5 and Fig. 6 we can see that large-scale simulations require higher communication usage.
Both ﬁgures show that as the number of individuals is increased, communication times are more expensive. As
example, the communication time of the synchronous message passing strategy by using 64 cores with workloads
of 131.072, 262.144 and 523.288 individuals were 441.38, 474.76 and 561.56 seconds respectively.
Fig. 5 and Fig. 6 show how the communication strategy impacts on the global simulation performance. The
synchronous communication strategies decrease the computing time. We can think that synchronous communication strategies are the solution to decrease the total simulation time. But, in view of complexity inside logical
process what it is gained in computing is lost in communication. The computing time in asynchronous communication strategy is the higher in comparison with other communication strategies. On the other hand, the cost
in terms of communication time is the lowest. In synchronous communication strategies we have a set of communication barriers. It could suggests that synchronous communication strategies show a good performance and
the asynchronous communication strategy could be discarded. Indeed the synchronous communication strategies
reduce the computing time in comparison to asynchronous strategy, however what it gains in computing time is

709

710

Roberto Solar et al. / Procedia Computer Science 18 (2013) 702 – 711

what it loses in communication time because the simulation is very heterogeneous and complex. Our simulation
has a high complexity, so it prejudice the eﬃciency of synchronous communication strategies and the gained performance. Despite that the time-driven simulation has a synchronous behavior the synchronous communication
strategies shown results are not the most appropriate.
In other words, the synchronous communication strategies have a better performance in terms of computing
times, but higher communication times in comparison to asynchronous communication strategies. As a consequence of the previously described, the asynchronous communication strategy has a better performance in terms
of total execution times in comparison to synchronous message passing and BSP. The improvements to the asynchronous method, after in-depth analysis of the simulator code, come from the waiting-time reduction that occurs
in those processes that are highly balanced in workload and belong to the same meta-cluster.
5. Conclusions
Many researchers in application areas, as ecology, biology and physics for example, claim by more realistic
simulations. Using distributed parallel simulation to create more complex models to achieve simulation results
closest to reality is a possible solution. Furthermore, these simulations have to be eﬃcient to get faster simulation
results. Thus, in this work, we have analyzed and compared three communication strategies implemented in our
distributed cluster-based individual-oriented ﬁsh schooling simulator: asynchronous and synchronous message
passing (via MPI) and bulk-synchronous parallel. This article is intended as a contribution toward this goal. The
main conclusions that can be extracted are:
• We showed that time-driven simulations do not always increase the performance by using synchronous
communication strategies. Many researchers believe that the synchronous communication strategies are
more appropriate for time-driven simulations because it has a synchronous behavior. The results show
that synchronous communication has worse performance in terms of execution times in comparison to
asynchronous communication strategy. Despite that the time-driven simulation has a synchronous behavior
we have shown that synchronous communication strategy is not the most appropriate.
Considering that, time-driven simulations by using conservative time-management algorithms have a barrier
in each simulation step it could be suggested that synchronous MPI and BSP would be more eﬃcient. If all
of the cores did the same quantity of computing the synchronous communication strategies would be more
eﬃcient. Because the time-slice between send and receive would be lower.
• In addition we have observed that asynchronous communication strategy increases the computing time
because of the management communication protocol. On the other hand, we can observe that the communication time decrease. However the total execution time in asynchronous communication strategy is lower
than the total execution time with the synchronous communication strategies. Therefore we can observe the
eﬃciency of the asynchronous communication strategy in this type of simulations.
• We could verify that bulk-synchronous parallel strategy tends to gain speedup when resources, such as:
number of cores and number of ﬁshes are increased. This strategy have shown to be scalable in time-driven
simulations.
5.1. Future work
The main objectives for future work are:
• The experiments have shown that the bulk-synchronous parallel strategy is scalable. For this reason, we
believe that full implementation of the BSP model can bring better results if it is associated with load
balance of computing between processors.
• Increasing performance of our simulator using hybrid programing. A lot of ﬁshes are in the same processors
but the communication between them occurs via MPI. In this case OpenMP operations would decrease
communication time and computing time.

Roberto Solar et al. / Procedia Computer Science 18 (2013) 702 – 711

711

Acknowledgements
This research has been supported by the MICINN Spain under contract TIN2007-64974 and the MINECO
(MICINN) Spain under contract TIN2011-24384.
References
[1] A. Huth, C. Wissel, The simulation of ﬁsh schools in comparison with experimental data, Ecological Modelling 75-76 (1994) 135 – 146,
state-of-the-Art in Ecological Modelling proceedings of ISEM’s 8th International Conference.
[2] C. W. Reynolds, Flocks, herds and schools: A distributed behavioral model, SIGGRAPH Comput. Graph. 21 (1987) 25–34.
[3] R. Solar, R. Suppi, E. Luque, High performance individual-oriented simulation using complex models, Procedia Computer Science 1 (1)
(2010) 447 – 456, iCCS 2010.
[4] R. Suppi, P. Munt, E. Luque, Using pdes to simulate individual-oriented models in ecology: A case study, in: Proceedings of the
International Conference on Computational Science-Part I, ICCS ’02, Springer-Verlag, London, UK, 2002, pp. 107–116.
[5] B. Zhou, S. Zhou, Parallel simulation of group behaviors, in: Proceedings of the 36th conference on Winter simulation, WSC ’04, Winter
Simulation Conference, 2004, pp. 364–370.
[6] J. J. Corner, G. B. Lamont, Parallel simulation of uav swarm scenarios, in: Proceedings of the 36th conference on Winter simulation,
WSC ’04, Winter Simulation Conference, 2004, pp. 355–363.
[7] G. Vigueras, M. Lozano, J. Ordua, Workload balancing in distributed crowd simulations: the partitioning method, The Journal of
Supercomputing (2009) 1–9.
[8] Y. Wang, M. Lees, W. Cai, S. Zhou, M. Low, Cluster based partitioning for agent-based crowd simulations, in: Winter Simulation
Conference (WSC), Proceedings of the 2009, 2009, pp. 1047 –1058.
[9] M. J. Quinn, R. A. Metoyer, K. Hunter-zaworski, Parallel implementation of the social forces model, in: Proceedings of the Second
International Conference in Pedestrian and Evacuation Dynamics, 2003, pp. 63–74.
[10] M. A. Stijnman, R. H. Bisseling, G. T. Barkema, Partitioning 3d space for parallel many-particle simulations, Computer Physics Comm
149 (2003) 121–134.
[11] Y. M. Marzouk, A. F. Ghoniem, K-means clustering for optimal partitioning and dynamic load balancing of parallel hierarchical n-body
simulations, J. Comput. Phys. 207 (2005) 493–528.
[12] D. M. Rao, A. Chernyakhovsky, Parallel simulation of the global epidemiology of avian inﬂuenza, in: Proceedings of the 40th Conference
on Winter Simulation, WSC ’08, Winter Simulation Conference, 2008, pp. 1583–1591.
[13] S. B. Yoginath, K. S. Perumalla, Parallel vehicular traﬃc simulation using reverse computation-based optimistic execution, in: Proceedings of the 22nd Workshop on Principles of Advanced and Distributed Simulation, PADS ’08, IEEE Computer Society, Washington, DC,
USA, 2008, pp. 33–42.
[14] X. Hu, Y. Sun, Agent-based modeling and simulation of wildland ﬁre suppression, in: Proceedings of the 39th conference on Winter
simulation: 40 years! The best is yet to come, WSC ’07, IEEE Press, Piscataway, NJ, USA, 2007, pp. 1275–1283.
[15] R. Solar, R. Suppi, E. Luque, High performance distributed cluster-based individual-oriented ﬁsh school simulation., Procedia CS 4
(2011) 76–85.
[16] R. Solar, R. Suppi, E. Luque, Proximity load balancing for distributed cluster-based individual-oriented ﬁsh school simulations, Procedia
Computer Science 9 (0) (2012) 328 – 337, proceedings of the International Conference on Computational Science, ICCS 2012.
[17] D. B. Skillicorn, J. M. D. Hill, W. F. McColl, Questions and answers about bsp, in: Scientiﬁc Programming, Vol. 6, 1997, pp. 249–274.
[18] J. M. D. Hill, B. McColl, D. C. Stefanescu, M. W. Goudreau, K. Lang, S. B. Rao, T. Suel, T. Tsantilas, R. H. Bisseling, Bsplib: The bsp
programming library, Parallel Comput. 24 (14) (1998) 1947–1980.
[19] R. O. Saber, R. M. Murray, Flocking with obstacle avoidance: cooperation with limited communication in mobile networks, in: Decision
and Control, 2003. Proceedings. 42nd IEEE Conference on, Vol. 2, 2003, pp. 2022–2028 Vol.2.
[20] E. Bonabeau, M. Dorigo, G. Theraulaz, Swarm intelligence: from natural to artiﬁcial systems, Oxford University Press, Inc., New York,
NY, USA, 1999.
[21] J. Kennedy, R. C. Eberhart, Swarm intelligence, Morgan Kaufmann Publishers Inc., San Francisco, CA, USA, 2001.
[22] S. Gueron, S. Levin, D. Rubenstein, The dynamics of herds: From individuals to aggregations, Journal of Theoretical Biology 182 (1996)
85–98(14).
[23] A. Huth, C. Wissel, The simulation of the movement of ﬁsh schools, Journal of Theoretical Biology 156 (3) (1992) 365 – 385.
[24] I. Aoki, A simulation study on the schooling mechanism in ﬁsh, Bulletin of the Japanese Society of Scientiﬁc Fisheries 48 (8) (1982)
1081–1088.
[25] R. Vabø, G. Skaret, Emerging school structures and collective dynamics in spawning herring: A simulation study, Ecological Modelling
214 (2-4) (2008) 125–140.
[26] J. K. Parrish, S. V. Viscido, D. Grnbaum, Self-organized ﬁsh schools: An examination of emergent properties, Biol. Bull 202 (2002)
296–305.
[27] J. C. Gonzlez, C. Dalforno, R. Suppi, E. Luque, A fuzzy logic ﬁsh school model., in: ICCS, Vol. 5544 of Lecture Notes in Computer
Science, 2009, pp. 13–22.
[28] F. Aurenhammer, Voronoi diagrams - a survey of a fundamental geometric data structure, ACM Comput. Surv. 23 (1991) 345–405.
[29] E. Chavez, G. Navarro, An eﬀective clustering algorithm to index high dimensional metric spaces, in: Proceedings of the Seventh
International Symposium on String Processing Information Retrieval (SPIRE’00), IEEE Computer Society, Washington, DC, USA,
2000, pp. 75–.
[30] R. M. Fujimoto, Parallel and Distribution Simulation Systems, 1st Edition, John Wiley & Sons, Inc., New York, NY, USA, 1999.

