Procedia Computer Science
Volume 29, 2014, Pages 713–727
ICCS 2014. 14th International Conference on Computational Science

A computational science agenda for programming language
research
Dominic Orchard1 , Andrew Rice2
1
2

Computer Laboratory, University of Cambridge
dominic.orchard@cl.cam.ac.uk
Computer Laboratory, University of Cambridge
andrew.rice@cl.cam.ac.uk

Abstract
Scientiﬁc models are often expressed as large and complicated programs. These programs
embody numerous assumptions made by the developer (e.g., for diﬀerential equations, the
discretization strategy and resolution). The complexity and pervasiveness of these assumptions
means that often the only true description of the model is the software itself. This has led various
researchers to call for scientists to publish their source code along with their papers. We argue
that this is unlikely to be beneﬁcial since it is almost impossible to separate implementation
assumptions from the original scientiﬁc intent. Instead we advocate higher-level abstractions in
programming languages, coupled with lightweight veriﬁcation techniques such as speciﬁcation
and type systems. In this position paper, we suggest several novel techniques and outline an
evolutionary approach to applying these to existing and future models. One-dimensional heat
ﬂow is used as an example throughout.
Keywords: computational science, modelling, programming, veriﬁcation, reproducibility, abstractions,
type systems, language design

1

Introduction

With the increase in computer modelling in the sciences, programming languages are now
an important tool for expressing complex scientiﬁc theories. However, this use of computer
models has not changed the fundamental scientiﬁc method of hypothesis, prediction, experiment,
analysis, and reproduction [Var10]. Despite this immutability of the scientiﬁc method, computer
modelling has substantially increased the complexity of both prediction and reproduction. For
example, one might imagine the method applied to the question of one-dimensional heat ﬂow:
1. Hypothesis A researcher argues that the change in heat within an object can be related
to time and space by a particular (second-order) diﬀerential equation.
Selection and peer-review under responsibility of the Scientiﬁc Programme Committee of ICCS 2014
c The Authors. Published by Elsevier B.V.
doi:10.1016/j.procs.2014.05.064

713

A computational science agenda for programming language research Dominic Orchard, Andrew Rice

2. Prediction They implement a computer model which ﬁnds solutions to this equation
for particular initial conditions and parameters. A complex hypothesis with many factors
requires numerous design decisions (such as choice of numerical approximation algorithm).
3. Experiment They design an experiment involving heating a length of wire (perhaps)
and making temperature measurements at particular locations and times.
4. Analysis The experimental results are compared to the prediction.
5. Reproduction An independent researcher considers the whole process: does the prediction and model follow from the hypothesis? does the model correctly predict the results
of new experiments? do diﬀerent approximation approaches give the same conclusions?
Particular challenges in the implementation of the model (the prediction step) are to capture
all the aspects of the hypothesis and produce an implementation which expresses this intent
without bugs, false assumptions, or over-approximations. This becomes increasingly diﬃcult
as the complexity of the hypothesis increases. Any researcher attempting to reproduce these
results must tackle these challenges again to generate their own predictions. Sharing the source
code of the model does little to help since this also shares any implicit assumptions, overapproximations, and bugs. Thus, by reproducibility we mean the ability to independently valid
a theory, rather than to replicate results by rerunning a program (see discussion in [Dru09]).
In addition to the essential complexity introduced by a complex hypothesis, computer models
also suﬀer from accidental complexity. Accidental complexity can arise from many sources
such as complicated programming language syntax or performance optimisations introduced
by programmers. Programming language research attempts to reduce these complexities by
developing better tools for programmers. In this position paper, we focus on the beneﬁt of
high-level abstractions and speciﬁcations. These provide researchers with conﬁdence in the
correctness of their program and guarantee the correctness of speciﬁcations shared with others.
The forall construct of Fortran 95 (originating in High Performance Fortran [KKZ07]) is
an example of a beneﬁcial language abstraction. It abstracts a loop over an array’s domain but
restricts the programmer such that the loop body has no side eﬀects or output dependencies.
This aids veriﬁcation and performance (the forall body is data parallel). We believe that
much higher levels of abstraction are possible.
We introduce ﬁrst a simple example using one-dimensional heat ﬂow (Section 2.1) which
we use to draw attention to issues of correctness (Section 2.2) and code quality (Section 2.3).
To gain adoption in computational science, any potential solutions to these issues must also
integrate with existing software and working practices and so we envisage an evolutionary
approach beginning with existing programming languages. We have begun implementing some
examples of this in our free, open-source Fortran refactoring tool CamFort [OR13]. We give an
overview of this evolutionary approach (Section 3) and illustrate it with transformations of our
heat ﬂow example (Sections 3.1 and 3.2). Along with this, we propose programming concepts
for further research, which address the issues of Section 2.
These ideas have developed from our work with climate science researchers and we now hope
to engage the wider community in identifying opportunities and areas to investigate further.

2

Key issues in programming for computational science

We have seen two major classes of problem corresponding to correctness: either that of the
implementation or the conceptual model itself, and code quality: either in communicating
714

A computational science agenda for programming language research Dominic Orchard, Andrew Rice
integer
real, parameter
real, parameter
real, parameter
real, parameter
real, parameter
integer, parameter
integer, parameter
real, parameter

1
2
3
4
5
6
7
8
9

::
::
::
::
::
::
::
::
::

t, x
alpha = ...
tmax = ...
xmax = ...
dt
= ...
dx
= ...
nt = tmax/dt
nx = xmax/dx
r = alpha*dt/(dx*dx)

!
!
!
!
!
!
!
!

diffusion coefficient
end time
length of material
time resolution
space resolution
# of time steps
# of space steps
constant in solution

10

real :: h(1:nx), h_old(1:nx)
! heat function (discretised in space) at t and t-1
h
= 0
! initialise as cold
h(1) = 1
!
with one hot end
do t = 1, nt
h_old = h
forall (x = 2:(nx - 1)) h(x) = h_old(x) + r*(h_old(x-1) - 2*h_old(x) + h_old(x+1))
end do

11
12
13
14
15
16
17

Figure 1: Fortran program fragment approximating the one-dimensional heat equation

choices made by the programmer or in the possibility of reusing or extending the software.
These are best illustrated in practice, for which we use our introductory one-dimensional heat
ﬂow example as a case study throughout.

2.1

Case study: heat equation

The one-dimensional heat equation describes the rate of change of heat in a uniform medium. In
abstract form, the relationship between change in heat (energy) in time and space is speciﬁed:
∂2φ
∂φ
=α 2
∂t
∂x

(1)

where φ is the energy function (φ : space × time → energy) and α is the constant diﬀusion rate.
Using standard analytical techniques (e.g., Taylor series, mean value theorem), the following
provides a discrete approximation to the continuous form using a ﬁnite-diﬀerence scheme with
“Forward Time, Centered Space” (FTCS) (see [DDD91, Rec04]):
φtx = φt−1
+
x

αΔt t−1
(φ
− 2φt−1
+ φt−1
x
x−1 )
Δx2 x+1

(2)

where φtx is the energy at the discrete time position t and location x, and Δt and Δx are the
discrete time and space steps. Figure 1 shows a Fortran implementation calculating φtx at time
tmax. Lines 11-13 deﬁne the discrete heat functions φt and φt−1 as h and h old. The outer
loop (line 14-) iterates over the discretised time dimension and the inner loop, written using
forall (line 16), iterates over the discretised spatial dimension, computing equation (2). The
outer loop cannot be expressed using forall since it includes a stateful operation (line 15),
updating h old with the values in h from the previous temporal iteration.

2.2

Questions of correctness: veriﬁcation and validation

Programming errors are a well known problem in computational science (and programming in
general) and can have a signiﬁcant negative impact. In one case, a research group in structural
biology retracted ﬁve papers (three published in Science) due to a single programming error
715

A computational science agenda for programming language research Dominic Orchard, Andrew Rice

which invalidated their results [CRR+ 06, Mer10]. As predictions from models are increasingly
used to direct social and environmental policy, correctness is not just an abstract concern
for researchers. High-assurance models are also important for public conﬁdence in science-led
decision making (see, e.g., the “ClimateGate” incident where leaked e-mails showing scientists’
own lack of conﬁdence in their programming sparked a credibility debate [Mer10]).
Model veriﬁcation is the process of checking that an implementation is free from programming errors. This is a necessary step before model validation– the process of checking a model’s
correspondence to empirical results [OR10]. Without proper veriﬁcation, it may be unclear
whether incorrect results are due to an invalid model or program errors, or both. Even worse
are results which appear correct due to program errors compensating for an invalid model.
Example sources of error Our example contains a variety of error-prone constructions.
Firstly, the various indexing operations are a common source of low-level error, such as incorrectly specifying iteration spaces (e.g., 1:nx instead of 2:(nx-1), line 16). Notably in Fortran,
iteration spaces cannot be easily abstracted thus there is no way to reduce the number of points
where these errors could be introduced.
The risk of such errors grows with programs involving multiple, multi-dimensional arrays,
such as in this fragment from a Navier-Stokes ﬂuid simulator (based on Griebel et al. [GDN97]):
duvdy = ((v(i,j)+v(i+1,j))*(u(i,j)+u(i,j+1)) + gam*abs(v(i,j)+v(i+1,j))*(u(i,j)-u(i,j+1))(v(i,j-1)+v(i+1,j-1))*(u(i,j-1)+u(i,j)) - gam*abs(v(i,j-1)+v(i+1,j-1))*(u(i,j-1)-u(i,j)))

Such code is at risk from errors such as permuting index or array variable names (e.g., writing
i instead of j) or using the wrong oﬀset (e.g., i-1 instead of i+1). These kinds of error may
manifest as obviously incorrect results (if the data can be easily observed and analysed) but
sometimes the eﬀect is more subtle.
Secondly, the use of state is prone to error. For example, exchanging the heat function in
the previous time step for the current (line 15) is a stateful computation; if instead h = h old
is written, then the calculation stays in the initial state. Such problems worsen with the use of
parallelism and as implementations grow in size.
Our example program also exploits implicit truncation of reals to integers (line 7-8) and
assumptions about the relative magnitude of time and space step-sizes (line 9), both of which
are possible sources of data error.
Approaches to veriﬁcation The need for more rigorous veriﬁcation strategies in science is
well known [OR10]. Usually the responsibility is placed on the scientist but extra support is
needed from our languages and tools since “diligence and alertness” are not enough [PV05].
Programming language research has had success in reducing programmer responsibility by automatically preventing various errors at compile time. For example, type systems has been used
to aid program veriﬁcation by recognising and rejecting large classes of programming errors, see
e.g., [She05, SV07]. These techniques are relatively simple from a user perspective, compared
with more heavyweight approaches using automated theorem provers and proof assistants (e.g.,
Coq). Functional programming languages currently lead the way in type system expressivity.
Many languages (C, Fortran, Java) used by scientists already beneﬁt from some use of types
as a simple check on a programs consistency (e.g., multiplying two strings is a type error). These
type systems give a basic speciﬁcation of what is computed by a program (e.g., a ﬂoatingpoint number from ﬂoating-point parameters). Some more advanced ideas from functional
programming have been adopted in object-oriented languages (for example, the addition of
716

A computational science agenda for programming language research Dominic Orchard, Andrew Rice

generics in Java, providing parametric polymorphism). We later outline how other ideas from
type theory might be incorporated to tackle the speciﬁc needs of scientiﬁc code.
Since many languages do not have a formal semantics, it is diﬃcult to formally prove larger
correctness results. However, veriﬁcation techniques can be combined with testing to increase
conﬁdence. There has been research in the programming language community on automatically
generating tests, reducing the burden on the programmer, for example QuickCheck [CH00].
Again, these techniques have not yet crossed over into computational science.

2.3

Conﬂating concerns and over-commitment

Many computer models consist of three conceptual aspects:
1. an abstract mathematical model (e.g., a system of partial diﬀerential equations);
2. a solution strategy (e.g., discretisation and approximation);
3. an implementation of this strategy (e.g., concrete, iterative code over arrays).
In many instances these three aspects are heavily intertwined. This obscures the original intent
of the model/scientiﬁc theory, which becomes distributed throughout a program and obfuscated
by implementation assumptions and choices. This hinders understanding, reﬁnement, validation, and veriﬁcation (where invalid models and programming errors are indistinguishable).
Our heat ﬂow program is highly specialised to the dimensionality of the problem, the solution
method, boundary values, and the topology and size of a particular instance. There are several
choices about initialisation and boundaries (lines 12-13, 16), with a Dirichlet boundary either
end of the array’s extent (1 at h(1) and 0 at h(nx)). It does not easily extend to multipledimensions, e.g., to the two-dimensional heat equations, without rewriting both the outer and
inner loops. It is also notable that the original diﬀerential equation (the intent of the model)
is completely absent as is the mathematical analysis which lead to the discrete approximation.
All of these issues arise because of the conﬂation of the three conceptual aspects above.
Imperative programming languages such as C and Fortran closely match their execution
to sequential (non-parallel) hardware, rather than a more abstract, declarative description of
a computation. This makes it diﬃcult to convert programs to new architectures (e.g., heterogeneous, parallel systems) and thus to exploit their full performance beneﬁts. Programs
may be rewritten to target a particular architecture. For example, OpenMP extensions can
be used for shared-memory parallelism, requiring only lightweight program annotation [DM98].
Other parallelisation strategies require more signiﬁcant rewrites to the program, for example
a GPU-based solution using CUDA primitives [Hal08] or a distributed-parallel solution using
MPI [SO98]. However, all of these approaches require the original sequential version to be
rewritten, leaving the program targeted to a particular hardware approach; a multi-platform,
or platform agnostic approach is not provided. This deﬁciency in portability between hardware
platforms is likely to worsen as hardware architectures evolve.
As an example, the heat ﬂow program uses the forall abstraction (line 16) which provides
an opportunity for data-parallel computation. However, the low-level nature of Fortran means
execution of the outer loop, with the stateful double-buﬀering operation on line 15, has a ﬁxed
behaviour and cannot be (safely) parallelised.

2.4

Alternate approaches

Lower-level imperative languages such as C and Fortran remain popular, but there is increasing
use of object-oriented languages such as Java, C++, and Python, and mathematics-oriented
717

A computational science agenda for programming language research Dominic Orchard, Andrew Rice
1
2

import numpy
# parameters go here ... (akin to Figure˜1, lines 1-9, modulo type declarations)

3
4
5
6
7
8

h = numpy.zeros([nx])
h[0] = 1
for t in range(0, nt):
h_old = numpy.copy(h)
h[1:-1] = h_old[1:-1] + r*(h_old[:-2] - 2*h_old[1:-1] + h_old[2:])

Figure 2: Python program with NumPy, solving an instance of the heat equation.

languages such as R, Matlab, and Mathematica. There are beneﬁts to be found in all these
new languages. However, at a fundamental level the programs they produce are very similar.
Figure 2 shows an equivalent solver to Figure 1, using Python with NumPy [ADH+ 01] which
is increasingly popular for computational science [Oli07]. NumPy’s beneﬁts include a multidimensional array data type (abstracting machine implementations of arrays) and extensive
library functions. The program is not vastly diﬀerent to the Fortran; topologically, they are
identical. Python’s slicing syntax is combined with NumPy’s operator overloading (of +/-, line
8)1 to provide the inner loop which is similar in essence to Fortran’s forall. However, this
requires some thought about the slicing domains, which are more complex than relative oﬀsets.
Object orientation does not improve the clarity of the model here. Instead, object-orientation
simply provides a means for extending Python, e.g., via operator overloading.

3

Towards programming language solutions

We propose that the problems of the previous section can be addressed by new programming
constructs, targeted to computational science. We advocate for (1) high-level abstractions in
programming, coupled with (2) restrictions on code and (3) lightweight veriﬁcation techniques
via speciﬁcations. Abstractions provided by programming languages support the development
of complex software by hiding lower-level details and/or supporting code reuse. Restrictions to
the expressivity of certain parts of a language support reasoning and optimisation, for example,
forall statements are restricted to pure (side-eﬀect free) expressions. Speciﬁcations aid the
design process and can be used to automatically verify code when coupled with automatic tools.
In this section, we discuss potential approaches to these three aspects (abstraction, restriction, speciﬁcation). We illustrate these with examples relating to our heat ﬂow example, but
imagine much wider applications to other kinds of model.
Functional programming We draw inspiration from functional and declarative programming approaches which have previously been argued as applicable to science (e.g., [Hin09,
Kar99]). Functional languages (such as F#, Haskell, ML, OCaml) more closely resemble mathematics than the execution approach of hardware (cf., imperative languages). Functional languages therefore tend to more clearly express the higher-level concepts behind a program. This
aids veriﬁcation, understanding, and eﬃcient execution across platforms.
Functional language abstractions are often coupled with restrictions to provide greater control over certain aspects of computation, most prominently over state and side eﬀects. This
allows programs to be treated more mathematically, aiding veriﬁcation and optimisation via
1 In normal Python, x[1:n]+y[1:n], for example, concatenates array slices. With NumPy, this code instead
computes the pointwise sum of the array slices.

718

A computational science agenda for programming language research Dominic Orchard, Andrew Rice

equational reasoning [Bac78]. Such optimisations mean that functional languages can now
out-perform traditional imperative languages, with less programming eﬀort (e.g., [MLPJ13]).
Functional languages also frequently provide veriﬁcation support through advanced and
ﬂexible type systems, into which various program invariants and properties can be encoded
and then automatically enforced at compile time. As an example of its ﬂexibility, Haskell’s
type system can be used to encode the bounds-checking of relative-array indexing against the
boundary (exterior) size of an array to guarantee code is free from out-of-bounds errors, without
incurring runtime bounds-checking overhead [OM11]. These advanced type systems encode not
just an abstract speciﬁcation of what is computed (e.g., a real number), but also how it is
computed (e.g., this computation uses a memory cell and accesses the ith element of array x).
The information encoded in types can then be further leveraged for program optimisation.
Evolutionary approach Given the signiﬁcant investment in current languages we propose
an evolutionary approach to introducing new programming features in three stages:
1. supporting existing models: with language extensions and refactoring tools;
2. extending modern language approaches: leveraging the ﬂexibility provided in existing
languages (e.g., overloading, object systems, type systems);
3. creating the next generation of languages: learning from current needs and practices.
Due to the evolutionary history of some languages (e.g., Fortran, through many language standards), models developed and used over many decades are often sedimentary, containing layers
of code using older features and idioms which are now deprecated and known to be a likely source
of programmer error. Furthermore, these older layers do not exploit more recent abstractions.
Automatic refactoring tools provide a pathway to evolving and upgrading a code base to
make better use of existing language features [OJ09, TM12]. For example, Photran is a Fortran
refactoring tool for improving code clarity [Pho13]. We built a related automatic refactoring
tool for Fortran (called CamFort) which eliminates uses of older Fortran features for manual
memory and data management, replacing these with equivalent code in a modern style [OR13].
Examples include common-block elimination (replacing these with modules) and replacing manual data structuring idioms, using arrays as records, with the derived data type abstraction of
Fortran 90. This improves code readability and often exposes potential sources of error. The
static analysis techniques of CamFort are powerful enough to detect and apply many more
transformations such as, replacing loops with forall (when the loops are of the correct form),
which then beneﬁts code portability to parallel architectures.
The rest of this section explores abstractions, speciﬁcations, and restrictions to improve computational science programming, and makes reference to supporting existing models as well as
developing new languages and language extensions. We focus on static techniques to speciﬁcation and restriction, i.e., those that can be reasoned about by considering only the source code
of the program. The alternative to this would be to fall back to dynamic checks (as in Python)
which require reasoning about the execution as well as the source code. Although run-time
techniques are easy to implement (consider assertion statements in many imperative/objectoriented languages) it is hard to assess whether suﬃcient constraints have been included to
preserve the desired properties of the program. We note that there are various attempts to
extend dynamically-typed languages such as Python with gradually-introduced static typing
(see, e.g., [LG11]) which may provide a pathway to static methods for such languages.
719

A computational science agenda for programming language research Dominic Orchard, Andrew Rice

3.1

Speciﬁcation systems

Speciﬁcation systems are a lightweight, automatic veriﬁcation technique. Speciﬁcations can be
used to guide the development process (design-by-speciﬁcation) or to verify existing models
(where code is checked against a speciﬁcation). We consider type systems as an example of
a speciﬁcation system, where type properties are speciﬁed explicitly in code or inferred, and
programs violating the speciﬁcation are rejected.
We discuss here dimension types (previously proposed in the literature), stencil speciﬁcations
relating to our heat ﬂoat example (new here), and a number of other type-related approaches
in the literature that could be leveraged in computational science.
Dimension/units-of-measure typing Dimensional analysis is a simple method for checking
basic consistency of a mathematical model where, for example, two quantities can only be added
if they are of the same dimension (e.g., both are length values) and unit (e.g., both are values
in metres). A dimension type system automates this analysis in programming, where numerical
types can be assigned information on their dimension and/or unit [Ken94]. Anecdotally, we
have observed that scientists sometimes include dimension/unit information in source code
comments. Dimension types allows this information to be part of the language, giving them
semantic meaning and power.
Consider the types of real-number addition and multiplication operations, which we write as
+, × : (R, R) → R (binary functions). With dimension types, real number types are annotated
with a unit/dimension Rd . The types of addition and multiplication are then:
+ : ∀d.(Rd , Rd ) → Rd

× : ∀d1 , d2 .(Rd1 , Rd2 ) → Rd1 d2

i.e., only quantities of the same unit can be added and multiplying values multiplies their
units. The universal quantiﬁcation ∀ here means these operations are dimension polymorphic
(generic in their input dimensions). The beneﬁts of such a system are highlighted by the wellknown example of an uncaught unit mismatch leading to the destruction of the Mars Climate
Orbiter [SMB+ 99]. Units-of-measure typing is now provided by F# [Ken08].
The beneﬁts of dimension typing can be provided to existing models written in other languages via a pre-processor, extending the language. In this approach, existing code is augmented
with comments, written with suitable lightweight syntax for dimension types, which are then
checked by a pre-processor stage before compilation. For example, the following adds unit types
to a fragment of the Fortran heat ﬂow program:
! unit(s)
:: tmax
real, parameter
:: tmax = ...
! unit(m) :: xmax
real, parameter
:: xmax = ...

! end time
! length of material

Since the unit types are comments they are ignored by the usual compilation tools.
Dimension typing for Fortran has been discussed for many years and there has been a recent
ISO standard proposal to add this to the language standard [ISO13]. This ISO proposal follows
Fortran’s approach to typing, where every variable must have a declared unit type and every unit
must itself be declared. Applying this approach to existing, large code cases therefore requires
signiﬁcant programmer eﬀort. Instead, type inference can be used to infer the dimension types
of unspeciﬁed parts of the program, and therefore reduce the number of required declarations.
We have prototyped a dimension typing system as part of the CamFort tool which resembles
the ISO proposal but with polymorphic type inference and increased ﬂexibility. This reduces
programmer eﬀort in applying the technique to existing models. We omit further details of the
approach for brevity here.
720

A computational science agenda for programming language research Dominic Orchard, Andrew Rice

Implementation speciﬁcations In Section 2.1, the discretization of the heat equation was
performed by hand, making a number of choices. The solution uses the ﬁnite diﬀerence technique with the Forward Time, Centered Space (FTCS) scheme. This means that any error is
αΔt
1
bounded above by Δt and (Δx)2 . Furthermore, if r = Δx
2 < 2 then the FTCS solution is known
to be stable [Rec04]. This information is lost in the implementation of Figure 1. We propose
that details of the discretization process should instead be part of the code to help verify and
test the implementation, and to better communicate the solution approach and assumptions.
One approach would be to encode the shape of the array indexing pattern following from the
FTCS scheme and the expansion depth of the Taylor series approximation. In our example, this
leads to a centered (symmetrical) spatial pattern to a depth of one element in each direction.
This could be encoded as a speciﬁcation on the forall statement. For example:
! h : {symmetrical 1}
forall (x = 2:(nx - 1))

h(x) = h_old(x) + r*(h_old(x-1) - 2*h_old(x) + h_old(x+1))

i.e., relative to the current index x, h is accessed with a symmetrical pattern to depth 1. The
program can then be automatically checked against the speciﬁcation in a pre-processor stage to
ensure that this approach was implemented correctly. The speciﬁcation language should allow
combinations of forward, backward, and centered (symmetrical) shapes in diﬀerent dimensions.
Stencil speciﬁcations can be seen as a kind of computation type which provides information
on how a computation is performed (in terms of data usage) and not just what is computed, as
in traditional type systems.
Other typed approaches Other useful speciﬁcations for computational science might include value constraints, for example using reﬁnement types [GF10] to specify the stability
constraint of the FTCS scheme for the heat equations, e.g., real {< 0.5}, parameter :: r.
More advanced type systems may be leveraged, for example dependent types which allow
types to depend on values, elucidating the role of parameters in a computation and providing
a richer description of computation [Hof97]. Dependent types have already been used in the
area of climate impact research [IJ13a]. This work formalised measures of vulnerability to
climate change using types which were then used to guarantee the correctness of programs
implementing such measures. In computational science, such guarantees are rare, but dependent
types can help scientists to write betters speciﬁcations and partial proofs of correctness leading
to increasingly correct scientiﬁc computing [IJ13b].
By combining diﬀerent kinds of type system (dependent, reﬁnement, dimension, data access)
future computational science languages can provide a rich set of automatic veriﬁcation choices.

3.2

New abstractions and a language paradigm

Programming language abstractions beneﬁt the reading, writing, understanding, veriﬁcation,
and high-performance execution of programs [Orc11]. This section considers abstractions for
improving the communication of the scientiﬁc intent of a model, using our heat ﬂow example.
Language features for general abstraction, such as higher-order functions coupled with parametric polymorphic types, can be used to build application-speciﬁc abstractions, for example,
as in the approach of algorithmic skeletons for parallelism [Col89]. Application-speciﬁc abstractions are particularly eﬀective when derived from data on the programming needs of practioners.
Previous studies have identiﬁed various core parallel programming patterns (many of which
appear in computational science models) [ABD+ 08]. Such studies point the way towards useful
new language abstractions for the computational science domain. For example, we previously
developed a new notation for working with structured grid programs (such as ﬁnite diﬀerence
721

A computational science agenda for programming language research Dominic Orchard, Andrew Rice
1
2
3

module heat {alpha : Real{m^2/s}}
model : PDE (X : Real{m}) * (T : Real{s}) -> (E : Real{j})
model h = d h T == alpha * (d (d h X) X)

4
5
6
7
8
9
10
11
12
13
14
15
16
17
18

instance heat(FTCS)
approx : {forward T 1, symmetrical X 1}
approx h [x, t] = let r = alpha * (delta(T) / delta(X)^2)
in h [x, t-1] + r * (h [x+1, t-1] - 2*(h [x, t-1]) + h [x-1, t-1])
instance heat(FTCS[Dirichlet[1]]) {x0 : Real{j}, xn : Real{j}, nx : Int, nt : Int}
delta(T)
= 0.05
-- time step size
delta(X)
= 0.05
-- space step size
extent(X)
= (0, nx)
-- size of X (for some nx)
extent(T)
= (0, nt)
-- size of T (for some nt)
boundary(T)[0] = array (0 -> x0, * -> xn)
-- set up initial array
boundary(T)[nt] = solve approx boundary(T)[0]
-- solve to get upper extent in T
h’ = heat(FTCS[Dirichlet[1]]) {alpha = 0.1, x0 = 1.0, xn = 0.0, nx = 40, nt = 50}

Figure 3: A mockup language, separating model speciﬁcation from solution implementation.

models) that reduces veriﬁcation problems by replacing indexing oﬀsets with a ﬁxed “grid pattern” notation, resembling diagrams of stencil access patterns [OM11, OBM10]. This new language construct, coupled with algorithmic-skeleton style libraries, provides various automated
veriﬁcation and parallelisation opportunities.
Abstractions for separating concerns Despite advanced abstractions in functional languages, functional programs still often suﬀer from the problem of conﬂating concerns in the
context of computational science. We thus propose here a multi-level language approach where
higher-level abstract speciﬁcations of a model can be described separately to the lower-level
numerical approximation and prediction process which reﬁne the model.
For example, a multi-level language might allow the original diﬀerential heat equation to
be directly encoded in the program as the abstract model (thus deﬁning an essential property
of the heat function) along with a solution strategy which gives a concrete deﬁnition (of the
same type). This has several beneﬁts. Firstly, the high-level language can communicate the
scientiﬁc intent, unencumbered by implementation assumptions and possible bugs in low-level
solution code. Secondly, validation of the model and veriﬁcation of the implementation will
be apportioned to the higher- and lower-level parts respectively. Thirdly, a model can be kept
abstract but instantiated with a number of diﬀerent solution methods which may have their
own low-level implementation, tuned to diﬀerent hardware platforms and architecture (e.g.,
exploiting parallelism).
Figure 3 uses a hypothetical multi-level language for the heat ﬂow example. The code is
split into an abstract model (lines 1-3), FTCS approximation approach (lines 5-8), and instance
of the approximation (lines 10-16). The example includes dimension types (lines 1-2,10) and
stencil speciﬁcations (line 6). Lines 1-3 give the abstract speciﬁcation of the heat equation,
where d is a higher-order function which captures a partial derivative and is parameterised
by a function and a dimension (e.g., T or X). Lines 5-8 describe our FTCS approximation but
does not specialise it to the problem size, resolution, or boundary conditions. Lines 10-16 then
give an instance of the approximating solution, deﬁning problem size and boundaries, which is
instantiated with values on line 18. On lines 1 and 10, parameters of the model and solution
respectively are declared, inside braces { and }, along with their unit types.
722

A computational science agenda for programming language research Dominic Orchard, Andrew Rice

The abstract model speciﬁcation in this approach (lines 1-3) is more than just a comment. It
speciﬁes solution behaviour and thus any approximate solutions can be backchecked at runtime
against this model (see, e.g., backchecking in [RB06]). For example, the FTCS predictions
can be plugged back into the abstract model, where standard numerical approximations are
automatically computed for diﬀerentials on each side of the equation. These can then be
checked against a speciﬁcation of expected error growth, or reported back to the programmer for
analysis (for example, reporting on the absolute error between the two sides of the speciﬁcation’s
equality on line 3). Further, the abstractions provided here allow for other automated testing
approaches. For example, the parameter space for α can be explored, using a QuickCheck-style
approach [CH00] to test the stability and robustness of the solution approach.
There are a number of useful language restrictions used here. Firstly, expressions between
brackets, [ and ], must be aﬃne expressions of indices, thus restricting indexing to a decidable
fragment of arithmetic. This provides decidable information to the compiler about the access
pattern which could be used for veriﬁcation, or to guarantee layout optimisation and parallelisation strategies (e.g., domain decompositions with minimal halos). Another restriction might
be that functions using state must declare so in a speciﬁcation, which must then be propagated
to the speciﬁcations of all functions that use it (cf., the monadic typing discipline [Wad95]). In
the example, the functions are free from state, and thus the compiler knows that the solution
method is data parallel (with only a backward, temporal dependency following from line 8).
We have experimented with this new programming approach in Haskell, where we have developed a prototype for specifying partial-diﬀerential equation (PDE) models and automatically
checking approximations against these model speciﬁcations.2 The prototype does not include
all features discussed here but supports the main approach of describing an abstract model in
code, separate to an implementation. Library functions then provide automatic testing of the
suitability of an approximation from the PDE speciﬁcation. Appendix A shows an example
using our prototype that resembles Figure 3. Our prototype validates the hypothesis that this
is a plausible programming approach.
Related to this approach of expressing models in code, the FEniCS project provides a programming system for the automatic solution of partial-diﬀerential equations which embeds
diﬀerential equations in code (C++ and Python, although the C++ approach is more powerful) [LMW12]. FEniCS provides its own system for solving PDEs and does not provide a
mechanism for coupling manual solutions with the PDE speciﬁcations.
The language approach described here, and provided by our prototype, supports reproducibility by providing programming constructs for clearly expressing an abstract model in
code which can then be shared separately to any approximations, in a modular fashion. Furthermore, the approach supports veriﬁcation by providing automated testing of approximations
against the abstract model. Future programming systems for computational science should provide similar abstractions for separating concerns in diﬀerent kinds of model (not just PDEs),
and thus aiding understanding, reproducibility, and veriﬁcation.

4

Conclusion

Computer modelling has beneﬁted the scientiﬁc method by providing tools to develop increasingly complex theories. However, at the same time this has substantially increased the complexity of making predictions from a hypothesis and reproducing results. We discussed how
programming language concepts can be applied to the computational science domain to pro2 The

prototype is available with documentation at https://github.com/dorchard/pde-specs.

723

A computational science agenda for programming language research Dominic Orchard, Andrew Rice

vide more eﬀective languages. The intention is to reduce the burden on scientists by evolving
existing tools and languages in new directions. We have begun this evolutionary process with
CamFort, which can apply code transformations to Fortran code-bases and type-check unit-type
annotations (embedded via comments).
We believe there are beneﬁts available from moving towards a multi-language approach.
Initially this could take the form of attaching relevant speciﬁcations to existing code (such
as dimension typing or stencil speciﬁcations as demonstrated). We outlined brieﬂy a new
programming language approach that more thoroughly separates the intent of a model from
its implementation. The novel approaches discussed here were however specialised to just one
kind of model: partial-diﬀerential equations, although stencil speciﬁcations are useful for other
kinds of model with regular, data-access patterns on arrays (such as cellular automata).
The general idea of separating concerns via language abstractions is however widely applicable to many diﬀerent kinds of modelling. What is needed now is increased collaboration between
computational scientists and programming language researchers such that the state-of-the-art
in computational science programming can progress to cover a wide variety of modelling approaches. There is a distinct lack of quantitative data on the programming patterns prevalent in
computational science models, which should be remedied. Furthermore, to aid adoption, there
is a deﬁnite need for user-focussed research, with usability analyses of any new programming
approaches and serious eﬀorts to integrate with the existing working practices of scientists.
There are many opportunities and there is much work to be done. The time is now to build
new languages and tools to support the next generation of scientiﬁc research.
Acknowledgments Thanks are due to Oliver Chick, Michael Fischer, Cezar Ionescu, and
Alan Mycroft for comments and discussion, Oleg Oshmyan for his work on units-of-measure
typing for Fortran in CamFort, and Andy Hopper for his support. This research was supported
by a Google Focused Research Award.

References
[ABD+ 08] Krste Asanovic, Ras Bodik, Demmel, et al. The Parallel Computing Laboratory at U.C.
Berkeley: A research agenda based on the Berkeley view. Technical Report UCB/EECS2008-23, EECS Department, University of California, Berkeley, Mar 2008.
[ADH+ 01] D. Ascher, P. F. Dubois, K. Hinsen, J. Hugunin, and T. Oliphant. Numerical Python.
Technical Report UCRL-MA-128569, 2001. Lawrence Livermore National Laboratory.
[Bac78]
J. Backus. Can programming be liberated from the von Neumann style?: a functional style
and its algebra of programs. Communications of the ACM, 21(8):613–641, 1978.
[CH00]
Koen Claessen and John Hughes. QuickCheck: A Lightweight Tool for Random Testing
of Haskell Programs. In Proceedings of the Fifth ACM SIGPLAN International Conference
on Functional Programming, ICFP ’00, pages 268–279, New York, NY, USA, 2000. ACM.
[Col89]
M.I. Cole. Algorithmic skeletons: structured management of parallel computation. Pitman,
1989.
[CRR+ 06] Geoﬀrey Chang, Christopher B. Roth, Christopher L. Reyes, Owen Pornillos, Yen-Ju Chen,
and Andy P. Chen. Retraction. Science, 314(5807):1875, 2006.
[DDD91] C. Dawson, Q. Du, and T. Dupont. A ﬁnite diﬀerence domain decomposition algorithm for
numerical solution of the heat equation. Mathematics of Computation, 57(195), 1991.
[DM98]
Leonardo Dagum and Ramesh Menon. OpenMP: An Industry-Standard API for SharedMemory Programming. IEEE Comput. Sci. Eng., 5(1):46–55, 1998.

724

A computational science agenda for programming language research Dominic Orchard, Andrew Rice
[Dru09]

Chris Drummond. Replicability is not reproducibility: nor is it good science. In Evaluation
Methods for Machine Learning Workshop at the 26th ICML, Montreal, Canada, 2009.
[GDN97] M. Griebel, T. Dornsheifer, and T. Neunhoeﬀer. Numerical simulation in ﬂuid dynamics:
a practical introduction, volume 3. Society for Industrial Mathematics, 1997.
[GF10]
Andrew D Gordon and C´edric Fournet. Principles and Applications of Reﬁnement Types.
Logics and Languages for Reliability and Security, 25:73–104, 2010.
[Hal08]
Tom Halfhill. Parallel Processing with CUDA. Microprocessor Report, Januray 2008.
[Hin09]
K. Hinsen. The promises of functional programming. Computing in Science & Engineering,
11(4):86–90, 2009.
[Hof97]
M. Hofmann. Syntax and semantics of dependent types. Semantics and logics of computation, 14:79, 1997.
[IJ13a]
Cezar Ionescu and Patrik Jansson. Dependently-Typed Programming in Scientiﬁc Computing - Examples from Economic Modelling. In IFL (Implementation and Application
of Functional Languages) 2012, volume 8241 of Lecture Notes in Computer Science, pages
140–156. Springer, 2013.
[IJ13b]
Cezar Ionescu and Patrik Jansson. Testing versus proving in climate impact research. In
Proceedings of the 18th Workshop Types for Proofs and Programs (TYPES’11), volume 19,
pages 41–54, 2013.
[ISO13]
ISO/IEC JTC1/SC22/WG5, Units of measure for numerical quantities, April 2013. N1696,
ftp://ftp.nag.co.uk/sc22wg5/N1951-N2000/N1969.pdf.
[Kar99]
L. Karczmarczuk. Scientiﬁc computation and functional programming. Computing in Science & Engineering, 1(3):64–72, 1999.
[Ken94]
Andrew Kennedy. Dimension types. In European Sympsium on Programming Languages
and Systems (ESOP), pages 348–362. Springer Berlin Heidelberg, 1994.
[Ken08]
Andrew Kennedy. Types for units-of-measure in F#: invited talk. In Proceedings of the
2008 ACM SIGPLAN workshop on ML, pages 1–2. ACM, 2008.
[KKZ07] Ken Kennedy, Charles Koelbel, and Hans Zima. The rise and fall of High Performance
Fortran: an historical object lesson. In Proceedings of the third ACM SIGPLAN conference
on History of programming languages, pages 7–1. ACM, 2007.
[LG11]
Jukka Lehtosalo and David J Greaves. Language with a Pluggable Type System and Optional Runtime Monitoring of Type Errors. In Proceedings of International Workshop on
Scripts to Programs (STOP), 2011.
[LMW12] A. Logg, K.A. Mardal, and G. Wells. Automated Solution of Diﬀerential Equations by the
Finite Element Method: The FEniCS Book. Lecture Notes in Computational Science and
Engineering. Springer, 2012.
[Mer10]
Z. Merali. Computational science: Error, why scientiﬁc programming does not compute.
Nature, 467(7317):775–777, 2010.
[MLPJ13] Geoﬀrey Mainland, Roman Leshchinskiy, and Simon Peyton Jones. Exploiting Vector Instructions with Generalized Stream Fusion. In Proceedings of the 18th ACM SIGPLAN
International Conference on Functional Programming, ICFP ’13, pages 37–48, 2013.
[OBM10] Dominic Orchard, Max Bolingbroke, and Alan Mycroft. Ypnos: declarative, parallel structured grid programming. In DAMP ’10: Proceedings of the 5th ACM SIGPLAN workshop
on Declarative aspects of multicore programming, pages 15–24, New York, USA, 2010. ACM.
[OJ09]
Jeﬀrey L Overbey and Ralph E Johnson. Regrowing a language: refactoring tools allow
programming languages to evolve. In ACM SIGPLAN Notices, volume 44, pages 493–502,
2009.
[Oli07]
Travis E Oliphant. Python for scientiﬁc computing. Computing in Science & Engineering,
9(3):10–20, 2007.
[OM11]
Dominic Orchard and Alan Mycroft. Eﬃcient and Correct Stencil Computation via Pat-

725

A computational science agenda for programming language research Dominic Orchard, Andrew Rice
tern Matching and Static Typing. Electronic Proceedings in Theoretical Computer Science,
66:68–92, 2011. arXiv:1109.0777.
[OR10]
W.L. Oberkampf and C.J. Roy. Veriﬁcation and validation in scientiﬁc computing. Cambridge University Press, 2010.
[OR13]
Dominic Orchard and Andrew Rice. Upgrading Fortran Source Code Using Automatic
Refactoring. In Proceedings of the 2013 ACM Workshop on Workshop on Refactoring Tools,
WRT ’13, pages 29–32, New York, NY, USA, 2013. ACM.
[Orc11]
Dominic Orchard. The four Rs of programming language design. In Proceedings of the 10th
SIGPLAN symposium on New ideas, new paradigms, and reﬂections on programming and
software, pages 157–162. ACM, 2011.
[Pho13]
Photran – An Integrated Development Environment and Refactoring Tool for Fortran,
Retrieved July 2013. http://www.eclipse.org/photran/.
[PV05]
D.E. Post and L.G. Votta. Computational science demands a new paradigm. Physics today,
58(1):35–41, 2005.
[RB06]
Andrew C Rice and Alastair R Beresford. Dependability and accountability for contextaware middleware systems. In Pervasive Computing and Communications Workshops, 2006.
PerCom Workshops 2006. Fourth Annual IEEE International Conference on, pages 5–pp.
IEEE, 2006.
[Rec04]
G.W. Recktenwald. Finite-diﬀerence approximations to the heat equation. Class Notes,
2004. http://www.f.kth.se/~jjalap/numme/FDheat.pdf.
[She05]
T. Sheard. Putting Curry-Howard to work. In Proceedings of the 2005 ACM SIGPLAN
workshop on Haskell, pages 74–85. ACM, 2005.
[SMB+ 99] Arthur G Stephenson, Daniel R Mulville, Frank H Bauer, Greg A Dukeman, Peter Norvig,
LS LaPiana, PJ Rutledge, D Folta, and R Sackheim. Mars Climate Orbiter Mishap Investigation Board Phase I Report, 44 pp. NASA, Washington, DC, 1999.
[SO98]
Marc Snir and Steve Otto. MPI-The Complete Reference: The MPI Core. MIT Press,
Cambridge, MA, USA, 1998.
[SV07]
M. Sulzmann and R. Voicu. Language-based program veriﬁcation via expressive types.
Electronic Notes in Theoretical Computer Science, 174(7):129–147, 2007.
[TM12]
Fernando G Tinetti and Mariano M´endez. Fortran legacy software: source code update and
possible parallelisation issues. In ACM SIGPLAN Fortran Forum, volume 31, pages 5–22,
2012.
[Var10]
Moshe Y. Vardi. Science has only two legs. Commun. ACM, 53(9):5–5, September 2010.
[Wad95]
Philip Wadler. Monads for functional programming. In Advanced Functional Programming,
pages 24–52. Springer, 1995.

A

Example of PDE models in Haskell

Available at http://github.com/dorchard/pde-specs/ in the ﬁle ICCS-example.hs.
Line 5 speciﬁes the heat ﬂow PDE, spec. Lines 8-13 describe the FTCS approximation as a
recurrence relation, approx, with Dirichlet boundaries. Line 18 uses a memoizing combinator
arrayMemoFix to provide a high-performance version of the recurrence, approxFast. Note the
type signature on lines 16-17 show that the approximation has a discrete domain (a pair of integers) and requires implicit parameters, ?nx, ?nt, ?dt, ?dx, and ?alpha. Lines 20-26 instantiate
the approximation (providing values for the implicit parameters) and then runs verifyModel
(line 26) with speciﬁcation spec and approximation approxFast. This computes the absolute error between the left- and right-hand sides of the PDE spec applied to the approxFast
solution, using the Euler method for its numerical approximation of the diﬀerentials.
726

A computational science agenda for programming language research Dominic Orchard, Andrew Rice

1
2

{-# LANGUAGE ImplicitParams #-}
import PDESpec

3
4
5

-- Specification of heat equation PDE
spec h = (d h T) === (constant ?alpha * d2 h X) ‘withDomain‘ (X :. T :. Nil)

6
7
8
9
10
11
12
13

-- Implementation
approx h’ (x, t)
| x == 0
=
| x == ?nx =
| t == 0
=
| otherwise =

using a recurrence relation
1
0
0
h’ (x, t-1) + r * (h’ (x+1, t-1) - 2 * h’ (x, t-1) + h’ (x-1, t-1))
where r = ?alpha * (?dt / (?dx * ?dx))

14
15
16
17
18

-- Create a fast version using
approxFast :: (?nx :: Int, ?nt
=> (Int, Int) ->
approxFast = arrayMemoFix ((0,

a memoizing combinator arrayMemoFix
:: Int, ?dx :: Float, ?dt :: Float, ?alpha :: Float)
Float
0), (?nx, ?nt)) approx

19
20
21
22
23
24
25
26

-- Instantiate approximation; verify by calculating abs error of ’approxFast’ from the spec
experiment = let ?dx = 0.05
?dt = 0.05
?nx = 100
?nt = 100
?alpha = 0.006
in verifyModel Euler spec approxFast

727

