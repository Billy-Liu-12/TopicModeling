Data Replication Techniques for Data-Intensive
Applications
Jaechun No1 , Chang Won Park2, and Sung Soon Park3
1

Dept. of Computer Software,
College of Electronics and Information Engineering,
Sejong University, Seoul, Korea
2
Intelligent IT System Research Center,
Korea Electronics Technology Institute,
Bundang-gu, Seongnam-si, Korea
3
Dept. of Computer Science & Engineering,
College of Science and Engineering,
Anyang University, Anyang, Korea

Abstract. Several data replication techniques have been developed to
support high-performance data accesses to the remotely produced scientiﬁc data. Most of those techniques, however, do not provide the replica
consistency because the data replica is just periodically updated through
the remote clients. We have developed two kinds of data replication techniques, called owner-initiated replication and client-initiated replication.
Our replication techniques do not need to use ﬁle system-level locking
functions so that they can easily be ported to any of ﬁle systems. In this
paper we describe the design and implementation of our two replication
techniques and present performance results on Linux clusters.

1

Introduction

Many large-scale scientiﬁc experiments and simulations generate very large
amounts of data [1, 2, 3](on the order of several hundred gigabytes to terabytes)
in the geographically distributed storages. These data are shared between the
researchers and colleagues for data analysis, data visualization, and so forth.
In order to reduce the communication and I/O cost, the remotely located
users replicate the data sets needed for their research in the local storage. The
usual way of replicating data sets is to periodically update the remotely located
data replicas, like implemented in Globus toolkit [4, 5]. This method, however,
does not provide the replica consistency in such a case that a data replica stored
in more than one remote site is modiﬁed by a remote client and accessed by
another client located at the other remote site before the modiﬁcation to the
replica is applied to the remote locations.
In order to provide the data replica consistency, we have developed two
kinds of data replication techniques, called owner-initiated replication and clientinitiated replication. We integrated those replication techniques to GEDAS (Grid
V.N. Alexandrov et al. (Eds.): ICCS 2006, Part IV, LNCS 3994, pp. 1063–1070, 2006.
c Springer-Verlag Berlin Heidelberg 2006

1064

J. No, C.W. Park, and S.S. Park

Environment-based Data Management System ) [6, 7] that is a grid toolkit providing a high-level, user-friendly interface to share the remotely produced data
among the grid communities.
In the owner-initiated replication, the data owner who owns the application
data sets starts the data replication to share the data sets with remote clients. In
the client-initiated replication, the client who needs the data sets starts the data
replication. Moreover, our replication techniques do not need to use ﬁle systemlevel locking functions so that they can easily be ported to any of ﬁle systems.
The rest of this paper is organized as follows. In Section 2, we discuss an
overview of GEDAS architecture to integrate our replication techniques with
GEDAS. In Section 3, we present the design and implementation of our two
kinds of replication techniques. Performance results on the Linux cluster located
at Sejong University are presented in Section 4. We conclude in Section 5.

2
2.1

GEDAS Architecture
Overview of GEDAS

In GEDAS, users on the data owner run large-scale, data-intensive applications
while writing large amounts of data to the local storage. The remote clients who
want to share the application data sets with the data owner for the purpose
of data visualization or data analysis are grouped into several client groups,
according to the data sets replicated on the local storage. In other words, the
remote clients sharing the same replicas belong to the same client group.
Figure 1 shows an overview of GEDAS. The six metadata database tables and
the application data sets generated by users are located at the data owner and n

Fig. 1. An Overview of GEDAS

Data Replication Techniques for Data-Intensive Applications

1065

remote client groups are created based on the data replicas shared among them.
Each client in a group is identiﬁed with groupID and clientID, such as (g0 , c0 )
for the ﬁrst client and (g0 , c1 ) for the second client in Group g0 .
The reason for making the client groups is that if a client modiﬁes the data
replicas stored in its local storage, GEDAS can easily detect the other clients
who share the same data replicas and can let them take the new copy of the
modiﬁed data, without aﬀecting other clients.

3
3.1

Data Replication
Owner-Initiated Data Replication

In order to maintain the replica consistency among the remote clients, we developed two replication approaches, called owner-initiated replication and clientinitiated replication.
In the owner-initiated replication, when user generates data sets on the data
owner, GEDAS replicates them to the remote clients who registered to GEDAS
to share the data sets with the data owner. When a remote client changes the
data replicas stored in its local storage, it broadcasts the modiﬁcations to the
members in the same group where it belongs to and to the data owner for replica
consistency. Figure 2 shows the steps taken in the owner-initiated replication.
Suppose that a client belonging to Group g0 modiﬁes the data replicas at time
ti . The client ﬁrst sends the request for the IP address of other clients in g0 to the
data owner. After the client receives the IP address, it sends the modiﬁed data to
the other clients in g0 and to the data owner and waits for the acknowledgement.
When the data owner receives the modiﬁed data, it updates them to the local
storage and sets the status ﬁeld of the replication registry table to ”holding”

Fig. 2. Owner-Initiated Replication

1066

J. No, C.W. Park, and S.S. Park

to prevent another client from accessing the data sets while being updated.
When the data owner receives the signal from the client who initiated the data
modiﬁcation, it sets the status ﬁeld to ”done”, allowing another client to use the
data replica.
The owner-initiated replication approach allows remote clients to share the
data replicas safely, provided that they ﬁnd out the corresponding status ﬁeld
is set to ”done”. Moreover, a remote client crash doesn’t aﬀect to the data
consistency because as soon as the data replicas are modiﬁed the change is
immediately reﬂected to the data owner and the other clients in the same group.
However, if the data modiﬁcation to the data replicas frequently happens, the
heavy communication bottleneck then incurs even if no one else would use the
data sets modiﬁed.
3.2

Client-Initiated Data Replication

Figure 3 shows the client-initiated replication where only when the modiﬁed data
replicas are needed by users are those data replicas sent to the requesting client
and to the data owner. Unlike in the owner-initiated replication, there is no data
communication when users on the data owner produce the application data sets.
If a client needs to access the remote data sets stored in the data owner, he will
then get the data replica while registering to GEDAS.
Suppose that client A belonging to Group g0 modiﬁes a data replica at time
ti . He just sends a signal to the data owner to update the corresponding status
ﬁeld of the data set to the IP address of client A.
At time tj , let client B access the data replica stored in its local storage but
not been updated by client A’s data modiﬁcation. In order to check the replica

Fig. 3. Client-Initiated Replication

Data Replication Techniques for Data-Intensive Applications

1067

consistency, client B ﬁrst requests the status information of the data replica to
the data owner. The data owner ﬁnds out that the data set has been modiﬁed
by client A and requests the data to client A. Client A sends the modiﬁed data
to the data owner and to the client B, and then waits for the acknowledgement
from both. After the data owner updates the modiﬁed data set and sets the
status ﬁeld to ”done”, it sends back an acknowledgement to the client A.
In the client-initiated replication approach, the data replicas are sent to the
remote clients only when the data sets are actually needed by them. Therefore,
unlike in the owner-initiated replication approach, the client-initiated replication
does not incur unnecessary data communication. However, if a client who keeps
the modiﬁcation of the data replica is crashed before the data modiﬁcation is
updated to the data owner and to the other members of the same group, a
signiﬁcant data loss will be happened.

4

Performance Evaluation

In order to measure the performance, we used two Linux clusters located at
Sejong university. Each cluster consists of eight nodes having Pentium3 866MHz
CPU, 256 MB of RAM, and 100Mbps of Fast Ethernet each. The operating
system installed on those machines was RedHat 9.0 with Linux kernel 2.4.20-8.
The performance results were obtained using the template implemented based
on the three-dimensional astrophysics application, developed at the University
of Chicago. The total data size generated was about 520MB and among them,
400MB of data were generated for data analysis and data restart, and then the
remaining 120MB of data were generated for data visualization. The data sets
produced for visualization are used by the remote clients, thus requiring the data
replication to minimize the data access time.
In order to evaluate two replication approaches, a randomly chosen remote
client modiﬁed 30MB of replicas at time steps 5, 10, and 15 and spread those
replicas to the data owner and to the clients, according to the owner-initiated
replication and to the client-initiated replication. A maximum execution time
for the data replication measured among the remote clients was selected as a
performance result. This time includes the cost for metadata access on the data
owner, real data communication, and I/O operations.
In Figure 4, we made two client groups, while each group consisting of two
nodes. At each time step, a client accesses either 30MB of replicas stored in the
local storage, or 30MB of remote data sets stored on the data owner in such a
case that the data sets required are not replicated.
In the owner-initiated replication, as soon as an application produces data
sets at time step 0, all the remote clients receive the necessary visualization data
sets to replicate them to the local storage. These replicas are used until the
modiﬁcation to the replicas happens at time steps 5, 10, and 15, respectively.
When the replicas stored in the local storage are used, the execution time
for accessing visualization data sets drops to almost about 3 seconds needed for
communicating the corresponding status information with the data owner.

1068

J. No, C.W. Park, and S.S. Park

Fig. 4. Execution time for replicating visualization data on the remote clients as a
function of time steps for accessing remote data sets. Two client groups were made,
while each group consisting of two nodes.

If the modiﬁcation to the replicas happens, like occurred at time steps 5, 10,
and 15, respectively, the modiﬁed replicas are then broadcast to the data owner
and to the clients in the sample group, thereby increasing the execution time for
accessing remote data sets.
In the client-initiated replication, since there is no replica stored in the client
side until time step 4, each remote client should communicate with the data
owner to receive the data sets needed. Because each client can use the data
replicas stored in its local storage from time step 5, the execution time for
accessing data sets dramatically drops to almost 3 seconds.
When the replicas are modiﬁed at time steps 5, 10, and 15, the client-initiated
approach just sends the IP address of the client modifying the replicas, and thus

Fig. 5. Execution time for replicating visualization data on the remote clients as a
function of time steps for accessing remote data sets. Two client groups were made,
while each group consisting of eight nodes.

Data Replication Techniques for Data-Intensive Applications

1069

it takes no more than 3 seconds. However, we can see that in Figure 4, at time
steps 6, 12, and 14, another client tries to access the modiﬁed replicas, thus
occurring the data communication and I/O cost to update the replicas to the
requesting client and to the data owner.
Without data replication, the data communication for accessing the remote
data sets consistently happens on the clients, aﬀecting the performance.
In Figure 5, we increased the number of nodes in each group to eight. With this
conﬁguration, when the replicas are modiﬁed at a remote client, the execution
time for accessing data sets in the owner-initiated replication is signiﬁcantly
increased, compared to Figure 4, because of the increment in the communication
cost to broadcast the replicas to the data owner and to the other clients.
On the other hand, as can be seen in Figure 5, the client-initiated replication shows not much diﬀerence in the execution time to receive the modiﬁed
data sets because less number of nodes than in the own-initiated replication
is involved in the communication. However, we believe that more performance
evaluations should be conducted to present some valuable conclusions with these
two replication approaches.

5

Conclusion

We have developed two data replication approaches to maintain the replica consistency in case of replica modiﬁcations or updates. In the owner-initiated replication, the replication occurs when applications generate the data sets in the
data owner location. Whenever a remote client modiﬁes or updates its replica,
in order to maintain the data consistency, it broadcasts the replica to the other
members of the same group, as well as to the data owner retaining the entire
application data sets. In the client-initiated replication, only when the data sets
are needed by a remote client are the necessary data sets replicated on the requesting client. If a client modiﬁes its replica, it just sends the signal to the data
owner in order for the other client to recognize the recently modiﬁed replica.
Due to the data broadcast, the owner-approach shows the increased communication overhead when the number of nodes in a group becomes large. On the
other hand, the client-initiated replication shows the constant communication
cost even with the increased number of nodes in a group. In the future, we plan
to use our replication techniques with more applications and evaluate both the
usability and performance.

References
1. B. Allcock, I. Foster, V. Nefedova, A. Chervenak, E. Deelman, C. Kesselman, J.
Leigh, A. Sim, A. Shoshani, B. Drach, and D. Williams. High-Performance Remote
Access to Climate Simulation Data: A Challenge Problem for Data Grid Technologies. SC2001, November 2001
2. R. Moore, A. Rajasekar. Data and Metadata Collections for Scientiﬁc Applications.
High Performance Computing and Networking (HPCN 2001), Amsterdam, NL,
June 2001

1070

J. No, C.W. Park, and S.S. Park

3. A. Chervenak, E. Deelman, C. Kesselman, L. Pearlman, and G. Singh. A Metadata
Catalog Service for Data Intensive Applications. GriPhyN technical report, 2002
4. I. Foster, C. Kesselman, J. Nick, and S. Tuecke. The Physiology of the Grid: An
Open Grid Services Architecture for Distributed Systems Integration WG, Global
Grid Forum, June 22, 2002
5. A. Chervenak, I. Foster, C. Kesselman, C. Salisbury, S. Tuecke. The Data Grid:
Towards an Architecture for the Distributed Management and Analysis of Large Scientiﬁc Datasets. Journal of Network and Computer Applications, 23:187-200, 2001
6. J. No, H. Park. GEDAS: A Data Management System for Data Grid Environments.
In Proceedings of International Conference on Computational Science, 2005, pages
485–492
7. J. No, R. Thakur, and A. Choudhary. High-Performance Scientiﬁc Data Management System. Journal of Parallel and Distributed Computing, (64)4:434-447, April
2003

