Procedia Computer
Science
Procedia
Computer Science
Science 001 (2010)
Procedia
Computer
(2012)1–8
1885–1892

www.elsevier.com/locate/procedia

International Conference on Computational Science, ICCS 2010

Using the feasible set method for rezoning in ALE
Markus Berndt
Los Alamos National Laboratory
Computational Physics and Methods Group, Mail Stop D413
Los Alamos, NM 87545, U.S.A.

Milan Kucharik
Department of Physical Electronics
Faculty of Nuclear Sciences and Physical Engineering
Czech Technical University in Prague
Brehova 7, Praha 1, 115 19, Czech Republic

Mikhail J. Shashkov
Los Alamos National Laboratory
Applied Mathematics and Plasma Physics Group, Mail Stop B284
Los Alamos, NM 87545, U.S.A.

Abstract
One of the steps in the Arbitrary Lagrangian Eulerian (ALE) algorithm is the improvement of the quality of the
computational mesh. This step, commonly referred to as rezoning, is essential for maintaining a mesh that does not
become invalid during a simulation. In this paper, we present a new robust and computationally eﬃcient 2D mesh
relaxation method. This feasible set method is a geometric method for ﬁnding the convex polygon that represents the
region of coordinates that a vertex in a mesh can occupy while the mesh around it remains valid. After the feasible set
has been computed for a vertex in a mesh, a new vertex location can be chosen that lies inside this feasible set. As a
result, the mesh after relaxation is guaranteed to be valid. We present an example ALE simulation, that highlights the
robustness of the feasible set method when used as a rezoning method in ALE.
c 2012 Published by Elsevier Ltd. Open access under CC BY-NC-ND license.
⃝
Keywords: mesh smoothing, arbitrary Lagrangian Eulerian method, ALE, rezoning, feasible set

1. Introduction
Arbitrary Eulerian Lagrangian (ALE) methods are popular for the simulation of continuum mechanics problems
with large shear deformation. These ALE methods [1, 2] consist of a Lagrangian step in which the mesh nodes move
along with the ﬂuid motion and a rezone step in which the mesh is modiﬁed to improve its quality, and a remap step
Email addresses: berndt@lanl.gov (Markus Berndt), kucharik@newton.fjfi.cvut.cz (Milan Kucharik), shashkov@lanl.gov
(Mikhail J. Shashkov)

c 2012 Published by Elsevier Ltd. Open access under CC BY-NC-ND license.
1877-0509 ⃝
doi:10.1016/j.procs.2010.04.211

1886

Berndtetetal.
al./ Procedia
/ Procedia Computer
Computer Science
M.M.
Berndt
Science001 (2010)
(2012)1–8
1885–1892

2

in which the solution is transferred from the old mesh to the new improved mesh. Many mesh improvement methods
generate rather small vertex displacements when the mesh is nearly invalid. This can eventually lead to a situation,
where the rezone step cannot keep up with the mesh motion that is the result of the Lagrangian steps, and the mesh
tangles. Mesh untangling is an approach that can be taken to repair such a situation. However, this does not address
the question of how to remap physical quantities from a tangled mesh to a repaired mesh.
Several researchers have investigated the problem of untangling unstructured meshes by node repositioning [3, 4].
Freitag and Plassmann [5, 6] untangle meshes by optimization of a local function based on maximizing the minimum
element area at each mesh vertex. Knupp [7] performs a global optimization of the diﬀerence between the absolute
and signed values of element volumes in order to untangle the mesh. Kovalev et al. [4] visit each vertex connected
to at least one invalid element and reposition the vertex directly to a point in its feasible set (or kernel) to make all
connected elements valid. They deﬁne the feasible set of a vertex to be the set of all locations of the vertex for which
all elements connected to the vertex will be valid, however, in the process of ﬁnding a new location for a tangled
vertex, this feasible set is not explicitly calculated. The approach presented in [8], is based on calculating the feasible
set explicitly, and not just an approximation. This provides more ﬂexibility for choosing a vertex location, since the
feasible region is larger than its subset that is computed in [4].
We observe that, in the case of a valid mesh, the feasible set is non-empty for all vertices, and propose to use this
feasible set method as a mesh improvement method, rather than a mesh repair method for tangled meshes.
Even theoretically robust optimization based mesh relaxation methods such as the reference Jacobian or the condition number mesh smoothing method (for both, see [9]) may in some cases be inadequate as rezoning methods in
an ALE algorithm. Problems in ALE typically occur, when the mesh displacements that are generated by the rezoner
are not large enough to keep up with the mesh displacements that the Lagrangian step yields. In such a case, the mesh
can eventually tangle, requiring user intervention such as frequent restarts to ﬁne tune the ALE strategy. In contrast,
the feasible set method when used as a rezoner yields by design the largest possible mesh displacements, since these
displacements are computed based on the feasible set. It can thus be used as a rezoning method of last resort, to more
rapidly recover mesh quality around mesh nodes that are close to tangling.
The rest of this paper is organized as follows. In Section 2, we review the feasible set method and explain how it
can be used as a mesh smoothing method. In Section 3, we give an example of a simple ALE simulation that utilizes
the feasible set relaxer.
2. The feasible set method
While the feasible set method was introduced in [4, 8], it is essential to this presentation and, thus, we begin by
giving a brief overview of it here.
A mesh M in 2D consists of vertices Vi , i = 1, . . . , NV , edges Ei , i = 1, . . . , NE each of which connects two distinct
vertices, Ei = (Vi1 , Vi2 ), and cells Ci , i = 1, . . . , NC each of which is a polygon with a boundary that can be written as
NC
the union of a sequence of distinct edges ∂Ci = j=1i Ei j such that Ei j ∩ Ei j+1 ∅ and the sequence of edges traces the
boundary of Ci in counter clockwise direction. For each vertex Vi we deﬁne its patch of cells as Pi = {C j |C j ∩ Vi ∅}.
If every cell in a mesh is convex, then we call that mesh valid. An equivalent deﬁnition of mesh validity uses
corners in the mesh. A corner is an ordered pair of adjacent edges. The corners in a mesh are generated by the corners
of the cells in the mesh. A cell C that has nc edges Ei j , j = 1, . . . , nc that are ordered in a counter clock-wise direction,
gives rise to nc ordered pairs of edges (Ei j , Ei j+1 ), j = 1, . . . , nc − 1, and (Einc , Ei1 ). Clearly, if the angle between the
two edges in each ordered pair that was generated by a cell C is positive but smaller than π then C is convex. We call
such an angle valid and use this to decide whether a vertex is tangled.
We note that each vertex V that is part of the boundary of a cell C has three adjacent corners that are also part of
the cell. We denote the corner that has this vertex at its apex as the apex connected corner and the other two as the far
connected corners to vertex V in the cell C.
Deﬁnition 1. If any of the angles that are attached to a vertex V is not valid, then we call V tangled.
In order to untangle a vertex, its coordinates must be changed such that all of its attached angles are valid. To that
end, we deﬁne the Cartesian coordinates of a vertex V as (x(V), y(V)).

3
1887

M. Berndt
et al. / Procedia
Computer
Science
00 (2010)
1–8
M. Berndt
et al. / Procedia
Computer
Science
1 (2012)
1885–1892

For each vertex V in the mesh we can deﬁne the set
F M (V) = {(ξ, η) ∈ R2 | V with (x(V), y(V)) = (ξ, η) is not tangled in M}

(1)

We refer to F M (V) as the feasible set of the vertex V in the mesh M. This deﬁnition is computationally impractical
since it cannot be used to construct the feasible set. An alternative deﬁnition that can be used to construct the feasible
set is based on the intersection of half planes.
We consider a corner K that is comprised of two distinct edges E1 and E2 and three vertices V1 , V2 , and V3 , where
E1 = (V1 , V2 ) and E2 = (V2 , V3 ) (see Figure 1). The ﬁrst case of a apex connected corner is depicted on the left in

A

B

V3
E2

V2

E2
V2

α
E1

V3

α
E1

V1

V1

Figure 1: A: For a corner that is apex connected to a vertex, that vertex (in this case V2 ) can be moved to any position on the positive side of the
line deﬁned by the other two vertices (here, V1 and V3 ), while the corner remains valid. B: For a corner that is far connected to a vertex, that vertex
(in this case V3 ) can be moved to any position on the positive side of the line that is deﬁned by the other two vertices (in this case V1 and V2 ).

Figure 1. The angle α between edges E1 and E2 is between zero and π if the coordinates of vertex V2 are on the
positive side of the line through vertices V1 and V3 . The second case of a far connected corner is depicted on the right
in Figure 1. The angle α between edges E1 and E2 is between zero and π if the coordinates of vertex V3 are on the
positive side of the line through vertices V2 and V1 . The case for varying the position of vertex V2 is analogous.
To say it more abstractly, in each of these three cases the free vertex must lie inside a half plane for the corner to
be valid, i.e.
⎛ −−−−−−−−−→ −−−−−−→ ⎞
⎜ (V2 , (ξ, η)) × (V2 , V3 ) ⎟⎟
−1 ⎜
(2)
H1 (K) = {(ξ, η) | 0 < cos ⎜⎜⎜⎝ −−−−−−−−−→ −−−−−−→ ⎟⎟⎟⎠ < π}
(V2 , (ξ, η)) (V2 , V3 )
⎛ −−−−−−−−−→ −−−−−−−−−→ ⎞
⎜⎜ ((ξ, η), V1 ) × ((ξ, η), V3 ) ⎟⎟
H2 (K) = {(ξ, η) | 0 < cos−1 ⎜⎜⎜⎝ −−−−−−−−−→ −−−−−−−−→ ⎟⎟⎟⎠ < π}
(3)
((ξ, η), V1 ) ((ξ, η), V3 )
⎛ −−−−−−→ −−−−−−−−−→ ⎞
⎜ (V2 , V1 ) × (V2 , (ξ, η)) ⎟⎟
−1 ⎜
(4)
H3 (K) = {(ξ, η) | 0 < cos ⎜⎜⎜⎝ −−−−−−→ −−−−−−−−−→ ⎟⎟⎟⎠ < π}
(V2 , V1 ) (V2 , (ξ, η))

For a particular vertex V in the interior of mesh M, we can construct F M (V) by intersecting a number of half
planes. As noted above, each cell that is adjacent to V contains three corners that are adjacent to V. Enumerate the V
adjacent cells as C j1 , . . . , C jnc and the corners in the adjacent cell with index ji as Kkj1i , Kkj2i , Kkj3i in counter clock-wise
direction relative to cell C ji , then the feasible set for vertex V can be written as
nc

F M (V) =

i=1

H1 (Kkj1i ) ∩ H2 (Kkj2i ) ∩ H3 (Kkj3i )

(5)

4

Berndtetetal.
al./ Procedia
/ Procedia Computer
Computer Science
M.M.
Berndt
Science001 (2010)
(2012)1–8
1885–1892

1888

In Figure 2, we give an example of a patch that consists of four cells. In part A, we label the cells and the corners
in each cell that are adjacent to the vertex in the center according to the labeling scheme described above. In the parts

B

A
K34 K13
C3
C4
K14 K24 K23 K 3
3
K31 K21 K 2 K 2
2
1
C1
C2
K11 K32

H2 (K23 )

H2 (K24 )

C

D

H1 (K12 )
H1 (K11 )

H2 (K21 )
H3 (K13 )

H1 (K14 )
H1 (K13 )

H2 (K22 )

H3 (K12 )

H3 (K14 )

H3 (K11 )

Figure 2: An example of the construction of the feasible set by the successive intersection of half planes. In part A, the labeling of cells and corners
j
j
j
is deﬁned, and in parts B through D the half planes that are generated by the corners of the three types K2 , K1 , and K3 are intersected. The half
j

planes Hi (Kk ) are each delineated by a dotted line. The arrow from the label points to the side of the line inside the half plane. The feasible set for
the center vertex is the most darkly shaded polygon in part D.

B through C, we generate the feasible set by successive intersections of half planes. In part B, we begin by intersecting
the half planes that are generated by the apex connected corner in each cell. Recall that these apex connected corners
i
i
are labeled K2j in cell Ci j and that the associated half plane is denoted by H2 (K2j ). The polygon that results as the
intersection of these four half planes is lightly shaded. In part C of Figure 2, we illustrate the further successive
intersection of the half planes that are generated by the far connected corners of the type (3). The resulting polygon
is shaded darkly, while we also for reference display the polygon that resulted in part B. In part D of Figure 2, we
illustrate the remaining intersections of with half planes that are generated by the far connected corners of type (4).
Again, for reference, we display the polygon that resulted in part C. Most darkly shaded is the polygon that is the
feasible set.
Note that none of the half planes in (5) depend on the location of V. Therefore, the feasible set is really a function
of the patch of cells that is adjacent to vertex V. In particular, the speciﬁc location of the edges that are adjacent to V
plays no role in the construction of the feasible set.
For a vertex that is interior to the mesh, the feasible set is not empty if the vertex only has valid adjacent corners.
However, if some of its adjacent corners are not valid, its feasible set may be empty. Also, by construction, the feasible
set is a convex polygon, if it is not empty.
For vertices that lie on the boundary of the mesh, the same construction of the feasible set can be used as for
interior vertices. The diﬀerence is that the feasible set of a boundary vertex, if it is not empty, may not be bounded.
If it is bounded, and not empty, the feasible set is, by construction a convex polygon. Analogously to the case of an
interior vertex, the feasible set of a boundary vertex is not empty, if all its adjacent corners are valid.

M. Berndt
et al. / Procedia
Computer
Science
00 (2010)
1–8
M. Berndt
et al. / Procedia
Computer
Science
1 (2012)
1885–1892

5
1889

2.1. The feasible set method as a mesh improvement method
The feasible set method can be employed as a robust local mesh relaxation technique. For a valid mesh, the
feasible set method will by design always yield a non empty feasible set. This requires that vertices are updated one
at a time (Gauss Seidel type sweep) and not all at once (Jacobi type sweep). The Gauss Seidel sweep is diﬃcult to
parallelize, and will in addition lead to mesh imprinting that is driven by the order in which the positions of mesh
vertices are updated. An alternative approach that is easily parallelizeable and does not produce any vertex order
induced mesh imprinting is the damped Jacobi sweep. First, the feasible set and the associated new vertex position
and its associated vertex displacement is computed for all eligible vertices. This new vertex position is based on old
mesh data, as the mesh is not updated during this step. Then a global damping parameter 0 < δ < 1 is multiplied with
all vertex displacements. This damped update constitutes the damped Jacobi mesh displacement. In our experience,
a damping factor of δ = 0.5 will work well in most cases. If the damping factor is chosen too close to one, ’ringing’
can result, where the neighboring mesh vertices start oscillating back and forth from rezone step to rezone step. In our
experience, the feasible set method can generate rather large vertex displacements. This behavior can be counteracted
by stronger damping of the displacements, however, as we will see in Section 3, these large displacements can be a
desirable feature.
An alternative approach that has proved to be successful is to mark mesh cells that are close to being invalid and
only apply the feasible set relaxer to vertices that are part of these marked cells. The rather large vertex displacements
tend to bring such nearly invalid mesh cells back from the brink, and place the marked vertices far away from an
invalid/tangled position.
2.2. Vertex placement inside the feasible set
For a particular valid vertex and its patch in a mesh, the feasible set can be computed and then an improved
placement for the vertex determined. By construction, this feasible set is a convex polygon. A simple choice that will
always yield a valid vertex position inside its convex feasible set is the arithmetic average of all corners of the feasible
set. Denote by (xi , yi ), i = 1, . . . , N the corners of a convex polygon, then the arithmetic average vertex position
(xavg , yavg ) is
xavg =
yavg =

N

1
N
1
N

xi

(6)

yi .

(7)

i=1
N
i=1

While this arithmetic average is very easy to compute, it has one obvious drawback that we illustrate in Figure 3. In
the case where corners of the feasible set are clustered in one area, the arithmetic average of its corners will be biased
toward that cluster, since it depends on the coordinates of the corners of the feasible set. A better choice for a relaxed

(x3 , y3 )
(x4 , y4 )
(x5 , y5 )
(x6 , y6 )

(xc , yc )

(x2 , y2 )

(xavg , yavg )
(x7 , y7 )

(x1 , y1 )

Figure 3: A convex polygon with corners that are clustered. The arithmetic average of its corners (xavg , yavg ) is biased toward that cluster, while its
centroid (xc , yc ) is not (the positions of the arithmetic average and the centroid in this schematic are approximate).

vertex position inside the feasible set is its centroid. The centroid of a convex polygon is always inside that polygon,

1890

Berndtetetal.
al./ Procedia
/ Procedia Computer
Computer Science
M.M.
Berndt
Science001 (2010)
(2012)1–8
1885–1892

6

and its location depends only on the shape of the polygon and is not biased by clusters of corners of the polygon. The
centroid of a closed polygon (xc , yc ) can easily be calculated by
xc =
yc =

1
6A
1
6A

N

(xi + xi+1 )(xi yi+1 − xi+1 yi )

(8)

(yi + yi+1 )(xi yi+1 − xi+1 yi ),

(9)

i=1
N
i=1

where A is the area of the polygon
A=

1
2

N
i=1

(xi yi+1 − xi+1 yi ),

(10)

and for convenience of notation (xN+1 , yN+1 ) ≡ (x1 , y1 ). We use the centroid of the feasible set as the target vertex
position.
3. A hydro example
We now give an example of a simple ALE calculation that employs our feasible set relaxer. We implemented the
relaxer in an ALE code that is based on the staggered grid compatible hydrodynamics scheme presented in [10].

Γu

Ω1

Ω2

Γl

Figure 4: The computational domain for the example is the unit square. Vertices are allowed to slide along the outside boundary, however they
are ﬁxed along the interior boundaries Γu and Γl . The gas inside the computational domain is initialized to have higher energy in Ω1 than in Ω2 .
As a result, the gas will rapidly expand from Ω1 into Ω2 and almost immediately cause the computational mesh to become nearly tangled near the
opening (the upper end of Γl and the lower end of Γu .

Figure 4 depicts the computational domain Ω(0, 1) × (0, 1). The computational domain is divided into two subdomains Ω1 = (0.5, 1) × (0, 1) and Ω2 = (0.5, 1) × (0, 1). The initial mesh on each of these two subdomains is logically
rectangular; on Ω1 , the mesh consists of 25 × 50 cells, and on Ω2 , the mesh consists of 5 × 50 mesh cells. As a result,
the mesh resolution is much lower in the x-direction on Ω2 than on Ω1 . Vertices in the mesh are allowed to slide
along the outside boundary of the domain ∂Ω, but are ﬁxed along the interior boundaries Γl = {0.5} × [0, 0.3] and
Γu = {0.5} × [0.7, 1].
The problem domain is occupied by a gamma law gas with γ = 5/3, a minimum sound speed of 0.001, and a
density of 1.0. It is initialized with an energy of 0.1 in Ω1 and 0.0 in Ω2 .
When run in pure Lagrangian mode, the computational mesh tangles after only a few time steps, at the tips of the
interior boundaries Γl and Γu . We use the feasible set relaxer with triggers: A vertex is marked as to be relaxed, when

M. Berndt
et al. / Procedia
Computer
Science
00 (2010)
1–8
M. Berndt
et al. / Procedia
Computer
Science
1 (2012)
1885–1892

7
1891

Figure 5: Snapshots of the initial computational mesh (left top) and of the mesh after 93 (right top), 1198 (left middle), 5273 (right middle), 11350
(left bottom) and 15882 cycles (right bottom) of the example problem outlined in Section 3. The meshes show quite a severe distortion around the
corners of the opening between Γl and Γu . With the help of the feasible set relaxer, it is possible to run the simulation to impressively late time.

one of its attached angles is smaller than 30◦ or larger than 150◦ , or when the aspect ratio is larger than ten. We use
one damped Jacobi sweep per time step over these marked vertices with a damping factor of 0.7.
Figure 5 depicts six snapshots of the computational mesh of the initial mesh and the mesh after cycles 93, 1198,
5273, 11350 and 15882, which corresponds to problem times 0.0, 1.0090388, 2.0006902, 3.0002201, 4.0002856 and

1892

Berndtetetal.
al./ Procedia
/ Procedia Computer
Computer Science
M.M.
Berndt
Science001 (2010)
(2012)1–8
1885–1892

8

5.0003796 seconds. This example highlights that with this rezoning strategy alone, the simulation can run to an
impressively late time. Note that, in this example, the emphasis is not creating a high quality mesh, but simply on
preserving a valid mesh. Consequently, the feasible set method should be combined with another mesh improvement
method that can generate meshes of better quality.
4. Conclusions
We have presented a new 2D rezone strategy for ALE methods, which is based on the feasible set method. If used
in a Gauss-Seidel type sweep, this rezone method is robust; it will never create a tangled mesh from a mesh that is not
tangled. In practice, the perhaps more desirable damped Jacobi sweep proves to be quite robust as well. This feasible
set rezone strategy if employed by itself can generate meshes that are valid but of low quality. We recommend to
combine it with another rezone strategy such as Winslow, to improve the quality of the resulting meshes.
5. Acknowledgments
This work was performed under the auspices of the US Department of Energy by Los Alamos National Laboratory
under contract DE-AC52-06NA25396, LA-UR 09-07380.
References
[1] C. W. Hirt, A. A. Amsden, J. L. Cook, An Arbitrary Lagrangian-Eulerian computing method for all ﬂow speeds, Journal of Computational
Physics 14 (1974) 227–253.
[2] L. G. Margolin, Introduction to ”An arbitrary Lagrangian-Eulerian computing method for all ﬂow speeds”, Journal of Computational Physics
135 (1997) 198–202.
[3] T. S. Li, Y. C. Wong, S. M. Hon, R. M. M. C. G. Armstrong, Smoothing by optimisation for a quadrilateral mesh with invalid elements, Finite
Elements in Analysis and Design 34 (2000) 37–60.
[4] K. Kovalev, M. Delanaye, C. Hirsch, Untangling and optimization of unstructured hexahedral meshes, in: S. A. Ivanenko, V. A. Garanzha
(Eds.), Proceedings of Workshop on Grid Generation: Theory and Applications, Russian Academy of Sciences, Moscow, Russia, 2002,
http://www.ccas.ru/gridgen/ggta02/papers/Kovalev.pdf.
[5] L. Freitag, P. Plassmann, Local optimization-based simplicial mesh untangling and improvement, International Journal of Numerical Methods
for Engineering 49 (2000) 109–125.
[6] L. Freitag, P. Plassmann, Local optimization-based untangling algorithms for quadrilateral meshes, in: Proceedings of the Tenth Anniversary
International Meshing Roundtable, Sandia Report, SAND 2001-2976C, Newport Beach, CA, 2001, pp. 397–406.
[7] P. M. Knupp, Hexahedral and tetrahedral mesh untangling, Engineering with Computers 17 (2001) 261–268.
627–644.
[9] P. M. Knupp, L. G. Margolin, M. J. Shashkov, Reference Jacobian optimization-based rezone strategies for arbitrary Lagrangian Eulerian
methods, Journal of Computational Physics 176 (2002) 93–128.
[10] E. J. Caramana, D. E. Burton, M. J. Shashkov, P. P. Wahlen, The construction of compatible hydrodynamics algorithm utilizing conservation
of total energy, Journal of Computational Physics 146 (1998) 227–262.

