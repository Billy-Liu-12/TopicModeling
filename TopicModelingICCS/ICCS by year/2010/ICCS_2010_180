Procedia Computer
Science
Procedia Computer
Procedia
ComputerScience
Science001(2010)
(2012)1–10
2689–2698

www.elsevier.com/locate/procedia

International Conference on Computational Science, ICCS 2010

Web service selection for transactional composition
Yudith Cardinalea , Joyce El Haddadb , Maude Manouvrierb,c,∗, Marta Rukozb,c,d,1
a Universidad

Sim´on Bol´ıvar, Departamento de Computaci´on y T. I., Apartado 89000, Caracas 1080-A, Venezuela
Paris-Dauphine, LAMSADE, CNRS FRE 3234, Place de Lattre de Tassigny, F-75016 Paris, France
Federation of the three database research teams, LIP6 (Paris 6 Univ.), LAMSADE and CEDRIC (CNAM)
d Universit´
e Paris Ouest Nanterre La D´efense, 200 Avenue de la R´epublique, 92001 Nanterre, France

b Universit´
e

c WISDOM,

Abstract
In this work we address the issue of selecting and composing Web Services (WSs) considering functional requirements and transactional properties. We formalize the WS composition problem using the user query, the transactional
properties of WSs and the composite WSs deﬁnition. We extends Colored Petri Net (CPN) formalism to incorporate
transactional WSs properties. We present a CPN-WS selection algorithm that satisﬁes the user query functional conditions expressed as input and output attributes, and transactional properties expressed as a risk level. Our algorithm
allows to construct a Colored Petri-Net representing a Transactional Composite WS.
c 2012 Published by Elsevier Ltd. Open access under CC BY-NC-ND license.
⃝

Keywords: Web Services, Automatic Transactional Composition, Colored Petri Net

1. Introduction
Web Services (WSs) are the most famous implementation of Service-Oriented Architectures (SOA) allowing
the construction and the sharing of independent and autonomous software. To ensure eﬃcient implementations of
compositions, we have to adequately manage heterogeneity, i.e., diverse functionality (e.g., ticket purchase, payment)
and diverse transactional behavior (e.g., compensatable or not) granted by multiple distributed services delivering
the same functionality. The interoperation of distributed software-systems is always aﬀected by failures, dynamic
changes, availability of resources, and others. These eﬀects are non-functional aspects and are caused by the nature of
distributed software-systems [1]. In this context, a service that does not provide a transactional property might be as
useless as a service not providing the desired functional results. If the composition is based on simple WSs considering
only functional requirements, then it is possible that during the execution, the whole system becomes inconsistent in
presence of failures. Selection of transactional WSs allows the system to guarantee reliable composition execution.
Indeed, the execution of transactional WSs will leave the system in a consistent state even in presence of failures.
The WS composition problem has been extensively treated in the literature by using a predeﬁned control structure
(comprised of abstract processes to meet the functional user request, and the order in which they must be evaluated)
such as workﬂows [1, 2, 3], Advanced Transactional Models (ATM) [4, 5, 6] and Petri Net [7]; or by automatically
∗ Corresponding

author
Email addresses: yudith@ldc.usb.ve (Yudith Cardinale), elhaddad@lamsade.dauphine.fr (Joyce El Haddad),
manouvrier@lamsade.dauphine.fr (Maude Manouvrier), Marta.Rukoz@dauphine.fr (Marta Rukoz)
1 On leave from Universidad Central de Venezuela.

c 2012 Published by Elsevier Ltd. Open access under CC BY-NC-ND license.
1877-0509 ⃝
doi:10.1016/j.procs.2010.04.302

2690

et al. / Procedia
(2012) 2689–2698
Cardinale,Y.ElCardinale
Haddad, Manouvrier,
RukozComputer
/ Procedia Science
Computer1 Science
00 (2010) 1–10

2

discovering the services and their control ﬂow [8, 9]. In workﬂows and Petri Nets, the execution control is deﬁned by
the structure of the workﬂow or the Petri Net respectively, while in ATM approaches, it is explicitly deﬁned within
the application logic. In all these approaches the problem is to identify resources or concrete services for each of the
abstract processes. Several systems based on these approaches have been proposed. Kepler [10], Taverna [11] and
Triana [12] are based on workﬂows. In the two former systems, the concrete services are identiﬁed manually and in
the later it is realized automatically. Fenecia [5] based on nested transactions assumes that the process of concrete
services discovery and selection is performed automatically.
In approaches where the control ﬂow is discovered by the composer, functional requirements are usually speciﬁed
in terms of the set of input attributes that will bound in the query, and the set of attributes that will be returned as
the output. Among these approaches, several are based on search meta-heuristics. In this context several works have
been proposed. In [9], the authors propose the speciﬁcation of WSs’ functional semantics with an ontology. In this
sense, Composite Web Services (CWSs) are represented by a graph which describes the relations among the services
in terms of input/output attributes and functional semantics. Both, attributes and functional semantics, are deﬁned by
diﬀerent ontologies. Users have to provide the desired functionality, along with the input and output attributes. In [13]
and [14] the available services are classiﬁed according to their functionalities, where each set of services with the
same functionality is called a community service or meta-service. The authors build abstract CWSs which consist of
community services (or meta-services), and then substitute each community service with concrete services. Although
the goal of their method is to improve the dynamism of composition, it is also helpful to improve the time complexity
of the composition process by reducing the search space. In [8, 15] the Service Aggregation Matchmaking (SAM)
algorithm is deﬁned. It makes use of an OWL-S ontology, and explicitly returns a sequence of atomic processes that
need to be executed in order to achieve the desired result. SAM follows a greedy approach in which only one sub-plan
is generated in each iteration and is able to scale up in environments with a moderated number of services (e.g., in the
range of 100 to 200 services). In [16], the authors propose an approach for the WS composition problem based on
Petri Net coverability. Web Services are represented into a Petri Net by merging the places with the same semantics
and the coverability tree and the coverability graph are built from the Petri Net and the user’s input/output attributes.
The composition is then represented by the services in the shortest path in the coverability graph that satisﬁes the
user’s request. [17, 18] propose Colored Petri Net based service model to represent data ﬂow and service behaviors.
Colors represent the diﬀerent types of the input/output attributes (meta messages). In this sense, the WS composition
problem relies on messages, which increase complexity of composition because the search space is not pruned and
many solutions can be produced. However, none of these approaches takes into account the transactional behavior of
the CWS.
In this work, we propose a hybrid solution that takes advantage of search meta-heuristics techniques to consider
functional conditions expressed as input and output attributes, and transactional properties expressed as a risk level.
We use CPN model because it allows to describe not only a static vision of a system, but also its dynamic behavior; it is
expressive enough to capture the semantics of complex WS combinations and their respective interactions. We extend
CPN formalism to incorporate transactional WSs properties and adapt a Petri Net unfolding algorithm to perform a
Best-First Search which stops when a desired marking, reachable from an initial marking in the CPN, is found. The
initial marking represents the input attributes and the risk level provided in the query. The unfolding method is guided
by the aggregated transactional properties, therefore, its result corresponds to a composition of WSs that satisﬁes
the functional and risk level user requirements. We formalize the Transactional WS composition problem adopting
from [19] the query deﬁnition and taking from [3] the deﬁnitions of transactional properties of WSs and composite
WSs. This article presents our CPN-WS selection algorithm for transactional WS composition.
2. Deﬁnitions
In this section we deﬁne the framework of our approach by presenting our formal deﬁnitions.
Def. 1. Query. Let OntoA be the integrated ontology2 . A query Q is a 3-tuple (IQ , OQ , RQ ), where IQ = {i | i ∈ OntoA

is an input attribute}, OQ = {o | o ∈ OntoA is an output attribute whose value has to be produced by the system}, and
2 Many

ontologies could be used and integrated.

Y. Cardinale
et al.Manouvrier,
/ Procedia Rukoz
Computer
Science
1 (2012)
2689–2698
Cardinale,
El Haddad,
/ Procedia
Computer
Science
00 (2010) 1–10

2691
3

RQ is the execution risk, such that: RQ ∈ {R0 , R1 }. If RQ = R0 , then the system guarantees that if the execution is
successful, the obtained results can be compensated by the user (i.e., the user can execute another application that
semantically undoes the previous one). If RQ = R1 , then the system does not guarantee the result can be compensated
by the user in case of successful execution. In both execution risk cases, if the execution is not successful, then no
result is reﬂected to the system i.e., nothing is changed on the system.
The result of this query can be obtained by a Composite Web Service (CWS), i.e., a conglomeration of existing
WSs interacting together to oﬀer a new value-added service. The WSs composing a CWS are called components. In
this article, WSs and CWSs are transactional, using the following deﬁnitions:
Def. 2. Transactional WS. Let s be a WS. s is said to be pivot (p) if once it successfully completes, its eﬀects remains
forever and cannot be semantically undone. If it fails then it has no eﬀect at all. A completed pivot WS cannot be
rolled back. s is compensatable (c) if it exists another WS, s , which can semantically undo the execution of s. s is
retriable (r) if it guarantees a successfully termination after a ﬁnite number of invocations. The retriable property
can be combined with properties p and c deﬁning pivot retriable (pr) WS and compensatable retriable (cr) WS. Thus,
the transactional property (TP) of a WS s is T P(s) ∈ {p, pr, c, cr}.
Def. 3. Transactional Composite Web Service (TCWS). Let cs be a CWS. cs is atomic (a) if once all its component

WSs complete successfully, their eﬀect remains forever and cannot be semantically undone. On the other hand, if one
component WS does not complete successfully, then all previously successful component WSs have to be compensated.
cs is compensatable (c) if all its component WSs are compensatable and cs is retriable (r) if all its component WSs
are retriable. The retriable property can be combined with properties a and c deﬁning atomic retriable (ar) CWS and
compensatable retriable (cr) CWS. Thus, cs is a TCWS if its transactional property is in {a, ar, c, cr}.
The WS registry can be modeled by a Petri Net – see for example [20, 18, 17, 7, 16]. In this article, we choose
to model it by a Colored Petri-Net whose deﬁnition is modiﬁed in such way that the WS registry is represented by a
Web Service Dependency Net (WSDN) deﬁned as:
Def. 4. WSDN. A WSDN is a 4-tuple (A, S , F, ξ), where: A is a ﬁnite non-empty set of places, corresponding to input

and output attributes of the WSs in the registry such that A ⊂ OntoA ; S is a ﬁnite set of transitions corresponding to
the set of WSs in the registry; F : (A × S ) ∪ (S × A) → {0, 1} is a ﬂow relation indicating the presence (1) or the
absence (0) of arcs between places and transitions deﬁned as follows: ∀s ∈ S , (∃a ∈ A | F(a, s) = 1) ⇔ (a is an input
place of s) and (∃a ∈ A | F(s, a) = 1) ⇔ (a is an output place of s); ξ is a color function such that ξ : C A ∪ CS with
C A : A → ΣA is a color function such that ΣA = {I, a, ar, c, cr} that represents for a ∈ A either the TP of the CWS
that can produce it or the user input (I); and CS : S → ΣS is a color function such that ΣS = {p, pr, a, ar, c, cr} that
represents the TP of s ∈ S .
The ﬁring of a transition of a WSDN corresponds to the selection of a WS (or CWS), which will participate in the
composition of a CWS allowing to answer the user query Q. In this article, we only focus on transactional composition
of WSs satisfying the user’s functional and risk level requirements. Therefore, we deﬁne the marking of a WSDN,
the f ireable property of a transition, and the f iring rules in such way we obtain, at the end, a TCWS, as deﬁned in
Def. 3.
Def. 5. Marked WSDN. A marked Web Service Dependency Net is a pair (WS DN, M), where M is a function which
assigns tokens (values) to places such that ∀a ∈ A, M(a) ⊆ {∅, Bag(ΣA )} where Bag corresponds to a set which can
contain several occurrences of the same element. The marking of a WSDN represents the current state of the system,
i.e., the set of attributes values produced by the system.
Def. 6. Initial Marking (MQ ). The initial marking MQ depends on the user query Q and is deﬁned as:

∀a ∈ (A ∩ IQ ), MQ (a) = {I} and ∀a ∈ (A − IQ ), MQ (a) = ∅.

For each x ∈ A ∪ S of the WSDN, let (• x) = {y ∈ A ∪ S : F(y, x) = 1} be the set of its predecessors and
(x ) = {y ∈ A ∪ S : F(x, y) = 1} be the set of its successors. Depending on the initial marking, some transitions can be
ﬁred. To determine if a transition s ∈ S is ﬁreable, we have to analyze (i) the color of its input places (x ∈ • s), (ii) its
own color (CS (s)), and (iii) the color of the other attribute places (a ∈ (A−• s)). We have the following deﬁnition:
•

2692

et al. / Procedia
(2012) 2689–2698
Cardinale,Y.ElCardinale
Haddad, Manouvrier,
RukozComputer
/ Procedia Science
Computer1 Science
00 (2010) 1–10

4

I

c

;c
//c
;cr
//cr

c

p

;pr //cr
;cr
;pr ;p
a
;ar ;a
;ar
;c
//c

a

pr

cr
;cr

;p //p
;a //a

cr

ar

//cr
;ar
;pr //pr
//ar
ar
;ar //ar
;pr
//cr
//pr;cr

Figure 1: Automaton modeling the possible transactional properties of the components of a TCWS (from [3]).

Def. 7. Fireable transition. A marking M enables a transition s iﬀ all its input places contain a token (∀x ∈ ( • s),

M(x) ∅) and at least one of the following conditions is veriﬁed:
1. ( ∀a ∈ A, M(a) ∈ {I, ∅ } )
2. ( CS (s) = cr )
3. ( CS (s) ∈ {pr, ar} ) ∧ [ ∀a ∈ (A−• s), M(a) ∈ {∅, Bag({I, ar, cr})} ]
4. ( CS (s) = c ) ∧ [ ∀a ∈ (A−• s), M(a) ∈ {∅, Bag({I, c, cr})} ] ∧ [ ∀x ∈ • s, M(x) ∈ Bag({I, c, cr})]
5. ( CS (s) ∈ {p, a} ) ∧ [ ∀a ∈ (A−• s), M(a) ∈ {∅, Bag({I, cr})} ] ∧ [∀x ∈ • s, M(x) ∈ Bag({I, c, cr}) ]

Tokens assigned by M, whose color is diﬀerent from I, are produced by transitions already ﬁred. More precisely,
if WS s is selected, then colors of the tokens in places a ∈ (A−• s) correspond to the Transactional Properties (TP) of
the WSs that might be executed in parallel with WS s whereas colors of the tokens in places x ∈ (• s) correspond to the
TP of the WSs that might be executed in sequential with WS s. The ﬁreable conditions of Def. 7 are deduced from
the automaton of Figure 1 whose states model all the possible TP of a TCWS and whose arc labels model the TP of
the component WSs. Label ”; t” represents a sequential execution and label ”//t” represents a parallel execution with
a WS whose TP is t (t ∈ ΣS ). For example, in condition 3, the marking of places a ∈ (A−• s) is deduced from the arcs
labeled by ”//t”, with t ∈ {ar, cr}, leaving from state ar (a pr or ar WS can only be executed in parallel with retriable
WSs). On the other hand, there is no condition on the marking of places (x ∈ • s), when the color of s is pr or ar,
because there is an arc with label ”; pr” leaving from all the ﬁnal states of the automaton (any WS can be executed in
sequential with a (previous) pr or ar WS).
To know the TP of the resulting CWS (composed by all the WSs corresponding to the ﬁred transitions), we deﬁned
the color associated with a marked WSDN by:
Def. 8. Color of a Marked WSDN. The color of a marked WSDN (WS DN, M) is: C M ∈ {I, a, ar, c, cr}. C M = I,
when no transition has been ﬁred (i.e., when no WS has been selected and there is no resulting CWS). Otherwise, C M
represents the TP of the resulting CWS and is updated each time a transition is ﬁred.

Due to a WS should be selected only one time to be a component of the resulting CWS, when a transition is ﬁred,
tokens are added to its output places and all the tokens are deleted from its input places (except from places that belong
to OQ ), using the following rules:
Def. 9. Firing rules.3 The ﬁring of a ﬁreable transition s for a marking M deﬁnes a new marking M , denoted as
s

M → M , such that :
1. Tokens are added to the output places of s depending on the color of s and on the color of the tokens contained by
the input places of s, according to the following rules :
if ( ∃x ∈ (• s) | a ∈ M(x) ) , then ∀y ∈ (s• ), M (y) ← M (y) ∪ {a}
else if ( ∃x ∈ (• s) | ar ∈ M(x) ), then ∀y ∈ (s• ), M (y) ← M (y) ∪ {ar}
else if ( ∃x ∈ (• s) | c ∈ M(x) ) and if ( CS (s) ∈ {p, pr, a, ar} ), then ∀y ∈ (s• ), M (y) ← M (y) ∪ {a}
else if ( ∃x ∈ (• s) | c ∈ M(x) ) and if ( CS (s) ∈ {c, cr} ), then ∀y ∈ (s• ), M (y) ← M (y) ∪ {c}
else4 ∀y ∈ (s• ), M (y) ← (M (y) ∪ CS (s)) if CS (s) ∈ {a, ar, c, cr}, M (y) ← (M (y) ∪ {a}) if CS (s) = p,
and M (y) ← M (y) ∪ {ar} if CS (s) = pr
3 These
4 In

rules are deduced from the transactional rules of CWS deﬁned in [3] (see Fig. 1).
this case, we are in the following situation: ∀x ∈ ( • s), M(x) ∈ Bag({I, cr}).

Y. Cardinale
et al.Manouvrier,
/ Procedia Rukoz
Computer
Science
1 (2012)
2689–2698
Cardinale,
El Haddad,
/ Procedia
Computer
Science
00 (2010) 1–10

2693
5

2. Tokens are deleted from input places of s, if they do not belong to OQ : ∀x ∈ (• s − OQ ), M(x) ← ∅,
3. Color C M of the resulting (WS DN, M ) (see Def. 8) is updated, according to the following rules:
if (C M ∈ {I, cr}) and CS (s) = p then C M ← a
else if (C M ∈ {I, cr}) and CS (s) = pr then C M ← ar
else if (C M ∈ {I, cr}) and CS (s) ∈ {a, ar, c, cr} then C M ← CS (s)
else if (C M = c}) and CS (s) ∈ {p, pr, a, ar} then C M ← a
else C M ← C M .
σ

Def. 10. Firing sequence. A ﬁring sequence σ = {s1 , . . . , sn | si ∈ S } is such that MQ → Mn iﬀ there are markings
s1

sn

M1 , ..., Mn with MQ → M1 . . . Mn−1 → Mn .

Note that a ﬁring sequence σ corresponds to a set of ﬁred transitions, that in fact represents the selection of several
WSs, s1 ...sn , components of the resulting TCWS, whose TP is C Mn .
σ

Def. 11. Reachable marking. A marking M is reachable if ∃σ such that: MQ → M.

Since the selection of two WSs which produce the same outputs is not useful, we have the following deﬁnition of
a cut-oﬀ transition:
Def. 12. Cut-oﬀ transition. Let O M be the set of the produced attributes by a ﬁring sequence σ such that: O M n =
σ

{a ∈ (∪(s•i )|si ∈σ ) | MQ → Mn }. A transition s is said to be a cut-oﬀ transition iﬀ its ﬁring does not change the set of the
σ

s

already produced attributes, i.e., iﬀ: MQ → Mn → Mn+1 and O Mn = O Mn+1 .

When several transitions are ﬁreable, to select which transition has to be ﬁred, we propose a quality measure of a
transition s which depends on the user query Q such that:
Def. 13. Quality associated with a transition. The quality of a transition si ∈ S , called QualityQ (si ), is deﬁned as:
card((s• )• )

QualityQ (si ) = g(CS (si )) × (card(OQ ∩ s•i ) + 1) × 1 + card(Si )
with g : S → N, a function such that g(p) = g(a) < g(pr) = g(ar) < g(c) < g(cr).
Function g allows to select a transition whose transactional property is the less restrictive. An example of g is:
g(p) = g(a) = 1, g(pr) = g(ar) = 2, g(c) = 3, and g(cr) = 4. (card(OQ ∩ s•i ) + 1) gives more chance to select
card((s• )• )
transitions producing more required outputs. 1 + card(Si ) increases the quality to those transitions which will allow
more transitions to be ﬁreable.
When several transitions have the same quality one of them is randomly selected. Our problem consists in discovering and selecting the WSs of the registry whose composition satisﬁes the functional and the transactional requirements of the user, such that:
Def. 14. The WS Composition Problem-(WSC Problem): Given an user query Q and a WSDN, the WSC Problem
consists in determining a Colored Petri Net WS DNσQ , sub-part of WSDN, created from the ﬁring sequence σQ , such
σQ

that: MQ → MF with MQ , the initial marking (see Def. 6) and MF , a reachable marking such that: ∀a ∈ (A ∩ OQ ),
MF (a) ∈ {c, cr}, if RQ = R0 , and ∀a ∈ (A ∩ OQ ), MF (a) ∈ {a, ar, c, cr}, if RQ = R1 and, such that the composition of
all the WSs corresponding to the transitions of σQ represents a TCWS.
3. Our Approach
We propose an automatic WS selection algorithm to resolve the WSC Problem. The input of our algorithm is the
user query Q and the WSDN, representing dependencies among the WSs of the registry and their input and output
attributes. Its output is, if it exists, a Colored Petri Net (CPN), WS DNσQ , representing the set of the transactional WSs
selected to participate in the composition. Our CPN-WS selection algorithm is composed by 4 steps. Step 1 veriﬁes
the validity of Q. Step 2 identiﬁes the WSs of the registry (i.e., the transitions of the WSDN) that may be useful to
produce the outputs of Q by considering the transactional properties that satisfy the risk level. Step 3 returns a ﬁring

2694

et al. / Procedia
(2012) 2689–2698
Cardinale,Y.ElCardinale
Haddad, Manouvrier,
RukozComputer
/ Procedia Science
Computer1 Science
00 (2010) 1–10

6

sequence σQ containing the component WSs of a TCWS required to evaluate Q. Step 4 returns a Colored Petri Net,
WS DNσQ , built from σQ and allowing to execute the resulting TCWS.
We also propose an algorithm to create the WSDN from the registry. The following sections describe the WSDN
creation algorithm and the 4 steps of the CPN-WS algorithm. Note that, due to the space limitation, proofs of the
proposed algorithms are not included in the article.
3.1. Creation of WSDN, the Colored Petri Net representing the WS registry
Algorithm 1: Adding a WS s into a WSDN
Input: WS DN, a Web Service Dependency Net (eventually empty) and s, a WS of the registry to be added in WSDN
Output: WS DN after adding s
1. Web Service s is mapped to a transition and is added to S ,
2. All input attributes of s are mapped into places and are added to set A if it does not already exist a place with the
same semantic or if it exists one with at least one successor:
∀i ∈ I s , if [ a ∈ A | ( semantic(i) = semantic(a) ) ] ∨ [ (∃a ∈ A) | ( semantic(i) = semantic(a) ) ∧ (a• ∅) ],
then create a corresponding place i ∈ A and F(i, s) → 1,
3. Every output attributes of s are mapped into places and are added to A, if it does not already exist a place with the
same semantic:
∀o ∈ O s , if [ a ∈ A | ( semantic(o) = semantic(a) ) ], then create a corresponding place o ∈ A and F(s, o) → 1,
4. An arc to s is created from any place having no successor and representing an input attribute of s:
∀a ∈ (I s ∩ A), if (a• = ∅), then F(a, s) ← 1,
5. An arc is created from s to each place a of WSDN having the same semantic than an output place of s:
∀a ∈ A, if [ ∃o ∈ (s• ) | ( semantic(a) = semantic(o) ) ], then F(s, o) ← 1,
6. For all transitions t of WSDN having an output place o with the same semantic than an input place i of s,
add an arc (t, i): ∀t ∈ S , if [ ( ∃o ∈ (t• ) ) ∧ ( ∃i ∈ ( • s) ) | ( semantic(o) = semantic(i) ) ], then F(t, i) ← 1.

Let s be a WS of the registry, whose input attribute set is I s and output attribute set is O s . The creation of WSDN
is done by adding one service at a time, using Algo. 1.
Note that, using this algorithm no exclusive transition exists because we duplicate input places (see Item 2 of
Algo. 1), then each place of a WSDN has zero or one successor. This is because we want to model the fact that
the execution of a WS s cannot forbid the execution of another WS s which would have the same input attributes (s
and s are independent even if they have the same input attributes). However, the execution of a WS s can allow the
execution of other ones when s produces their inputs attributes (see Item 5 of Algo. 1).

WS Name
s1
s3
s5
s7
s9

Input
AuthorCod,Inst
PubCod
PubCod
Inst
AuthorCod

Table 1: Example of WSs of the registry (from [19])

Output
PubCod
Title
ConfCod,ConfName
AuthorCod
ConfCod

TP
p
p
p
p
pr

WS Name
s2
s4
s6
s8

Input
AuthorName
PubCod
ConfCod
ConfCod

Output
PubCod
ConfCod
ConfName,ConfDate
ConfPlace

TP
p
p
cr
pr

We illustrate the execution of this step with the following example. Let us suppose that the registry contains the
WSs described in Table 1 and each WS has been added in the WSDN from s1 to s9 . First s1 is added to the WSDN,
Item 1 of Algo. 1 is executed, thus all places of transition s1 are created (Items 2 to 3 of Algo. 1 are executed). Then
s2 is added, its input places are created (Item 2 of Algo. 1), but because a place PubCod already exists (successor of
s1 ), then an arc is created from s2 to this place (Item 5 of Algo. 1). When s3 is added, an arc is added from place
PubCod (successor of s1 and s2 ) because this place has no successor (Item 4 of Algo. 1), and the output place T itle
is created. On the other hand, when s4 is added, because it already exists a place PubCod (successor of s1 and s2 )
with a predecessor (s3 ), then a new place PubCod is created as input of s4 and as output of s1 and s2 (Items 1 and 6 of
Algo. 1). Moreover, an output place Con f Cod is created as output of s4 (Item 3 of Algo. 1). Figure 2.(a) represents
the WSDN created from the WSs of Table 1.
While the creation of the WSDN is independent from Q, all steps of the CPN-WS selection algorithm are executed
for each Q.

2695
7

Y. Cardinale
et al.Manouvrier,
/ Procedia Rukoz
Computer
Science
1 (2012)
2689–2698
Cardinale,
El Haddad,
/ Procedia
Computer
Science
00 (2010) 1–10
s

s

9

Inst

s

9

Inst

s

7

PubCod

5

ConfName

s

s

7

PubCod

5

ConfName

AuthorCod

AuthorCod
AuthorCod

AuthorCod

s

1

s
PubCod

s

4

6

s
ConfDate

Inst

1

s
PubCod

s

4

6

ConfDate

Inst
ConfCod

ConfCod
Author
Name

s

s

2
PubCod

3

Title

(a)

ConfCod

s

8

ConfPlace

Author
Name

s

2

(b)

Figure 2: (a) The WSDN created from the WSs of Table 1 – (b) WS DNQ resulting from Algo. 2 if ∀s ∈ S , C s (s) ∈ {c, cr}.

3.2. Query admissibility
A query Q = (IQ , OQ , RQ ) (see Def. 1) is admissible iﬀ the WS registry contains (i) at least one WS whose TP
satisﬁes RQ and whose input attributes are included in IQ , and (ii) one or more WSs, whose TP satisﬁes RQ , allowing
to produce all output attributes of OQ . Let S RQ the set of transitions whose color satiﬁes RQ (see Line 1 of Algo. 2).
In terms of CPN, Q is admissible iﬀ the WS DN contains (i) at least one transition of S RQ with all its predecessors in
IQ and (ii) one or several transition of S RQ such that the union of their successors contains OQ .
If both conditions are satisﬁed, then the selection algorithm can proceed to the next step. Otherwise, the algorithm
can not continue (there is no ﬁreable transition then no WS can be selected meaning that no solution satisfying Q can
be found). Note that the admissibility of Q does not guarantee that a solution satisfying Q exists.
3.3. Identiﬁcation of the potentially useful WSs
If Q is admissible, then WSs of the registry potentially useful to answer Q can be identify. The identiﬁcation
step, presented in Algo. 2, analyzes the WSDN from the output places corresponding to the output attributes in OQ
and creates a new Colored Petri Net, WS DNQ , by recursively adding all the predecessors of the analyzed places or
transitions. This step takes into account the transactional properties in order to select useful WSs that also satisfy
the user risk level. If it does not exists at least one input attribute ∈ IQ among the input places of WS DNQ (i.e., the
places with no predecessor), then the algorithm returns an error, because Q has no solution. Otherwise, the selection
algorithm can proceed to the next step. Algo. 2 is inspired from the yellow coloring step of SAM [15] algorithm.
We illustrate this identiﬁcation step with the following example: let suppose IQ = {Inst}, OQ = { Con f Name,
Con f Date }, RQ ∈ {R0 , R1 }, that the WSDN of the registry is represented by Figure 2.(a), and that all WSs are
either compensatable or compensatable retriable. In this scenario, the result of Algo. 2 is the Colored Petri Net
WS DNQ represented in Figure 2.(b). It contains predecessors of Con f Name and Con f Date places and recursively
their predecessors. Transitions s3 and s8 of WSDN do not appear in WS DNQ because they are not predecessors of
Con f Name and Con f Date. When the transactional properties of the WSs are those represented in the TP column of
Table 1 and RQ = R1 , then only transitions s7 , s9 , s4 , s5 and s6 are selected by Algo. 2.
Algo. 2 returns a CPN MS DNQ = (AQ , S Q , F Q , ξQ ) such that: S Q = { s ∈ S RQ | [OQ ⊆ (∪(s•i )|si ∈S Q )] ∧
∅] } with S RQ deﬁned in Line 1 of Algo. 2. Moreover, MS DNQ allows to determine all the
[(∪(• si )|si ∈S Q ) ∩ IQ
σ

ﬁring sequences σ such that M → M , with M an initial marking such that (∃a ∈ IQ | M(a) = {I}) and, M a ﬁnal
marking such that (∃a ∈ OQ | M(a) ∅), and such that the composition of all the WSs corresponding to the transitions
of σ represents a TCWS.

3.4. Automatic selection of the component WSs
The automatic selection step is presented in Algo. 3. The inputs of this step are the WS DNQ returned by Algo. 2,
the initial and the ﬁnal markings (MQ and MF ), and Q. The output is, if it exists, a ﬁring sequence σQ (see Def. 10),
corresponding to the TCWS whose components are the WSs of the registry required to evaluate Q and satisfying all
the user requirements.

2696

et al. / Procedia
(2012) 2689–2698
Cardinale,Y.ElCardinale
Haddad, Manouvrier,
RukozComputer
/ Procedia Science
Computer1 Science
00 (2010) 1–10

8

Algorithm 2: Identification of the potentially useful WSs

1
2

3
4

5

Input: WS DN = (A, S , F, ξ) corresponding to the registry – see Algo. 1, and Q = (IQ , OQ , RQ ), the user query Q
Output: WS DNQ = (AQ , S Q , F Q , ξQ ), a sub-part of WSDN with AQ ⊆ A, S Q ⊆ S , F Q : (AQ × S Q ) ∪ (S Q × AQ ) → {0, 1} and
ξQ : C AQ ∪ CS Q with C AQ : AQ → ΣA and CS Q : S Q → ΣS
begin
S RQ ←− { s ∈ S | CS (s) ∈ {c, cr} if RQ = R0 or CS (s) ∈ Σ s if RQ = R1 } /*all transitions whose color satiﬁes RQ */;
Create WS DNQ ← (AQ , S Q , F Q , ξQ ) with AQ ← OQ and S Q ← ∅;
if RQ = R0 /* If only transitions whose color are c or cr are authorized */ then
/* Recursively add all predecessors of the predecessors of all places corresponding to attributes of OQ */
Pred ← AQ ;
repeat
Select a ∈ Pred;
if ((• a) ∅) then
if a ∈ (S RQ − S Q ) then AQ ← AQ ∪ ((• a) ∩ A); ∀x ∈ (• a), F Q (x, a) ← 1; /* Add predecessor of a to AQ */
else if (a ∈ (A − AQ )) ∧ ((• a) ∈ S RQ ) then
S Q ← S Q ∪ (• a); ∀x ∈ (• a), F Q (x, a) ← 1; /* Add transitions of S RQ */
Pred ← Pred ∪ ( ( • a) ∩ (A ∪ S RQ ) ) ;

6

else
7
8
9
10

11

12

13

Pred ← (Pred − {a});
until Pred ∅ ;

/* All transitions, allowing to select a TCWS, are authorized whatever is their color */ ;
RO ← OQ /* the set of reached outputs */ ; Pred ← ∅ ; Pred p ← ∅;
repeat
Select o ∈ RO /* Selection of a reached output */;
/* Deﬁne a marking such that place o contains a token of each color of S and all the other places no token*/ ;
Mo ← {Mo (a) | [(Mo (a) = ∅) ∧ (a ∈ (AQ − {o})) ] ∨ [(Mo (a) = S ) ∧ (a = o) ]};
Pred ← (• o) /* Then, recursively add all predecessors of the predecessors of place o */;
if Pred ∅ then
repeat
Select po ∈ Pred;
/* If po is a transition whose color is included in the set of colors of the tokens of o */ ;
if [ (po ∈ (S RQ − S Q )) ∧ (CS (po ) ∈ ∪a∈(po • ) MO (a)) ] then
/* Add transition to S Q */ S Q ← (S Q ∪ {po }); ∀x ∈ ((po • ) ∩ AQ ), F Q (po , x) ← 1 ;
Pred ← Pred ∪ ( ( • po ) ); Pred p ← (• po );
if CS (po ) ∈ {p, a, c} then
/* All input places of po have to contain a token of color c or cr to allow po to be ﬁreable*/ ;
repeat Select a ∈ Pred p ; Mo (a) ← {c, cr}; Pred p ← (Pred p − {a}) until Pred p ∅
else
/* All input places of po can contain a token of any color to allow po to be ﬁreable */ ;
repeat Select a ∈ Pred p ; Mo (a) ← S ; Pred p ← (Pred p − {a}) until Pred p ∅
else if po ∈ (A − AQ ) then
AQ ← AQ ∪ (po ); Pred ← Pred ∪ ( ( • po ) );∀x ∈ ((p•o ) ∩ S Q ), F Q (po , x) ← 1;
Pred ← (Pred − {po });
until Pred ∅ ;

14

RO ← (RO − {o});
until RO ∅ ;

15
16

17

end

I = {a ∈ AQ | (• a) = ∅} /* Set of input place, i.e. places with no predecessor */;
/* If at least one attribute of IQ corresponds to an input place (with no precedessor) in the WSDN, then return WS DNQ , else returns
ERROR and stops the CPN-WS algorithm */
if ((IQ ∩ I) ∅) then Return WS DNQ ; else Return ERROR;

Let suppose that IQ = {Inst} and OQ = {Con f Name, Con f Date}. Depending on the color of the transitions, the
following ﬁring sequences can be returned by Algo. 3: {s7 , s1 , s4 , s6 }; {s7 , s1 , s5 , s6 }; {s7 , s1 , s4 , s5 , s6 }; {s7 , s1 , s5 , s6 };
{s7 , s9 , s6 }; {s7 , s1 , s9 , s6 }; {s7 , s9 , s1 , s6 }. Note that if s4 is ﬁred, then s9 is cut-oﬀ and if s9 is ﬁred, then s4 is cut-oﬀ
(because WSs s4 and s9 produce the same output attributes). If s5 is ﬁred then s4 and s9 are cut-oﬀ (because (s4 )• ⊂
(s5 )• and (s9 )• ⊂ (s5 )• ). If s4 and s6 are ﬁred or if s9 and s6 are ﬁred then s5 is cut-oﬀ (because (s5 )• ⊂ [(si )• ∪ (s6 )• )]
with i ∈ {4, 9}).

Y. Cardinale
et al.Manouvrier,
/ Procedia Rukoz
Computer
Science
1 (2012)
2689–2698
Cardinale,
El Haddad,
/ Procedia
Computer
Science
00 (2010) 1–10

2697
9

Algorithm 3: Automatic WSs selection
Input: WS DNQ = (AQ , S Q , F Q , ξQ ) returned by Algorithm 2, MQ , the initial marking – see Def. 6, MF , the ﬁnal marking – see Def. 14,
and the user query Q = (IQ , OQ , RQ ) - see Def. 1.
σQ

1
2
3
4
5

6
7
8
9
10
11
12
13

Output: σQ : a ﬁring sequence that satisﬁes Q (i.e., MQ → MF )
begin
Current M ← MQ /* The current marking is the initial one */ ;
New M ← NULL /* The new marking obtained after ﬁring a transition */;
σQ ← ∅ /* The resulting ﬁring sequence is empty at the beginning */;
C M ← I /* The color of the marked Colored Petri Net */; O M ← ∅ /* The set of the output attributes produced by σQ */;
Fireable ← {s ∈ S Q : s is ﬁreable } /* see Def.7 */
repeat
/* Select the best ﬁreable transition according to QualityQ */ ;
Select s ∈ Fireable s.t.: [ ∀s ∈ Fireable, (QualityQ (s) ≥ QualityQ (s )) ] ;
if ¬ isCutO f f (s) /* See Def. 12 and value of O M */ then
Fired s applying ﬁring rules /* See Def. 9 */;
O M ← O M ∪ (s• ) /* Update O M with successors of s */ ; σQ ← σQ ∪ s /* Add s to σQ */ ;
s

New M ← M such that Current M → M /* Recall the new marking */;
Current M ← New M /* Update current marking with the new marking*/;
S ucc ← (s• )• /* Compute the set of transitions successor of s */;
Parallel ← Fireable − S ucc − {s} /* Set of transitions corresponding to WSs to be executed in parallel with s*/;
/* Add successors of s to Fireable if they verify the ﬁreable conditions – see Def. 7 */
repeat
Select the ﬁrst element w of S ucc;
if (C M ∈ {a, ar}) ∧ (C s (w) ∈ {pr, ar, cr}) /* See arcs labeled by ’; ∗’ from State a and ar in Fig. 1*/ then
if (w Fireable) ∧ (w is ﬁreable) then Fireable ← Fireable ∪ {w}

14

else if (C M ∈ {c, cr}) ∧ (w is ﬁreable) then Fireable ← Fireable ∪ {w};
S ucc ← S ucc − {w};
until S ucc ∅ ;
/* Disable ﬁreable transitions which do not verify the ﬁreable conditions anymore */
repeat
Select the ﬁrst element w of Parallel; /* For the following conditions, see arcs labeled by ’//∗’ in Fig. 1*/
if (C M = a) ∧ (C s (w) cr) then Fireable ← Fireable − {w} else if (C M = ar) ∧ (C s (w) {pr, ar, cr}) then
Fireable ← Fireable − {w} else if (C M = c) ∧ (C s (w) {c, cr}) then Fireable ← Fireable − {w} ;
Parallel ← Parallel − {w};
until Parallel ∅ ;

15
16

17

18

Fireable ← Fireable − {s};

19

σQ

until Fireable = ∅ or the desired marking MF is not reached (i.e., MQ → Current M with Current M

20

MF ) ;

σQ

21

end

if MF the desired Marking is reached (i.e., MQ → MF ) then Return σQ ; else Return ERROR;

σQ

Note that if a ﬁring sequence σQ exists, such that MQ → MF , and σQ corresponds to a TCWS satisfying Q, then
Algo. 3 ﬁnds it. On the other hand, if an error is returned, then no ﬁring sequence σQ , satisfying Q, exists. Moreover,
if a ﬁring sequence σQ is returned by Algo. 3, then it corresponds to a TCWS satisfying Q.
3.5. Creation of the resulting Colored Petri Net
Let suppose that Algo. 3 returns the ﬁring sequence σQ = {s7 , s1 , s4 , s5 , s6 }. This ﬁring sequence contains a useless
ς
transition, s4 . Indeed, [(s•4 )• ⊂ (s•5 )• ] and MQ → MF , with ς = σQ − {s4 }, but because s4 has been selected before
s5 , therefore it has not been considered as cut-oﬀ. As a consequence, we add another step to our algorithm, in order
to eliminate potentially useless transitions of the resulting ﬁring sequence. Moreover, if the Algo. 3 produces the
ﬁring sequence σQ = {s7 , s1 , s9 , s6 }, this last step will eliminate transition s1 because in σQ there is no sequence of
transitions starting from s1 and leading to the output places of OQ .
In this sense, the last step of CPN-WS algorithm consists in cleaning σQ , result of Algo. 3, by deleting useσQ

less transitions, producing a ﬁring sequence σQ such that MQ → MF and such that the composition of all the WSs
corresponding to the transitions of σQ represents a TCWS.
The algorithm of our last step is similar to the ﬁve ﬁrst lines of Algo. 2, except that S RQ is replaced by σQ in the
i f instructions and except that all transitions a, such that it exists another transition s into σQ verifying ((a• ) ∩ AσQ ) ⊂

2698

et al. / Procedia
Science 1Science
(2012) 00
2689–2698
Cardinale,Y.ElCardinale
Haddad, Manouvrier,
Rukoz Computer
/ Procedia Computer
(2010) 1–10

10

((s• ) ∩ AσQ ), are not added into Pred nor into WS DNσQ .
4. Conclusion
In this work, we propose a transactional-driven WSs selection and composition algorithm where functional conditions, expressed as input and output attributes, and transactional properties, expressed as a risk level, are considered
at the same time to compute adequate transactional WS compositions. We use Colored Petri Net as a formalism to
represent composite WSs, adapt a Petri Net unfolding algorithm and perform a Best-First search, guided by the aggregated transactional properties, which stops when the desired marking corresponds to a composition of WSs that
satisﬁes both functional and risk level user requirements. Our future work will focus on QoS-aware selection and on
failure recovery of TCWS execution.
5. Acknowledgments
This work was supported by the Franco-Venezuelan CNRS-FONACIT project N◦ 22782 and the ANR PERSO
project N◦ JC07 186508.
6. References
[1] A. Liu, Q. Li, L. Huang, M. Xiao, FACTS: A Framework for Fault Tolerant Composition of Transactional Web Services, IEEE Trans. on
Services Computing 99 (RapidPosts) (2009) 1–14.
[2] S. Bhiri, O. Perrin, C. Godart, Extending workﬂow patterns with transactional dependencies to deﬁne reliable composite Web services, in:
Proc. of the Advanced Int. Conf. on Telecomm. and Int. Conf. on Internet and Web Appl. and Services (AICT-ICIW), 2006, p. 145.
[3] J. El Haddad, M. Manouvrier, M. Rukoz, TQoS: Transactional and QoS-aware selection algorithm for automatic Web service composition,
IEEE Trans. on Services Computing 99 (PrePrints) (2010) 1–14, - Note de recherche LAMSADE Univ. Paris-Dauphine N◦ 45.
[4] K. Vidyasankar, G. Vossen, A Multi-Level Model for Web Service Composition, in: Proc. of the IEEE Int. Conf. on Web Services (ICWS),
San Diego, California, USA, 2004, pp. 462–469.
[5] N. B. Lakhal, T. Kobayashi, H. Yokota, FENECIA: failure endurable nested-transaction based execution of composite Web services with
incorporated state analysis, VLDB Journal 18 (1) (2009) 1–56.
[6] J. El Haddad, M. Manouvrier, M. Rukoz, A Hierarchical Model for Transactional Web Service Composition in P2P Networks, in: Proc. of
the IEEE Int. Conf. on Web Service (ICWS), Salt Lake City, UT, 2007, pp. 346–353.
[7] Z. li Zhang, F. Hong, H. jun Xiao, A colored petri net-based model for web service composition, Journal of Shanghai University (English
Edition) 12 (4) (2008) 323–329.
[8] A. Brogi, S. Corﬁni, SAM : A Semantic Web Service Discovery System, in: 11th Int. Conf. on Knowledge-Based Intelligent Information and
Eng. Systems (KES) - LNCS (4694), Vietri sul Mare, Italy, 2007, pp. 703–710.
[9] D.-H. Shin, K.-H. Lee, T. Suda, Automated generation of composite web services based on functional semantics, Web Semant. 7 (4) (2009)
332–343.
[10] I. Altintas, C. Berkley, E. Jaeger, M. Jones, B. Ludascher, S. Mock, Kepler: An Extensible System for Design and Execution of Scientiﬁc
Workﬂows, in: Proc. of the 16th Int. Conf. on Scientiﬁc and Statistical Database Management (SSDBM), 2004, p. 423.
[11] A. Lanz´en, T. Oinn, The Taverna Interaction Service : enabling manual interaction in workﬂows, Bioinformatics 24 (8) (2008) 1118–1120.
[12] D. Churches, G. Gombas, A. Harrison, J. Maassen, C. Robinson, M. Shields, I. Taylor, I. Wang, Programming scientiﬁc and distributed
workﬂow with Triana services: Research Articles, Concurrency and Computation: Practice & Experience 18 (10) (2006) 1021–1037.
[13] Y. Gamha, N. Bennacer, L. B. Romdhane, G. Vidal-Naquet, B. el Ayeb, A Statechart-Based Model for the Semantic Composition of Web
Services, in: Proc. of The Int. Conf. on Services Computing - Workshops (SCW), Salt Lake City, Utah, USA, 2007, pp. 49–56.
[14] H. Li, H. Wang, L. zhen Cui, Automatic Composition of Web Services Based on Rules and Meta-Services, in: Proc. of the 11th Int. Conf. on
Computer Supported Cooperative Work in Design (CSCWD), Melbourne, Australia, 2007, pp. 496–501.
[15] A. Brogi, S. Corﬁni, R. Popescu, Semantics-based composition-oriented discovery of web services, ACM Trans. on Internet Technology 8 (4)
(2008) 1–39.
[16] Y. Xu, B. Li, J. Wu, A Petri-net Coverability Model for Automatic Web Service Composition, in: Proc. of the Int. Conf. on Industrial and Inf.
Sys. (IIS), Haikou, China, 2009, pp. 31–34.
[17] Z. Qian, S. Lu, L. Xie, Colored Petri Net Based Automatic Service Composition, in: Proc. of The 2nd IEEE Asia-Paciﬁc Service Comp.
Conf. (APSCC), Tsukuba Science City, Japan, 2007, pp. 431–438.
[18] X. Deng, Z. Lin, W. Cheng, R. Xiao, L. Fang, L. Li, Modeling Web Service Choreography and Orchestration with Colored Petri Nets, in:
Proc. of the 8th ACIS Int. Conf. on Soft. Eng., AI, Networking, and Parallel/Dist. Comp. (SNPD), Qingdao, China, 2007, pp. 838–843.
[19] E. Blanco, Y. Cardinale, M.-E. Vidal, Aggregating Functional and Non-Functional Properties to Identify Service Compositions - In: IGI
BOOK, Vol. 53, 2010, accepted to be published.
[20] R. Hamadi, B. Benatallah, A petri net-based model for web service composition, in: Proc. of the 14th Australasian database Conf. (ADC),
Darlinghurst, Australia, 2003, pp. 191–200.

