Eﬃcient Parallelization of
Spatial Approximation Trees
Mauricio Mar´ın1 and Nora Reyes2
1
2

Computer Cs. Department, University of Magallanes, Chile
Computer Cs. Department, University of San Luis, Argentina
Mauricio.Marin@umag.cl

Abstract. This paper describes the parallelization of the Spatial Approximation Tree. This data structure has been shown to be an eﬃcient
index structure for solving range queries in high-dimensional metric space
databases. We propose a method for load balancing the work performed
by the processors. The method is self-tuning and is able to dynamically
follow changes in the work-load generated by user queries. Empirical results with diﬀerent databases show eﬃcient performance in practice. The
algorithmic design is based on the use of the bulk-synchronous model of
parallel computing.

1

Introduction

The Spatial Approximation Tree (SAT) is a recent data structure devised to support eﬃcient search in high-dimensional metric spaces [5, 6]. It has been compared successfully against other data structures devised for the same purpose
[2, 3] and update operations have been included in the original design [1, 7].
The typical query for this data structure is the range query which consists on
retrieving all objects within a certain distance from a given query object. From
this operation one can construct other ones such as the nearest neighbors. The
distance between two database objects in a high-dimensional space can be very
expensive to compute and in many cases it is certainly the relevant performance
metric to optimize; even over the cost secondary memory operations [1]. For large
and complex databases it then becomes crucial to reduce the number of distance
calculations in order to achieve reasonable running times. The SAT is able to
achieve that goal but still range query operations can be very time consuming.
This makes a case for the use of parallelism.
In this paper we propose eﬃcient parallel algorithms for range query operations upon the SAT data structure. The model of parallel computing is the
so-called BSP model [10] which provides independence of the computer architecture and has been shown to be eﬃcient in applications such as text databases
and others [4, 8]. The proposed algorithms can be implemented using any modern communication library such as PVM, MPI or special purpose libraries such
as BSPlib or BSPpub.
V.S. Sunderam et al. (Eds.): ICCS 2005, LNCS 3514, pp. 1003–1010, 2005.
c Springer-Verlag Berlin Heidelberg 2005

1004

M. Mar´ın and N. Reyes

The main contribution of this paper is a low-cost method for load balancing
the number of distance calculations performed by the processors. It works with
any strategy of tree node distribution onto the processors. The method is selftuning and is able to adapt itself to the evolution of the work-load generated
by the stream of queries being submitted to the SAT (we assume a high-traﬃc
client-server setting in which the SAT is used as an index structure to eﬃciently
solve user’s range queries). Experimental results with diﬀerent databases show
that the method is able to achieve eﬃcient performance.

2

SAT & BSP

The SAT construction starts by selecting at random an element a from the
database S. This element is set to be root of the tree. Then a suitable set N (a)
of neighbors of a is deﬁned to be the children of a. The elements of N (a) are
the ones that are closer to a than any other neighbor. The construction of N (a)
begins with the initial node a and its “bag” holding all the rest of S. We ﬁrst
sort the bag by distance to a. Then, we start adding nodes to N(a) (which is
initially empty). Each time we consider a new node b, we check whether it is
closer to some element of N (a) than to a itself. If that is not the case, we add
b to N(a). We now must decide in which neighbor’s bag we put the rest of the
nodes. We put each node not in a ∪ N (a) in the bag of its closest element of
N (a). The process continues recursively with all elements in N (a).
The resulting structure is a tree that can be searched for any q ∈ S by
spatial approximation for nearest neighbor queries. Some comparisons are saved
at search time by storing at each node a its covering radius, i.e., the maximum
distance R(a) between a and any element in the subtree rooted by a.
Range queries q with radius r are processed as follows. We ﬁrst determine
the closest neighbor c of q among {a} ∪ N (a). We then enter into all neighbors
b ∈ N (a) such that d(q, b) ≤ d(q, c) + 2r. This is because the result elements q ∗
sought can diﬀer from q by at most r at any distance evaluation, so it could have
been inserted inside any of those b nodes. In the process, we report all the nodes
q ∗ we found close enough to q. Finally, the covering radius R(a) is used to further
prune the search, by not entering into subtrees such that d(q, a) > R(a)+r, since
they cannot contain useful elements.
In the bulk-synchronous parallel (BSP) model of computing [10, 8], any parallel computer (e.g., PC cluster, shared or distributed memory multiprocessors)
is seen as composed of a set of P processor-local-memory components which
communicate with each other through messages. The computation is organized
as a sequence of supersteps. During a superstep, the processors may perform
sequential computations on local data and/or send messages to other processors. The messages are available for processing at their destinations by the next
superstep, and each superstep is ended with the barrier synchronization of the
processors.
We assume a server operating upon a set of P machines, each containing
its own memory. Clients request services to a broker machine, which in turn

Eﬃcient Parallelization of Spatial Approximation Trees

1005

distribute those requests evenly onto the P machines implementing the server.
Requests are queries that must be solved with the data stored on the P machines.
We assume that under a situation of heavy traﬃc the server start the processing
of a batch of Q queries in every superstep.
Every processor has to deal with two kind of messages, those from newly
arriving queries coming from the broker, in which case a range search is started
in the processor, and those from queries located in other processors that decided
to continue their range search in a subtree of this processor (in this case the
query is sent packed into a message, thus an initial query can give place to a
number of additional query messages).
In the following discussion the main metric used to measure performance is
the load balance of the computations eﬀected by the processors. This is deﬁned
by the ratio A/B where A is the average of a given measure across processors,
and B is the maximum of the measure in any processor. The average A/B is
taken over all the supersteps. This is called eﬃciency Ef and the value Ef = 1
indicates the optimal. Speed-up is deﬁned by P Ef . We measure computation
by considering the number of distance calculations among objects during query
operations and communication is the number of query messages among processors.
In the experiments below we use a 69K-words English dictionary and queries
are composed by words selected uniformly at random. The distance between
two objects is the edit distance, that is, the minimum number of character insertions, deletions, and replacements to make the two strings equal. We assume
a demanding case in which queries come in pairs that are a range query for the
same object but with two diﬀerent radius (large and small) and the broker distribute them circularly among the processors. We use the values 1 (small) and 2
(large) for the dictionary database. The SAT is initialized with the 90% of the
database and the remaining 10% are left as query objects (randomly selected
from the whole database).

3

Range Queries in Parallel

A ﬁrst point to emphasize is that the SAT structure contains nodes of very
diverse number of children. Every child node causes a distance comparison, so it
is relevant to be able to balance the number of distance comparisons performed
in every processor per superstep. Thus it is desirable to map the tree nodes onto
the processors by considering the number of distance comparisons that can be
potentially performed in every sub-tree rooted at the children of the SAT’s root.
That is, the sub-trees associated with nodes b in N (a) where a is root and N (a)
is the set deﬁned in the previous section.
We count the total number of nodes C(b) in each sub-tree with b ∈ N (a).
We then sort the C(b) values and collapse these values onto the P processors.
To this end, we deﬁne an array U of size P to sum up the C(b) values. For every
b ∈ N (a) such that b is in decreasing order of C(b) values, the node b goes to
processor i such that U [i] has the minimum sum among the P elements of U .

1006

M. Mar´ın and N. Reyes

We can improve eﬃciency by setting upper limits V to the number of distance comparisons that are performed per processor in every superstep. During
a superstep, every time any processor detects that it has eﬀected more than V
distance comparisons, it suspends query processing and waits until the next superstep to continue with this task. “Suspending” in our BSP realization means
that all queries going down recursively in the tree in every processor k are sent
to processor k as a message exactly as if they found out that the search has to
continue in another processor (no communication cost is involved for these extra
messages). Also the processors stop extracting new queries from their messages
input queues. Figure 1.a shows the eﬀect of this strategy in load balance; average eﬃciency improves to Ef = 0.95 in this case and communication is less than
0.1%.
70000
V
Limit to Distance Calculations

Number of Distance Calculations

60000

50000

40000

p=0
p=1
p=2
p=3

30000

20000

10000

0

60000
50000
40000
30000
20000
10000
0

0

2

4

6

8
10
Superteps

(a)

12

14

16

0

10

20

30

40
50
60
Superteps

70

80

90

100

(b)

Fig. 1. (a) SAT distributed onto the processors. Number of distance calculations (comparisons) per processor versus supersteps. Demanding case for queries: Circular distribution and every object is queried with two radius. (b) Automatic and adaptive
calculation of limits V . Halfway the work-load changes suddenly to queries with one
small radius

The value V should be able to adapt itself to follow changes in the workload
produced by the ﬂow of queries arriving constantly to the processors. We propose
a simple and low-cost solution to this problem. The key idea is to periodically,
e.g., every s supersteps, collect statistics that are used to deﬁne the value of
V for the next sequence of s supersteps. The key is to make these statistics
independent of the current value of V and thereby of the s supersteps used
to calculate them. Because of the limits V , supersteps can be truncated before
processing all the available queries. Therefore real supersteps are not a reliable
measure of the real average number of supersteps required to complete a query.
However, for each query we can know exactly when it is necessary to cross
over to another processor. We can equip every query q with a counter of “virtual”
supersteps q.w. We distinguish these virtual supersteps from the real supersteps
being executed by the BSP computer. We also keep counters of virtual supersteps
Sv (k) in each processor k. Every time a new query q is initiated in a processor

Eﬃcient Parallelization of Spatial Approximation Trees

1007

k we set q.w to be equal the batch number at which it belongs to. The broker
(or the processors themselves) can assign to every query the batch number in
q.w before sending it to one of the processors. In a situation with V = ∞ the
reception of every new batch of queries marks the beginning of a new superstep
(in this case, virtual and real supersteps are the same). Thus every time a new
query is received we set Sv (k) = max(Sv (k), q.w).
We further reﬁne the Sv (k) values by considering that every time a query q
has to migrate to another processor we must set q.w = q.w + 1 because it takes
one virtual superstep to get there. Thus every time one of such queries q arrives to
a processor k we also set Sv (k) = max(Sv (k), q.w), and from this point onwards
this query q takes the value q.w = Sv (k). This ensures that queries traveling
through several processors will account for the necessary (minimal) number of
virtual supersteps to get their target processors and they will reﬂect this fact in
the counters Sv (k), a fact that will also be reﬂected in all other queries visiting
the processor k.
In addition we keep counters D(k) that maintain the total number of distance calculations that has been performed in every processor k. Thus after the
processing of the s real supersteps has been completed, the total number of
virtual supersteps u that has been completed is given by the maximum among
the P values Sv (k), i.e., u = max 0≤k≤P −1 {Sv (k)}. Thus the limit V set in
every processor k for the next s real supersteps is given by V = d/u with
d = avg 0≤k≤P −1 {Dv (k)}. Figure 1.b shows the eﬀectiveness of this method.
Figures 2.a and 2.b show further experiments. In the ﬁrst ﬁgure it is seen the
positive eﬀects of limits V for the milder workloads which do not mix two radius
for the same query object. In contrast, we show in the second ﬁgure results for a
naive strategy of duplicating the SAT in every processor and distributing queries
evenly for the same workloads. The results show that even in the case with no
small, no
small,
large, no
large,

1.4
1.2

limit
limit
limit
limit

1.2
1
Efficiency

1
Efficiency

small, duplication
large, duplication

1.4

0.8
0.6

0.8
0.6

0.4

0.4

0.2

0.2

0

0
10

15

20
Superteps

(a)

25

30

10

15

20
Superteps

25

30

(b)

Fig. 2. (a) Eﬃciencies per supersteps. Proposed strategy of SAT distribution onto
the processors and limits to the number of distance calculations per superstep. Two
separate workloads; small and large radius. (b) Eﬃciencies per supersteps. Case in
which a copy of the whole SAT is kept in each processor. Two separate workloads;
small and large radius

1008

M. Mar´ın and N. Reyes

limits V , our proposed strategy for range queries outperform the alternative
approach. Speed-ups are shown in table 1. Column “serial” is a measure of the
eﬀect of suspending queries in every superstep, i.e., the increase in supersteps
(no more than 20%).
3.1

Other Databases and Nodes Mapping

In ﬁgure 3.a we show results for the amount of communication demanded by
an alternative mapping of SAT nodes to processors. In this case, nodes are
Table 1. Comparing diﬀerent strategies
Case
work-load ssteps serial speed-up
Duplicated
small
432
–
2.85
Duplicated
large
432
–
3.33
Distributed
small
433
–
3.18
Distributed
large
433
–
3.43
Dist., Limits small
519 0.17
3.62
Dist., Limits large
482 0.10
3.53

1

1
0.95

0.9

0.85
Efficiency

Communications

0.9
0.8

0.7

0.6

0.8
0.75
0.7

Words, r = 1
Words, r = 2
Histograms, 0.01%
Histograms, 0.1%
Vectors, 0.01%
Vectors, 1%

0.5

0.4
2

4

8

16
Processors number

Words, r = 1
Words, r = 2
Histograms, 0.01%
Histograms, 0.1%
0.6
Vectors, 0.01%
Vectors, 1%
0.55
2 4
8
0.65

32

(a)

16
Processors number

32

(b)

1
0.95
0.9

Efficiency

0.85
0.8
0.75
0.7
Words, r = 1
Words, r = 2
Histograms, 0.01%
Histograms, 0.1%
Vectors, 0.01%
Vectors, 1%

0.65
0.6
0.55
2

4

8

16
Number of processors

32

(c)
Fig. 3. (a) Eﬀect in communication of multiplexed node distribution. (b) Eﬃciency
achieved by the multiplexed node distribution. (c) Eﬃciency achieved by the multiplexed node distribution with upper limits to the number of distance calculations

Eﬃcient Parallelization of Spatial Approximation Trees

1009

placed in a circular manner independently of their father-child-brother relations.
The results were obtained with the above dictionary words and two additional
databases. The new data sets are a 20-dimensional cube with points generated
uniformly at random and a set of images represented by histograms deﬁned by
values of frequency amplitude. Every curve is a value for a diﬀerent range query
radious. Each point indicate the ration A/B where A is the total number of
messages sent between processors and B the total number of times that the
function range-search was called to complete the processing of all queries. These
results are in contrast with the mapping based on distance calculation suggested
in this paper as the values for this case are all less than 0.1 for all databases. As
expected, the amount of communication in the multiplexed approach increases
signiﬁcantly with the number of processors.
The ﬁgure 3.b shows results for the eﬃciency Ef with the same node distribution. Note that the vectors and histograms databases are more demanding in
terms of load balance. Similar eﬃciency values are observed for the distribution
method proposed above (selecting the least loaded processor to place a new subtree). The actual diﬀerence is in the reduced communication. Figure 3.c shows
the improvement in eﬃciency Ef as a result of setting upper limits V .

4

Final Comments

We have proposed parallel algorithms for range queries on a distributed SAT
structure. We have focused on balancing the number of distance calculations
across supersteps because this is most relevant performance metric to optimize.
Distance calculation between complex objects are known to be expensive in
running time. On the other hand, we have observed that the amount of communication and synchronization is indeed extremely small with respect to the cost
of distance calculations. We have observed that the number of message transmissions is well below 1% with respect to the number of distance calculations.
This does not consider the cost of sending solution objects as this cost has to be
paid by any strategy. Also, less than 500 supersteps for processing 13K queries
is also a very modest amount of synchronization.
Note that we have mapped SAT nodes by considering the sub-trees belonging
to the children of the root. It may happen that we have more processors than
those children. This case cannot be treated by considering the mapping of subtrees one or more levels downwards the tree. Those sub-trees actually generate
too few distance comparisons. We believe such case can be treated by simply
using less processors than available (after all that particular SAT does not admit more parallelism) or by resorting to duplication of some sub-trees in other
processors. Here we select the ones which generates more distance comparisons
in an attempt to further increase parallelism by ways of dividing the query ﬂow
for that sub-trees in two or more processors. This is the subject of our future
investigation.
We also tried a multiplexed approach in which every node is circularly distributed onto the processors. Eﬃciency is good but the cost of communication
is extremely high.

1010

M. Mar´ın and N. Reyes

Acknowledgements
This work has been partially funded by research project Fondecyt 1040611 and
RIBIDI VII.19.

References
1. D. Arroyuelo, F. Mu noz, G. Navarro, and N. Reyes. Memory-adaptative dynamic
spatial approximation trees. In Proceedings of the 10th International Symposium
on String Processing and Information Retrieval (SPIRE 2003), LNCS 2857, pages
360–368. Springer, 2003.
2. C. Bohm, S. Brchtold, and D. Kein. Searching in high-dimensional spaces: Index
structures for improving the performance of multimedia databases. ACM Computing Surveys, 33(3):322–373, 2001.
3. V. Gaede and O. Gnnther. Multidimensional access methods. ACM Computing
Surveys, 30(2):170–321, 1998.
4. M. Mar´ın and G. Navarro. Distributed query processing using suﬃx arrays. In
Proceedings of the 10th International Symposium on String Processing and Information Retrieval (SPIRE 2003), LNCS 2857, pages 311–325. Springer, 2003.
5. G. Navarro. Searching in metric spaces by spatial approximation. The Very Large
Databases Journal (VLDBJ), 11(1):28–46, 2002.
6. G. Navarro and N. Reyes. Fully dynamic spatial approximation trees. In Proceedings of the 9th International Symposium on String Processing and Information
Retrieval (SPIRE 2002), LNCS 2476, pages 254–270. Springer, 2002.
7. G. Navarro and N. Reyes. Improved deletions in dynamic spatial approximation
trees. In Proc. of the XXIII International Conference of the Chilean Computer
Science Society (SCCC’03), pages 13–22. IEEE CS Press, 2003.
8. D.B. Skillicorn, J.M.D. Hill, and W.F. McColl. Questions and answers about BSP.
Technical Report PRG-TR-15-96, Computing Laboratory, Oxford University, 1996.
Also in Journal of Scientific Programming, V.6 N.3, 1997.
9. URL.
BSP PUB Library at Paderborn University, http://www.unipaderborn.de/bsp.
10. L.G. Valiant. A bridging model for parallel computation. Comm. ACM, 33:103–
111, Aug. 1990.

