Hunting for Bindings
in Distributed Object-Oriented Systems
Magdalena Slawi˜
nska
Faculty of Electronics, Telecommunications and Informatics
Gda´
nsk University of Technology
Narutowicza 11/12, 80-952 Gda´
nsk, Poland
magg@eti.pg.gda.pl

Abstract. The paper examines the problem of ﬁnding a group of objects that are involved in a certain transitive relation. It is especially
important when a group of related objects has to be identiﬁed, for example for monitoring. The article deﬁnes static and dynamic binding
relations between objects in a distributed object-oriented system. It also
presents an architecture for catching these relations since current operating systems do not support such mechanisms. In the paper the algorithm
for ﬁnding bindings of a given object is described.

1

Introduction

In distributed object-oriented systems objects are scattered over the network.
One of the main design goals of distributed systems is to provide diﬀerent types
of transparency for users, e.g., location or replication transparency [1][2]. However, sometimes such transparency can be very uncomfortable for testers and
programmers, for example during debugging.
This paper presents the framework for ﬁnding objects that are involved
in a certain transitive relation. For instance, consider the situation when a
tester wants to examine method m of object o1 . However, method m invokes
method m1 of object o2 . It means that object o1 is in a binding relation with
object o2 . The problem complicates when the so-called native and foreign objects are considered [3]. The former are objects with the full access to the source
code by testers while the latter are those ones for which testers have only on-line
access to objects’ methods but no access to the source code.
Finding bindings among distributed objects is necessary when programmers
want to isolate a group of bound objects, for example in order to limit the number
of monitored objects only to relevant ones. It is also important in program replay
or recovery [4]. The problem is similar to causality tracking, however it has a
diﬀerent ﬂavor [5].
This paper is organized as follows: in Section 2 the model of distributed
object-oriented system is presented. Section 3 introduces two important relations between objects: static and dynamic binding relations. In Section 4 the
Funded in part by the State Committee for Scientiﬁc Research (KBN) under grant
4-T11C-004-22
M. Bubak et al. (Eds.): ICCS 2004, LNCS 3036, pp. 35–42, 2004.
c Springer-Verlag Berlin Heidelberg 2004

36

M. Slawi˜
nska

architecture of the system for identifying bound objects is shown. Section 5
presents the algorithm for identifying bound objects and ﬁnally in Section 6 the
paper is concluded.

2

The System Model

A distributed object-oriented system is a ﬁnite set of objects performing a given
task. It is denoted by S = {o1 , o2 , ..., on }, where n = 1, 2, 3, ... . There is a ﬁnite
set of hosts denoted by H = {h1 , h2 , ..., hk }, where k = 1, 2, 3, ... . Objects are
located in hosts. One object can be located in only one host but many objects
may reside in one host. Objects and hosts are identiﬁable.
In contrast with classical procedural distributed systems like PVM (Parallel
Virtual Machine) [6] or MPI (Message Passing Interface) [7] where processes
communicate with each other by message passing, objects cooperate with other
objects through method invocations. In fact, remote method invocation mechanisms only wrap the message-passing stuﬀ. Messages are still sent and received
over the network, however, it is done by special software entities automatically
generated by compilers like stubs and skeletons [1][8]. They are responsible for
object binding, (un)marshaling parameters and results, issuing method on a target object. In fact, considering the lower level of abstraction, a remote method
invocation which returns a certain result consists of the following steps: (1) a
client object sends request req for the method invocation of a server object, (2)
the server object receives request req, (3) the server object carries out request
req, (4) the server object sends reply rep to request req, (5) the client object
receives reply rep. So invoking a remote method with a return value consists of
four communication actions: two sends and two receives. Two kinds of messages
are exchanged during a method invocation: requests (denoted by req) and replies
(denoted by rep). Requests as well as replies are messages (denoted by mesg). A
message consists of an identiﬁer, a source object, a target object and contents.
In case of requests the contents contains an identiﬁer of a method to be invoked
and parameters (if any). The contents of replies comprises a method identiﬁer
that has been invoked and a return value (if any). Figure 1 schematically shows
a method call in terms of sending and receiving requests and replies. Please notice that it is also possible to model local invocations on a given object in the
send/receive request/reply semantics (although it is ineﬃcient). There are three
objects in Figure 1: o1 , o2 and o3 . Horizontal lines represent time and arrows
denote messages. Symbols s(·) and r(·) stand for send and receive events, respectively. Subsequent events are numbered in the context of a given object (ei ).
An identiﬁer of a message consists of a source object identiﬁer (unique in the
system) and a number of an event in the context of the source object (unique in
the object). Message identiﬁers contain a type of a message (reply or request).
For simplicity reasons it is assumed that all methods of an object are public
and can be invoked remotely.
A sequence of events of a given object forms its history (h). For instance in
Figure 1: ho1 = (e1 , e2 ), ho2 = (e1 , e2 ) and ho3 = (e1 , e2 , e3 , e4 ). A history of an

Hunting for Bindings in Distributed Object-Oriented Systems
o1

e1 = s(req)

o3

e2 = r(rep)

req = (o1 .1, o1 , o2 , m, p)

o2

37

e1 = r(req)

rep = (o1 .1, o2 , o1 , r)

e2 = s(rep)

e1 = s(req) e2 = r(req)
req = (o3 .1, o3 , o3 , m, p)

e3 = s(rep) e4 = r(rep)

time

rep = (o3 .1, o3 , o3 , r)

Fig. 1. Method invocations in the send/receive request/reply semantics in distributed
object-oriented systems.

object is available for other objects. It may be implemented by interception of
communication events. For example interceptors are deﬁned in CORBA [8]. The
Eternal system, which provides fault tolerance for distributed objects, intercepts
method invocations in order to assure replica consistency [9].

3

Relations among Distributed Objects

Relations among objects concern the static or dynamic point of view.
3.1

Statically Bound Objects

In case of native objects, it is possible to deduce certain connections among
objects by examining their source code.
Deﬁnition 1 (The static binding relation) Object o1 is in the “static binding” relation with object o2 if the following conditions are satisﬁed:
SB1. Object o1 is a client of object o2 .
SB2. Condition SB1 can be deduced from the source code of object o1 .
SB3. Object o1 does not create object o2 .
Notation o1
object o2 .

s

o2 means that object o1 is in the “static binding” relation with

The simplest static binding relation is presented in Example 1.
Example 1
class A {
public void m1() {}
public void m2() {
oB.m1();
}
public void m3() {
C c = new C();
c.m1();
}
};

class B {
public void m1() {}
public void m2() {}
};

class C {
public void m1() {}
public void m2() {}
public void m3() {}
};

38

M. Slawi˜
nska

Let’s assume that the system consists of two objects: oA and oB which are
instances of classes A and B, respectively. It is clear from the pseudo-code of class
A (i.e. condition SB2 is satisﬁed) that oA is a client of oB (oA.m2 calls oB.m1 ).
It means that SB1 is satisﬁed. Since there is no instruction of oB creation in the
scope of oA, also SB3 is satisﬁed. It implies that oA s oB. Let’s notice that
although SB1 and SB2 are satisﬁed in case of objects oA and c, oA s c since
SB3 is violated.
Relation s is not symmetrical. In spite of oA s oB, oB s oA since
condition SB1 is not satisﬁed. Relation s is transitive.
Example 2
class A {
public void m1() {}
public void m2() {
objB.m1();
}
};

class B {
public void m1() {}
public void m2() {
objC.m1();
}
};

class C {
public void m1() {}
public void m2() {}
public void m3() {}
};

Let’s assume that there are three objects objA, objB and objC which are instances of classes A, B and C deﬁned in Example 2. It is easy to notice that
objA s objB and objB s objC since SB1, SB2 and SB3 are satisﬁed. It means
that if objA is to exist, also objB should exist and if objB is to exist also objC
should exist what implies that since objA should exist, objC should exist. The
presented deduction is performed on the source code analysis (SB2 is satisﬁed).
In fact, objA is an indirect client of objC (SB1 is satisﬁed). Also objC is not
created by objA (SB3 is satisﬁed too).
The static binding relation is suitable for ﬁnding hypothetical relationships
among objects. For instance, in Example 1 it is possible that method oA.m2 will
be never invoked in real execution, i.e., oA will never be a client of oB. Relation
s only indicates that a given binding is probable but it does not guarantee
that it really happens.
3.2

Dynamically Bound Objects

In case of foreign objects, the source code is unavailable. In order to identify
bindings among foreign objects, or to identify bindings that happened in the
past, it is necessary to analyze their histories.
Deﬁnition 2 (The dynamic binding relation) Object o1 is in the dynamic
binding relation with object o2 if the following conditions are satisﬁed:
DB1. In the history of object o1 exists event e which is a sending of a request of
a method invocation of object o2 .
DB2. If o1 is in the dynamic binding relation with object o2 and o2 is in the
dynamic binding relation with object o3 then o1 is in the dynamic binding relation
with object o3 .
Notation o1
object o2 .

d

o2 means that object o1 is in the dynamic binding relation with

Hunting for Bindings in Distributed Object-Oriented Systems

39

For example in Figure 1 o1 d o2 since e1 ∈ ho1 and e1 = s(o1 .1, o1 , o2 , m, p).
Let’s notice that o3
d o3 since e1 ∈ ho3 and e1 = s(o3 .1, o3 , o3 , m, p). In
comparison to relation s , relation d is transitive by deﬁnition (condition
DB2). Please notice, that DB2 is not a property since relation d may concern
the same objects but diﬀerent methods and transitivity will be not satisﬁed.
Relation d extends s since sometimes the source code of objects is unavailable (foreign objects) or even if it is available it is impossible to ﬁnd out
with which objects the interaction will be performed (e.g. a dynamic vector of
object references).
3.3

Bound Objects

It is useful for further consideration to deﬁne more general binding relation.
Deﬁnition 3 (The binding relation) Object o1 is in the binding relation
with o2 if object o1 is in the static binding relation with o2 or object o1 is in the
o2 ) ⇐⇒ (o1 s o2 ) ∨ (o1 d o2 ).
dynamic binding relation with o2 , i.e., (o1
Since relation s is transitive and d is transitive by deﬁnition then relation
deﬁned as a logical sum is transitive.
Binding relations can be represented by directed graphs where vertices depict
objects in the system and directed edges denote binding relations (e.g. Figure 4).

O

L

o1
o2
o3

host1 o2 , o4
host1 o1 , o3
host1 o6

B

O

L

o6

host3 o2 , o5

B

o1 o2 o3
LIC1 host1
host3
LIC3

o6

o4 LIC2
host2

o5

host4
GIC1

O

L

o4
o5

host2 o3
host2 o4

B

network
O

L

B

LIC1 host1 o1 , o2 , o3
LIC2 host2 o4 , o5
LIC3 host3 o6

Fig. 2. The architecture for ﬁnding bound objects.

4

The Architecture for Finding Bound Objects

Figure 2 presents the architecture for ﬁnding objects which are involved in the
binding relations deﬁned in the previous section. There are three important
entities in Figure 2: Global Information Center (GIC), Local Information Center
(LIC) and Object-Location-Bindings (OLB) tables. Both GIC and LIC objects
keep the so-called OLB tables where they store necessary information. Column L
has the same meaning for GIC-OLB or LIC-OLB tables. It shows a location of
an object from column O. In case of a GIC-OLB table, column O contains LIC
objects registered in a given GIC object whereas column O of a LIC-OLB table

40

M. Slawi˜
nska

shows objects registered in a given LIC object. For example, in Figure 2 GIC1
keeps information about LIC1 , LIC2 and LIC3 , while LIC3 stores information
about object o6 . Column B has diﬀerent meaning for GIC-OLB and LIC-OLB
tables. A GIC-OLB table contains data about objects registered in a given LIC
object. However, in case of LIC objects column B indicates the set of objects
which a given object from column O is in relation
with. For instance, in
Figure 2 from GIC1 -OLB it is clear that two objects are registered in LIC2
o2 and o6
o5 .
(o4 and o5 ). However, table LIC3 -OLB indicates that o6
GIC as well as LIC objects are responsible for keeping current information in
their OLB tables. The presented architecture assumes that it exists a special layer
(not depicted in the ﬁgure) that is responsible for recording histories of objects
to the log. In order to keep a GIC-OLB table up-to-date diﬀerent strategies can
be used, e.g., push (changes are pushed to GIC objects), pull (GIC objects pull
information from LIC ones) or mixed (pull or push when necessary) models [10].
The hierarchical structure of the architecture assures scalability [1]. In order
to improve performance and availability GIC objects may be replicated [1][2][9].
In order to ﬁnd out a list of objects bound with a given object a graph of
bindings in the system can be constructed.

5

Constructing a Graph of Bindings

A graph of bindings in a system can be constructed with Algorithm 1. The
result of Algorithm 1 is array A[n][n] of object bindings, where n is the number
of objects in the system. Function index(ObjectId) assigns ObjectId in the
system to a column number in A (see Figure 3). Function object(idx) (reverse
to index(·)) assigns idx in A to an object id. In array A two values are possible:
0 and 1. If value A[i][j] equals 1 it means that object(i)
object(j), otherwise
object(i)
object(j).
Algorithm 1 (Constructing a matrix of bindings)
1. Update the GIC-OLB table (if necessary).
2. Construct array A[n][n] and fill it with 0 values.
3. For each LIC in the GIC-OLB table do:
(a) Get column O of the LIC-OLB table
(b) For each object o in column O do:
Get relevant values from column B of the LIC-OLB table
For each value b from column B do:
A[index(o)][index(b)] = 1

The result of Algorithm 1 is the matrix of bindings in the system. For the system
in Figure 2 the result of the algorithm is shown in Figure 3. In order to get a
directed graph it is necessary to transform array A by, for example, Algorithm 2.
The obtained graph is presented in Figure 4. In order to generate a list of bound
objects Algorithm 3 may be applied.

Hunting for Bindings in Distributed Object-Oriented Systems

41

o1 o2 o3 o4 o5 o6
object(·)

bindings

0
1
2
3
4
5

index(·)

0

1

2

3

4

5

0
1
0
1
0
0

1
0
1
0
0
0

0
0
0
0
0
1

0
0
1
0
0
0

0
0
0
1
0
0

0
1
0
0
1
0

o1
o2

o1

o2

o3

o3
o4
o5

o6

o4

o6

table A

o5

Fig. 3. The matrix of bindings in the Fig. 4. The transformed matrix
system in Figure 2.
from Figure 3.

Algorithm 2 (Transforming A2G)
1. Put n vertices.
2. Label each vertex according to function object()
3. For each column in A do:
For each value in column do:
if(A[i][j] == 1) then {draw an arrow from object(i) to object(j)}

Algorithm 3 (Finding a list of bound objects)
1. A;
// up-to-date table of bindings (Algorithm 1)
Vector V;
// the dynamic list of bound objects
Set
S;
// a result set of bound objects
int I = index(O);
// for what object -- O we have to look for
boolean isRemoved;
// indicates if an element was removed from V
2. do{
isRemoved = false;
// nothing was removed from vec
makeBoundObjectList(V, S, A, I); // see point 5
if( V.size() > 0){
I = V[0];
// take index of object to be checked
V.remove(0);
// remove it from from vector V
isRemoved = true;} // indicate that the length of V was decreased
}while ((V.size() != 0) || isRemoved );
3. check in A if O is in the relation with itself; update S if necessary
4. S contains a list of indexes which object O is bound with
5. Procedure makeBoundObjectList(V, S, A, I):
for (i = 0; i < A[I].length; i++)
if( A[I][i] == 1 ) then // object(I) in relation with object(i)?
if ( S.add(i) ) then
// check if elem. i in S and add if not
V.add(i);
// we must check bindings of object(i)
// so remember it in V

The result obtained from Algorithm 3 on table A from Figure 3 for ﬁnding bindings of o1 is S = {1, 3, 2, 5, 4} what implies (after object(·)) {o2 , o4 , o3 , o6 , o5 }.

42

M. Slawi˜
nska

The main idea of Algorithm 3 is to investigate A in order to ﬁnd objects that
are transitively bound with a speciﬁed object. Procedure makeBoundObjectList
looks for objects that are in relation
with a given object (I) and if it ﬁnds
some, set S is updated (please notice that this is a set so no duplicates are allowed). Next, since the added object may be in the relation with other objects
(and since it has just been added to the set, so it was not checked earlier) it must
be added to V for further investigation. From vector V elements are systematically
removed as they are checked for relations in makeBoundObjectList().

6

Conclusions

The paper describes the algorithm for ﬁnding objects involved in the transitive binding relation with a given object. It is especially important if a tester
wants to identify a group of objects. The article presents the framework architecture for maintaining information about bindings among distributed objects.
The algorithm makes use of OLB tables, GIC and LIC services. It constructs the
2-dimensional table of bound objects. Having such a table it is possible to ﬁnd
out all objects that are bound with a given object. The situation complicates
in the case of foreign objects since it is practically impossible to deduce relationships. It implies that special architectures for logging relevant information is
necessary. The presented algorithms have been implemented in a prototype tool
in order to verify the concepts in practice.

References
1. G. Coulouris, J. Dollimore, and T. Kindberg, Distributed Systems. Concepts and
Design. Addison-Wesley Longman Limited, 1994.
2. A. S. Tanenbaum, Distributed Operating Systems. Prentice-Hall International, Inc.,
1995.
3. M. Slawi˜
nska, “Testability of Distributed Objects,” in Proc. of the 5-th International Conference on Parallel Processing and Applied Mathematics, SpringerVerlag, 2003. (to appear).
4. E. N. M. Elnozahy, L. Alvisi, Y.-M. Wang, and D. B. Johnson, “A survey of
rollback-recovery protocols in message-passing systems,” ACM Computing Surveys,
vol. 34, no. 3, pp. 375–408, 2002.
5. L. Alvisi, K. Bhatia, and K. Marzullo, “Causality tracking in causal messagelogging protocols,” Distributed Computing, vol. 15, no. 1, pp. 1–15, 2002.
6. A. Geist, A. Beguelin, J. Dongarra, W. Jiang, R. Manchek, and V. Sunderam,
PVM:Parallel Virtual Machine: A Users’ Guide and Tutorial for Networked Parallel Computing. MIT Press, 1994.
7. Message Passing Interface Forum, ed., MPI: A Message-Passing Interface Standard. Message Passing Interface Forum, June 1995.
8. OMG, Common Object Request Broker Architecture: Architecture and Speciﬁcation, v3.0. http://www.omg.org, December 2002.
9. P. Narasimhan, L. Moser, and P. M. Melliar-Smith, “State Synchronization and
Recovery for Strongly Consistent Replicated CORBA Objects,” in Proc. of the
IEEE Int. Conf. on Depend. Syst. and Net., IEEE Computer Society Press, 2001.
10. OMG, Event Service Speciﬁcation, v1.1. http://www.omg.org, March 2001.

