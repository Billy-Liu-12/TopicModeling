Monitoring System for Distributed Java
Applications
Wlodzimierz Funika1 , Marian Bubak1,2 , and Marcin Sm¸etek1
1
2

Institute of Computer Science, AGH, al. Mickiewicza 30, 30-059 Krak´
ow, Poland
Academic Computer Centre – CYFRONET, Nawojki 11, 30-950 Krak´
ow, Poland
phone: (+48 12) 617 39 64, fax: (+48 12) 633 80 54
{bubak,funika}@uci.agh.edu.pl, smentos@icslab.agh.edu.pl

Abstract. Recently, the demand for tool support (performance analyzers, debuggers etc.) for eﬃcient Java programming is increasing.
A universal, open interface between tools and a monitoring system,
the On-line Monitoring Interface Speciﬁcation (OMIS), and the OMIS
compliant monitoring system (OCM) enable to specify such a Java
oriented monitoring infrastructure which allows for an extensible range
of functionality intended for supporting various kinds of tools. The
paper presents an approach to building a monitoring system underlying
this infrastructure.
Keywords: Java, monitoring system, monitoring interface, distributed
object system, tools, OMIS

1

Introduction

Java technology has grown in popularity and usage because of its portability.
This simple, object oriented, secure language supports multithreading and distributed programming including remote method invocation, garbage collection
and dynamic class loading. The Java environment simpliﬁes the development
and deployment of distributed systems, but such systems are still very complex and more error prone than single process applications. The best monitoring
of distributed Java programs could be achieved by using diverse observation
techniques and mechanisms, therefore it is often desirable to have a suite of specialized tools such as debuggers, performance analyzers each of them addressing
a diﬀerent task and allowing developers to explore the program’s behaviour from
various viewpoints. Our goal is to build a comprehensive tool support for building distributed Java applications by providing uniform, extendible monitoring
facilities for communication between components, for analyzing an application’s
execution, and for detecting bugs.
The paper is organised as follows. General considerations of Java tools
functionality and implications for monitoring are presented in Section 2. Then
follows an overview of OMIS, the OMIS-compliant monitoring system OCM,
and the characteristics of a Java-oriented extension to OMIS. Next, an overview
of the Java-oriented monitoring system architecture is presented (Section 3).
M. Bubak et al. (Eds.): ICCS 2004, LNCS 3038, pp. 472–479, 2004.
c Springer-Verlag Berlin Heidelberg 2004

Monitoring System for Distributed Java Applications

473

Sections 4 and 5 describe how the proposed monitoring system processes
requests from monitoring based tools and events generated by the target Java
system. Conclusions and future work are summarised in Section 6.

2

Design Concepts of a Monitoring System

Based on the analysis of Related work presented in [2] we have accepted requirements which must be met by the part of the infrastructure which provides
monitoring data. In order to provide comprehensive support for distributed programming, the tools need to be able to manipulate and observe the whole application distributed over diﬀerent machines at runtime. To provide a ﬂexible
functionality of tools, the monitoring activities underlying the access to and
manipulation of the observed application should be concentrated in a separate
module which is usually called monitoring system. Such a system should ideally
provide a uniform on-line interface for diﬀerent kinds of tools, which allows to
easily build tools without a need to understand the implementation of monitoring, while providing scalability and a wide range of analysis methods.
To build a versatile monitoring system we used a monitor/tool interface speciﬁcation, OMIS [3], and a monitoring system, the OCM [4], which implements
this speciﬁcation. OMIS follows the idea of separation of a tool from a monitoring
system through a standardized interface. The cooperation between the tool and
the monitoring system is based on the service request/reply mechanism. A tool
sends a service request to the monitoring system, e.g. as a coded string which
describes a condition (event) (if any) and activities (action list) which have to
be invoked (when the condition gets true). In this way the tool programs the
monitoring system to listen for event occurrences, perform needed actions, and
transfer results to the tool. OMIS relies on a hierarchy of the abstract objects:
nodes, processes, threads, messages queues and messages. Every object is represented by an abstract identiﬁer (token) which can be converted into other
token types by the conversion functions localization and expansion which are
automatically applied to every service deﬁnition that has tokens as a parameter. Each tool at each moment has a well deﬁned scope, i.e. it can observe and
manipulate a speciﬁc set of objects attached on a request from this tool. Due to
the distributed nature of parallel application, the monitoring system must itself
be distributed and needs one monitoring component per node, which in case of
the OCM is called Local Monitor (LM). The OCM also comprises a component
called the Node Distribution Unit (NDU) that has to analyze each request issued by a tool and split it into separate requests that can be processed locally by
LMs on proper nodes. OMIS allows the monitoring system to be expanded with
a tool extension or monitor extension, which adds new services and new types of
objects to the basic monitoring system, for speciﬁc programming environments.
Java-bound On-line Monitoring Interface Speciﬁcation (J-OMIS) is a monitor extension to OMIS for Java distributed applications, which introduces a new
Java-bound object hierarchy that is divided into two kinds of objects: execution
objects, like nodes, JVMs, threads and application objects, e.g. interfaces, classes,

474

W. Funika, M. Bubak, and M. Sm¸etek

objects, methods. As in the original OMIS, J-OMIS speciﬁes tree types of services: information services, manipulation services, and event services. J-OMIS
deﬁnes relations between the objects of a running application, which are expressed by conversion functions, enlarged w.r.t. OMIS by additional operations
that result from the object-oriented nature of Java.

3

Architecture of the Java-Oriented Monitoring System

Based on J-OMIS, we have designed a Java-oriented extension to the OCM, the
J-OCM, by extending the functionality of the OCM, via adding new software
components and adapting existing ones (see Fig.1). This approach allows to
combine the existing functionality of the OCM with the Java platform.
The Node Distribution Unit(NDU), an unchanged part of the whole monitoring infrastructure, is still responsible for distributing requests and assembling
replies. E.g. a tool may issue a request in order to run the garbage collector
on speciﬁed JVMs, therefore the NDU must determine the nodes executing the
JVMs and, if needed, split the request into separate sub-requests to be sent to
the proper nodes. The NDU must also assemble the partial replies from local
monitors into a global reply. The NDU is aimed to make the whole system manageable, thus it has to program the local monitors of all the currently observed
nodes. As the set of monitored nodes may change over time, the NDU must
properly react to these changes: to create local monitors on the newly added
nodes or to re-arrange a list of the objects involved in the execution of requests
that have been issued by tools, when some nodes are deleted.
Tool A

Tool B

performance analyzer

debugger

Legend:
New components
Elements of Distributed
Application

Node Distribution Unit

JVMLM = [JVM] agent

Local Monitor

Local Monitor

JVMEXT

SHMLAE

Node

JVMEXT

SHMLAE

JVMLM

JVMLM

JVMLM

JVMLM

JVM

JVM

JVM

JVM

Node

Fig. 1. J-OCM architecture

Monitoring System for Distributed Java Applications

475

The Local Monitor is a monitor process, independent from the whole global
monitoring infrastructure. Each monitor process provides an interface similar to
that of the NDU, with the exception that it only accepts requests to operate on
local objects. To support the monitoring of Java applications, the LM’s extension, JVMEXT, provides new services deﬁned by J-OMIS, which control JVM via
agents. JVMEXT is linked to LMs as a dynamically linked library at runtime using the dlopen interface, whenever the tool issues a service request to JVMEXT.
LM stores information about the target Java application’s objects such as
JVMs, threads, classes, interfaces, objects, methods etc. referred to by tokens.
The Java Virtual Machine Local Monitor is an agent embedded into a JVM
process, which is responsible for execution of the requests received from the LM.
It uses Java Virtual Machine native interfaces such as JVMPI [5], JVMDI [6],
and JNI [7] that provide low level mechanisms for interactive monitoring, independent of a JVM implementation. The Shared Memory based Local Agents Environment (SHMLAE) is a communication layer to support cooperation between
agents and the LM. This allows the components involved in communication to
ﬁnd each other during start-up and notify about their existence.

4

Request Processing

The proposed monitoring infrastructure allows the tool to see the whole monitored application as a set of distributed objects and the monitoring system as
a higher-level software layer (middleware) that provides a standardized interface to access those objects, regardless of implementation details, like hardware
platform or software language.
To deal with the distributed target system we consider the functioning of
the J-OCM as a distributed system, which has to usually comprise additional
architectural elements: an object interface speciﬁcation, object stub and skeleton,
object manager, registration/naming service and communication protocol.
Interface deﬁnition. The ﬁrst stage of the process of developing a distributed application is to deﬁne the interface of a remote object (e.g. methods,
data types), written in an Interface Deﬁnition Language. Similarly, a leading
idea of OMIS is to provide support for building monitoring tools and systems
for new parallel or distributed environments by extending its functionality. For
each extension, an IDL ﬁle, called registry, has to be provided, which speciﬁes
new objects, new services and their relevant attributes.
Stub and Skeleton provide transparent communication between the client
and the remote object. They are based on the Proxy Design Pattern1 , where
the object is represented by another object (the proxy), in order to control access
to the object. In distributed computing the stub plays the role of the proxy and
allows to make a local call on the remote object. The skeleton, residing on the
server side, receives an incoming call, and invokes it on the real object. The
Proxy pattern is used by the J-OCM to provide the tool with transparent access
1

Proxy design pattern as described in “Design Patterns” by Gamma, Helm, Johnson
and Vlissides [8]

476

W. Funika, M. Bubak, and M. Sm¸etek

to monitored objects 2 . The monitored objects are identiﬁed by tokens which
refer to the proxy object. The proxy is a representation of the real object in the
monitoring system. The object proxy contains all information that is needed to
deliver the tool’s requests to the JVM agent (JVMLM) which directly accesses
the JVM. The JVM agent acts as a skeleton, while the remote proxy which
is embedded into the JVM is a platform dependent native library. The agent
transforms a call and parameters received from the LM into the format required
by one of interfaces used to interact with JVM.
Object manager and registration/naming service. Remote method
calls issued by the client are routed through the object manager to the proper
object on the server. The object manager also routes results back to the client.
The registration/naming service acts as an intermediary layer between the object
client and the object manager. Once an interface to the object has been deﬁned,
an implementation of the interface needs to be registered with the naming service
so that the object can be accessed by clients using the object’s name. The main
components of the J-OCM — the NDU and LMs — can be classiﬁed as an object
manager and provide operations similar to the naming service that is present in
distributed systems. Any object that can be observed or manipulated by tools
is represented by a token, which is a globally unique name of monitored object.
The tokens and objects’ proxies of proper monitored objects are created
when: (1) the JVMLM is started up and notiﬁes the node’s LM of its existence
(e.g. jvm j 1), (2) events referring to the creation of threads, classes, objects,
interfaces, etc. are raised and the tool is interested in them, or (3) the tool
issues information requests of the following syntax: {jvm, thread, class,
etc.} get tokens() to obtain a list of tokens of all monitored objects of a
given class.

5

Event Handling

An event is a characteristic atomic program behavior. In an event-based monitoring system, basic events are captured by sensors, which are inserted in to a
target systems, and notiﬁed to the monitoring system. The monitoring system
takes some action(s) - a sequence of commands associated with the event. These
actions can either carry out data collection, or also manipulate the running program. In order to follow the idea of event-based monitoring both the LM and
the JVMLM must support the event notiﬁcation.
Java-oriented Techniques for Event-Based Monitoring. JVM notiﬁes
several internal events to the JVMLM, using JVMPI and JVMDI. These events
are ﬁred by changes in the state of Java threads, like (started, ended, blocked
on a locked monitor ), the beginning/ending of an invoked method, class loading
operations, object allocation/deallocation, and the beginning/ending of JVM
garbage collection, exception throwing, etc.
To support the interactive observation of the target system, all events must
be processed by the JVM agent, while the agent sends the events to the LM
2

The word object is used in terms of the J-OMIS object hierarchy.

Monitoring System for Distributed Java Applications

477

selectively, to avoid too much overhead on the LM. This is based on a ﬁltering
mechanism introduced into the JVM agent, which selects which events should
be sent to the LM.
To control the forwarding of events, the agent uses a ﬁlter in form of a table,
where it stores information about what events the LM is interested in. The LM
manipulating this event ﬁlter table can stop or resume the notiﬁcation of speciﬁc
events sent from its agents.
The OMIS Event Model, along with the event term, additionally deﬁnes
the event class predicate, specifying a set of event occurrences, a pattern deﬁning
the events of interest. In the OCM, event classes are represented by an event
service together with its parameters. The event processing in the OCM is based
on the idea that event classes form a tree hierarchy, where the root is the universal
class containing all detectable events. New event classes are derived from the
existing ones via the use of ﬁlters that allow only certain events to pass. Each
class in the event class tree may be associated with a set of ﬁlters, each of
which is used to derive a more speciﬁc event class from a more general one.
In addition, some event classes may have their associated action lists. When
an event is detected by the OMIS compliant monitoring system, it is matched
against all the event classes in the tree, by doing a tree traversal starting with
the tree’s root, which matches all events. At each traversed node, the ﬁlters
associated with that node are evaluated. If a ﬁlter evaluates to true, the event
matches the derived event class, which is therefore traversed, too. During this
tree traversal, the action lists associated with the event classes matched by the
event are scheduled for execution.
Event Processing in the J-OCM. The J-OCM as an adaptation of the
OCM for Java applications extends the event tree of the OCM by its own subtree.
The new event hierarchy, shown in Fig.2, consists of three types of event classes.
The jvm any is the ’root’ of Java related event classes and is triggered whenever any of JVMs registered in the monitoring system generates an event. The
jvm any is a Singleton 3 , the event class that has only one instance to provide
the global point of access to it in the Local Monitor.
All other event classes, which relate to other object types speciﬁed in JOMIS, e.g. jvms, threads, classes, etc. are derived from this one using ﬁlters.
The jvm control, jvm {thread, class, object, method} control classes
represent abstract object control event classes 4 . Leaves, those elements of the
tree which do not have children, represent the events which are deﬁned by the
interface speciﬁcation, i.e. J-OMIS. J-OMIS classiﬁes event services based on the
categories of elements of the Java program architecture the services operate on.
The J-OCM event tree follows this classiﬁcation, similarly the control services
group the event services operating on a type of token, e.g. thread, JVM. But some
3
4

Singleton Design Pattern
The term ’abstract’ is used in the sense that these event classes cannot be involved
in a conditional request via the J-OMIS tool/monitor interface, whereas the term
’control’ refers to all events occurrences, characteristic for the particular type of
object, e.g. jvm thread control comprises all events connected with JVM threads

478

W. Funika, M. Bubak, and M. Sm¸etek
any

mon_received_signal

proc_control

jvm_any

jvm_thread_control
jvm_control
...

jvm_interface_unloaded

jvm_class_control
jvm_thread_ended

jvm_thread_has_started_thread

jvm_object_control
jvm_started_gc . . . jvm_loaded_class

jvm_class_unloaded . . . jvm_class_loaded_class

...
jvm_object_ref_alloc
Legend:

jvm_object_ref_free

jvm_method_control
Filter
Event Class
Control Event
Class

jvm_method_entered

jvm_method_exited

Fig. 2. Hierarchy of J-OCM events

event services have been moved over in the event hierarchy in order to recognize
the situation where the event took place. The information which is needed to
determine whether an event matches a given event class is the location (context)
of the event, e.g. the event service jvm method entered indicates when a given
method is called, i.e. we need to specify the most dynamic elements of a Java application execution, e.g. JVM, thread, object because they determine the context
of the event occurrence, i.e. an event may occur on a particular JVM, in a thread,
and refer to an object. The presented shape of the J-OCM events tree allows to
narrow the event detection and to simplify extending the tree by new events.
Event-Based Interaction. The most critical part of the J-OCM event system are interactions between the Local Monitor and its Java agents (JVMLMs).
The Java agents use the SHMLAE to notify the LM of the event occurrence
and to transfer event-speciﬁc parameters. A speciﬁc event, before being handled
by the LM, must be enabled in the speciﬁc JVMLM. This is done when a tool
enables the previously deﬁned event service request, by issuing a csr enable
service. Once the JVM agent has received the request from the LM, it starts
passing events to the LM which must take care of handling them.
The OCM uses signals as asynchronous mechanism to notify the message
arrival and deﬁnes a special event class, called mon received signal(integer
sig no) that is triggered when the monitor process receives the speciﬁed signal.
The use of this event class is the solution to handle events from the JVM agents,
and next to process them, according to the OMIS event model. The universal
event class jvm any relating to Java speciﬁc events derives from mon receive signal event class. The ﬁlter that is located between these two event classes
(Fig. 2) is invoked each time the monitor gets a signal sent by an agent. It uses a

Monitoring System for Distributed Java Applications

479

non-blocking receive call to get messages containing information about an event
that has occurred in a monitored JVM and executes jvm any, i.e. the ’root’ of
the Java event classes hierarchy, where further event processing takes place.

6

Conclusions

The work on building a Java-oriented tools followed the idea of separating the
layer of tools from a monitoring system’s functionality. We extended the On-line
Monitoring Interface Speciﬁcation by a Java speciﬁc hierarchy of objects and a
set of relevant services. The work on a Java-oriented monitoring system, the JOCM, concentrated on extending the functionality of Local Monitors which are
the distributed part of the system and introducing new software levels interfacing
the J-OCM to JVM and providing a communication mechanism for the low-level
layers. Our on-going work focuses on completing the implementation of the JOCM and designing a suite of Java-oriented monitoring-based tools.
Acknowledgements. We are very grateful to Prof. Roland Wism¨
uller for valuable comments. This research was carried out within the Polish-German collaboration and it was partially supported by the KBN grant 4 T11C 032 23.

References
1. M. Bubak, W. Funika, P. M¸etel, R. Orlowski, and R. Wism¨
uller: Towards a Monitoring Interface Speciﬁcation for Distributed Java Applications. In Proc. 4th Int.
Conf. PPAM 2001, Nal¸ecz´
ow, Poland, September 2001, LNCS 2328, pp. 315-322,
Springer, 2002.
2. M. Bubak, W. Funika, M.Sm¸etek, Z. Kilia´
nski, and R. Wism¨
uller: Architecture of
Monitoring System for Distributed Java Applications. In: Dongarra, J., Laforenza,
D., Orlando, S. (Eds.), Proceedings of 10th European PVM/MPI Users’ Group
Meeting, Venice, Italy, September 29 - October 2, 2003, LNCS 2840, Springer,
2003
3. T. Ludwig, R. Wism¨
uller, V. Sunderam, and A. Bode: OMIS – On-line Monitoring
Interface Speciﬁcation (Version 2.0). Shaker Verlag, Aachen, vol. 9, LRR-TUM
Research Report Series, (1997)
http://wwwbode.in.tum.de/˜omis/OMIS/Version-2.0/version-2.0.ps.gz
4. R. Wism¨
uller, J. Trinitis and T. Ludwig: A Universal Infrastructure for the Runtime Monitoring of Parallel and Distributed Applications. In Euro-Par’98, Parallel
Processing, volume 1470 of Lecture Notes in Computer Science, pages 173-180,
Southampton, UK, September 1998. Springer-Verlag.
5. Sun Microsystems: Java Virtual Machine Proﬁler Interface (JVMPI)
http://java.sun.com/j2se/1.4.2/docs/guide/jvmpi/jvmpi.html
6. Sun Microsystems: Java Virtual Machine Debugging Interface (JVMDI)
http://java.sun.com/products/jdk/1.2/docs/guide/jvmdi/jvmdi.html
7. Sun Microsystems: Java Native Interface (JNI)
http://java.sun.com/products/jdk/1.2/docs/guide/jni/
8. Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. Design Patterns.
Addison-Wesley, 1995.

