Predicting the Shrinking Generator with Fixed
Connections
Patrik Ekdahl1 , Willi Meier2 , and Thomas Johansson1
1

Dept. of Information Technology
Lund University, P.O. Box 118
SE-221 00, Lund, Sweden
{patrik,thomas}@it.lth.se
2
FH Aargau,
CH-5210 Windisch, Switzerland
meierw@fh-aargau.ch

Abstract. We propose a novel distinguishing attack on the shrinking
generator with known feedback polynomial for the generating LFSR. The
attack can e.g. reliably distinguish a shrinking generator with a weight
4 polynomial of degree as large as 10000, using 232 output bits. As the
feedback polynomial of an arbitrary LFSR is known to have a polynomial
multiple of low weight, our distinguisher applies to arbitrary shrunken
LFSR’s of moderate length. The analysis can also be used to predict the
distribution of blocks in the generated keystream.

1

Introduction

The shrinking generator (SG) is a well known pseudo random generator proposed
in 1993 by Coppersmith, Krawczyk and Mansour [3]. It is intended for use in
stream cipher applications and is of interest by its conceptual simplicity: It
combines only two linear feedback shift registers (LFSR’s) in a simple way. Thus
far, it has resisted against eﬃcient cryptanalysis.
In this paper, a practical distinguishing attack on the (SG) is proposed. The
attack exploits a newly detected non-randomness in the distribution of output
blocks in the generated keystream.
Recall that the (SG) [3] uses two independent binary LFSRs, say A and S,
as basic components. The pseudo random bits are produced by shrinking the
output sequence of the generating LFSR A under the control of the selecting
LFSR S as follows: The output bit of LFSR A is taken if the current output bit
of LFSR S is 1, otherwise it is discarded. It is recommended in [3] that besides
the initial states also the feedback polynomials be deﬁned by the secret key. We
would like to stress that the present attack is not applicable to a (SG) with
unknown feedback polynomial for the generating LFSR.
There have been known several approaches for attacking the (SG): A basic divide-and-conquer attack, which requires an exhaustive search through all
possible initial states and feedback polynomials of S, [3]. On the other hand,
a correlation attack targeting LFSR A is proposed in [6] and is experimentally
E. Biham (Ed.): EUROCRYPT 2003, LNCS 2656, pp. 330–344, 2003.
c International Association for Cryptologic Research 2003

Predicting the Shrinking Generator with Fixed Connections

331

analyzed in [16]. It requires exhaustive search through all initial states and all
possible feedback polynomials of LFSR A. In [12], a reduced complexity correlation attack based on searching for speciﬁc subsequences of the output sequence
has been given, where the complexity and required keystream length are exponential in the length of LFSR A.
It has been shown in [7,8], that the output sequence has a detectable linear
statistical weakness if the feedback polynomial of the generating LFSR A has
very low weight and moderate degree, or is known to have polynomial multiples
with this property.
For our attack we assume the feedback connection of the generating LFSR A
to be known, whereas the selecting sequence can be any random sequence with
independent and equally distributed bit probabilities.
To describe our approach, denote by a-stream the output sequence generated
by LFSR A and by z-stream the output sequence generated by the (SG). The bits
in the a-stream are denoted an , n ≥ 0 and the bits in the z-stream are denoted
zi , i ≥ 0. Rather than single bits, we consider bit strings (blocks) in the a-stream
and compare them with suitable strings in the z-stream.
Consider a block of odd length, centered at the position of an in the a-stream.
If this block is xor-ed with similar blocks (of equal length) centered at all other
tap positions (including the feedback position) in the LFSR-recursion, the sum
is (trivially) the all-zero block. For blocks of odd length, the majority bit is set
1 if the number of ones is larger than the number of zeroes, and 0 otherwise.
Then a key observation is that the majority bits of such blocks fulﬁll the linear
recursion of LFSR A more often than random.
Through the shrinking process, the exact positions of the undiscarded astream bits in the z-stream get lost. However, the deletion rate is 1/2, and we
can guess averaged shrunken tap positions by halving the distances of the tap
positions in the a-stream.
The main idea of our attack is to consider samples in the z-stream where the
blocks near the shrunken tap positions are all imbalanced (a block is imbalanced
if it has a diﬀerent number of ones than zeroes). The bits in these blocks have
with high probability been generated by bits in the neighborhood of the original
tap positions. If a z-block (i.e., a block in the z-stream) with high imbalance
is found, the probability that the corresponding a-block is imbalanced, is quite
high. By estimating the imbalance in the blocks in the a-stream using the measured imbalance in the blocks in the z-stream, we can estimate the majority bit
of the a-blocks.
If these estimated majority bits fulﬁll the linear recursion of LFSR A more
often than random, we can distinguish the z-stream generated by the (SG) from
a truly random sequence. This is indeed the case: Theoretical estimates as well
as extensive experiments have shown that we are able to reliably distinguish
the (SG) from random for low-weight recursions of LFSR A. E. g., for a weight
4 recursion of length 10000, the attack needs about 232 output bits, and for a
weight 3 recursion of length 40000, the attack needs about 223 output bits to
reliably distinguish the (SG). This compares nicely with the estimates given for

332

P. Ekdahl, W. Meier, and T. Johansson

Linear recursion:
an+an+n2+...+an+nW = 0
Generating LFSR
a-stream

Selection
logic

z-stream

Selection source
Fig. 1. Model of the shrinking generator used in the attack.

the distinguishers as described in [7,8], both of which for these parameters needs
about 248 output bits, and 239 output bits, respectively.
As the feedback polynomial of an arbitrary LFSR of length L is known to
have a polynomial multiple of weight 4 and length about 2L/3 , [1,9,13,17] our
distinguisher also applies to arbitrary shrunken LFSR-sequences of moderate
length.
The paper is organized as follows. In Section 2 we present the attack. In
Section 3 we analyze the proposed attack in terms of probability of success
and required length of observed keystream. Simulation results are presented in
Section 4, and some concluding remarks are given in Section 5. Finally, the
technical details are presented in Appendix A.

2

Description of the Attack

For the description of the attack, we assume a (SG) with a weight W feedback polynomial generating the an sequence. See Fig. 1. The known recurrence
equation is given by
an + an+n2 + an+n3 + . . . + an+nW = 0,

n ≥ 0.

(1)

We do not distinguish the feedback position from the other tap positions, so for a
certain bit an , the tap positions are n, n+n2 , n+n3 , . . . , n+nW . Now, consider a
bit string (block) surrounding a position an in the a-stream. If we xor this block
with the blocks (of equal length) surrounding the other positions in the LFSR
recurrence equation, an+n2 , . . . , an+nW , the sum (trivially) is the all-zero block.
If we choose the considered block length to be odd, each of the W blocks must
have a unique majority bit. The majority bit is 1 if the number of ones in the
block is larger than the number of zeros, and vice versa. The main observation
is, that the majority bits of such blocks fulﬁll the linear recurrence equation of
the LFSR, with a probability larger than 1/2. First we formally introduce the
intuitive notion of imbalance.
Deﬁnition 1. The imbalance of a block B, Imb(B), is deﬁned as
number of 1’s in B − number of 0’s in B
Furthermore, a block B is said to be imbalanced if Imb(B) = 0.

Predicting the Shrinking Generator with Fixed Connections

333

The general idea is to search for imbalanced blocks in the z-stream at positions zi1 , zi1 +n2 /2 , . . . , zi1 +nW /2 . These positions are called the shrunken tap
positions, where i1 implicitly is the reference position. The bits in these blocks
have with high probability been generated by bits in the neighborhood of the
unshrunken tap positions, an1 , an1 +n2 , . . . , an1 +nW , where w.l.o.g. we assume
an1 = zi1 . If we ﬁnd a block with high imbalance in the z-stream, then the
probability that the corresponding block in the a-stream is imbalanced, is quite
high. Then we can derive good approximations of the true majority bits in the
a-blocks.
The attack has two phases. The ﬁrst phase is a search for positions in the
output sequence, where we ﬁnd imbalanced blocks centered around every of the
shrunken taps. Whenever we ﬁnd such a position we say we have a hit, and
invoke the second phase, which estimates the majority bits of the unshrunken
segments. We then count the number of times the xor sum of the estimated
majority bits equal zero, and compare with the truly random case.
2.1

First Phase

Pick a block B1 of odd length BL1 = E + 1 centered around a reference position
zi1 , where E is an even parameter to the attack. As we assume zi1 = an1 , the
bits in B1 come from bits surrounding an1 .
The next unshrunken tap an1 +n2 is with high probability mapped to an
√
interval near i1 + n2 /2. This interval size grows proportionally to n2 . The same
holds for the other taps. Thus at tap position nj , j = 2, . . . , W , we measure on
√
a block centered at position i1 + nj /2 of length BLj ≈ BL1 + nj /2. The ≈
symbol denotes here: “take the closest odd integer”, since we need an odd length
for having a unique imbalance.
Next, we measure the imbalance in each block, Imb(Bj ), j = 1 . . . W . Whenever we have |Imb(Bj )| > T, j = 1 . . . W , where T is an imbalance threshold, we
have found a hit, and it is likely that the a-blocks surrounding the unshrunken
taps, also are imbalanced. If we do not ﬁnd imbalanced z-blocks at the chosen
reference position we pick a new zi1 and again measure the imbalance. However,
if we have a hit in phase 1, we invoke the second phase.
2.2

Second Phase

The ﬁrst goal of the second phase is to try to estimate the bit probability of the
a-blocks. First we introduce some notations. Let S1 be the a-block of length La
surrounding an1 . Similarly, we denote by Sj , j = 2, . . . , W the a-block of length
La surrounding an1 +nj . Denote by pj , j = 1, . . . , W the estimated probability
that a bit in Sj equals 1.
Since we assumed that the center bit zi1 = an1 , we will use the ﬁrst block as
a reference. The ﬁrst z-block is of length E + 1. We denote this reference block
length by Lz = E + 1. For our considerations we can assume that the z-block
B1 of odd length, was produced by an odd length a-block. Thus we choose the
a-block length as La = 2Lz − 1 = 2E + 1.

334

P. Ekdahl, W. Meier, and T. Johansson
a-stream:

position n1+nj

a-block Sj of length La

z-stream:
k=-1
k=0
k=1

position i1+nj / 2-1

position i1+nj / 2

blocks of length Lz

position i1+nj / 2+1

Fig. 2. Picture of which blocks are used in the weighting of estimating pj , j = 2, . . . , W .
The interval size shown here is only 3 positions.

If we measure the imbalance Imb(B1 ) in B1 , and assume that the bits which
where discarded are balanced, i.e., the La − Lz = E bits not visible as output
bits are equally distributed, we have the following estimate
number of ones in S1
(Imb(B1 ) + Lz )/2 + E/2
=
La
La
1 Imb(B1 )
= +
.
2
4E + 2

p1 =

(2)
(3)

For the other W − 1 taps we proceed in a slightly diﬀerent way. Since we are
not sure which z-block contains the most bits from Sj , we must consider several
z-blocks centered near zi1 +nj /2 . Thus, we pick an interval Ij and calculate a
weighted average over Ij , of the bit probability in Sj as
pj =

1
+
2

k∈Ij

imbj,k
P (k is the best position for estimating Sj ) j = 2 . . . W,
4E + 2
(4)

where imbj,k is the imbalance in the z-block of length Lz surrounding zi1 +nj /2+k .
The expression for P (k is the best . . . ) is discussed in Appendix A, but the aim
is to try to derive a probability that the z-block at i1 + nj /2 + k has the most
bits from Sj , and we assume that the binomial distribution
P (k is the best position for estimating Sj ) = Bin[nj , 0.5](

nj
+ k)
2

(5)

is adequate. Fig. 2 shows a picture of the blocks used in the weighting process
for a small interval of k ∈ [−1, 0, 1].
In (4), we have used similar calculations as in (2) and the additional assumption that the bit probability is 0.5 if the best position, k, is outside the interval
Ij .
The estimated bit probability pj , j = 1, . . . , W also represent an estimate of
the majority bit for Sj . For each hit we have in phase 1 of the attack, we can

Predicting the Shrinking Generator with Fixed Connections

335

determine an estimate of the xor sum of the majority bits. The simplest decision
rule is to ﬁrst make a hard decision on the estimated majority bit m
ˆ j as
m
ˆj =

1
0

if pj ≥ 12
,
otherwise

j = 1, . . . , W,

(6)

ˆ j = 0 holds. By dividing the number of times the
then check if the xor sum j m
xor sum equals zero with the number of hits we have, we can derive a measured
ﬁnal probability that the sum of the true majority bits equals zero.
We can also employ a soft decision rule. It is well known [11] that a soft
decision rule is no worse than a hard decision rule, so employing a soft decision
rule can only improve the attack. The hard decision rule is however simpler to
analyze, and for that reason we have use a hard decision rule in the analysis and
in our simulations.
If we indeed are attacking the (SG), we expect the total probability
P = 0.5 + εH ,

(7)

where εH is a positive value depending on the number H of hits we get in phase
1. If we are attacking a true random sequence, we expect P = 0.5. The optimal
test to distinguishing these cases [4] is a Maximum Likelihood (ML) test, where
we decide using a threshold Γ such that if P ≥ Γ we decide the output sequence
to be generated from the (SG), otherwise we decide it is a random source. We
have summarized the proposed attack in Fig. 3.

3

Analysis of the Proposed Attack

We start by considering the probability that the majority bits of Sj , j = 1, . . . , W
fulﬁll the recurrence equation. We will interchangeably be using imbalance and
Hamming weight (Hw) as they measure similar quantities, where the Hamming
weight of a block B is the number of ones in B. For odd block length L we have
the conversion between imbalance imb and Hamming weight hw as:
imb = 2hw − L,
imb + L
.
hw =
2
3.1

The Probability of the Sum of the Majority Bits

Assume we look at the direct output of a LFSR with W taps (including the
feedback position). Pick a reference position an in the a-stream, and consider
the positions an+n2 , . . . , an+nW that together with an sum to zero, according to
the linear recurrence equation of the LFSR. At each position we take a centered
block (or vector) Sj of odd length La . The positions and the length are assumed
to be chosen such that the blocks are non-overlapping. We aim to calculate the

336

P. Ekdahl, W. Meier, and T. Johansson
Input: even integer E, imbalance threshold T , the tap positions nj , j =
1, . . . , W , where n1 = 0, and a sequence Zi , i = 1, . . . , N of received bits.
1. Setup variables.
BL1 = E + 1,

√
BLj = closest odd integer (BL0 + nj /2), j = 2, . . . , W,
√
√
Ij = integers in [− nj /3, . . . , nj /3], j = 2, . . . , W
√
low = E/2, high = N − (nW /2 + nW /3 + E/2),
hits = 0, good = 0.

2. For i1 = low to high do
a) For all j = 1, . . . , W , let Bj be the z-block centered at i1 + nj /2 of
length BLj .
b) Let imbj = Imb(Bj ), j = 1, . . . , W .
c) If ∀j |imbj | > T then
i. Increase hits and set
p1 =

1
imb1
+
2
4E + 2

pj =

1
+
2

k∈Ij

imbj,k
nj
4E + 2 nj /2 + k

1
2

nj

, j = 2, . . . , W,

where imbj,k is the measured imbalance in the z-block of length
BL1 centered at position i1 + nj /2 + k.
ii. Make a hard decision ∀j, m
ˆ j = 1 if pj ≥ 0.5 otherwise m
ˆ j = 0.
iii. if j m
ˆ j = 0 increase good. ( denotes here the xor sum.)
√
3. Set Γ = 0.5 + hits/(2hits).
4. If good/hits > Γ return Shrinking else return Random.
Fig. 3. A summary of the proposed attack using a hard decision rule.

probability that the majority bits of the segments fulﬁll the recurrence equation
of the LFSR. We assume the distribution of the possible vectors at tap j, j =
1, . . . , W − 1, only to be dependent on the Hw of the vector. The vector at the
ﬁnal tap is totally determined by the choices at the W − 1 previous taps since
the xor of the vectors must be the all-zero vector. Introduce the notation
Vj (α) = P (H(Sj ) = α),

(8)

for the probability that we have a vector of length La and Hw α at tap j, j =
1, . . . , W − 1.
We can partition the possible vectors at the taps into sets of equal Hamming
weight. The probability of each set is given by Vj (α). When we xor the ﬁrst two
vectors, we get a new probability distribution on the sets of diﬀerent Hamming
weight. In these sets, the majority bit of the vector sum may or may not agree
with the sum of the majority bits of the xored vectors. So when we derive the

Predicting the Shrinking Generator with Fixed Connections

337

Table 1. Simulation results versus theory for the probability that the majority bits
sum to zero.
La Simulation Theory
5 0.56082 0.56054
0.56050
11 0.52254 0.522076
0.52169
17 0.51372 0.51340
0.51298
29 0.50764 0.50748
0.50727

new distribution, we also keep track of when the sum of the constituent majority
bits agree with the majority bit of the resulting vector. When we have xored the
W − 1 vectors, we know that the ﬁnal vector must agree with the sum of the
ﬁrst W − 1 vectors. Thus we can sum up the probabilities where the sum of the
constituent majority bits agree with the majority bit of the resulting vector.
The technical part of the calculations can be found in Appendix A. We only
conclude the validity of the approach by comparing the theoretical probability
to a number of simulations for diﬀerent block length La with W = 4. The
comparison is shown in Table 1. The number of trials in the simulations were
10 000 000.
3.2

Skewing the Distributions Vj

Since in phase 1 of the attack we impose the condition that the absolute value
of the imbalance in the z-block should be greater than a certain threshold T , the
distributions Vj for the a-blocks will not be binomial, as expected from a random
source. As the probabilities P (Imb(Bj ) > T ) = 0.5 and P (Imb(Bj ) < −T ) = 0.5
are equally likely, we divide the distribution Vj into two parts.
Vj (α) =

Vj+ (α) + Vj− (α)
,
2

j = 1, . . . , W

(9)

where
Vj+ (α) = P (H(Sj ) = α|Imb(Bj ) > T ),

(10)

Vj− (α)

(11)

= P (H(Sj ) = α|Imb(Bj ) < −T ),

and H(Sj ) is the Hw of the a-block Sj .
We can not hope to give an exact expression for (10) and (11) since there are
too many dependencies between adjacent imbj,k in (4). We can however derive
approximate expressions. The derivation is omitted due to space limitations, but
can be found in an extended version of this paper available from the authors.
Intuitively, and also from the derived approximations, we note that Vj+ and Vj−
are “mirrored” distributions in the sense that Vj+ (α) = Vj− (La − α).

338

3.3

P. Ekdahl, W. Meier, and T. Johansson

An Approximation on the Required Number of Hits

First, we consider the probability that the estimated majority bit m
ˆ j is correct.
We will conﬁne us to the case of a hard decision rule. Through simulations we
have noted that these probabilities are not independent. The ﬁrst W −1 majority
bits are more often correctly predicted if all or most of the W − 1 a-block are
strongly imbalanced. But then also the W ’s block tends to have some imbalance
and thus gives better prediction of the majority bit. In the analysis we will
however assume that they are independent.
Assume without loss of generality that mj = 1. Then we know that the
vectors of Sj are drawn (on the average) from the distribution Vj+ . The probability Pmj that mj is correct is determined by the probability mass that gives a
majority bit equal to 1. We have
La

Vj+ (α),

Pmj =

j = 1, . . . , W.

(12)

α=(La +1)/2

The same holds if we have mj = 0 because of the mirrored properties of Vj+ and
Vj− .
Let mj be the true majority bit of the a-block Sj , and as before, let m
ˆ j be
ˆ j) =
the hard decision estimate as derived in the attack. We have P (mj = m
Pmj . We can model this as if we have a noisy observation of the true majority
bits, where the noise for each observation is equal to 0 with probability Pmj .
Furthermore, let Pn denote the probability that noise variables sum to zero.
Using the independency assumption and the piling-up-lemma [14] we have
W

Pn =

1
(Pmj − 0.5).
+ 2W −1
2
j=1

(13)

The correctness of the estimates m
ˆ j , j = 1, . . . , W are assumed independent
of the probability P ( j mj = 0). Recalling (7) and introducing the notation
PM for the probability that the true majority bits sum to zero, we have an
approximation of the total probability P , that the estimated majority bits sum
to zero:
1
1
P = + 2(PM − 0.5)(Pn − 0.5) = + εH .
(14)
2
2
Using similar arguments as in [2,5], we can state an upper bound on the
number of hits H we need in phase 1 to distinguish the (SG) from a truly
random sequence as:
1
(15)
H≤ 2 .
εH
3.4

A Lower Bound on the Expected Number of Hits

In phase 1 of the attack, we search for positions in the z-stream where we ﬁnd
W blocks Bj , j = 1, . . . , W of length BLj , j = 1, . . . , W , such that we simultaneously have |Imb(Bj )| > T . If we again make the simplifying assumption

Predicting the Shrinking Generator with Fixed Connections

339

that the imbalance (or Hamming weight) of the blocks are independent, we can
derive a lower bound on the expected number of hits in phase 1, given a received
sequence of length N from the generator.
The probability PBj that we have |Imb(Bj )| > T for a block of length BLj
where we assume the keystream bits from the generator to be independent and
random is given by
BLj

PB j =
h=1+

T +BLj
2

BLj
h

1
2

−T +BLj
2

BLj

+
h=0

−1

BLj
h

1
2

BLj

.

(16)

The approximated joint probability of ﬁnding W blocks is given by PH =
PBj and thus we would expect

W
j=1

H ≥ PH N.
3.5

(17)

Parameters Trade-Oﬀs

If we choose a large value for the parameter E we will have larger blocks Bj and
the probability for the bit anj to be mapped inside Bj increases. On the other
hand the a-blocks will also be larger, resulting in a smaller probability for the
true majority bits summing to zero. If we only choose the lengths BLj larger
then the distribution for the smaller block which is scanned in (4) tends to be
more binomial, which gives us less non-randomness to extract information from.
If we choose a high imbalance threshold T , we will get more skewed distributions Vj and we will need a fewer number of hits to distinguish the sequence.
But on the other hand, the probability for getting a hit in phase 1 decreases,
thus requiring a longer received sequence.

4

Simulation Results

In this section we present some simulation results and do a comparison with the
derived theoretical approximation. In the attack
we have used the hard decision
√
rule and a decision threshold Γ = 0.5 + hits/(2hits), which corresponds to
about one standard deviation from the expected value if the sequence were truly
random. We start by attacking a weight 4 LFSR given by the linear recurrence
equation
an + an+302 + an+703 + an+1000 = 0.

(18)

Using a threshold T = 3 and block size parameter E = 14, the theoretical
calculations (14) and (16) give PH = 0.02648 and εH = 0.00092. Thus we would
need about H = 1/ε2H ≈ 220 hits in phase 1 and N = H/PH ≈ 225 received
output bits. Running the attack with these conﬁgurations 50 times (with random
initial state), we can distinguish the (SG) in all 50 cases.

340

P. Ekdahl, W. Meier, and T. Johansson

Table 2. Theoretic results and simulation results of attacking the (SG) with some
weight 4 feedback polynomials
Tap positions
(excluding 0)
302, 733, 1000

Theoretic parameters
PH

εH

H

N used Successes out

N in attack

0.02648 2−10.1 220.2 225.4

223
24

812, 1433, 2500

−11.5

0.03586 2

23.0

2

27.8

2

2333, 5847, 8000 0.05542 2

27.0

2

31.2

2

46

225

50

25

2

3097, 6711, 10000 0.05989 2

27.7

2

31.8

2

39

2

46

227

50

28

2

29

−13.9

43

2

26

−13.5

of 50 runs

42

2

48

230

50

28

2

45

229

45

30

2

46

Table 3. Theoretic results and simulation results of attacking the (SG) with weight 3
and weight 5 feedback polynomial
Tap positions

Theoretic parameters

(excluding 0)

PH

17983, 40000

εH
−10.2

0.1414 2

N used Successes out

H

N in attack

20.3

23.1

2

2

21

2

36

222

46

23

2
−11.56

73, 131, 219, 300 0.0068 2

23.1

2

30.3

2

of 50 runs

29

50

2

48

230

50

As the degree of the feedback polynomial increases, the attack naturally needs
a larger received sequence, and it becomes impractical to simulate the attack.
Also, the approximations made in the analysis tends to overestimate the required
N , as experiments with shorter sequences have shown. We have summarized
some results on attacking weight 4 feedback polynomials in Table 2. We also
give two examples of attacking a (SG) with weight 3 and weight 5 feedback
polynomial in Table 3.
The computational complexity of the attack is quite modest. If we use precomputed tables for (5) we see that we need to scan the input sequence once,
and whenever we have a hit we calculate (4). The size of the interval Ij is pro√
√
portional to nj and hence we have the computational complexity O(N nW ),
where N is the number of received output bits and nW is the last tap position
or the degree of the feedback polynomial.

Predicting the Shrinking Generator with Fixed Connections

5

341

Conclusions

We have proposed a practical distinguishing attack on the shrinking generator
with a low-weight feedback polynomial for the generating LFSR. The new idea
is that the majority bits of blocks in the LFSR stream fulﬁll the linear recursion
more often than random, and we have presented and analyzed a quite powerful
method of estimating those bits, based on the received sequence.
We do not need to have the ﬁrst segment as reference segment. We could
also use a tap in the middle and calculate both forward and backward, thus
increasing the probabilities of the estimates.
The proposed attack can also be used to predict the distribution of bits
in the generated sequence. Assume we know that the generating source is the
(SG). First we calculate the bit probability of the W − 1 ﬁrst segments. By the
theoretical calculations of the probability that the majority bits sum to zero we
can derive the unknown distribution of the last segment.
The authors also would like to thank Vishal Chandra, who helped simulating
some early ideas for an attack, and the anonymous referees for giving valuable
comments on how to improve the manuscript.

References
1. A. Canteaut, M. Trabbia, “Improved Fast Correlation Attacks Using Parity-Check
Equations of Weight 4 and 5”, Advances in Cryptology – EUROCRYPT 2000,
LNCS vol 1807, Springer-Verlag, 2000, pp. 573-588.
2. D. Coppersmith, S. Halevi, C. Jutla, “Cryptanalysis of stream ciphers with linear
masking”, Advances in Cryptology - CRYPTO 2002, LNCS vol 2442, Springer,
2002, pp 515-532.
3. D. Coppersmith, H. Krawczyk, Y. Mansour, “The Shrinking Generator”, Advances
in Cryptology - Crypto’93, LNCS vol 773, Springer-Verlag, 1994, pp 22-39.
4. T. Cover, J. Thomas, Elements of Information Theory, Wiley series in telecommunications, Wiley-interscience, 1991.
5. P. Ekdahl, T. Johansson, “Distinguishing attacks on SOBER”, Fast Software Encryption (FSE) 2002, LNCS vol 2365, Springer 2002, 210-224.
6. J. Dj. Goli´c, L. O’Connor, “Embedding and probabilistic correlation attacks
on clock-controlled shift registers”, Advances in Cryptology – EUROCRYPT’94,
LNCS vol 950, Springer-Verlag, 1995, pp. 230-243.
7. J. Dj. Goli´c, “Towards Fast Correlation Attacks on Irregularly Clocked Shift Registers”, Advances in Cryptology – EUROCRYPT’95, LNCS vol 921, Springer-Verlag,
1995, pp. 248-262.
8. J. Dj. Goli´c, “Linear Models for Keystream Generators”, IEEE Trans. on Computers, vol 45, No 1 January, IEEE Press, 1996, pp. 41-49.
9. J. Dj. Goli´c, “Computation of low-weight parity-check polynomials”, Electronic
Letters, Vol. 32, No 21 October, 1996.
10. J. Dj. Goli´c, “Correlation analysis of the Shrinking Generator”, Advances in Cryptology – CRYPTO 2001, LNCS vol 2139, Springer-Verlag, 2001, pp. 440-457.
11. R. Johannesson, K. Sh. Zigangirov, Fundamentals of convolutional coding, IEEE
Series on digital and mobile communication, IEEE Press, 1999, p 5.

342

P. Ekdahl, W. Meier, and T. Johansson

12. T. Johansson, “Reduced complexity correlation attacks on two clock-controlled
generators”, Advances in Cryptology – ASIACRYPT’98, LNCS vol 1514, SpringerVerlag, 1998, pp. 342-357.
13. T. Johansson, F. J¨
onsson, “Fast Correlation Attacks Through Reconstruction of
Linear Polynomials”, Advances in Cryptology – CRYPTO 2000, LNCS vol 1880,
Springer-Verlag, 2000, pp. 300-315.
14. M. Matsui, “Linear cryptanalysis method for DES cipher, Andvances in Cryptology
– EUROCRYPT’93, LNCS vol 765, Springer-Verlag, 1994, pp. 386-397.
15. A. Menezes, P. van Oorschot, S. Vanstone, Handbook of Applied Cryptography,
CRC Press, 1997.
16. L. Simpson, J. Dj. Goli´c, E. Dawson, “A probabilistic correlation attack on the
shrinking generator”, Information Security and Privacy’98 - Brisbane, LNCS vol
1438, Springer-Verlag, 1998, pp. 147-158.
17. D. Wagner, “A Generalized Birthday Problem”, Advances in Cryptology –
CRYPTO 2002, LNCS vol 2442, Springer-Verlag, 2002, pp. 288-303.

Appendix A
In this Appendix we have gathered some of the more technical details in the
proposed attack and the analysis of the attack.
Some Details of Phase 2
The interval size in (4) is a tunable parameter to the attack and we have chosen
√
√
it to be the integers in the range [− nj /3, . . . , nj /3]. Next we consider the
probability that the z-block centered at zi1 +nj /2+k , k ∈ Ij , is the best block
to choose. An exact mathematical expression for this notion is hard to ﬁnd
because of the deletion process. To simplify the calculations we assume that
this probability is given by the binomial distribution, Bin[nj , 0.5](nj /2 + k).
This assumption does not take into account that the bit an1 +nj might not be
visible (printed) in the z-stream at all, since it might be deleted. However, we can
disregard whether the bit is printed or not since we are only trying to estimate the
surrounding of an1 +nj . Thus, the assumed distribution is reasonably adequate,
and we write
P (k is the best position for estimating Sj ) = P (k is best) =
Bin[nj , 0.5](

nj
+ k) =
2

We note that the interval Ij is chosen such that

k∈Ij

nj
nj
2 +k

1
2

nj

(19)

P (k is best) ≈ 0.5.

Probability That the Sum of the Majority Bits Equal Zero
We will assume that the bits in the ﬁrst W − 1 vectors in the LFSR case can be
approximated by the true random case. Given this assumption, the probability
Vj is given by the binomial distribution
Vj (α) = Bin[La , 0.5](α),

i = 1 . . . W − 1.

(20)

Predicting the Shrinking Generator with Fixed Connections

343

When xoring vectors together, we will denote the distribution of vectors (for the
sum) by Qj (α). We will add a super script to this Q later, but for now on, we
say that Q1 (α) = V1 (α), α = 0 . . . La , since we have not added any vectors but
the ﬁrst. Q2 (α) will be the probability of a vector of Hw α when we have xored
two V distributions. We also introduce an operator to determine the majority
bit. Let M aj(α) denote the majority bit of a vector of length La and Hw α. We
have
M aj(α) =

1 if α > (La − 1)/2,
0 otherwise.

The next lemma states what Hw’s to expect, and how many of them we get,
when xoring two vectors together.
Lemma 1. Let A be a ﬁxed vector of length La and Hw α. If we xor all possible
vectors (one at a time) of Hw β with A, then the possible Hw’s of the xor sum
are γ = α − β + 2κ where max(0, β − α) ≤ κ ≤ min(La − α, β). The number of
resulting vectors with Hw γ is given by
α
β−κ

La − α
.
κ

(21)

Proof. Denote by B the set of all vectors with Hw equal to β. Assume κ of the
1’s in B coincide with the 0’s of A. This implies that β − κ of the 1’s in B
coincide with the 1’s of A. The number of such vectors in B is
α
β−κ

La − α
.
κ

For the choice of κ we must have 0 ≤ β − κ ≤ α or equivalently α − β ≤ κ ≤ β,
since at least zero 1’s and at most α of the 1’s can coincide. Similarly, we must
have 0 ≤ κ ≤ La − α, since the number of 0’s in A is La − α. Combining these
restrictions we get max(0, α − β) ≤ κ ≤ min(La − α, β). The resulting Hw of
the xor sum is γ = α − (β − κ) + κ = α − β + 2κ, which proves the lemma.
Thus, if we pick one vector B of Hw β uniformly at random (over the set of
vectors with Hw β) and xor with the ﬁxed vector A, we have the probability

Pγ (α, β, κ) =

α
β−κ

La − α
κ
La
β

,

(22)

of obtaining a resulting vector of Hw γ = α − β + 2κ, where max(0, β − α) ≤
α ≤ min(La − α, β).
When xoring two vectors, we must keep track if the xor of the majority bits
agrees with the majority bit of the sum. For instance, we can get the vector
11110 by

344

P. Ekdahl, W. Meier, and T. Johansson

Vector H-weight Maj. bit
11000
2
0
or by
⊕00110
2
0
11110
4
1

Vector H-weight Maj. bit
11100
3
1
⊕00010
1
0
11110
4
1

We can determine this condition by checking if M aj(α)⊕M aj(β) = M aj(γ),
and we will save the corresponding probability mass in diﬀerent variables, Q0j (α)
for when the sum of the constituent majority bits agrees with the majority bit of
the sum, and Q1j (α) for when it does not. One can think of the super script as a
parity bit for making the sum (of the constituent majority bits and the resulting
majority bit) equal to zero.
Recalling (22) and the fact that we deﬁned Q01 (α) = V1 (α), α = 0, . . . , La we
have for the sum of j = 2 . . . W − 1 vectors:
If M aj(α) ⊕ M aj(β) = M aj(γ),
Q0j (γ) =

Pγ (α, β, κ)Q0j−1 (α)Vj (β),

(23)

Pγ (α, β, κ)Q1j−1 (α)Vj (β),

(24)

Cond(α,β,κ)

Q1j (γ) =
Cond(α,β,κ)

and if M aj(α) ⊕ M aj(β) = M aj(γ),
Q0j (γ) =

Pγ (α, β, κ)Q1j−1 (α)Vj (β)

(25)

Pγ (α, β, κ)Q0j−1 (α)Vj (β),

(26)

Cond(α,β,κ)

Q1j (γ)

=
Cond(α,β,κ)

where Cond(α, β, κ) determines the summation conditions according to

 ∀α, β, κ :
Cond(α, β, κ) = α − β + 2κ = γ,

max(0, β − α) ≤ κ ≤ min(La − α, β).

(27)

In QW −1 , we have the distribution of all but the last tap position vector. If we
know that the sequence comes from a LFSR, we know that the last vector must
force the total vector sum to the all-zero vector. Thus we get the probability
that the xor of the majority bits (mj ) fulﬁlls the recurrence equation as
La

W

PM = P (

Q0W −1 (α).

mj = 0) =
j=1

(28)

α=0

These are the probabilities of the vectors that will have 0 as “majority parity
bit”, thus fulﬁlling the recurrence equation.

