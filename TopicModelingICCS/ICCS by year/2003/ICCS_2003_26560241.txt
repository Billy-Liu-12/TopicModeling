A Simpler Construction of CCA2-Secure
Public-Key Encryption under General
Assumptions
Yehuda Lindell
IBM T.J. Watson
19 Skyline Drive, Hawthorne,
New York 10532, USA.
lindell@us.ibm.com

Abstract. In this paper we present a simpler construction of a publickey encryption scheme that achieves adaptive chosen ciphertext security
(CCA2), assuming the existence of trapdoor permutations. We build on
previous works of Sahai and De Santis et al. and construct a scheme that
we believe is the easiest to understand to date. In particular, it is only
slightly more involved than the Naor-Yung encryption scheme that is
secure against passive chosen-ciphertext attacks (CCA1). We stress that
the focus of this paper is on simplicity only.

1

Introduction

One of the most basic tasks of cryptography is that of providing encryption
schemes that enable the safe delivery of private messages on an open network.
Such an encryption scheme should reveal no information about the plaintext to
an eavesdropping adversary. However, it may be necessary to protect the privacy of messages from an adversary who has more power than just the ability to
eavesdrop. In a chosen-ciphertext attack, the adversary has access to a decryption oracle and uses this is in an attempt to “break” the encryption scheme. Such
attacks come in two ﬂavours: passive chosen-ciphertext attacks (CCA1), where
the adversary can access the decryption oracle only up until the point that it
receives a challenge ciphertext, and adaptive chosen-ciphertext attacks (CCA2),
where the adversary can even access the decryption oracle after it receives the
challenge ciphertext. (In the latter case, the adversary can query the decryption
oracle for any ciphertext except for the challenge itself.) This is a very strong
attack; nevertheless, there are real settings in which this level of security is required (see [2] for an example of an attack on an RSA standard that was made
possible due to the fact that the encryption scheme used was not CCA2-secure).
We refer the reader to [19] for a survey on the importance of CCA2 security.
Feasibility and eﬃciency. Two rather distinct directions of research have been
considered with respect to secure encryption (and cryptography in general).
This work was carried out while the author was at the Weizmann Institute of Science.
E. Biham (Ed.): EUROCRYPT 2003, LNCS 2656, pp. 241–254, 2003.
c International Association for Cryptologic Research 2003

242

Y. Lindell

One direction of research focuses on proving the feasibility of obtaining secure
schemes, while the other concentrates on doing this eﬃciently. The latter research usually relies on speciﬁc number-theoretic (or other) complexity assumptions, whereas the former prefers to only assume the existence of some general
primitive, like a trapdoor permutation. This paper considers the question of
the feasibility of obtaining CCA2-secure encryption, under the assumption that
trapdoor permutations exist. It is well known that such a feasibility result has
already been established. However, known constructions of CCA2-secure encryption schemes under general assumptions are rather complicated. Thus, despite
their importance, it is hard to teach these schemes in a course on cryptography,
for example. The aim of this paper is to improve this situation.
The Naor-Yung paradigm [15]. Our encryption scheme follows the Naor-Yung
paradigm for constructing CCA1-secure encryption schemes. According to this
paradigm, the plaintext is encrypted twice (independently), and then a noninteractive zero-knowledge proof (NIZK) is used in order to prove that both
ciphertexts are encryptions to the same plaintext. The intuition behind this idea
is that if the adversary manages to obtain two encryptions of the same plaintext
with independent keys, then essentially it must already “know” the plaintext.
Therefore, the decryption oracle that it is given is of no help.
The history of the feasibility of CCA2-encryption. The ﬁrst CCA2-secure encryption scheme was presented in a breakthrough work by Dolev, Dwork and
Naor (DDN) [7]. However, their construction is rather complicated, requiring
many multiple encryptions and an involved key-selection technique. An important step in the simpliﬁcation of CCA2-secure encryption was taken by Sahai [17] who showed that CCA2-encryption schemes can actually be constructed
using the Naor-Yung paradigm. This involved introducing a stronger notion of
NIZK proofs, called one-time simulation-sound NIZK. Loosely speaking, onetime simulation-soundness ensures that it is not feasible for an adversary to
generate an accepting NIZK proof of a false statement, even if the reference
string is generated by the simulator and even if a simulated proof (of a not
necessarily true statement) is observed.1 Sahai showed that the Naor-Yung encryption scheme, with the NIZK proof system replaced by one which is one-time
simulation-sound, is CCA2-secure. Unfortunately, much of the complexity of the
DDN construction remained in Sahai’s construction of this strong NIZK. Thus,
on the one hand, the Sahai high-level construction is signiﬁcantly simpler than
DDN; however, when considering all the details, it is still quite involved.
Recently, De Santis et al. [6,18] presented a very elegant and far simpler
construction of simulation-sound NIZK. The aim of their work was actually
to strengthen the notion even further to many-time simulation-soundness. (In
a many-time simulation-sound NIZK, the soundness is preserved even if the
adversary observes many simulated proofs.) Nevertheless, their construction also
yields a simpler CCA2-secure encryption scheme.
1

This is in contrast to regular NIZK proof systems where soundness is only guaranteed
relative to a uniformly distributed reference string.

A Simpler Construction of CCA2-Secure Public-Key Encryption

243

Our contribution. In this paper, we use ideas from [6] and apply them to the
problem of one-time simulation-soundness. Exploiting the fact that one-time
simulation soundness is enough for CCA2-security, we obtain a signiﬁcant simpliﬁcation of the [6] construction for many-time simulation-sound NIZK. Our
construction is both intuitive and simple, and not less importantly, has a short
and easy proof of correctness. By plugging our construction into the Sahai CCA2secure encryption scheme, we obtain a scheme that is only slightly more involved
than the original CCA1-secure encryption scheme of Naor and Yung. Thus, we
provide an alternative (and simpler proof) to the following theorem:
Theorem 1 Assuming the existence of enhanced trapdoor permutations 2 , there
exists a public-key encryption scheme that is secure against adaptive chosenciphertext (CCA2) attacks.
Related work. The focus of this work is the construction of public-key encryption
schemes that are secure against adaptive chosen-ciphertext attacks, assuming
only the existence of (enhanced) trapdoor permutations. As we have mentioned
above, the ﬁrst such scheme was presented by Dolev, Dwork and Naor [7]. On
the other hand, our construction builds rather directly on the chain of works of
Naor and Yung [15], Sahai [17] and De Santis et al. [6].
The ﬁrst eﬃcient CCA2-secure encryption scheme (proved in the standard
model) was presented in a breakthrough work by Cramer and Shoup [4]. However, their construction relies on a speciﬁc complexity assumption (namely, the
Decisional Diﬃe-Hellman assumption). Recently, they presented other CCA2secure schemes, relying on other speciﬁc assumptions (some of which are more
standard) [5]. (We stress that our work is incomparable to theirs. On the one
hand, they achieve high eﬃciency while relying on speciﬁc complexity assumptions. On the other hand, we assume only the existence of trapdoor permutations,
but obtain a scheme that is very ineﬃcient). that is used.)
Much work on the problem of eﬃcient CCA2-secure encryption has been carried out in the random-oracle model; the most famous of these being OAEP [1].
However, when the random oracle is replaced by a concrete hash function, the
security argument becomes heuristic only. Thus, the existence of these schemes
does not constitute a proof of Theorem 2.
Organization. As we have mentioned, the technical contribution of this paper
is the construction of a simple one-time simulation-sound NIZK. Therefore, the
main body of the paper focuses on this issue. In particular, Section 2 contains
the formal deﬁnitions of simulation-sound NIZK proof systems and the cryptographic tools necessary for our construction. Then, in Section 3 we present our
construction of a one-time simulation-sound NIZK and its proof of correctness.
For the sake of completeness, in Section 4 we describe the Sahai CCA2-secure
encryption scheme.
2

Enhanced trapdoor permutations have the property that a random element generated by the domain sampler is hard to invert, even given the random coins used
by the sampler. See [11, Appendix C] for a full discussion on enhanced trapdoor
permutations and why they are needed.

244

2
2.1

Y. Lindell

Deﬁnitions and Cryptographic Tools
Deﬁnitions

In this section, we present the deﬁnitions for adaptive non-interactive zeroknowledge (NIZK) and one-time simulation-sound adaptive NIZK. Our formal
deﬁnitions are essentially taken from [10,17]. We denote the security parameter
by n, and an unspeciﬁed negligible function by µ(n) (i.e., µ(n) grows slower
than 1/p(n) for every polynomial p(·)). We often omit explicit reference to the
security parameter n in our notations.
Adaptive non-interactive zero-knowledge. In the model of non-interactive zeroknowledge proofs [3], the prover and veriﬁer both have access to the same uniformly distributed reference string. A proof in this model is a single string sent
by the prover to the veriﬁer, and the reference string is used for both generating
proofs and verifying their validity. The soundness of the proof system is such that
if the reference string is indeed uniformly distributed, then with overwhelming
probability, no false theorem can be proved (even by an all-powerful cheating
prover). On the other hand, the zero-knowledge property is formulated by stating that there exists a simulator who outputs a reference string and a proof,
that are computationally indistinguishable from what is viewed by a veriﬁer in
the real setting described above. Notice that the simulator generates both the
reference string and the proof and is not expected to simulate proofs relative to a
uniformly distributed reference string (which would not be possible to achieve).
In particular, this means that the simulator may choose the reference string to
be pseudorandom, and according to some speciﬁc distribution.
The adaptivity of a NIZK system refers both to the soundness and zeroknowledge. In both cases, an adaptive NIZK is one where the statement to
be proven is chosen only after the reference string has been ﬁxed. Thus, the
cheating prover ﬁrst receives a uniformly distributed reference string, and then
attempts to ﬁnd some x ∈ L for which it can provide an accepting proof π
for x. The adaptive soundness condition states that the probability that such
a π is an accepting proof is negligible. The adaptive zero-knowledge property
is formulated by having the simulator output a reference string before giving
it a statement x for which it must generate a simulated proof. In the formal
deﬁnition below, a function f is speciﬁed that “chooses” a statement x to be
proven, based on the reference string R (for soundness, f chooses x ∈ L, whereas
for zero-knowledge f chooses x ∈ L).
Deﬁnition 2 (adaptive non-interactive zero-knowledge): A pair of probabilistic
machines (P, V ) is called an adaptive non-interactive zero-knowledge proof system
for a language L if the following holds:
• Completeness: For every x ∈ L,
Pr[V (x, R, P (x, R)) = 1] > 1 − µ(|x|)
where R is a random variable uniformly distributed in {0, 1}poly(|x|) .

A Simpler Construction of CCA2-Secure Public-Key Encryption

245

• Adaptive Soundness: For every function f : {0, 1}poly(n) → {0, 1}n \ L and
prover P ∗ ,
Pr[V (f (R), R, P ∗ (R)) = 1] < µ(n)
where R is a random variable uniformly distributed in {0, 1}poly(|x|) .
• Adaptive Zero-Knowledge: There exists a probabilistic polynomial-time simulator S = (S1 , S2 ) such that for every probabilistic polynomial-time function
f : {0, 1}poly(n) → {0, 1}n ∩ L, the ensembles {f (Rn ), Rn , P (f (Rn ), Rn )}n∈N
and {S f (1n )}n∈N are computational indistinguishable, where Rn is a random
variable uniformly distributed in {0, 1}poly(n) and S f (1n ) denotes the output
from the following experiment:
1. (r, s) ← S1 (1n ): Simulator S1 (upon input 1n ) outputs a reference string
r and some state information s to be passed on to S2 .
2. x ← f (r): the statement x to be proven is chosen.
3. π ← S2 (x, r, s): Simulator S2 generates a simulated proof π that x ∈ L.
4. Output (x, r, π).
Adaptive NIZK proof systems can be constructed from any enhanced trapdoor permutation [8]. We note that any NIZK proof system is witnessindistinguishable, where informally speaking, witness-indistinguishability means
that proofs generated using one witness are indistinguishable from proofs generated using a diﬀerent witness [9].
One-time simulation-sound adaptive NIZK. Loosely speaking, a NIZK proof system is one-time simulation-sound if the soundness condition holds even with
respect to a reference string generated by the simulator (and not uniformly distributed), and even after a single simulated proof (of a not necessarily correct
statement) has been observed. Of course, it is always possible for a cheating
prover to simply copy the simulated proof that it observed. Therefore, the requirement is that it is infeasible to eﬃciently compute any other pair of an
incorrect statement and accepting proof.
Deﬁnition 3 (one-time simulation soundness): Let (P, V ) be an adaptive NIZK
proof system for a language L, and let S = (S1 , S2 ) be a simulator for (P, V ).
Then, we say that (P, V, S) is one-time simulation-sound, if for every probabilistic
polynomial-time adversary A = (A1 , A2 ), it holds that the probability that A
succeeds in the following experiment is negligible:
1. (r, s) ← S1 (1n ).
2. (x, a) ← A1 (r): Adversary A1 receives the (simulator-generated) reference
string r and outputs a statement x for which it wants to see a proof, and
state information a for A2 .
3. π ← S2 (x, r, s).
4. (x , π ) ← A2 (x, r, π, a): Adversary A2 receives the simulated proof, and outputs a statement x and a proof π that x ∈ L.

246

Y. Lindell

5. We say that A succeeds if it outputs an accepting proof of a false statement
(and did not copy the proof π). That is, A succeeds if x ∈ L, (x , π ) = (x, π)
and V (x , r, π ) = 1.
If there exists an S such that (P, V, S) is one-time simulation sound, then we
say that the proof system (P, V ) is a one-time simulation-sound adaptive NIZK.
As we have mentioned above, the notion of simulation-soundness was ﬁrst introduced by [17] who also presented a construction for one-time simulationsoundness (and an extension to allow for any predetermined polynomial number
of simulated proofs). Unbounded simulation-soundness (allowing any polynomial
number of simulated proofs) was later demonstrated in [6].
2.2

Cryptographic Tools

In this section, we present informal deﬁnitions for the cryptographic tools that we
use in constructing our one-time simulation-sound NIZK. These tools are standard; however we add minor (yet important) additional requirements. We note
that it is easy to obtain these additional requirements using known techniques.
Non-interactive perfectly-binding commitment schemes. Loosely speaking, a noninteractive perfectly-binding commitment scheme is a probabilistic algorithm C
with the following properties:
• Hiding: for every two strings s1 and s2 (such that |s1 | = |s2 |), it is hard to
distinguish {C(s1 )} from {C(s2 )}.
• Binding: for every two strings s1 = s2 , the range of C(s1 ) is disjoint from
the range of C(s2 ). (Thus, given C(s1 ), it is impossible to decommit to any
value other than s1 .)
We denote by C(s; r) the output of the commitment scheme C upon input s ∈
{0, 1}n and using random coins r ∈R {0, 1}poly(n) . (Thus, the binding property
states that for s1 = s2 , it holds that C(s1 ; r1 ) = C(s2 ; r2 ) for every r1 and r2 .)
In addition to the above, we require the following properties:
• Pseudorandom range: We require that the output of the commitment algorithm be pseudorandom. This property is fulﬁlled by the following commitment scheme based on one-way permutations: Let f be a one-way permudef
tation and b a hard-core of f . Then, C(σ) = (f (Un ), b(Un ) ⊕ σ), where Un
denotes the uniform distribution over {0, 1}n .
• Negligible support: We require that a random string is a valid commitment
with only negligible probability. This is easily obtained from the abovedescribed commitment scheme based on one-way permutations, by requiring
that any commitment to s is preceded by a commitment to 0n . That is, deﬁne
C (s) = (Commit(0n ), Commit(s)), where each bit is separately committed
to using C(σ) = (f (Un ), b(Un ) ⊕ σ).3
3

We remark that if it suﬃces to obtain soundness for polynomial-time provers only,
then the commitment scheme used need not have negligible support.

A Simpler Construction of CCA2-Secure Public-Key Encryption

247

We note that the Naor commitment scheme [13] as is, has both of these above
properties. (Although the [13] commitment scheme is interactive, the receiver
message can be hardwired into the common reference string, and so suﬃces for
our needs here.)
“Strong” one-time signature schemes. Loosely speaking, a one-time signature
scheme is an existentially unforgeable signature scheme (secure against a chosenmessage attack), with the restriction that the signer must only sign a single
message with any key. Thus, such a signature scheme is deﬁned as a triplet
of algorithms (G, Sign, Verify), where G is a probabilistic generator that outputs a signing-key sk and a veriﬁcation-key vk. The validity of the signature
scheme fulﬁlls that for every message m, Verify(vk, m, Sign(sk, m)) = 1, where
(vk, sk) ← G(1n ) (i.e., honestly generated signatures are always accepted). A
signature scheme is said to be secure if the probability that an eﬃcient forging
algorithm S ∗ succeeds in generating a forgery given a single chosen signature is
negligible. More formally, the following experiment is deﬁned: The generator G is
run, outputting a key-pair (vk, sk). Then, S ∗ is given vk and chooses a message
m for which it receives a signature σ = Sign(sk, m). Following this, S ∗ outputs
a pair (m , σ ) and it is required that the probability that Verify(vk, m , σ ) = 1
and m = m is negligible.
As with the commitment scheme, here we also require an additional property.
The standard deﬁnition of security requires that the forger cannot generate a
valid signature on any diﬀerent message. We strengthen this and require that the
forger cannot even generate a diﬀerent valid signature on the same message. That
is, we modify the above (informal) deﬁnition and require that the probability
that Verify(vk, m , σ ) = 1 and (m , σ ) = (m, σ), is negligible. (Thus, the only
valid signature the forger can present is the exact one that it has seen.) Such
a signature scheme can be constructed using universal one-way hash functions
[14] and 1–1 one way functions (in a similar fashion to the standard construction
based on any one-way function [16]). By using 1–1 one-way functions, we ensure
that each message has a unique signature and therefore the above strengthening
is achieved.

3

Simple One-Time Simulation-Sound NIZK

The motivation behind our construction is as follows. Following [8], (and similarly to [6]) the reference string for the non-interactive proof is divided into two
parts. The ﬁrst part of the string is used by the simulator to simulate a proof,
while the second is really used for proving (according to a given NIZK scheme).
Typically, in order to prove that x ∈ L, a compound statement of the following
structure is proved: either the ﬁrst part of the reference string has some special
property or x ∈ L. Now, when the reference string is chosen at random, the
ﬁrst part will not have this special property (except with negligible probability).
Therefore, if the proof is accepting it must be that x ∈ L, and soundness holds
for the proof system. Zero-knowledge is derived from the fact that the simulator

248

Y. Lindell

is able to generate a pseudorandom string that does have the special property,
enabling it to “cheat” in the proof.
In our scheme, the special property used is that the ﬁrst part of the reference string is a commitment to a veriﬁcation-key vk of a one-time signature
scheme. That is, the prover sends a veriﬁcation-key vk along with the proof
and proves that: either the ﬁrst part of the reference string is a commitment to
this veriﬁcation-key vk, or x ∈ L. Furthermore, the prover signs on the proof
using the associated signing-key sk (and the veriﬁer checks the validity of this
signature using vk). A real prover chooses a random pair of signature keys and
generates a proof based on the fact that x ∈ L.
In contrast, the simulator works by generating the reference string so that
indeed the ﬁrst part is a commitment to a veriﬁcation-key vk (for which it knows
the associated signing-key sk). Then, the simulator proves the proof using this
fact (rather than the fact that x ∈ L). Notice that the simulator is also able to
sign on the proof, as required, because it knows the associated secret-key. The
fact that the scheme is simulation-sound follows from the observation that any
accepting proof to a false statement must use the property that the ﬁrst part of
the reference string is a commitment to vk. In particular, this means that such
a proof is accompanied with a signature using sk (where sk is known only to
the simulator). Thus, it is only possible to generate an accepting proof to a false
statement if it is possible to forge a signature.
We now formally present the proof system. In the presentation, we refer
to an adaptive NIZK proof system, denoted (P, V ), and to commitment and
signature schemes. These commitment and signature schemes have the additional
properties described in Section 2.2.
Protocol 1 (NIZK Scheme Π)
• Common reference string: (r1 , r2 )
• Prover protocol (upon input x ∈ L and a witness w for x):
1. Choose a random pair of signature keys (vk, sk) for a strong one-time
signature scheme.
2. Let L be the following language:
L = {(x, r1 , vk) | x ∈ L or r1 = Commit(vk)}
Then, generate a non-interactive proof (using reference string r2 ) that
(x, r1 , vk) ∈ L . That is, invoke the NIZK prover P for L on input
(x, r1 , vk), auxiliary-input w and reference string r2 , obtaining a proof p.
3. Compute σ = Signsk (x, p).
4. Output π = (vk, x, p, σ).
• Veriﬁer protocol (upon input x and a proof π = (vk, x, p, σ)):
1. Check the signature using vk. That is, check that Verifyvk ((x, p), σ) = 1.

A Simpler Construction of CCA2-Secure Public-Key Encryption

249

2. Invoke the NIZK veriﬁer V and check that p constitutes a correct proof
that (x, r1 , vk) ∈ L when the reference string equals r2 (i.e., check that
V ((x, r1 , vk), r2 , p) = 1).
3. Output 1 if and only if the above two checks succeed.
We now proceed to prove the correctness of Protocol 1:
Theorem 4 Assume that (P, V ) is a secure adaptive NIZK proof system for
N P, and that the signature and commitment schemes meet the requirements as
described in Section 2.2. Then, Protocol 1 constitutes a one-time simulationsound adaptive NIZK proof system for N P.
Proof: We begin by proving that Protocol 1 is an adaptive non-interactive
proof system. Completeness is immediate. Soundness follows from the fact that
the commitment scheme used has negligible support (see Section 2.2), and thus
a random string is a valid commitment with only negligible probability. Therefore, when r1 is uniformly chosen, x ∈ L implies that (x, vk, r1 ) ∈ L , except
with negligible probability. Adaptive soundness then follows from the adaptive
soundness of the NIZK proof system (P, V ) for which proofs are generated using
the uniformly distributed reference string r2 .
We now proceed to demonstrate the zero-knowledge property. As we mentioned in the motivating discussion, intuitively, zero-knowledge holds because a
simulator can set r1 to be a commitment to a veriﬁcation-key vk, for which it
knows the associated signing-key sk. Then, the simulator proves that (x, vk, r1 ) ∈
L based on the fact that r1 = Commit(vk), and without any witness to the fact
that x ∈ L. Since, the commitment scheme used has a pseudorandom range, such
a r1 is indistinguishable from a random string. Furthermore, the NIZK proof system (P, V ) is witness indistinguishable and therefore the simulated proof cannot
be distinguished from a real one. We now provide the exact description of the
simulator. The simulator is divided into two parts: S1 who chooses the reference
string and S2 who generates simulated proofs.
1. Simulator S1 :
a) Choose a random pair of signature keys (vk, sk) for a strong one-time
signature scheme.
b) Compute r1 = Commit(vk) = C(vk; rc ) for a random rc .
c) Choose a uniformly distributed string r2 .
d) Output (r1 , r2 ) and s = (vk, sk, rc ) where s is S1 ’s output state information to be given to S2 .
2. Simulator S2 (upon input x, (r1 , r2 ) and s = (vk, sk, rc )):
a) Invoke the NIZK prover for L (as deﬁned in Protocol 1) on input
(x, r1 , vk), auxiliary-input rc and reference string r2 , and obtain a
proof p. (Note that the witness provided to the NIZK prover is for
r1 = Commit(vk), and not the witness for x ∈ L.)
b) Compute σ = Signsk (x, p).
c) Output π = (vk, x, p, σ).

250

Y. Lindell

There are two diﬀerences between a real proof and that provided by the simulator
(where we consider the joint distribution {x, (r1 , r2 ), π} of the reference string
and the proof). Firstly, the string r1 generated by S1 is only pseudorandom (and
not random as in a real setting). Secondly, the proof p provided by S2 is based
on the witness for the fact that r1 = Commit(vk), rather than being based on
the witness for x ∈ L. Intuitively, since r1 is pseudorandom and the NIZK is
witness indistinguishable, these distributions cannot be distinguished. Formally,
one deﬁnes a hybrid distribution in which r1 = Commit(vk) and yet the proof
p is based on the witness for x ∈ L. Then, the hybrid is indistinguishable from
a real proof by the indistinguishability of r1 from a random string (everything
else is exactly the same). Furthermore, the hybrid is indistinguishable from a
simulated proof due to the witness indistinguishability of the NIZK. (Notice
that the reference string r2 for this NIZK is uniformly distributed, and thus
the witness indistinguishability property holds.) The indistinguishability of a
simulated proof from a real one follows. (We note that from the above proof it
follows that the underlying non-interactive proof need not be zero-knowledge;
rather, adaptive witness indistinguishability suﬃces.)
One-time simulation-soundness. Until now, we have shown that Protocol 1
constitutes a non-interactive zero-knowledge proof system. It remains to show
that it is also one-time simulation-sound. Intuitively, this holds for the following
reason. Let (vk, sk) be the signature keys chosen by the simulator S1 . Then, if
an adversary generates a proof based on the fact that r1 = Commit(vk), it must
sign on the proof using the key sk (otherwise, the veriﬁcation of the signature will
fail). This constitutes a successful forgery of the signature scheme and therefore
can only occur with negligible probability. Details follow.
Assume by contradiction that there exists an adversary A = (A1 , A2 ) (as in
Deﬁnition 3) who sees a simulated proof π for a statement x, and with nonnegligible probability outputs a pair (x , π ) = (x, π) where x ∈ L and π is an
accepting proof. That is, let (r1 , r2 ) be the reference string output by S1 , let x be
the statement that A1 outputs upon receiving (r1 , r2 ), and let π = (vk, x, p, σ) be
the simulated proof of x ∈ L that is supplied by S2 . Then, by the contradicting
assumption, with non-negligible probability A2 outputs an accepting proof π =
(vk , x , p , σ ), such that (x , π ) = (x, π), and x ∈ L. We consider two diﬀerent
cases:
1. Case 1 – vk = vk: First recall that by the deﬁnition of the simulator S1 , the
string r1 is such that r1 = Commit(vk). However, vk = vk and therefore
we have that r1 = Commit(vk ) (by the perfect binding property of the
commitment scheme). Therefore, x ∈ L implies that (x, r1 , vk) ∈ L . By
the (unconditional) soundness of the underlying NIZK scheme, we have that
the probability that p (and therefore π ) is an accepting proof is at most
negligible.
2. Case 2 – vk = vk: In this case, we use A to contradict the (strong) security of the signature scheme. Recall that A’s proof π is only accepting if
Verifyvk ((x , p ), σ ) = 1. Since (x , π ) = (x, π) and vk = vk, it holds that

A Simpler Construction of CCA2-Secure Public-Key Encryption

251

(x , p , σ ) = (x, p, σ). Therefore, we have that A received a message and signature ((x, p), σ) and generated a valid message and signature ((x , p ), σ ),
where ((x , p ), σ ) = ((x, p), σ). By the strong security of the signature
scheme, A can succeed in doing this with only negligible probability.
Formally, we construct a forger A who receives vk and a single oracle query
to Signsk (·) and successfully forges a signature. A works exactly like the
simulator S except that in Step (b) of S2 ’s speciﬁcation, it “computes” the
signature by consulting its oracle. Notice that S1 and S2 need no knowledge
of sk in order to complete all their other steps. Thus, A can perfectly emulate
the simulation setting for A. Therefore, if A outputs π = (vk, x , p , σ ),
where (x , p , σ ) = (x, p, σ) and σ is a valid signature on (x , p ), then this
constitutes a successful forgery of the signature scheme. This implies that A
succeeds with at most negligible probability.
This completes the proof.
We remark that enhanced trapdoor permutations suﬃce for securely obtaining
all the building blocks required in the construction of Protocol 1. We therefore
have the following result:
Proposition 5 Assuming the existence of enhanced trapdoor permutations,
there exists a one-time simulation-sound adaptive NIZK proof system.

4

The Encryption Scheme

In this section, we describe the CCA2-secure public-key encryption scheme of
Sahai [17]. This scheme is exactly the scheme of Naor-Yung [15], with the modiﬁcation that the NIZK used is one-time simulation-sound. We stress that our
contribution is in Section 3, where we present a simple one-time simulation-sound
NIZK. Thus, we directly plug our NIZK into the construction (and proof) of [17],
obtaining a new (and simpler) CCA2-secure public-key encryption scheme. (For
the exposition below, we omit the formal deﬁnitions of encryption and CCA2
security and assume that the reader is familiar with them.)
The Naor-Yung paradigm. As we have mentioned, the [17] encryption scheme is
based on the Naor-Yung paradigm [15]. According to this paradigm, the plaintext
is encrypted twice with independent keys (from an encryption scheme that is
secure against chosen-plaintext attacks) and then a NIZK proof is provided to
ensure that both encryptions are indeed of the same plaintext. Passive chosenciphertext security (CCA1) or adaptive chosen-ciphertext security (CCA2) are
achieved by applying NIZKs with certain “special” properties. For CCA1, the
NIZK is such that soundness holds even with respect to the pseudorandom string
output by the simulator (as long as a simulated proof has not been observed).4
For CCA2, the NIZK must be one-time simulation-sound. From here on, we focus
4

This is in contrast with standard NIZK proof systems, where soundness is guaranteed
only if the reference string is uniformly distributed.

252

Y. Lindell

on the CCA2 case. However, we stress that the CCA2 scheme and its proof of
security are almost identical to that of the CCA1 scheme. This highlights one of
the conceptual advantages of the [17] approach; both CCA1 and CCA2-secure
encryption schemes can be presented and proved together (and for almost the
price of one).
Formal deﬁnition of the scheme. We now present the construction of the encryption scheme. Let (G, E, D) be a public-key encryption scheme that is secure against chosen-plaintext attacks. Furthermore, let (P, V ) be a one-time
simulation-sound adaptive NIZK proof system for the following NP-language:
L = {(c1 , c2 , pk1 , pk2 ) | ∃m s.t. c1 = Epk1 (m) & c2 = Epk2 (m)}
That is, L is the language of pairs of ciphertexts (and public-keys), such that
both ciphertexts are encryptions of the same message (we denote c = Epk (m),
if c is an encryption of m). Then, the CCA2-secure scheme, denoted (G, E, D),
is deﬁned as follows:
Construction 2 (Adaptive chosen-ciphertext encryption scheme (G, E, D)):
• Key Generation: Obtain two independent key sets from G. That is, obtain
(pk1 , sk1 ) ← G(1n ) and (pk2 , sk2 ) ← G(1n ). Furthermore, choose a uniformly distributed reference string r of the correct length for the NIZK proof
system (P, V ). The public key is deﬁned by PK = (pk1 , pk2 , r) and the secret
key is SK = (sk1 , sk2 ).
• Encryption: In order to encrypt a plaintext m, compute c1 = Epk1 (m; r1 )
and c2 = Epk2 (m; r2 ), for random strings r1 and r2 . Then, invoke the NIZK
prover P upon (c1 , c2 , pk1 , pk2 ) with reference string r, obtaining a proof π.
Notice that P can prove this statement eﬃciently when it is given the witness
(m, r1 , r2 ). Finally, output E(m) = (c1 , c2 , π).
• Decryption: In order to decrypt (c1 , c2 , π), ﬁrst verify that π is an accepting
proof for the statement (c1 , c2 , pk1 , pk2 ) with reference string r. If yes, then
decrypt c1 and output the decryption value m.5
The fact that the above encryption scheme is secure against adaptive chosenciphertext attacks has been proven in [17]. That is,
Theorem 6 (Sahai [17]): Assume that (G, E, D) is a public-key encryption
scheme secure against chosen-plaintext attacks, and that (P, V ) is a one-time
simulation-sound adaptive NIZK proof system. Then, the encryption scheme
(G, E, D) of Construction 2 is secure against adaptive chosen-ciphertext attacks.
Combining Theorem 6 with Proposition 5, we obtain the existence of CCA2secure encryption assuming enhanced trapdoor permutations only (i.e., we obtain Theorem 2). For the sake of completeness, we describe the main ideas behind
this proof.
5

Our choice of decrypting the ﬁrst ciphertext c1 is arbitrary; equivalently, one could
deﬁne the decryption algorithm by having it decrypt c2 .

A Simpler Construction of CCA2-Secure Public-Key Encryption

253

Motivation for the proof of security. The basic idea underlying Construction 2 of
(G, E, D) is that it is enough to use only one secret-key in order to decrypt ciphertexts. This is because anyone can verify the validity of a NIZK proof. Therefore,
given knowledge of any of the two secret-keys, decryption can be carried out
by verifying the NIZK and then decrypting. Since the NIZK proof ensures that
both encryptions are to the same plaintext, it does not matter which secret-key
is used. Now, consider an adversary Acpa who carries out a chosen-plaintext
attack (CPA) on the scheme (G, E, D). (Recall that in a CPA attack, the adversary gets no decryption oracle.) Adversary Acpa receives a public-key pk1
and proceeds to generate a simulated public-key for the scheme (G, E, D) which
incorporates pk1 . Speciﬁcally, Acpa chooses a second key-pair (pk2 , sk2 ) and a
NIZK reference string r, thereby obtaining a public-key (pk1 , pk2 , r) for (G, E, D).
Furthermore, Acpa knows one of the two secret-keys (namely sk2 ). Therefore,
as we have discussed above, Acpa is able to correctly decrypt ciphertexts. The
important point is that Acpa is able to correctly simulate a decryption oracle for
a CCA2-adversary A who attacks (G, E, D). In other words, given only chosenplaintext ability, Acpa can simulate an adaptive chosen-ciphertext attack for a
CCA2-adversary A.
The above shows how the decryption oracle in a CCA2-attack can be simulated by Acpa . However, Acpa must also be able to generate a challenge ciphertext
for A from (G, E, D), given its own challenge ciphertext from (G, E, D). That is,
during its attack, Acpa receives some challenge ciphertext c1 . Based on c1 , Acpa
must provide A with a challenge. Furthermore, it must be shown that if A can
distinguish ciphertexts in (G, E, D) with non-negligible probability, then Acpa
can use this to also distinguish ciphertexts in (G, E, D). Loosely speaking, Acpa
generates the needed ciphertext by simply computing c2 = Epk2 (0n ) (i.e., c2 is
an encryption to garbage) and then providing a proof π that c1 and c2 are encryptions of the same message. Of course, this statement may not be true (since
Acpa does not know if c1 is an encryption of 0n or of some other message). Nevertheless, such a proof can be generated using the NIZK simulator, and this will be
indistinguishable from a real ciphertext. Thus, A receives the challenge ciphertext (c1 , c2 , π) in its CCA2-attack. The point is that A’s challenge ciphertext
contains c1 and therefore any “information” learned by A about its challenge
ciphertext (c1 , c2 , π) can be used by Acpa to derive information about its own
challenge ciphertext c1 . Observe, however, that by the way Acpa constructs the
challenge ciphertext, it follows that A receives a simulated NIZK proof π during
its attack. Furthermore, A is able to ask for more decryptions of ciphertexts
after seeing this simulated proof, and these ciphertexts contain NIZK proofs.
In order for the decryption simulation of Acpa described above to be correct, it
must hold that A cannot generate accepting proofs of false statements, even in
such a setting. This is where the one-time simulation-soundness of the NIZK is
utilized. Thus we have that Acpa can simulate a complete CCA2-attack for A.

A full proof of Theorem 6 can be found in [17] and in [12, Appendix A].

254

Y. Lindell

Acknowledgements. We thank Amit Sahai for pointing out to us that the
soundness of the simulation-sound NIZK can be made unconditional by using a
commitment scheme with negligible support. We also thank Oded Goldreich for
helpful discussions and for encouraging us to write this work.

References
1. M. Bellare and P. Rogaway. Optimal asymmetric encryption – How to encrypt
with RSA. In EUROCRYPT’94, Springer-Verlag (LNCS 950), pages 92–111, 1994.
2. D. Bleichenbacher. Chosen Ciphertext Attacks Against Protocols Based on the
RSA Encryption Standard PKCS#1. In CRYPTO’98, Springer-Verlag (LNCS
1462), pages 1–12, 1998.
3. M. Blum, P. Feldman and S. Micali. Non-interactive zero-knowledge and its
applications. In 20th STOC, pages 103–112, 1988.
4. R. Cramer and V. Shoup. A practical public-key cryptosystem provably secure against adaptive chosen ciphertext attack. In CRYPTO’98, Springer-Verlag
(LNCS 1462), pages 13–25, 1998.
5. R. Cramer and V. Shoup. Universal Hash Proofs and a Paradigm for Adaptive Chosen Ciphertext Secure Public-Key Encryption. In EUROCRYPT 2002,
Springer-Verlag (LNCS 2332), pages 45–64, 2002.
6. A. De Santis, G. Di Crescenzo, R. Ostrovsky, G. Persiano and A. Sahai. Robust Non-interactive Zero-Knowledge. In CRYPTO 2001, Springer-Verlag (LNCS
2139), pages 566–598, 2001.
7. D. Dolev, C. Dwork and M. Naor. Non-malleable Cryptography. In SICOMP,
30(2):391–437, 2000.
8. U. Feige, D. Lapidot and A. Shamir. Multiple Non-Interactive Zero-Knowledge
Proofs Under General Assumptions. In SICOMP, 29(1):1–28, 1999.
9. U. Feige and A. Shamir. Witness Indistinguishability and Witness Hiding Protocols. In 22nd STOC, pages 416–426, 1990.
10. O. Goldreich. Foundation of Cryptography – Basic Tools. Cambridge University
Press, 2001.
11. O. Goldreich. Foundations of Cryptography: Volume 2 – Basic Applications. To
be published. Available from http://www.wisdom.weizmann.ac.il/∼oded.
12. Y. Lindell. A Simpler Construction of CCA2-Secure Public-Key Encryption Under
General Assumptions. Cryptology ePrint Archive, Report 2002/057,
http://eprint.iacr.org/, 2002.
13. M. Naor. Bit Commitment using Pseudorandom Generators. Journal of Cryptology, 4(2):151–158, 1991.
14. M. Naor and M. Yung. Universal One-Way Hash Functions and their Cryptographic Applications. In 21st STOC, pages 33–43, 1989.
15. M. Naor and M. Yung. Public-key cryptosystems provably secure against chosen
ciphertext attacks. In 22nd STOC, pages 427–437, 1990.
16. J. Rompel. One-way functions are necessary and eﬃcient for secure signatures.
In 22nd STOC, pages 387–394, 1990.
17. A. Sahai. Non-Malleable Non-Interactive Zero Knowledge and Adaptive ChosenCiphertext Security. In 40th FOCS, pages 543–553, 1999.
18. A. Sahai. Simulation-Sound Non-Interactive Zero Knowledge. Manuscript, 2000.
19. V. Shoup. Why chosen ciphertext security matters. IBM Research Report RZ
3076, November, 1998.

