Interacting Automata for Modelling
Distributed Systems
Irina A. Lomazova
Program Systems Institute of the Russian Academy of Science
Pereslavl-Zalessky, 152020, Russia
irina@univ.botik.ru

Abstract. A community of interacting automata is a set of nondeterministic ﬁnite automata which can execute actions autonomously, synchronize with each other, or generate new members of the community.
Thus interacting automata allow to model distributed systems with unlimited number of interacting agents. We show that the formalism of
interacting automata has a clear semantics and nice semantic properties, leading to decidability of some important behavioral properties of
modelled systems.

1

Introduction

Finite automata are widely used in modelling systems, especially when handling
control aspects is important. The beneﬁts of ﬁnite automata are in particular
connected with clear mathematical semantics, systems visualization and decidability of many crucial behavioral properties.
The up-to-date needs for modelling concurrent and distributed systems with
a complex structure lead to diﬀerent extensions of the ﬁnite automata formalism, such as hierarchical, interacting, dynamic automata [1,5,9,10], which allow
to model hierarchy, concurrency and communication among concurrent components.
Here we introduce the interacting automata, which together with concurrency
and communication allow to model dynamic activation of new agents. There is
a rather large variety of formalisms for representing distributed systems in the
modern theoretical computer science. Modelling systems with a dynamically
changing number of agents requires extending standard formalisms to capture a
possibility of changing a system structure (see e.g. [6] for an extension of Petri
nets for modelling multi-agent systems).
Interacting automata represent in some sense the most simple model of a
system consisting of agents, which can do autonomous actions, interact with
each other, be generated by other agents and die. Interacting agents form an unstructured community with no hierarchical structure, all agents have thus equal
This work was partly supported by the Presidium of the Russian Academy of Science,
program “Intellectual computer systems”, project 2.3 – “Instrumental software for
dynamic intellectual systems“ and INTAS-RFBR (Grant 01-01-04003).
P.M.A. Sloot et al. (Eds.): ICCS 2003, LNCS 2658, pp. 851–860, 2003.
c Springer-Verlag Berlin Heidelberg 2003

852

I.A. Lomazova

rights to do actions autonomously or synchronize. Agents are represented by ﬁnite automata. Initially there is one automata which can generate new members
of community, which in turn can also generate new members. An agent automata
dies, when it comes to its terminal state. Concurrent behavior is represented by
interleaving semantics. A community comes to its ﬁnal state, when it is empty,
i.e. all its members have died.
The paper is organized as follows. In section 2 we give the deﬁnitions of interacting automata community. In section 3 we study languages, accepted by interacting automata. It is shown, that interacting automata accept some context-free
nonregular and even some noncontext-free languages. In section 4 it is shown,
that interacting automata can be considered as well-structured transition systems, and this leads to decidability of some behavioral properties for them. In
section 5 interacting automata are compared with Petri nets. It is proved, that
interacting automata can be simulated by Petri nets. As the consequence of
this result we obtain decidability of the Reachability problem for interacting
automata. Also it implies, that there exist a context-free language, which is not
accepted by interacting automata. Together with the results of section 3 this
means, that the class of interacting automata languages is incomparable with
the class of context-free languages.

2

Interacting Automata

We start by recalling that a (nondetermitistic) ﬁnite automaton is deﬁned as a
tuple A = (Q, U, θ, q0 , F ), where
–
–
–
–
–

Q is a ﬁnite set of inner states;
F — a ﬁnite set of terminal states, F ∩ Q = ∅;
U — a ﬁnite alphabet of action names;
θ : Q × U → 2(Q∪F ) — a transition map;
q0 ∈ Q — an initial state.

Here the set F of terminal states is not included into the set Q of inner
states (as it is usually done in the standard deﬁnition of a ﬁnite automaton) by
reasons of convenience. In our deﬁnition the transition map can’t be applied to
terminal states, so after coming to any terminal state an automaton stops. It can
be easily shown, that our deﬁnition is equivalent to the standard one concerning
expressibility, accepted languages and other behavioral properties of automata.
We do not consider here the questions of automata size and minimization.
A ﬁnite automaton can be considered as a ﬁnite oriented graph with a set
Q ∪ F of nodes and with arcs labelled by symbols from U . As usual, we suppose
U contains a special symbol τ for the silent (invisible) action. In the graph
representation inner states are designated by circles. The set Q of inner states
contains a designated initial state q0 . Terminal nodes are designated by squares
and do not have outgoing arcs.
A community of interacting automata will be a multiset of ﬁnite automata
with actions of three types: usual autonomous actions, actions of synchronization, and actions generating a ﬁnite automaton — a new member of the community.

Interacting Automata for Modelling Distributed Systems

853

Recall, that a multiset m over a set S is a mapping m : S → N, where
N is the set of natural numbers, i.e. a multiset may contain several copies of
the same element. A multiset m is ﬁnite iﬀ the set {s ∈ S | m(s) > 0} is
ﬁnite. For two multisets m, m we write m ⊆ m iﬀ ∀s ∈ S : m(s) ≤ m (s)
(the inclusion relation). The sum of two multisets m and m is deﬁned as usual:
∀s ∈ S : (m+m )(s) = m(s)+m (s). We deﬁne also (m−m )(s) = m(s)−m (s),
if m(s) > m (s), and (m − m )(s) = 0, otherwise.
Deﬁnition 2.1. Let L be a ﬁnite set of synchronizing labels, s.t. for each label
l ∈ L the adjacent label l ∈ L is deﬁned and l = l. Let U be a ﬁnite set of
action names, A = {α1 , . . . , αk } — a set of automata names. A community of
interacting automata is deﬁned as a collection Σ = (A1 , . . . , Ak ) (k ≥ 1) of
ﬁnite nondeterministic automata, where for i = 1, . . . , k an automaton Ai =
(αi , Qi , (U ∪ L ∪ A), θi , q0i , Fi ) is speciﬁed by the following components:
– αi — a name of the automaton Ai ;
– Qi — a ﬁnite set of inner states of the automaton Ai ;
– (U ∪ L ∪ A) — a (common for all automata) set of names for autonomous
(U ), synchronized (L) and generating (A) actions;
– θi : Qi × (U ∪ L ∪ A) → 2(Qi ∪Fi ) — a transition map for Ai ;
– q0i ∈ Qi — an initial state for Ai , and
– Fi — a set of terminal states for Ai .
Among this collection a distinguished parent automaton is chosen, we suppose
it to be A1 .
Now we deﬁne the behavior of an automata community Σ = (A1 , . . . , Ak ).
A conﬁguration of an automaton Ai is represented by a pair (αi , q), where
αi is the name, q ∈ Qi ∪ Fi — a state of Ai . An automaton conﬁguration (αi , q)
is called terminal, iﬀ q ∈ Fi — a terminal state.
A conﬁguration of an automata community Σ is a multiset K over the set of
all nonterminal conﬁgurations of automata A1 , . . . , Ak .
A step for an automata community Σ is a triple (K, u, K ), where K, K —
conﬁgurations for Σ, u ∈ (U ∪ A ∪ {τ }) — an action name. We deﬁne three kinds
of steps.
– An autonomous step. Let the conﬁguration K include an automaton conﬁguration (αi , q) and for some u ∈ U we have q ∈ θi (q, u), i.e. an autonomous
action u transforms a state q of the automaton Ai into the state q . Then
u
the conﬁguration K of Σ is transformed to K (write K → K ), where
K = K − (αi , q) + (αi , q ) provided q ∈ Qi and K = K − (αi , q), if q ∈ Fi .
Thus terminal automaton conﬁgurations are deleted from the community.
– A synchronization step. Let K include two automata conﬁgurations
(αi , q), (αj , p) and for some label l ∈ L, q ∈ θi (q, l), p ∈ θj (p, l). Then
τ
K can be transformed to K (write K → K ), where K is obtained by
deleting all terminal automaton conﬁgurations from K − (αi , q) − (αj , p) +
(αi , q ) + (αj , p ).

854

I.A. Lomazova

– A generating step. Let K include an automaton conﬁguration (αi , q) and
for some automaton name αj ∈ A we have q ∈ θi (q, αj ). Then K can
αj
be transformed to K (write K → K ), where K is obtained by deleting a
terminal automaton conﬁguration (if any) from K −(αi , q)+(αi , q )+(αj , q0j ).
We write K → K , if there exists a step from K to K .
An automata community behavior is deﬁned in terms of consecutive runs
(or just runs). A run R is a ﬁnite or inﬁnite sequence of automata community
conﬁgurations K0 , K1 , . . ., such that
1. The initial conﬁguration K0 consists of the only automaton conﬁguration
(α1 , q01 ), i.e. the parent automaton in its initial state;
2. Ki → Ki+1 for all i = 0, 1, . . .;
3. R is ﬁnite iﬀ it can’t be continued.
Thus the last conﬁguration in a ﬁnite run may be either empty (a terminating
run), or a nonempty conﬁguration in which no action can occur (a deadlock).
The behavior of an automata community Σ is deﬁned as the set of all its runs.

3

Languages of Interacting Automata

Figure 1 shows an example of very simple automata community Σ1 without synchronization; Σ1 consists of the only automaton A, which can generate its own
copies.
✎☞

b✲ q
q1
4
a✟✟
✯ ✍✌

a:

✎☞
✟
q0
✍✌
b ✎☞
PP
q q2 a ✲ q5
P
τ
✍✌
❄
q3

Fig. 1. The automata community Σ1 .

Here a is the name of the automaton A, A = (a, Q, (U ∪ A), θ, q0 , F ), where
Q = {q0 , q1 , q2 } is the set of inner states of A with the initial state q0 , U = {b, τ }
— the set of autonomous actions, the set of synchronization labels is empty,
A = {a} — the set of automata names, θ — the transition map, shown by arcs
in the graph representation of A, F = {q3 , q4 , q5 } is the set of terminal states.
The automaton A can
– either do a silent action and terminate,
– or can generate its own copy, after that at some further moment do the
action b and terminate,

Interacting Automata for Modelling Distributed Systems

855

– or ﬁrst do the action b, then at some further moment generate its own copy
and also terminate.
The visible actions of the automata community, generated by the automaton
A, are actions a and b. During the life cycle of this automata community the
unlimited number of copies of A can appear.
Deﬁnition 3.1. Let Σ be an automata community. The language L(Σ) accepted
by Σ is the set of all ﬁnite words over the alphabet (U ∪ A) \ {τ }, s.t. for each
word w ∈ L(Σ) there exists a terminating run R for Σ with a sequence w of
visible actions.
It’s easy to see, that for an automata community Σ1 , represented in Figure 1, L(Σ1 ) = {w | w ∈ {a, b}∗ and na (w) = nb (w)}, where na (w) and nb (w)
designate the number of symbols ’a’ (correspondingly, symbols ’b’) in the word
w.
Since the language L(Σ1 ) can’t be accepted by any ﬁnite nondeterministic
automaton, the immediate consequence of this example is the following
Proposition 3.2. The formalism of automata communities is strictly more expressive than nondeterministic ﬁnite automata.
It is well-known, that the language L(Σ1 ) is a context-free language, so it can
be accepted by a push-down automaton. Further in Section 5 we show that there
are contest-free languages, that are not accepted by any automata community.
a

λ3

✎☞
✎☞ ✎☞
✌ λ1 ✎☞
✲ q1 λ2✲ q2 λ3✲ q3 ✌ ✲ q4
q0
✍✌ ✍✌ ✍✌ ✍✌
♦ λ1

a:

✎☞
✎☞
λ1✲✎☞
λ2✲✎☞
λ3✲✎☞
b✲ p
c✲ p
p0
p1
p3
p4
5
2
✍✌ ✍✌ ✍✌ ✍✌ ✍✌
Fig. 2. The automata community Σ2 .

However, interacting automata can accept also some languages, which are
not context-free. Figure 2 shows the automata community Σ2 , which accepts
the language {an bn cn | n ≥ 1}. It is well-known, that this language is not
context-free and can’t be accepted by any push-down automaton.

4

Interacting Automata as Well-Structured Transition
Systems

Interacting automata may generate new members of their community, and hence
they are inﬁnite state-space systems. In this section we show, that interacting

856

I.A. Lomazova

automata satisfy a nice monotonicity property: a bigger community can produce
all actions that are possible for a smaller one. Moreover, we prove that interacting
automata can be considered as a Well-Structured Transition System (WSTS) [2].
The theory of WSTS helps to obtain some decidability results for interacting
automata.
Recall that a transition system is a pair S = S, → , where S is an abstract
set of states (or conﬁgurations) and →⊆ S × S is any transition relation. For a
transition system S = S, → we write Succ(s) for the set {s ∈ S | s → s } of
immediate successors of s. S is ﬁnitely branching if all Succ(s) are ﬁnite.
Deﬁnition 4.1. A quasi-ordering is any reﬂexive and transitive relation ≤
(over some set X). A well-quasi-ordering (a wqo) is any quasi-ordering ≤ such
that, for any inﬁnite sequence x0 , x1 , x2 , . . . , in X, there exist indexes i < j with
xi ≤ xj .
Note, that if ≤ is a wqo, then any inﬁnite sequence contains an inﬁnite increasing
subsequence: xi0 ≤ xi1 ≤ xi2 . . ..
Deﬁnition 4.2. A well-structured transition system (a WSTS) is a transition
system Σ = S, →, ≤ equipped with an ordering ≤ between states such that ≤
is a wqo, and ≤ is “compatible” with →, where “compatible” means that for all
s1 ≤ t1 , and transition s1 → s2 , there exists a transition t1 → t2 , such that
s2 ≤ t2 .
Now we deﬁne a wqo on conﬁgurations of an automata community and show
that together with transformation relation K → K on conﬁgurations it forms
WSTS.
Theorem 4.3. Let Σ be an automata community, K — the set of all conﬁgurations for Σ. Then
– the relation ⊆ of multiset inclusion on K is a wqo,
– if K1 ⊆ K2 are conﬁgurations for Σ and K1 → K1 , then there exists a
conﬁguration K2 , s.t. K2 → K2 and K1 ⊆ K2 .
Thus every automata community is a WSTS w.r.t. the multiset inclusion relation.
The following diagram illustrates the statement of the theorem:
K1


u

⊆

K2

u

K1

⊆

K2

Proof sketch: To prove that the multiset inclusion on K is a wqo note, that for
a given automata community the number of diﬀerent automaton conﬁgurations
is ﬁnite. So, conﬁgurations of an automata community are multisets over a ﬁnite
set of automaton conﬁgurations and can be encoded by vectors of some ﬁxed size
n with nonnegative integers as elements. The multiset inclusion then corresponds
to the component-wise comparison of integer vector elements, which is a wqo.
Compatibility is proved straightforward from the deﬁnition of an automata
community behavior by the analysis of all three kinds of steps.

Interacting Automata for Modelling Distributed Systems

857

We say, that a conﬁguration K accepts an action word ω, if there exists a
sequence of steps K → K1 → . . . with the sequence ω of visible actions.
Corollary 4.4. Let K, K be two conﬁgurations for automata community Σ,
such that K ⊆ K . Then K accepts an action word ω implies K accepts ω.
Though a transition system with an inﬁnite state-space has an inﬁnite reachability tree, for each WSTS with an eﬀective ordering relation and computable
transition relation a ﬁnite coverability tree can be eﬀectively constructed [3]. For
interacting automata it can be done as follows.
We start from the root node labelled by the initial conﬁguration K0 . It is
easy to see, that the number of conﬁgurations K, s.t. K0 → K, is ﬁnite. For
each such K we construct a node, labelled by K and an arc from K0 to K.
Then we continue this process taking each K instead of K0 in turn, i.e. we
start to construct the reachability tree. Each branch of this tree is continued
until one of the following situations occurs:
1) we reach the terminal empty conﬁguration, which is a leaf, or
2) we reach a deadlock conﬁguration, which is also a leaf, or
3) we reach a conﬁguration K, s.t. the branch leading to K contains a node,
labelled by a conﬁguration K and K ⊆ K, and then we also do not continue
further this branch and declare the node K to be a leaf.
Since the multiset inclusion relation is a wqo, all branches in a coverability
tree are ﬁnite. Since automata communities are ﬁnitely branching, for every
automata community its coverability tree is ﬁnite. A coverability tree can be
used for checking some behavioral properties of a modelled system.
A system terminates if there exists no inﬁnite run (Termination Problem).
The Control-State Maintainability Problem is to decide, given an initial state
K and a ﬁnite set {K1 , K2 , . . . , Km } of conﬁgurations, whether there exists a
computation starting from K with all its inner conﬁgurations covering (not less
than w.r.t. the multiset inclusion) one of the Ki ’s. The dual problem, called
the Inevitability Problem, is to decide whether all computations starting from
K eventually visit a state not covering one of the Ki ’s. Thus for example, for
automata communities we can ask whether there is a run with all conﬁgurations
containing at least one copy of a given automaton (control-state maintainability),
or whether all copies of a given automaton, which can evolve during a life-cycle
of an automata community, will eventually come to its terminating state and
disappear (inevitability).
Theorem 4.5. Termination, the control-state maintainability problem and the
inevitability problem (w.r.t. ⊆) are decidable for automata communities.
Proof sketch: An automata community doesn’t have inﬁnite runs iﬀ all leaves
in its coverability tree are marked by either empty conﬁgurations or deadlocks.
For a given automata community a computation starting from K with all
its inner conﬁgurations not less than one of {K1 , K2 , . . . , Km } exists iﬀ in the
coverability tree with the conﬁguration K in the root there exists a path from
the root to a leaf with all inner conﬁgurations not less than one of the Ki ’s.

858

5

I.A. Lomazova

Interacting Automata and Petri Nets

In this section we compare automata communities with Petri nets — a popular
formalism for modelling and analysis of parallel and distributed systems [8].
Deﬁnition 5.1. A Petri net is a ﬁnite directed graph with two types of nodes,
referred to as places and transitions. An arc in a Petri net goes either from a
place to transition, or from a transition to a place.
For a transition t every place p with an arc going from p to t is called an
input place, and a place q with an arc going from t to q is called an output place.
A marking M in a Petri net is a mapping from the set P of places to nonnegative integers. We say, that there are k tokens in the place p, if M (p) = k.
A marked Petri net is a Petri net together with its initial marking.
We now deﬁne the behavior of a Petri net. A transition t is enabled in a
marking M iﬀ each input place of t contains at M at least one token. An enabled
transition t may ﬁre by removing one token from every input (for t) place and
by adding one token to every its output place.
A Petri net run is deﬁned as a sequence of its ﬁrings starting from the initial
marking.
Transitions in a Petri net may be labelled by names of actions to make a
behavior of a Petri net observable. Some of transitions may be invisible (labelled
by a silent action τ ).
We show, that the behavior of every automata community can be simulated
by a labelled Petri net. Let Σ = (A1 , . . . , Ak ) be an automata community with
inner states Q1 , . . . , Qk , terminal states F1 , . . . , Fk and transition maps θ1 , . . . , θk
correspondingly. Without loss of generality we can suppose, that all sets of inner
and terminal states here are pairwise disjoint. A Petri net PN(Σ) simulating Σ
will be constructed as follows:
1. For each inner state q ∈ Q1 ∪ . . . ∪ Qk there will be a place q˜ in PN(Σ). A
˜ so that n copies
conﬁguration K for Σ will be represented by a marking K,
of an automaton conﬁguration (α, q) will be encoded by n tokens residing in
the place q˜.
2. For each arc (q, q ), labelled by an internal action u, in an automaton Ai of
the community Σ we construct a transition t in PN(Σ), also labelled by u,
with the input place q˜ and the output place q˜ . If q is a terminal state in
Ai , then the transition t doesn’t have output places.
3. For each arc (q, q ), labelled by the name αi of an automaton Ai , in some
(other or the same) automaton we construct a transition t, labelled by αi ,
with the input place q˜ and two output places: the place corresponding to
the initial state qi0 of Ai and the place q˜ . If the state q is terminal in its
automaton, then the transition t has only one output place q˜i0 .
4. For each two arcs (q, q ), (p, p ) labelled by mutually adjacent synchronization
labels (these two arcs may be either in two diﬀerent automata of the community, or in one automaton) we construct a transition t, labelled by τ with
two input places q˜, p˜ and two output places q˜ , p˜ . As before, if q , or p , or
both are terminal states in their automata, then the corresponding output
places for the transition t are omitted.

Interacting Automata for Modelling Distributed Systems

859

Figure 3 shows a Petri net, simulating the automata community Σ1 , shown
in Figure 1.
✯ a
✟✟

a:

✎☞
✎ ✟
q0
✍✌
P
q b
❑ PP
❄

✎☞
✲ q1
✲ b
✍✌
✎☞
✲ q2
✲ a
✍✌

Fig. 3. A Petri net, simulating Σ1 .

The observable behavior of a Petri net can be described in terms of Petri net
languages [4].
Deﬁnition 5.2. Let PN be a labelled Petri net with transition labels from X.
Let R∅ be the set of all runs for PN, leading to the empty marking. A terminal
language of PN is a set of all words (over X) labelling runs from R∅ .
Note, that in the deﬁnition of a terminal Petri net language an arbitrary ﬁxed
marking can be used as the target marking instead of the empty one. These two
deﬁnitions are equivalent. The following theorem states, that for every automata
community Σ there exists a Petri net PN(Σ), simulating the behavior of Σ.
Theorem 5.3. For every automata community Σ there exists a Petri net
PN(Σ), such that the terminal language of PN(Σ) coincides with the language
L(Σ), accepted by the automata community Σ.
Proof sketch: It can be shown, that for each run of Σ there exists a corresponding run of PN(Σ) and vice versa. The proof can be done by induction on
the length of the run by the analysis of all cases of state transitions.
In the theory of Petri net languages it is known, that context-free languages
are incomparable with Petri net languages [4]. More precisely, there exist contextfree languages, which are not terminal Petri net languages. An example of such
a language is the language {wwR | w ∈ {a, b}∗ }, where wR denotes a word w in
the inverse order, i.e. written from the right to the left. Then from theorem 5.3
we get the following
Proposition 5.4. There exist context-free languages, which are not accepted by
any automata community.
The Petri net PN(Σ) simulates runs of Σ not only as sequences of actions,
but also as sequences of reachable states. These means, that the Reachability
Problem for automata communities can be reduced to the Reachability Problem
for Petri nets. Recall, that the Reachability Problem is to decide, given an initial
state S and a ﬁnite state S , whether there exists a run, leading from S to S .
For Petri nets reachability is decidable [7], hence we obtain

860

I.A. Lomazova

Proposition 5.5. Reachability Problem is decidable for interacting automata
communities.

References
1. R. Alur, S. Kannan, and M. Yannakakis. Communicating Hierarchical Automata.
In ICALP’99, volume 1644 of Lecture Notes in Computer Science, pages 169–178.
Springer, 1999.
2. A. Finkel. Reduction and covering of inﬁnite reachability trees. Information and
Computation, 89(2):144–179, 1990.
3. A. Finkel, and Ph. Schnoebelen. Well-structured transition systems everywhere!
Theoretical Computer Science, 256:1–2, pages 63–92, 2001.
4. M. Jantzen. Language Theory of Petri Nets. In Petri nets: Central Models and
their Properties, volume 254 of Lecture Notes in Computer Science, pages 397–412.
Springer, 1987.
5. R. Lanotte, A. M. Schettini, A. Peron, S. Tini. Dynamic Hierarchical Machines.
In Proc. of the Concurrency Speciﬁcation and Programming (CS&P’2000) Workshop. 7–9 October 2002. Vol.2, Informatik-Bericht Nr.161, Humboldt-Universit¨
at
zu Berlin, pages 205–216, 2002.
6. I. A. Lomazova. Nested Petri nets — a Formalism for Speciﬁcation and Veriﬁcation
of Multi-Agent Distributed Systems. Fundamenta Informaticae, 43(1–4): 195–214,
2000.
7. E. W. Mayr. An Algorithm for the General Petri Net Reachability Problem. SIAM
Journal on Computing, 13:441-460, 1984.
8. W. Reisig. Petri Nets. An Introduction, volume 4 of EATCS Monographs on Theoretical Computer Science. Springer, 1985.
9. B.A. Trakhtenbrot. Automata, Ciruits, and Hybrids: Facets of Continious Time.
volume 2076 of Lecture Notes in Computer Science, pages 4–23. Springer, 2001.
10. M. Yannakakis. Hierarchical State Machines. In IFIP Theoretical Computer Science’2000, volume 1875 of Lecture Notes in Computer Science, pages 315–330.
Springer, 2000.

