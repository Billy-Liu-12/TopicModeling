A Theoretical Treatment of Related-Key
Attacks: RKA-PRPs, RKA-PRFs, and
Applications
Mihir Bellare and Tadayoshi Kohno
Dept. of Computer Science & Engineering,
University of California at San Diego,
9500 Gilman Drive, La Jolla, California 92093, USA.
http://www-cse.ucsd.edu/users/{mihir,tkohno}

Abstract. We initiate a theoretical investigation of the popular blockcipher design-goal of security against “related-key attacks” (RKAs). We
begin by introducing deﬁnitions for the concepts of PRPs and PRFs
secure against classes of RKAs, each such class being speciﬁed by an
associated set of “related-key deriving (RKD) functions.” Then for some
such classes of attacks, we prove impossibility results, showing that no
block-cipher can resist these attacks while, for other, related classes of
attacks that include popular targets in the block cipher community, we
prove possibility results that provide theoretical support for the view
that security against them is achievable. Finally we prove security of
various block-cipher based constructs that use related keys, including a
tweakable block cipher given in [14].

1

Introduction

Most modern block ciphers, including the AES [6], are designed with the explicitly stated goal of resisting what are called “related-key attacks (RKAs)” [3].
However, it is not clear exactly what types of attacks this encompasses, and
against which of these security is even achievable.
Towards answering such questions, this paper provides a theoretical treatment of related-key attacks. Via notions of RKA secure PRPs and PRFs parameterized by a class of “related-key deriving functions,” we provide a formal
deﬁnition of what it means for a block cipher to be secure against a given class
of related-key attacks. Then for some classes of attacks, we prove impossibility
results, showing that no block-cipher can resist these attacks while, for other,
related classes of attacks that include popular targets in the block cipher community, we prove possibility results that provide theoretical support for the view
that security against them is achievable. We also prove security of some speciﬁc
related-key-using block-cipher-based constructs based on assumptions about the
security of the block cipher under an appropriate class of RKAs.
This work can help block-cipher designers and cryptanalysts by clarifying
what classes of attacks can and cannot be targets of design. It can help blockcipher users by providing guidelines about the kinds of related keys that are safe
E. Biham (Ed.): EUROCRYPT 2003, LNCS 2656, pp. 491–506, 2003.
c International Association for Cryptologic Research 2003

492

M. Bellare and T. Kohno

to use in constructs, and by enabling them to prove security of the resulting constructs. Finally, it puts forth a new primitive for consideration by theoreticians
with regard to constructions based on minimal complexity assumptions. Let us
now discuss the background and our results in more detail.
Overall our results indicate that there is a thin dividing line between unachievable and achievable goals in this area, and thus a need for care on the part
of both designers and users.
RKAs. Under a related-key attack, an adversary can obtain input-output examples of the block cipher E, not just under the target key K, but under
keys K1 , K2 , . . . related to K. However the understanding of what “related”
means seems currently to be based only on speciﬁc examples, such as Ki being
K + i mod 2k where k is the key-length, or K ⊕ ∆i where ∆1 , ∆2 , . . . are known
values. We ask what a related-key attack might mean in general, and how one
might model it and deﬁne a corresponding notion of security.
Motivation for definitions. There is signiﬁcant value in capturing blockcipher security goals via formal deﬁnitions of security. It provides cryptanalysts
with clear attack models, and it enables theorists to prove the security of blockcipher based constructs. The best example to date is the pseudorandom permutation (PRP) model for a block cipher [15,1] which has been instrumental in
both these ways. We seek something similar with regard to RKAs.
Definition. We propose an extension of the notion of a PRP. Let E : K ×
D → D be the block cipher whose security we are trying to capture. We allow
the adversary A to make related-key oracle queries consisting of a related-keyderiving (RKD) function φ : K → K and a point x ∈ D. It is placed in one
of two “worlds.” In world 1, a key K is chosen at random from K, and query
(φ, x) is answered by E(φ(K), x). In world 0, a key K is again chosen at random
from K but we also choose at random, for each key L ∈ K, a permutation
G(L, ·) : D → D, and the query is answered by G(φ(K), x). The advantage of
A is the diﬀerence between the probabilities that it returns 1 in the two worlds.
For any set Φ of functions mapping K to K, we say that E is secure against Φrestricted RKAs if the advantage of an adversary of limited resources, restricted
to drawing the RKD functions in its oracle queries from Φ, is small. See Section 3
for formal deﬁnitions.
Φ as a parameter. An important deﬁnitional choice above was to have made
the set Φ of allowed RKD functions a parameter of the deﬁnition rather than, say,
letting Φ be the set of all functions from K to K. The reason is that the power
of attacks depends signiﬁcantly on the types of related-key-deriving functions
the adversary uses. (In particular we will see that security when Φ is the set of
all functions, or even just all permutations, is impossible to achieve.) The main
question is thus for what classes Φ of RKD functions security against Φ-restricted
RKAs is achievable.
Canonical classes of RKD functions. Examples of Φ, corresponding to
the example attacks discussed above, include Φ+
k , the set of functions K →
K + i mod 2k for 0 ≤ i < 2k , and Φk⊕ , the set of functions K → K ⊕ ∆ for

A Theoretical Treatment of Related-Key Attacks

493

∆ ∈ {0, 1}k , where K = {0, 1}k . These classes are important because security
against Φ-restricted RKAs appears not only to be a design target but is useful
in applications, and hence we will pay extra attention to these classes.
DES: A test case. The goal of resisting related-key attack seems to have
been a design target only relatively recently. It is well-known that DES, due
to its complementation property (DESK (P ) = DESK (P ) for all keys K and
plaintexts P ) is insecure against related-key attacks. It is worth noting that our
model and deﬁnition capture this. One can design an adversary that, in just two
oracle queries, wins the game outlined above with advantage almost 1, as long
as Φ contains the identity function and the map K → K. In other words, DES
is insecure against Φ-restricted RKAs for any such Φ.
Impossibility Results. We show that there are inherent limitations to the
security one can achieve against related-key attacks. Namely, we identify some
relatively simple classes Φ of RKD functions such that for any block cipher E,
there exist successful Φ-restricted RKAs against E. This means it is impossible
to design a block cipher to resist these attacks.
This is relatively easy to see when Φ includes a non-injective function such as
a constant function (cf. Proposition 2). One would expect better, however, if Φ
consists only of permutations on the key space, because the result of applying a
permutation to a random key is itself a random key. However, Proposition 3 identiﬁes small, simple classes of permutations Φ for which we can present successful
Φ-restricted RKAs on any block cipher, and Proposition 4 shows that there are
⊕
successful (Φ+
k ∪ Φk )-restricted RKAs on almost any block cipher of key-length
k. (That is, it is impossible to design a block-cipher that is simultaneously resistant to the two basic classes of RKAs that we noted above.) Furthermore, in the
last two cases, our attacks not only break the pseudorandomness of the block
cipher, but are stronger in that they recover the target key.
The need for possibility results. Block-cipher designers seem to believe
⊕
that security against Φ+
k and Φk -restricted RKAs is achievable. Nothing above
contradicts this, but the unachievability of security against the closely related
⊕
class of (Φ+
k ∪ Φk )-restricted RKAs leads us to desire better evidence of the
achievability of security against Φ-restricted RKAs on these classes, as well as
other classes, than the mere inability to ﬁnd attacks as above.
However, while unachievability of a security goal can be conclusively established via attacks as above, it is harder to ﬁnd ways of gauging achievability
that are better than merely saying that we have not found attacks. Our approach is based on the thesis that the minimal requirement for a block-cipher
security goal to be considered feasible is that it should be provably achievable
for an ideal (ie. Shannon) cipher. (We may not, in practice, be able to realize all
properties of an ideal cipher in a real cipher, but certainly we should be wary of
targeting goals that are not achieved by ideal ciphers, and thus it is a good idea
to ensure that goals we target are at least achieved by ideal ciphers.) Accordingly, we seek to determine classes Φ of RKD functions for which we can prove
that ideal ciphers resist Φ-restricted RKAs.

494

M. Bellare and T. Kohno

A general possibility result. We deﬁne two properties of a class Φ of RKD
functions that we call collision-resistance and output-unpredictability. Theorem 1
then shows that an ideal cipher is secure against Φ-restricted RKAs for any Φ
having these two properties. We consider this the main result of the paper.
The properties themselves are fairly simple. Roughly, collision-resistance asks
that for any small subset P of Φ, the probability, over a random choice of key
K, that there exist distinct φ1 , φ2 ∈ P with φ1 (K) = φ2 (K), is small. Outputunpredictability asks that for any small subset P of Φ and any small subset X of
the key-space, the probability, over a random choice of key K, that there exists
φ ∈ P with φ(K) ∈ X, is small. The actual deﬁnitions and results in Section 6
are quantitative, upper bounding the advantage of a related-key attack in terms
of advantages with respect to the two underlying properties of Φ.
Implications. A corollary of these results is that an ideal cipher is secure
⊕
against Φ-restricted related-key attacks both when Φ = Φ+
k and when Φ = Φk .
Corollary 1 establishes this by showing that these two sets of related-key-deriving
permutations have the collision-resistance property and then applying our main
result. (We clarify that this does not contradict the impossibility result of
Proposition 4 since in the latter the adversary could use RKD functions from
both classes in its attack, and in the current possibility result it can use RKD
functions from one or the other, but not both simultaneously.)
Applications. One consequence of having a notion of security for block ciphers
with respect to RKAs is that we can now prove the security of protocols that use a
block cipher with multiple, but related, keys. The proofs are standard reductions
that assume that the underlying block cipher resists Φ-restricted RKAs for some
suitable set of RKD functions Φ. An important point is that because Φ is a
parameter of our deﬁnitions, and because diﬀerent applications use keys with
diﬀerent relationships, these proofs precisely identify what assumptions we are
making about the underlying block cipher. When Φ is some small set (eg. with
two or three elements) or when Φ is some set whose RKA-resistance is commonly
targeted as a design goal (eg. Φk⊕ ), then we may have reasonable conﬁdence that
the protocol is secure. We now discuss some speciﬁc results in this vein.
Tweakable block ciphers. Liskov, Rivest and Wagner [14] introduce the
notion of a tweakable block cipher and argue that use of this primitive enables
conceptually simpler designs and proofs of security for modes of operation. They
suggest a simple way to construct a tweakable block cipher out of a block cipher
resistant to related-key attacks: simply xor the tweak into the key. Having no
deﬁnitions for security against related-key attack, however, they are not able to
prove the security of their construction. As an application of our notions, we
prove that their construct yields a secure tweakable PRP under the assumption
that the original block cipher is a PRP resistant to Φk⊕ -restricted related-key
attacks.
Simplifying constructs. Some block-cipher based schemes such as Black and
Rogaway’s three-key CBC MAC constructions [4] use several independent blockcipher keys. In such schemes it is possible to use related keys instead and thereby

A Theoretical Treatment of Related-Key Attacks

495

both reduce the key-length of the scheme and conceptually simplify it. In the full
version of this paper we present related-key using modiﬁcations of these schemes
and prove that they retain their security if the block cipher is assumed to be
a PRP secure against Φ-restricted related key attacks, where Φ is some ﬁxed
⊕
three-element subset of Φ+
(eg. {K → K, K → K + 1 mod 2k , K →
k or Φk
k
K + 2 mod 2 }).
Analysis of legacy protocols. Constructions using related keys also show
up in existing cryptographic applications. (For example, [11] mentions a proprietary application that uses diﬀerent, related keys to encrypt diﬀerent messages.)
Our notions can be used to retroactively analyze such protocols, thus providing
formal justiﬁcation for those protocols in the case they are secure, or insights
into their insecurity if they are not secure.
Extensions. This extended abstract focuses on PRPs secure against chosenplaintext RKAs, since this is the simplest goal related to the question of the
security of block ciphers under RKAs. In the full version of this paper we provide
deﬁnitions for PRPs secure against chosen-ciphertext RKAs, and also for PRFs
secure against RKAs, and discuss how our results extend to them.
Towards constructs. The central theoretical question raised by this work is
whether it is possible, for some non-trivial classes Φ, to construct PRPs or PRFs
that are provably secure against Φ-restricted related-key attacks under some
standard assumption, such as the existence of one-way functions or the hardness of an algebraic problem like factoring or Decision-Diﬃe-Hellman (DDH).
Related-key attacks are so diﬀerent from standard ones that this appears to be
a challenging problem. Our results along these lines appear in the full version of
this paper.
In the full version of this paper we ﬁrst note that it is possible to solve this
problem for some very simple classes Φ, such as if Φ consists of functions that
modify only the second half of their input key. In that case, we show how a
standard PRP can be modiﬁed to be provably resistant to Φ-restricted relatedkey attack. This is already of some interest for applications, since an example of
a class Φ meeting the desired condition is the subset of Φk⊕ given by the set of
all maps K → K ⊕ ∆ where ∆ = 0k/2 ∆ and ∆ is any k/2-bit string. However,
we would like such results for broader classes Φ like Φk⊕ or Φ+
k.
A natural approach is to examine existing proven-secure constructions of
PRFs and PRPs and see whether they resist related-key attacks. In this regard,
we note that although Luby and Rackoﬀ proved that a three-round Feistel network with independent round keys and a PRF-secure round function is a secure
pseudorandom permutation in the standard model [15], any Feistel networks (regardless of the number of rounds) with independent round keys is not resistant
to Φk⊕ -restricted related-key attacks. We then look at DDH-based PRF constructions such as those of Naor-Reingold [16] and Nielsen [17] and show that
they succumb to related-key attacks restricted to trivial classes Φ. (We stress
that these constructs were never designed with the goal or claim of resisting
any kind of related-key attack, so the attacks we present do not contradict their

496

M. Bellare and T. Kohno

provable-security. However, in the search for constructs secure against relatedkey attacks it makes sense to analyze existing constructs and learn from how
they fail in the new model.)
Discussion. Whether to accept these new notions of pseudorandomness may
be controversial since they are certainly stronger than the standard notions. But
we hope this work will stimulate more interest in the continued analysis of the
security of block ciphers against related-key attacks, in the design and analysis of
protocols using related keys, and, from a foundational perspective, in proving the
existence, based on standard assumptions, of PRFs secure against Φ-restricted
RKAs for non-trivial classes Φ.
Related work. Prior to the recent work of Courtois and Pieprzyk [5], the
best (in terms of the number of rounds) known attack against Rijndael was a
Φk⊕ -restricted related key attack that uses 256 diﬀerent related keys and that
extends through nine (out of 14) rounds of Rijndael with 128-bit blocks and 256bit keys [8]. Daemen and Rijmen discuss related-key attacks in their book [7]
and in their AES submission documents [6] and comment that the diﬀusion and
non-linearity of Rijndael’s key schedule makes it diﬃcult for related-key attacks
to pass through the entire cipher. In [11] Kelsey, Schneier, and Wagner give a
related-key key-recovery attack against 3DES (or 3AES) using resources roughly
that of an exhaustive search for a single DES (or AES) key.
Full version. This abstract omits much of the content of the associated full
paper [2].

2

Notation and Standard Deﬁnitions
$

We denote by s ← S the operation of selecting s at random from set S and by
x ← y the assignment of value y to x. If S is a set then |S| denotes its size, while
if s is a string then |s| denotes its length.
PRFs were introduced by [9] and PRPs by [15]. We recall the latter, but since
our goal is to model block ciphers, we adopt the concrete approach of [1] rather
than the asymptotic approach of the original papers. Let Perm(D) denote the set
of all permutations on D. Let F : K × D → R be a family of functions from D
to R indexed by keys K. We use FK (D) as shorthand for F (K, D). F is a family
of permutations (i.e. a block-cipher), if D = R and FK (·) is a permutation on D
−1
(·) to denote the
for each K ∈ K. If F is a family of permutations, we use FK
−1
inverse of FK (·) and we use F (·, ·) to denote the function that takes as input
−1
(D).
(K, D) and computes FK
Suppose E : K × D → D is a family of functions. If A is an adversary with
access to an oracle, we let
EK (·)
= 1 − Pr g ← Perm(D) : Ag(·) = 1
Advprp
E (A) = Pr K ← K : A
$

$

denote the prp-advantage of A in attacking E. Under this concrete security
approach [1], there is no formal deﬁnition of what it means for E to be a “secure
PRP,” but in discussions this phrase should be taken to mean that, for any A

A Theoretical Treatment of Related-Key Attacks

497

attacking E with resources (running time, size of code, number of oracle queries)
limited to “practical” amounts, the prp-advantage of A is “small.” Formal results
are stated with concrete bounds.

3

New Notions

In this section we introduce our formalizations for capturing the security of block
ciphers under related-key attacks.
We let Perm(K, D) denote the set of all block-ciphers with domain D and
$
key-space K. Thus the notation G ← Perm(K, D) corresponds to selecting a
random block-cipher. In more detail, it comes down to deﬁning G via
$

For each K ∈ K do: GK ← Perm(D) .
Given a family of functions E : K × D → D and a key K ∈ K, we deﬁne the
related-key oracle Erk(·,K) (·) as an oracle that takes two arguments, a function
φ : K → K and an element M ∈ D, and that returns Eφ(K) (M ). In pseudocode,
Oracle Erk(φ,K) (M )
// where φ : K → K is a function and M ∈ D
K ← φ(K) ; C ← EK (M )
Return C
We shall refer to φ as a related-key-deriving (RKD) function or a key transformation. We let Φ be a set of functions mapping K to K. We call Φ the set of allowed
RKD functions, or allowed key-transformations, and it will be a parameter of
our deﬁnition.
Deﬁnition 1. [Pseudorandomness with respect to related-key attacks.]
Let E : K×D → D be a family of functions and let Φ be a set of RKD functions
over K. Let A be an adversary with access to a related-key oracle, and restricted
to queries of the form (φ, x) in which φ ∈ Φ and x ∈ D. Then
Advprp-rka
(A) = Pr K ← K : AErk(·,K) (·) = 1
Φ,E
$

− Pr K ← K ; G ← Perm(K, D) : AGrk(·,K) (·) = 1
$

$

.

is deﬁned as the prp-rka-advantage of A in a Φ-restricted related-key attack
(RKA) on E.
The attack model allows the adversary A to choose a function φ which transforms
the target key K into the key φ(K), and then to obtain the value of the block
cipher, on an input of A’s choice, under this transformed key. We measure its
success at determining whether its oracle queries are being answered via the
block cipher E or via a random block cipher.
Remark 1. [Concrete security versus asymptotics] Since our goal is to
model block ciphers, our deﬁnition uses the concrete security approach rather

498

M. Bellare and T. Kohno

than the asymptotic approach. Under the concrete security approach there is no
formal deﬁnition of what it means for E to be a “secure PRP under Φ-restricted
related-key attack,” but in discussions, this phrase should be taken to mean that
for any A attacking E with resources (running time, size of code, number of oracle queries) limited to “practical” amounts, and obeying the restriction that
the related-key deriving functions in all its oracle queries are from the set Φ, the
prp-rka-advantage of A is “small.” We remark that for other considerations, such
as the design of RKA-secure PRPs based on complexity-assumptions, an asymptotic deﬁnition is likely to be more appropriate, but it is trivial to extend our
deﬁnitions to asymptotic ones. One would consider families of functions indexed
by a security parameter, and families of RKD functions, also indexed by the
same security parameter. Then one would view the advantage above as function
of this security parameter, and ask that it be negligible for all polynomial-time
adversaries.
The following proposition shows that the notion of pseudorandomness under
related-key attacks is stronger than the standard notion of pseudorandomness,
assuming that the set of RKD functions Φ includes any permutation on the key
space. As a special case, this proposition shows that if Φ contains the identity
permutation and if a block cipher is secure against Φ-restricted RKAs, then it
is also secure under the standard notion of pseudorandomness. (Furthermore,
the RKA notion and the standard notion are equivalent when |Φ| = 1 and the
function in Φ is a permutation.) The proof of Proposition 1 appears in [2].
Proposition 1. Let E : K×D → D be any block cipher, and let Φ be any set of
RKD functions over K that contains at least one permutation. Then given any
PRP adversary A against E, we can construct a Φ-restricted RKA adversary
BA against E such that
prp-rka
Advprp
(BA )
E (A) ≤ AdvΦ,E

and adversary BA uses the same resources as adversary A.
Deﬁnition 1 is for pseudorandom permutations under chosen-plaintext relatedkey attack. It is straight forward to extend this deﬁnition to pseudorandom functions under related-key attack, and also to pseudorandom permutations under
chosen-ciphertext related-key attack. For simplicity, in this extended abstract
we stick to the basic notion of Deﬁnition 1, but shall discuss the other notions
in [2].
Since we shall often consider xor and additive diﬀerences on k-bit keys, we
give the corresponding classes of RKD functions special names. Let K = {0, 1}k
where k ≥ 1 is an integer. For any integer i with 0 ≤ i < 2k we let ADDi : K →
K denote the function which on input K returns K + i mod 2k . (Here K is ﬁrst
interpreted as an integer and then the ﬁnal result is interpreted as a k-bit string.)
For any ∆ ∈ {0, 1}k we let XOR∆ : K → K denote the function which on input
K returns K ⊕ ∆. Then we let
k
Φ+
k = { ADDi : 0 ≤ i < 2 }

and

Φk⊕ = { XOR∆ : ∆ ∈ {0, 1}k } .

A Theoretical Treatment of Related-Key Attacks

4

499

Impossibility Results

There are inherent limitations to security against related-key attacks. We show
here that there exist relatively simple sets of RKD functions Φ over K such
that no block cipher E : K × D → D (with |D| suﬃciently large) can resist Φrestricted related-key attacks. (One consequence of this is that it is impossible to
design a block cipher that resists Φ-restricted related-key attacks for all Φ.) The
ﬁrst and obvious example is when Φ contains a constant function. The formal
proof of the following appears in [2].
Proposition 2. Let Φ be any class of RKD functions that contains a constant
function. (Meaning there exists a C ∈ K such that Φ contains the function φ
deﬁned by φ(K) = C for all K ∈ K.) Let E : K × D → D be any block cipher.
Then there exists an adversary A such that
Advprp-rka
(A) ≥ 1 −
Φ,E

1
,
|D|

and A makes only one oracle query and has running time that of one computation
of E.
One might expect better if Φ consists only of permutations (since the result of
applying a permutation to a random key is again a random key). The following
indicates, however, that there are simple sets Φ of permutations on K such that
there exist Φ-restricted related-key attacks against any block cipher.
Proposition 3. Let E : {0, 1}k ×D → D be any block cipher. Then there exists
an adversary A and a set of RKD functions Φ such that Φ consists only of
permutations on {0, 1}k and
Advprp-rka
(A) ≥ 1 −
Φ,E

k+1
,
|D|

and A makes 2k + 1 oracle queries (using 2k + 1 diﬀerent key transformations)
and has running time O(k) plus the time for one computation of E.
An example set Φ for which the above proposition holds is Φ = { φci : c ∈
{0, 1}, i ∈ {1, . . . , k} } ∪ {id} where id is the identity function, φ0i (K) maps K to
K if the i-th bit of K is 0 and complements all but the i-th bit of K if the i-th
bit of K is 1, and φ1i (K) maps K to K if the i-th bit of K is 1 and complements
all but the i-th bit of K if the i-th bit of K is 0. See the full version of this paper
for the complete proof.
While one might consider the above set of RKD permutations somewhat
contrived, we remark that there exist other, more natural sets Φ of permutations
on K such that an adversary can mount a Φ-restricted related-key attack against
most block ciphers E : K×D → D. Namely we will show this for K = {0, 1}k and
⊕
k
Φ = Φ+
k ∪Φk . To state the result we ﬁrst need a deﬁnition. If E : {0, 1} ×D →
D is a block cipher, we let
KCE = max
L=M

$

Pr D ← D : EL (D) = EM (D)

.

500

M. Bellare and T. Kohno

The maximum is over all pairs of distinct keys in K. Above, when we said our
result applied to “most” block ciphers, we meant ones for which KCE is assumed
small. In practice this does not seem to be a restriction. (We would expect
the above probability to be about 1/|D|.) The formal result below applies to
any block cipher and is stated quantitatively. From the result one sees that the
advantage of the adversary is high as long as KCE is small. The proof of the
following proposition appears in [2].
⊕
Proposition 4. Let E : {0, 1}k ×D → D be any block cipher. Let Φ = Φ+
k ∪Φk .
Then there exists an adversary A such that

Advprp-rka
(A) ≥ 1 −
Φ,E

(k − 1) · KCE
2
−
,
2
|D|

and A makes 2k − 1 oracle queries, each with a diﬀerent key transformation, and
has running time O(k) plus the time for two computations of E.

5

Properties of RKD Transformations

The attack in Proposition 2 works because the adversary is able to predict
the output of the function φ(K) for a random key K. And the attacks in
Proposition 3 and Proposition 4 work because the adversary is able to ﬁnd two
diﬀerent functions in Φ that sometimes produced the same output key (eg. if the
i-th bit of K is 0 then φ0i (K) = id(K) in the attack for Proposition 3). In this
section we introduce two security notions capturing these properties. We will use
these deﬁnitions in Section 6 when we present possibility results in the Shannon
model.
In both security notions, we associate to a given set of RKD transformations
Φ a measure of the extent to which Φ fails to have the property in question. The
measure function takes resource bounds and returns a number between 0 and 1.
The higher this number, the more “insecure” is Φ with regard to the property in
question. We name the ﬁrst property we measure output-unpredictability. Intuitively, a set Φ is output-unpredictable if, for all reasonably-sized sets P ⊆ Φ and
X ⊆ K, the probability, over a random choice of key K, that there exists a φ ∈ P
and K ∈ X such that φ(K) = K , is small. The set Φ used in Proposition 2 was
not output-unpredictable.
Deﬁnition 2. [Output-unpredictability for Φ.] Let K be a set of keys and
let Φ be a set of RKD functions over K. Let r, r be positive integers. Then
InSecup
Φ (r, r )
=

max

P ⊆Φ,X⊆K,|P |≤r,|X|≤r

$

Pr K ← K : { φ(K) : φ ∈ P } ∩ X = ∅

is deﬁned as the (r, r )-output-unpredictability of Φ.
We name the second property we measure collision-resistance. Intuitively, a set
Φ is collision-resistant if, for all reasonably-sized sets P ⊆ Φ, the probability,

A Theoretical Treatment of Related-Key Attacks

501

over a random choice of key K, that there exist distinct φ1 , φ2 ∈ P such that
φ1 (K) = φ2 (K), is small. The attacks in Proposition 3 and Proposition 4 both
exploit collisions of this form.
Deﬁnition 3. [Collision resistance for Φ.] Let K be a set of keys and let Φ
be a set of RKD functions over K. Let r be a positive integer. Then
InSeccr
Φ (r) =

max

$

P ⊆Φ,|P |≤r

Pr K ← K : |{ φ(K) : φ ∈ P }| < |P |

is deﬁned as the r-collision resistance of Φ.
Upper-bounding output-unpredictability and collision-resistance.
The following lemma shows that if Φ contains only permutations and if the
key-space is large, then output-unpredictability is assured for reasonable r, r .
Lemma 1. Let Φ be a set of permutations on some keys space K. Let r, r be
positive integers. Then
−1
InSecup
.
Φ (r, r ) ≤ rr |K|

For the canonical sets of RKD functions in which we are interested, namely Φ+
k
and Φk⊕ , the following lemma shows that collision-resistance is guaranteed.
⊕
Lemma 2. Let K = {0, 1}k and let Φ be either Φ+
k or Φk . Then for any positive
integer r,

InSeccr
Φ (r) = 0 .
See [2] for the proof of Lemma 1 and Lemma 2.
Lower-bounds. It is possible to lower-bound the insecurity of a block cipher
against Φ-restricted RKAs as a function of the output-unpredictability of Φ.
See [2] for details.

6

Possibility Results: The Shannon Model

In this section we show that if a set of RKD transformations Φ over K is both
output-unpredictable and collision-resistant, then security against Φ-restricted
RKAs is achievable in the Shannon model. This suggests that security against
Φ-restricted RKAs for such Φ is a reasonable block cipher design goal.
The Shannon model. We begin by extending Deﬁnition 1 to the Shannon
model. This is easily done: we simply provide the adversary with oracles for E
and E −1 , in both worlds, where E, the target block cipher, is chosen at random
from the class of all block ciphers. Note the choice of G remains as before.
Deﬁnition 4. [RKA pseudorandomness in the Shannon model.] Fix sets
K and D and let Φ be a set of RKD functions over K. Let A be an adversary

502

M. Bellare and T. Kohno

with access to three oracles, and restricted to queries of the form (K , x) for the
ﬁrst two oracles and (φ, x) for the last, where K ∈ K, φ ∈ Φ, and x ∈ D. Then
E(·,·),E
Advprp-rka
Φ,K,D (A) = Pr K ← K ; E ← Perm(K, D) : A
$

$

−1

(·,·),Erk(·,K) (·)

− Pr K ← K ; E ← Perm(K, D) ; G ← Perm(K, D) : AE(·,·),E
$

$

$

−1

=1

(·,·),Grk(·,K) (·)

=1

is deﬁned as the prp-rka-advantage of A in a Φ-restricted related-key attack on
a Shannon cipher with keys K and domain D.
Remark 2. The attacks in Section 4 apply in the Shannon model as well. (This is
as one would expect since the attacks exploit properties of Φ and not properties
of the block cipher in question.) For example, the lower bounds on Advprp-rka
Φ,K,D (A)
in Proposition 2, Proposition 3 and Proposition 4 become, respectively
1−

1
k+1
k+3
, 1−
and 1 −
.
|D|
|D|
2 · |D|

Possibility results. We are now able to present our main result: if Φ is both
output-unpredictable and collision-resistant, then security against Φ-restricted
RKAs is a reasonable design goal for a real block cipher.
More formally, we show that the Φ-restricted prp-rka-advantage of an advercr
sary A in the Shannon model is upper-bounded by InSecup
Φ (r, r ) plus InSecΦ (r)
where r is the number of diﬀerent keys A queries its Shannon cipher with and
r is the number of diﬀerent RKD functions with which the adversary queries
cr
its related-key oracle. This implies that if InSecup
Φ (r, r ) and InSecΦ (r) are
small, then any attack on a real block cipher that succeeds with high probability
must exploit a property of the block cipher itself and not just a property of the
related-key transformations Φ.
Theorem 1. Fix a key space K and domain D. Let Φ be a set of RKD functions
over K. Let A be a Shannon adversary that queries its ﬁrst two oracles with a
total of at most r diﬀerent keys and that queries its last oracle with a total of
at most r diﬀerent RKD functions from Φ. Then
up
cr
Advprp-rka
Φ,K,D (A) ≤ InSecΦ (r, r ) + InSecΦ (r) .

The proof of Theorem 1 is in [2]. Note that this result is independent of the
number of queries A performs with respect to each key (for its ﬁrst two oracles)
or key transformation (for the last oracle). That is, the parameters of interest
are only the number of diﬀerent keys with which A queries its Shannon cipher
and the number of diﬀerent RKD functions with which A queries its related key
oracle.
Remark 3. Theorem 1 extends to PRPs with respect to Φ-restricted chosenciphertext RKAs and to Φ-restricted RKAs against the pseudorandomness of
function families. See [2].

A Theoretical Treatment of Related-Key Attacks

503

The value of this general result is that one can now, given a class Φ of RKD
functions, determine whether security against Φ-restricted RKAs is achievable
by testing whether Φ has the collision-resistance and output-unpredictability
properties. This is typically easy to do, as we saw in Section 5.
Results about the security against Φ-restricted RKAs in the Shannon model
⊕
for Φ = Φ+
k or Φ = Φk follow. These results are important because they provide
evidence that security against RKAs restricted to the classes of RKD functions
that are popular targets in the block cipher community, is achievable. They also
provide a quantitative indication of how well such attacks might be expected to
fare.
Corollary 1. Fix key-space K = {0, 1}k and domain D. Let Φ be either Φ+
k or
Φk⊕ . Then, for all Shannon prp-rka adversaries A that query their last oracle
with a total of at most r diﬀerent key transformations and that query their ﬁrst
two oracles with a total of at most r diﬀerent keys,
−k
.
Advprp-rka
Φ,K,D (A) ≤ rr 2

Proof (Corollary 1). Combine Lemma 1, Lemma 2, and Theorem 1.

7

Applications of RKA-Secure PRPs

Above we have been able to formally deﬁne a notion of security of block ciphers against Φ-restricted RKAs, and to determine for which classes Φ it is
reasonable to assume security against Φ-restricted RKAs. Based on this we can
approach the analysis of block cipher based constructions that use related keys
with the goal of proving their security based on assumptions about the security against Φ-restricted RKAs of the underlying block cipher. As per the above
we will certainly want to conﬁne the choices of Φ to classes with low outputunpredictability and collision-resistance. But typically we do more than that. We
conﬁne our assumptions on the security of the block cipher against Φ-restricted
⊕
RKAs to Φ = Φ+
k or Φk , or, even better, to small subsets of these classes.
We begin by showing how to use our new notions of security to prove the
security of a tweakable block-cipher constructions suggested in [14].
Proof of security for a tweakable block cipher. In [14] Liskov, Rivest,
and Wagner suggest that if a block cipher resists related key attacks, then one
could construct a tweakable block cipher by xoring the tweak into the key. Here
we provide formal justiﬁcation for their belief.
Let us recall some deﬁnitions from [14]. A tweakable block cipher E is a
function mapping {0, 1}k × {0, 1}t × {0, 1}l to {0, 1}l . For each K ∈ {0, 1}k and
T ∈ {0, 1}t , we require that E(K, T, ·) is a permutation on {0, 1}l . We shall use
EK (·, ·) as shorthand for E(K, ·, ·). If A is an adversary with access to one oracle,
we let
(A) = Pr K ← K : AEK (·,·) = 1
Advtweak-prp
E
$

− Pr G ← Perm({0, 1}t , {0, 1}l ) : AG(·,·) = 1
$

504

M. Bellare and T. Kohno

denote the tweak-prp-advantage of A in attacking E. We can now state the
following theorem, namely that if E : {0, 1}k ×{0, 1}l → {0, 1}l is a secure block
cipher under Φk⊕ -restricted related-key attacks, then E : {0, 1}k × {0, 1}k ×
{0, 1}l → {0, 1}l deﬁned as EK (T, M ) = EK ⊕ T (M ) will be a secure tweakable
block cipher. The proof of Theorem 2 appears in [2].
Theorem 2. Let E : {0, 1}k × {0, 1}l → {0, 1}l be a block cipher and let
E : {0, 1}k × {0, 1}k × {0, 1}l → {0, 1}l be a tweakable block cipher deﬁned
as E(K, T, M ) = E(K ⊕ T, M ). Then given a tweak-prp adversary A against E
we can construct an Φk⊕ -restricted prp-rka adversary B against E such that
(A) ≤ Advprp-rka
(B) .
Advtweak-prp
Φ ⊕ ,E
E
k

If A queries its oracle with at most r tweaks and at most q times per tweak,
then B runs in the same time as A and queries its oracle with at most r key
transformations and at most q times per transformation.
Single-key CBC MACs for Arbitrary-Length Messages. In addition to
proving the security of existing constructions (eg. the examples mentioned in [11]
and the tweakable block cipher above), related-keys can also be used to reduce
the number of keys in constructs that are deﬁned to use several independent keys,
thereby conceptually simplifying the designs. We exemplify this by providing,
in the full version of this paper, some CBC-MAC variants that are provably
secure for variable-length messages yet use just one key. (While these MAC
constructions have only one key, they still require running the block cipher’s key
schedule algorithm for three related keys.)
We base our constructions on two of Black and Rogaway’s [4] “three-key
constructions,” and our constructions, keyed with a single key K, invoke the
underlying block cipher with keys φ1 (K), φ2 (K), φ3 (K), where Φ = {φ1 , φ2 , φ3 }
is some set of RKD permutations and InSeccr
Φ (3) = 0. For example, Φ might
consist of the three functions ADD0 , ADD1 , ADD2 .
From a pragmatic perspective, one may now wish to use TMAC [13] or
OMAC [10], two recently-proposed two-key and one-key CBC-MAC variants,
rather than the constructions we present in the full version of this paper. We
present our constructions primarily because they illustrate the use of RKA-secure
PRPs in constructs. See the full version of this paper for details.
Discussion. We end this section with some observations about constructs that
use related keys.
Remark 4. If Φ is a subset of Φ, then the insecurity of E with respect to Φ restricted related-key attacks can be no greater than the insecurity of E with
respect to Φ-restricted related-key attacks (and may, in fact, be much smaller).
Take Φ to be {ADD0 , ADD1 , ADD2 } ⊂ Φ+
k . While one may not wish to base
the security of a protocol on the security of a block cipher against Φ+
k -restricted
related-key attacks, one may feel more comfortable basing the security of a protocol on the security of a block cipher against Φ -restricted related-key attacks,

A Theoretical Treatment of Related-Key Attacks

505

as we did with our CBC-MAC variants. See also the full version of this paper,
⊕
which shows that the insecurity of block ciphers under Φ+
k - or Φk -restricted
related-key attacks is (essentially) lower-bounded by a birthday-like term of the
form rr 2−k (r is the number of diﬀerent related-key transformations with which
an adversary queries its related-key oracle, and r is the number of diﬀerent keys
K with which the attacker computes EK (·) directly).
Remark 5. Consider a construct that uses a block cipher with related keys and
that is provably secure under some standard notion of security (eg, unforgeability
for MACs or indistinguishability for encryption schemes) assuming that the block
cipher resists Φ-restricted RKAs for some appropriate set Φ. It is important to
note that even though that construct is provably secure under some standard
notion, that construct may be vulnerable to a construction-level related-key
attack (this is not a contradiction since construction-level related-key attacks
are outside the standard models of security for MACs and encryption schemes).
Consider, for example, the construction-level related-key attack against RMAC
in [12]. As another example, note that the tweakable block cipher in Theorem 2
is vulnerable to construction-level related-key attacks. Namely, E(K, T, M ) =
E(K ⊕ X, T ⊕ X, M ) for any k-bit string X. Whether or not construction-level
related-key attacks are of a concern depends on the application in question.
Remark 6. While most modern block ciphers, including the AES, are designed
with the explicitly stated goal of resisting related-key attacks, it is important to
note that some block cipher constructions do not resist related-key attacks (or
are more vulnerable to related-key attacks than one would expect). Consider,
for example, the complementation property with DES, or [11]’s attack against
three-key triple DES. Developers of protocols that use related-keys should be
aware of this problem and realize that some block ciphers may not be good
candidates for use with their constructions. See, for example, the problems with
using 3DES in RMAC [12].
Acknowledgments. Mihir Bellare is supported in part by NSF Grant CCR0098123, NSF Grant ANR-0129617 and an IBM Faculty Partnership Development Award. Tadayoshi Kohno is supported by a National Defense Science and
Engineering Graduate Fellowship.

References
1. M. Bellare, J. Kilian, and P. Rogaway. The security of the cipher block chaining message authentication code. Journal of Computer and System Sciences,
61(3):362–399, 2000.
2. M. Bellare and T. Kohno. A theoretical treatment of related-key attacks: RKAPRPs, RKA-PRFs, and applications. Full version of this paper, available at
http://www-cse.ucsd.edu/users/tkohno/papers/RKA/, 2003.

506

M. Bellare and T. Kohno

3. E. Biham. New types of cryptanalytic attacks using related keys. In T. Helleseth,
editor, Advances in Cryptology – EUROCRYPT ’93, volume 765 of Lecture Notes
in Computer Science, pages 398–409. Springer-Verlag, Berlin Germany, 1993.
4. J. Black and P. Rogaway. CBC MACs for arbitrary-length messages: The threekey construction. In M. Bellare, editor, Advances in Cryptology – CRYPTO 2000,
volume 1880 of Lecture Notes in Computer Science, pages 197–215. Springer-Verlag, Berlin Germany, 2000.
5. N. Courtois and J. Pieprzyk. Cryptanalysis of block ciphers with overdeﬁned systems of equations. Cryptology ePrint Archive http://eprint.iacr.org/: Report
2002/044, 2002.
6. J. Daemen and V. Rijmen. AES proposal: Rijndael. http://csrc.nist.gov/
encryption/aes/rijndael/Rijndael.pdf, 1999.
7. J. Daemen and V. Rijmen. The Design of Rijndael. Springer-Verlag, Berlin Germany, 2002.
8. N. Ferguson, J. Kelsey, S. Lucks, B. Schneier, M. Stay, D. Wagner, and D. Whiting.
Improved cryptanalysis of Rijndael. In B. Schneier, editor, Fast Software Encryption 2000, volume 1978 of Lecture Notes in Computer Science, pages 213–230.
Springer-Verlag, Berlin Germany, 2000.
9. O. Goldreich, S. Goldwasser, and S. Micali. How to construct random functions.
Journal of the ACM, 33(4):210–217, 1986.
10. T. Iwata and K. Kurosawa. OMAC: One-key CBC MAC. In T. Johansson, editor,
Fast Software Encryption 2003, Lecture Notes in Computer Science. Springer-Verlag, Berlin Germany, 2003.
11. J. Kelsey, B. Schneier, and D. Wagner. Key-schedule cryptanalysis of IDEA, GDES, GOST, SAFER, and Triple-DES. In N. Koblitz, editor, Advances in Cryptology – CRYPTO ’96, volume 1109 of Lecture Notes in Computer Science, pages
237–251. Springer-Verlag, Berlin Germany, 1996.
12. L. Knudsen and T. Kohno. Analysis of RMAC. In T. Johansson, editor, Fast
Software Encryption 2003, Lecture Notes in Computer Science. Springer-Verlag,
Berlin Germany, 2003.
13. K. Kurosawa and T. Iwata. TMAC: Two-key CBC MAC. NIST submission,
available at http://csrc.nist.gov/CryptoToolkit/modes/, June 2002.
14. M. Liskov, R. Rivest, and D. Wagner. Tweakable block ciphers. In M. Yung,
editor, Advances in Cryptology – CRYPTO 2002, volume 2442 of Lecture Notes in
Computer Science, pages 31–46. Springer-Verlag, Berlin Germany, 2002.
15. M. Luby and C. Rackoﬀ. How to construct pseudorandom permutations from
pseudorandom functions. SIAM J. Computation, 17(2), Apr. 1988.
16. M. Naor and O. Reingold. Number-theoretic constructions of eﬃcient pseudorandom functions. In Proceedings of the 38th Annual Symposium on Foundations
of Computer Science, pages 458–467. IEEE Computer Society Press, 1997.
17. J. B. Nielsen. A threshold pseudorandom function construction and its applications. In M. Yung, editor, Advances in Cryptology – CRYPTO 2002, volume 2442
of Lecture Notes in Computer Science, pages 401–416. Springer-Verlag, Berlin Germany, 2002.

