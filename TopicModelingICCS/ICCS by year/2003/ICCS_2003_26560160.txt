Simulation in Quasi-Polynomial Time, and Its
Application to Protocol Composition
Rafael Pass
Department of Numerical Analysis and Computer Science,
Royal Institute of Technology, 100 44 Stockholm, Sweden.
rafael@nada.kth.se

Abstract. We propose a relaxation of zero-knowledge, by allowing the
simulator to run in quasi-polynomial time. We show that protocols satisfying this notion can be constructed in settings where the standard deﬁnition is too restrictive. Speciﬁcally, we construct constant-round straightline concurrent quasi-polynomial time simulatable arguments and show
that such arguments can be used in advanced composition operations
without any set-up assumptions. Our protocols rely on slightly strong,
but standard type assumptions (namely the existence of one-to-one oneway functions secure against subexponential circuits).

1

Introduction

The ground-breaking notion of zero-knowledge proofs, i.e. proofs that yield no
knowledge except the validity of the assertion proved, was introduced by Goldwasser, Micali and Rackoﬀ [27] in 1982. Although the notion in itself is very
beautiful, zero-knowledge is often not a goal but is rather used as a tool or
technique for proving security of other cryptographic protocols. The deﬁnition
of zero-knowledge is captured through the simulation paradigm. Namely, an interactive proof is said to be zero-knowledge if there exist a simulator that can
simulate the behavior of every, possibly malicious, veriﬁer, without having access to the prover, in such a way that its output is indistinguishable from the
output of the veriﬁer after having interacted with an honest prover. The logic
behind the simulation paradigm is straightforward: Assuming that a malicious
veriﬁer succeeds in doing something after having interacted with a prover, then
by running the simulator, he could have done it himself, without any interaction
with a prover.
Nevertheless, it seems that current simulation techniques do not allow for
advanced composition of protocols [22] [10]. The problem has been adressed in
a positive way by Canetti [6], and Canetti and Fischlin [7] where the use of
a stronger model, namely the Common Reference String model, was suggested
to achieve zero-knowledge protocols that are universally composable [6]. Their
approach is, however, not entirely problem free as was recently pointed out in
[30]. In this paper we, instead, suggest a meaningful relaxation of the zeroknowledge deﬁnition that allows us to construct protocols in the plain model
E. Biham (Ed.): EUROCRYPT 2003, LNCS 2656, pp. 160–176, 2003.
c International Association for Cryptologic Research 2003

Simulation in Quasi-Polynomial Time

161

without any set-up assumption, on which advanced composition operations can
be performed. We start by outlining the deﬁnitions and then motivate why they
are meaningful.
Simulation in quasi-polynomial time. As the veriﬁer in an interactive proof often
is modeled as a probabilistic polynomially bounded turing machine, a PPT, the
zero-knowledge deﬁnition requires that the simulator should be a PPT as well.
Here, we weaken that speciﬁc assumption on the simulator, allowing it to be a
probabilistic turing machine with running time bounded by npoly(logn) , i.e. with
quasi-polynomial running time. Loosely speaking, we say that an interactive
proof is nO(σ(n)) -simulatable (or nO(σ(n)) -strongly simulatable) if there exist a
simulator, running in time nO(σ(n)) , where n is the size of the statement being
proved, whose output is indistinguishable, by polynomial size (or nσ(n) -size)
circuits, from a veriﬁer’s output after interacting with an honest prover.
Extraction in quasi-polynomial time. Another useful tool for proving security of
cryptographic protocol is the concept of proofs of knowledge, introduced in [27].
A proof of knowledge is a proof whereby the veriﬁer gets, not only convinced
of the validity of the statement proved, but also that the prover has an (NP)
witness to the statement. The deﬁnition is captured through the introduction of
an extractor, i.e. a machine that is able to extract a witness from a prover that
convinces an honest veriﬁer. Thus a prover that convinces an honest veriﬁer of
a statement, could have run the extractor (on himself) and obtained a witness
to the statement. Since the extractor models the power of the prover, and the
prover usually is modeled by a PPT, the extractor is so as well. We weaken this
assumption on the extractor and only require that extraction can be performed in
time npoly(logn) . Loosely speaking, we say that an interactive proof is nO(σ(n)) witness extractable if there exist a probabilistic turing machine with running
time bounded by nO(σ(n)) that succeeds in extracting witnesses.
1.1

Practical Motivation Behind the Proposed Notions

Generalization. The intuitive meaning of nO(σ(n)) -simulatable proofs are proofs
where the veriﬁer might learn something from the prover, but not more than
can be calculated by a machine running in time nO(σ(n)) . Our notion is thus a
generalization of zero-knowledge where the “knowledge leaked” is quantiﬁed in
a natural way.
Relaxation. Our work is in the vein of [19], where the notions witness indistinguishability and witness hiding were introduced. Like our notions, these notions
are weaker than zero-knowledge, but are suﬃcient in many applications. Since
our notions, however, still build on the standard simulation paradigm they can
often be directly used to replace zero-knowledge/proof of knowledge protocols.
In fact, the logic behind zero-knowledge and proofs of knowledge holds in many
settings with nO(σ(n)) -simulatable, and extractable proofs, respectively. If a malicious veriﬁer succeeds with a task after having interacted with an honest prover

162

R. Pass

using an nO(σ(n)) -simulatable protocol, then there exists a nO(σ(n)) -time machine
that succeeds with the task without interacting with the prover. In the case when
σ = poly(logn), this means that the task is solvable in quasi-polynomial time.
Yet most natural problems that we believe are hard on average for polynomial
time are also believed hard for quasi-polynomial time. In such a case, nO(σ(n)) simulatable proofs can be directly used to replace zero-knowledge proofs. The
situation is analogous in the case of proofs of knowledge. Proofs of knowledge are
often used to show that if an adversary successfully convinces an honest veriﬁer,
then the adversary can ﬁnd a solution to an intractable problem. Now, if using
npoly(logn) -extractable proofs, we arrive at a contradiction as well, assuming that
the underlying problem is intractable for quasi-polynomial time.
Guarantee security in the On-line/Oﬀ-line model. In many settings it seems
reasonable to assume that parties are given a certain on-line time and a certain,
longer, oﬀ-line time. Such an on-line/oﬀ-line model can be modeled by letting
parties to run in polynomial time while being on-line, and npoly(logn) time oﬀline.
An important property of npoly(logn) -strongly simulatable arguments is that
they are zero-knowledge in the on-line/oﬀ-line model. If a protocol is strongly
quasi-polynomial time simulatable, that means that there exist an oﬀ-line simulator for every on-line veriﬁer such that the output of of the simulator is indistinguishable in quasi-polynomial time, i.e. oﬀ-line, from the output of the veriﬁer
after interaction with a real on-line prover. Strongly quasi-polynomial time simulatable protocols thus guarantee that anything that a veriﬁer can calculate after
interaction with a prover, he could have calculated by himself oﬀ-line.
Allow for advanced composition. As zero-knowledge protocols normally are quite
easy to construct there is not really a need for a relaxed notion in the synchronous setting. In asynchronous settings it seems harder to achieve eﬃcient
zero-knowledge protocols. Indeed, Canetti, Kilian, Petrank, Rosen [10] have
shown the impossibility of constant-round black-box concurrent zero-knowledge,
i.e. zero-knowledge under concurrent executions. In fact, it in general seems hard
to compose protocols that are proven secure using standard rewinding techniques. We show how to construct constant-round protocols that are concurrent
quasi-polynomial time simulatable without the use of rewinding, i.e. straight-line
simulatable. We also show that such straight-line protocols can be used in fully
asynchronous composition operations.
1.2

Theoretical Motivation Behind the Proposed Notions

In the standard model several strong impossibility results are known:
1. The impossibility of non-trivial straight-line simulatable expectedpolynomial-time black-box zero-knowledge arguments. (folklore)
2. The impossibility of non-trivial 2-round expected-polynomial-time zeroknowledge arguments. (straight-forward extension, from proofs to arguments, of the result of [25])

Simulation in Quasi-Polynomial Time

163

3. The impossibility of non-trivial 3-round expected-polynomial-time black-box
zero-knowledge arguments. [22]
4. The impossibility of non-trivial strict polynomial-time constant-round blackbox zero-knowledge arguments and proofs of knowledge. [2]
5. The impossibility of non-trivial constant-round concurrent black-box zeroknowledge arguments. [10]
Our main theoretical motivation is to investigate if these impossibility results still are valid if relaxing the running time of the simulator/extractor to
npoly(logn) .1 We show that all these impossibility result can be overcome when
allowing the simulator/extractor to run in quasi-polynomial time.
1.3

Our Contribution

On top of the deﬁnitional eﬀorts, we demonstrate a powerful composition theorem for straight-line concurrent npoly(logn) -simulatable arguments showing that
in settings where proving the security of a ﬁxed protocol, straight-line concurrent
npoly(logn) -simulatable arguments can be used as sub-protocols to guarantee security against concurrent and man-in-the-middle attacks. We note that it is the
straight-line simulation property that allows us to achieve such a composition
theorem.
Results. We construct a 2-round argument for N P that is straight-line concurrent black-box strict-npoly(logn) -simulatable2 and straight-line strict-npoly(logn) extractable, under the assumption that one-to-one one-way functions secure
against subexponential circuits exists, and the existence of zaps [15] . We have
thus shown that all the above mentioned impossibility results in the standard
model no longer hold in our relaxed setting. We further show the impossibility of 2-round npoly(logn) -simulatable proofs with negligible soundness error for
languages that are not decidable in quasi-polynomial time.
On the practical side, we construct an eﬃcient 4-round straight-line concurrent strict-npoly(logn) -perfectly simulatable argument, under the assumption of
one-to-one one-way functions secure against subexponential circuits, and perfectly hiding commitments. In analogy with perfect zero-knowledge, perfect simulation here means that the simulator’s output has the same distribution as
the veriﬁer’s output, after interaction with a real prover. The 4-round argument for N P is thus concurrent zero-knowledge in the on-line/oﬀ-line model.
We also mention that the protocol is constructed through an eﬃcient generic
1

2

We note that even in the standard deﬁnition of zero-knowledge, the veriﬁer is modeled as a strict polynomial time machine, whereas the simulator is allowed to run in
expected polynomial time. Thus, already in the standard deﬁnition there is a slight
gap between the power of the veriﬁer and the power of the simulator. The same
concerns are also valid in the case of proofs of knowledge.
In this section we emphasize that our protocols are simulatable in strict npoly(logn) time, as opposed to expected time. In the rest of the paper we do not emphasize this
fact.

164

R. Pass

transformation from 3-round special-sound public-coin honest-veriﬁer perfect
zero-knowledge arguments.
1.4

Related Research

Our on-line/oﬀ-line model is quite similar to the timing model introduced by
Dwork, Naor and Sahai [14] in the context of concurrent zero-knowledge. We
mention that the concurrent zero-knowledge protocol presented in [14] relies
on both time-out and delay mechanism, whereas our protocol only relies on
time-outs, which drastically improves the eﬃciency. The on-line/oﬀ-line model,
however, relies on stronger assumptions than the timing model as it explicitly
bounds the on-line running time of malicious parties.
Recently, Dwork and Stockmeyer [13], investigated the possibility of 2-round
zero-knowledge protocols in a model where the prover has bounded resources.
The intuition and the structure of our 2-round protocol is similar to that of [13],
however both the security deﬁnitions and the techniques used to instantiate
the intuition are very diﬀerent. Indeed the results of Dwork and Stockmeyer
are quite limited in the setting where the prover’s running time is bounded,
while we are able to prove security under standard type assumptions. We note,
however, that the deﬁnition used in [13] is more restrictive than that of simply
quasi-polynomial time simulatable arguments.
Canetti et al have, in [9], used the technique of complexity leveraging. The
proof of security of our 2-round protocol relies on the same technique.

2
2.1

Deﬁnitions and Preliminaries
One-Way Functions and Hard-Core Predicates

Intuitively one-way functions are functions that are easy to compute, but hard
to invert. Here “easy” means, achievable in polynomial time, and “hard” normally means not achievable in polynomial time. In this paper we rely on stronger
assumptions than the most commonly used, namely we assume the existence of
one-way functions where inverting the function is hard for subexponential circuits. The assumptions is, nevertheless, very plausible and has for example been
used to construct resettable zero-knowledge in [9]. More formally, (borrowing
notation from [20])
Deﬁnition 1. A function f : {0, 1}∗ → {0, 1}∗ is called one-way against 2n
adversaries if the following two conditions hold:

κ

– Easy to compute: There exist a (deterministic) polynomial-time algorithm A
such that on input x, A outputs f (x).
– Hard to invert: For every probabilistic algorithm A with running time
κ
bounded by 2n , every positive polynomial p, and all suﬃciently large n’s,
every auxiliary input z ∈ {0, 1}poly(n) ,
P r[A (f (Un ), z) ∈ f −1 (f (Un ))] < 2−n

κ

where Un is a random variable uniformly distributed in {0, 1}n .

Simulation in Quasi-Polynomial Time

165

Deﬁnition 2. A function f : {0, 1}∗ → {0, 1}∗ is called one-way against subexκ
ponential circuits iﬀ there exist a κ such that f is one-way against 2n adversaries.
A predicate b is a called a hard-core of a function f if an adversary given f (x)
can guess b(x) with success probability only negligibly higher than one half. Here
again, the adversary is normally limited to polynomial time. We use a stronger
deﬁnition, allowing the adversary to be a subexponential circuit:
Deﬁnition 3. A polynomial-time-computable predicate b : {0, 1}∗ → {0, 1} is
κ
called a hard-core against 2n adversaries of a function f if for every probabilistic
κ
algorithm A with running time bounded by 2n , every positive polynomial p, and
all suﬃciently large n’s, every auxiliary input z ∈ {0, 1}poly(n) ,
P r[A (f (Un ), z) = B(Un )] <

κ
1
+ 2−n
2

where Un is a random variable uniformly distributed in {0, 1}n .
Deﬁnition 4. A polynomial-time-computable predicate b : {0, 1}∗ → {0, 1} is
called a hard-core against subexponential circuits of a function f if there exist
κ
a κ such that b is a hard-core against 2n adversaries for f .
Goldreich and Levin [23] have shown that a simple hard-core predicate can
be constructed assuming the existence of one-way functions. We note that the
Goldreich-Levin predicate is also a hard-core against subexponential circuits of
a function that is one-way against subexponential circuits.
Theorem 1 (Goldreich-Levin). If there exist a one-way function f :
{0, 1}∗ → {0, 1}∗ against subexponential circuits, then there exist a pair f ,b ,
where f : {0, 1}∗ → {0, 1}∗ is a one-way function against subexponential circuits, and b : {0, 1}∗ → {0, 1} is a hard-core predicate against subexponential
circuits for f . Furthermore, if f is one-to-one, then f is so as well.
2.2

Commitment Schemes

We will give an informal deﬁnition of a commitment scheme. For a formal definition we refer the reader to [20]. Informally a commitment scheme between a
PPT committer C and a PPT receiver R is a protocol in two phases, a commit
phase and a reveal phase, such that C commits to a string (or bit) during the
commit phase, that it can thereafter reveal (or “decommit to”) during the reveal
phase. The commitment scheme should also have the two properties: hiding and
binding. The hiding property means that the receiver should have no knowledge of the string, that C has committed to, before the reveal phase. In other
words, this means that there should not exist a non-uniform distinguisher that
can distinguish between two commitments. The binding property means that
the committer should not be able to successfully pass the commit phase and still
be able to decommit to two diﬀerent values during the reveal phase.

166

2.3

R. Pass

Witness Indistinguishabilty

The notion witness indistinguishability was introduced by Feige and Shamir
in [19] as a weaker alternative to zero-knowledge. It has later proved to be
an excellent tool to achieve zero-knowledge [17], [18], [32], [1]. Intuitively an
interactive proof of an N P relation, in which the prover uses one of several secret
witnesses is witness indistinguishable if the veriﬁer can not tell what witness the
prover has used. We further say that an interactive proof is witness independent
if the veriﬁer’s view is equally distributed independently of what witness the
prover has used.
2.4

Zaps

Zaps, two round witness indistinguishable public-coin protocols, where the
ﬁrst message can be ﬁxed once and for all, were introduced in [15] by Dwork
and Naor. They presented the following construction of a zap for proving
membership of x in the language L:
Suppose that there exist a non-interactive zero-knowledge proof for the language
L using a CRS string consisting of l bits. Then the following protocol is a
witness indistinguishable proof.
V → P : Sends a random k-bit string ρ = b1 ...bk which is interpreted as
B1 ...Bm , where Bi denotes the i’th block of l consecutive bits.
P → V : The prover chooses and sends a random l-bit string C = c1 ...cl . For
j = 1 to m the prover sends a non-interactive zero-knowledge argument that
x ∈ L using Bj ⊕ C as CRS string.
2.5

Proofs of Knowledge

Informally an interactive proof is a proof of knowledge if there exists an oracle
machine, a so called extractor, such that if a prover can convince the veriﬁer with
non-negligible probability, then the extractor having oracle access to the prover
can extract a witness to the statement being proved in polynomial time. Proofs
of knowledge are of special interest to us since the existence of an extractor
directly implies soundness. See [20] for a formal deﬁnition.
In the following we will also be needing a restricted form of proofs of knowledge, namely special-sound proofs.
Deﬁnition 5. Suppose Π is a three round interactive proof (or argument) for
the language L ∈ N P, with witness relation RL . We say that the protocol Π
is special sound if there exist a PPT extractor machine E, such that for all
x ∈ L and all pairs of accepting transcripts for proving x, T1 = (a, b1 , c1 ), T2 =
(a, b2 , c2 ), where b1 = b2 , E(T1 , T2 ) ∈ RL (x).
It can be seen that if an interactive proof is special sound it is also a proof of
knowledge. [12]

Simulation in Quasi-Polynomial Time

3

167

Deﬁnition of the Relaxed Notions and Some
Consequences

As argued in the introduction, for many applications, it is often suﬃcient to
use interactive proofs (or arguments) with simulators, or extractors, running in
quasi-polynomial time.
3.1

Simulation

We start by deﬁning nO(σ(n)) -simulatable interactive proofs.
Deﬁnition 6. We say that an interactive proof (or argument) (P, V ) for the
language L ∈ N P, with the witness relation RL , is nO(σ(n)) -simulatable if there
for every PPT machine V ∗ exists a probabilistic simulator S with running time
bounded by nO(σ(n)) such that the following two ensembles are computationally
indistinguishable (when the distinguishing gap is a function in n = |x|)
– {( P (y), V ∗ (z) (x))}z∈{0,1}∗ ,x∈L for arbitrary y ∈ RL (x)
– {S(x, z)}z∈{0,1}∗ ,x∈L
That is, for every probabilistic algorithm D running in time polynomial in the
length of its ﬁrst input, every polynomial p, all suﬃciently long x ∈ L, all y ∈
RL (x) and all auxiliary inputs z ∈ {0, 1}∗ it holds that
|P r[D(x, z, ( P (y), V ∗ (z) (x))) = 1] − P r[D(x, z, S(x, z)) = 1]| <

1
p(|x|)

Notation: As in the literature, A, B (x) is the random variable representing
B’s output when interacting with machine A on common input x.
We note that in this deﬁnition, the distinguisher, as well as the distinguishing
gap is polynomial, even though the simulator is allowed to run in time nO(σ(n)) .
We show, in the composition theorem in the next section, that in many cases
this is a suﬃcient requirement. Intuitively this stems from the fact that both
the adversary, i.e. the malicious veriﬁer, and parties that it will interact with,
outside of the interactive proof, are polynomial time. Thus, an PPT adversary
that succeeds with a protocol execution, communicating with PPT machines,
after having interacted with a prover using a nO(σ(n)) -simulatable proof, could
have done so by itself in time nO(σ(n)) .
We also introduce two stronger and more robust notions, namely strongly
simulatable, and perfectly simulatable proofs. We say that an interactive proof
(or argument) is nO(σ(n)) -strongly simulatable if the two above ensembles are
indistinguishable by nO(σ(n)) -sized circuits, with distinguishing gap nO(σ(n)) . In
analogy with standard deﬁnitions of perfect zero-knowledge, we say that an
interactive proof (or argument) is nO(σ(n)) -perfectly simulatable if there exist a
simulator that fails with probability smaller than 12 and the two above ensembles
have the same distribution, when the simulator’s output is conditioned on not
failing. It is an easy excercise to show that npoly(logn) -perfectly simulatable proofs
are npoly(logn) -strongly simulatable.

168

R. Pass

npoly(logn) -strongly simulatable arguments are trivially zero-knowledge in the
on-line/oﬀ-line model introduced in the introduction 3 . In the on-line/oﬀ-line
model all parties are allowed to run in polynomial time when being on-line, i.e.
in communication with other parties, but are allowed to use npoly(logn) time when
being oﬀ-line. If a protocol in such a setting is npoly(logn) -strongly simulatable
then it means that the veriﬁer does not learn anything that it could not have
learned by itself when being oﬀ-line.
The deﬁnitions can be restricted to straight-line simulators:
Deﬁnition 7. We say that an interactive argument (proof ) (P, V ) for the
language L ∈ N P, with the witness relation RL , is straight-line nO(σ(n)) simulatable if there for every PPT machine V ∗ exists a probabilistic simulator
S with running time bounded by nO(σ(n)) such that the following two ensembles
are computationally indistinguishable (when the distinguishing gap is a function
in n = |x|)
– {( P (y), V ∗ (z) (x))}z∈{0,1}∗ ,x∈L for arbitrary y ∈ RL (x)
– {( S, V ∗ (z) (x))}z∈{0,1}∗ ,x∈L
We note that the above deﬁnition is very restrictive. In fact, the simulator is
supposed to act a cheating prover, with its only advantage being the possibility
of running in time nO(σ(n)) , instead of polynomial time. Trivially, there therefore
do not exist any straight-line nO(σ(n)) -simulatable proofs.
We also generalize the deﬁnition to guarantee security under concurrent runs:
Deﬁnition 8. We say that an interactive argument (proof ) (P, V ) for the language L ∈ N P, with the witness relation RL , is straight-line concurrent nO(σ(n)) simulatable if there for every PPT oracle machine A that is not allowed to restart
or rewind the oracle it has access to, every polynomial g(n), exists a probabilistic
simulator S(i, x) with running time bounded by nO(σ(n)) such that the following
two ensembles are computationally indistinguishable (when the distinguishing gap
is a function in n)
– {AP (x1 ,y1 ),P (x2 ,y2 ),..P (xg(n) ,yg(n) ) (z, x1 , x2 , .., xg(n) )}z∈{0,1}∗ ,x1 ,x2 ,..,xg(n) ∈L for
arbitrary yi ∈ RL (xi )
– {AS(1,x1 ),S(2,x2 ),..S(g(n),xg(n) ) (z, x1 , x2 , .., xg(n) )}z∈{0,1}∗ ,x1 ,x2 ,..,xg(n) ∈L
We end this section by noting that the notion of strongly simulatable proof
(and also perfectly simulatable proofs) is more robust than that of simply simulatable proofs, as is shown in the following useful lemma:
Lemma 1. If the interactive argument (P, V ) is straight-line nO(σ(n)) -strongly
simulatable (or perfectly simulatable), then it is also straight-line concurrent
nO(σ(n)) -strongly simulatable (or perfectly simulatable).
Proof. Let S be the straight-line simulator for (P, V ). Then by a standard hybrid argument [26] it follows that S (i, x) = S(x) is a straight-line concurrent
nO(σ(n)) -strong simulator for (P, V ).
3

This is not true for simply npoly(logn) -simulatable arguments.

Simulation in Quasi-Polynomial Time

169

We note that the same proof can not be applied in the case of simply simulatable
proofs, as the simulators in the hybrid argument will cause the distinguisher to
run in time nO(σ(n)) .
3.2

Extraction

Analogously, we extend the deﬁnition of proofs of knowledge to nO(σ(n)) -witness
extractable interactive proofs:
Deﬁnition 9. We say that an interactive proof (or argument) with negligible
soundness (P, V ) for the language L ∈ N P, with the witness relation RL ,
is nO(σ(n)) -witness extractable if there for every PPT machine P ∗ exists a
probabilistic witness extractor oracle machine E with running time bounded by
∗
nO(σ(n)) , such that for all x ∈ L, all y, r ∈ {0, 1}∗ , if Px,y,r
convinces the honest
∗
veriﬁer with non-negligible probability on common input x, E Px,y,r (x) ∈ RL (x)
∗
with overwhelming probability, where Px,y,r
denotes the machine P ∗ with common input ﬁxed to x, auxiliary input ﬁxed to y and random tape ﬁxed to r.
∗

Notation: As in the literature, E P signiﬁes the machine E given oracle access
to the machine P ∗ .
We say that an interactive proof with negligible soundness (P, V ) for the
language L ∈ N P, with the witness relation RL , is straight-line nO(σ(n)) -witness
extractable if the extractor ﬁnds a witness without rewinding the prover. In
analogy with straight-line simulation, we here note that a straight-line extractor
machine is, in fact, a cheating veriﬁer running in time nO(σ(n)) instead of in
polynomial time.
We will, in the following, also be needing nO(σ(n)) -extractable commitment
schemes, i.e. commitment scheme where an extractor running in time nO(σ(n))
can extract the committed value. For simplicity we only state the deﬁnition for
one-round commitment schemes.
Deﬁnition 10. Let a PPT committer C commit to a string using a noninteractive commitment scheme, sending c to the receiver, where |c| = poly(n).
We say that the non-interactive commitment scheme is nO(σ(n)) -extractable if
there exists a probabilistic extractor machine E with running time bounded by
nO(σ(n)) , such that for all c, if C succeeds in decommiting to x with non-negligible
probability, then E(c) = x with overwhelming probability.

4

Applications to General Composition of Protocols

In this section we show our main theorem regarding the use of straight-line
concurrent npoly(logn) -simulatable interactive arguments. This section formalizes
and extends some of the intuition described in the motivation. Very loosely
speaking the theorem states that when proving the security of a ﬁxed protocol,
straight-line concurrent npoly(logn) -simulatable interactive arguments can be used
as sub-protocols to provide security under concurrent, and man-in-the-middle
attacks.

170

R. Pass

Suppose that we have a cryptographic system (an environment) that an adversary is trying to break. Suppose further that we are able to prove that a
stand-alone adversary will not be able to break the system. We say that such an
environment is hard. A central problem in cryptography is to guarantee that an
adversary that is participating in other protocol executions simultaneously will
still not be able to break the system.
Naively, one could expect that an adversary participating as a veriﬁer of zeroknowledge proofs should not be able to break an environment that he is not able
to break stand-alone. It is, however, known that the deﬁnition of zero-knowledge
only guarantees security under sequential composition [22].
In fact, it is quite easy to see the problem can not be resolved in its most
general form. Consider the environment consisting of the veriﬁer of an interactive
proof of knowledge for a hard-instance language. A stand-alone adversary that
does not have a witness will not be able to succeed with such an environment.
However, the man-in-the-middle adversary that simultaneously is participating
as a veriﬁer in a diﬀerent execution of the same interactive proof will, by simply
forwarding messages between the environment and the prover it is communicating with, succeed in breaking the environment.
Thus, in order to give a solution to the problem it is inevitable to, in some
way, put restrictions on the environment. Recently a solution was proposed in
[7] by resorting to the Common Reference String (CRS) model. The solution
implicitly restricts the environments to those where CRS string are not reused.
See [30] for further discussion. We here, instead, show that this problem can be
resolved in the plain model, if restricting the environments to only those that
are hard against nO(σ(n)) -adversaries.
We start by deﬁning the notion of an environment. We see an environment
as a system that an adversary is trying to break. The environment outputs 1 if
the adversary succeeds and 0 otherwise. Intuitively, we say that an environment
is hard if an adversary can not make the environment output 1, i.e. break the
system. More formally,
Deﬁnition 11. We say that an interactive PPT machine E, called environment, is hard for the language L and the generator GenL against nO(σ(n)) adversaries, if for all interactive probabilistic machine A with running time
bounded by nO(σ(n)) , every z ∈ {0, 1}poly(n)
P r[x ← GenL , A (z), E (x) = 1]
is negligible as a function of n, where GenL is a machine that chooses an element
x ∈ L ∩ {0, 1}n according to some distribution.
Our composition theorem now, informally, states that a PPT adversary, that
is allowed concurrent access to diﬀerent provers, communicating using straightline concurrent nO(σ(n)) -simulatable interactive arguments, and an environment,
will not be able to succeed in an attack against the environment if the environment is hard against nO(σ(n)) adversaries. We note that since the environment is
a polynomial time machine, it is enough that the arguments that the adversary is

Simulation in Quasi-Polynomial Time

171

allowed to participate in are simply simulatable and not strongly simulatable, i.e.
that the simulator’s output only is indistinguishable in polynomial time instead
of in time nO(σ(n)) . More formally,
Theorem 2. Let Π be a straight-line concurrent nO(σ(n)) -simulatable interactive argument for the language L, such that σ(n) ∈ ω(1). Let p(n) be a polynomial, GenL p(n) be a generator for (L ∩ {0, 1}n )p(n) , i.e. a machine that chooses
an element (x1 , x2 , ..xp(n) ) ∈ (L ∩ {0, 1}n )p(n) according to some distribution,
such that the environment E is hard for the language Lp(n) and the generator
GenLp(n) against nO(σ(n)) -adversaries. Let P (x) be the honest prover in Π for
x ∈ L. Now let the adversary A be a PPT oracle machine that can not restart
or rewind the oracle it gets access to. Then for all z ∈ {0, 1}poly(n) ,
P r[¯
x = (x1 , x2 , .., xp(n) ) ← GenLp (n) , yi ∈ RL (xi ),
x) = 1]
AP (x1 ,y1 ),P (x2 ,y2 ),..P (xg(n) ,yg(n) ) (z), E (¯
is negligible.
Informally, the theorem follows from the fact that a straight-line simulator is a
cheating prover running in time nO(σ(n)) . If a man-in-the-middle attacker succeeds with a speciﬁc environment, then the attacker with access to the straightline simulator running in time nO(σ(n)) , instead of a real prover, would succeed
as well. See the full version of the paper for a formal proof.
The theorem shows that straight-line nO(σ(n) -simulation is a suﬃcient condition for security when integrating a sub-protocol in an environment that is hard
against nO(σ(n) -adversaries. This yields an eﬃcient way of constructing protocols
with strong security properties by the use of telescopic composition of protocols,
i.e. using protocols that are successively harder and harder. Indeed, the key to
the theorem is the fact that the interactive arguments, that are run by the adversary trying to cheat an environment, are easy against nO(σ(n)) adversaries
(since they are straight-line nO(σ(n)) -simulatable) while the environment is hard
against nO(σ(n)) adversaries.

5

A Two Round Simulatable and Extractable Argument

We combine npoly(logn) -extractable commitments with the zaps of [15] to achieve
a 2-round straight-line concurrent npoly(logn) -simulatable and straight-line
npoly(logn) -witness extractable argument for N P.
5.1

Extractable Commitments under General Assumptions

We start by showing that assuming the existence of one-to-one one-way functions against subexponential circuits, there exists npoly(logn) -extractable commitment schemes. Speciﬁcally, we construct a npoly(logn) -extractable bit commitment scheme using a modiﬁed version of Blum’s commitments scheme [4]

172

R. Pass

(using the notation of [20]). The idea behind the construction is to create commitments that are large enough to guarantee the hiding property against polynomial adversaries, but small enough for a quasi-polynomial adversary to perform
a brute-force attack and thus extracting the commitments.
The construction. Let f : {0, 1}∗ → {0, 1}∗ be a function, and let b : {0, 1}∗ →
{0, 1} be a predicate.
Commit phase
k
To commit to value v ∈ {0, 1}, the sender uniformly selects s ∈ {0, 1}log n and
sends the pair (f (s), b(s) ⊕ v).
Reveal phase
The sender reveals v and s. The receiver accepts if f (s) = α and b(s) ⊕ v = β
where (α, β) is the receiver’s view of the commit phase.
Lemma 2. Let f : {0, 1}∗ → {0, 1}∗ be a one-to-one one-way function against
subexponential circuits, and let b : {0, 1}∗ → {0, 1} be a hard-core predicate
against subexponential circuits for f , i.e. there exists a κ such that b is a hardcore
κ
against probabilistic non-uniform adversaries with running time bounded by 2n .
k
Then for k = κ1 + 1, the protocol presented constitutes a nO(log n) -extractable
bit-commitment scheme.
The proof of the lemma is given in the full version of the paper. We note that
in order to construct this, and the following protocols, the constant κ needs to
be known.
5.2

The Protocol

We are now ready to show the protocol. The protocol builds on the FeigeLapidot-Shamir construction [17], where a witness indistinguishable proof (argument) is used, in such a way that the simulator can perform the simulation
using a “fake” witness. In our case, the veriﬁer starts by sending a random
image b = f (r) through a one-to-one one-way function against subexponential
adversaries f . The prover thereafter proves that he either has a witness to the
statement x or that he has the pre-image to b. The size of b is chosen in such
a way that a polynomial time adversary will not be able to ﬁnd a pre-image
to b, but a pre-image can be found in quasi-polynomial time by performing a
brute-force attack. Now, intuitively, soundness follows from the proof of knowledge property. The simulator, on the other hand, is able to ﬁnd a pre-image and
can thus use it as a fake witness. The protocol follows:
Suppose that f is a one-to-one one-way function against adversaries running
κ
in time 2n , C is a committing machine for a commitment scheme extractable
k
in time nlog n , k = κ1 + 2k
κ . Now, consider the following protocol:
Protocol Π
k
V uniformly chooses r ∈ {0, 1}log n , B ∈ {0, 1}poly(n)

Simulation in Quasi-Polynomial Time

173

V → P: b = f (r), B
P → V: c = C(r ||w), a zap using B as randomness, showing the statement
“∃r , w s.t c = C(r ||w ) ∧ (b = f (r ) ∨ w ∈ RL (x))”.
In the full version of the paper we show that Π is a straight-line concurrent
k
O(log k n)
-simulatable, and straight-line nO(log n) -extractable argument. Thus,
n
Theorem 3. Assuming the existence of one-to-one one-way functions against
subexponential circuits, and the existence of zaps, there exist a two round interactive argument that is straight-line concurrent npoly(logn) -simulatable and straightline npoly(logn) -extractable.
Remark 1. Zaps can be constructed based on the existence of non-interactive
zero-knowledge proofs in the common random string model, which in turn can
be based on the existence of trapdoor permutations. [15]
5.3

On the Round-Complexity of Quasi-Polynomial Time
Simulatable Protocols

We do not know if there exists a one-round argument that is npoly(logn) simulatable. In a weakened random oracle model, as recently deﬁned in [29],
where the simulator is not allowed to choose the random oracle but should be
able to perform a simulation for an overwhelming part of random oracles, we
are, however, able to construct one-round expected-nω(1) -time simulatable and
extractable arguments without any further complexity assumptions by using a
protocol very similar to the moderately hard function of [16]4 . This result does
however not give us any concrete indication of the possibility of achieving a
similar result in the standard model as the two models are incomparable [8].
Changing perspective and considering proofs instead of arguments, we show
the impossibility of two-round npoly(logn) -simulatable proofs with negligible
soundness for languages that are not decidable in quasi-polynomial time:
Theorem 4. If there exist a two-round interactive proof with negligible soundness for the language L that is npoly(logn) -simulatable, then L is decidable in
quasi-polynomial time.
Proof. Recall the proof of the impossibility result for non-trivial two-round
auxiliary-input zero-knowledge of Goldreich-Oren [25]. They show how that the
simulator for the cheating veriﬁer that simply forwards its auxiliary input as its
message, can be used to decide the language. The same transformation can be
used in our setting, yielding a distinguisher running in quasi-polynomial time,
since our simulator runs in quasi-polynomial time.
We mention that the lower bound can be matched: Consider the 3-round interactive proof consisting of log 2 n parallel repetitions of the graph hamiltonicity
protocol of [5]. The protocol has both negligible soundness error, and is simulatable in quasi-polynomial time, by simple rewinding.
4

We mention that the impossibility of non-trivial one-round zero-knowledge arguments using the strengthened deﬁnition of zero-knowledge in the random oracle
model is proved in [29].

174

6

R. Pass

An Eﬃcient Perfectly Simulatable Argument

In this section we show an eﬃcient transformation from a 3-round specialsound public-coin honest-veriﬁer perfect zero-knowledge argument into a 4round straight-line npoly(logn) -perfectly simulatable argument. The protocol is
thus zero-knowledge in the on-line/oﬀ-line model. 5
On a high level, the idea behind the protocol is very similar to the protocol
described in section 5.2 with the main diﬀerence that a witness independent
argument is used instead of a witness indistinguishable argument. Since we use
4 rounds instead of 2 we are also able to construct a more eﬃcient protocol.
Let f be a one-to-one one-way function against adversaries running in time
κ
2n . Let the witness relation RL , where (x, y) ∈ RL if f (x) = y, characterize
the language L .
Let the language L ∈ N P, and k = κ1 + 1. Consider the following protocol
for proving that x ∈ L:
Protocol Π
k
V uniformly chooses r ∈ {0, 1}log n .
V → P: c = f (r)
P ↔ V: a 3-round witness independent argument of knowledge of
the statement “∃r s.t c = f (r ) ∨ x ∈ L” for the witness relation
RL∨L (c, x) = {(r , w)|r ∈ RL (c) ∨ w ∈ RL (x)}.
To implement the 3-round witness independent argument we start by noting
that honest-veriﬁer perfect zero-knowledge arguments are witness independent
[11]. It is known that every language in N P has a special-sound public-coin
honest-veriﬁer perfect zero-knowledge argument (consider for example Blum’s
proof for the Hamiltonian Cycle problem [5], using perfectly hiding commitments). We can thereafter combine the argument for L and the argument for
L using the eﬃcient OR-transformation of [11] yielding a special-sound honestveriﬁer zero-knowledge public-coin argument for L ∨ L and the witness relation
RL∨L 6 . We remark that if a speciﬁc one-way function is used, the protocol
for proving knowledge of instances in L , i.e. the knowledge of a pre-image to
f , can be implemented eﬃciently. Examples of such protocols are the GuillouQuisquater scheme [28] for the RSA function, and the Schnorr scheme [33] for
the discrete logarithm.
In the full version of the paper we show that Π is a straight-line concurrent
k
nO(log n) -perfectly simulatable argument. Thus,
5

6

The 2-round protocol presented earlier is not zero-knowledge in the on-line/oﬀ-line
model, since a witness to the statement proved can be straight-line extracted in
quasi-polynomial time.
Since the transformation in [11] uses that the second messages of the two protocols
have the same length, we need to run several parallel versions of the protocol for L .
The resulting argument then uses less communication than the the argument for L
plus the (parallelized) argument for L .

Simulation in Quasi-Polynomial Time

175

Theorem 5. Assuming the existence of one-to-one one-way functions against
subexponential circuits, and the existence of perfectly hiding commitments, there
exist a four round interactive argument of knowledge that is straight-line concurrent npoly(logn) -perfectly simulatable.
Remark 2. Perfectly hiding commitments can be constructed based on claw-free
collections [21].

7

Extensions

If assuming one-to-one one-way functions against exponential circuits, our protocols can be modiﬁed in a straight-forward way to become nω(1) -simulatable.
In fact, if assuming provers that are computationally bounded below a speciﬁc
polynomial f (n), then our protocols can be modiﬁed to become simulatable in
time g(n), where g(n) > f (n) is another polynomial. It would be interesting to
extend this analysis to exact security.
Acknowledgments. I wish to thank Johan H˚
astad for his invaluable help and
comments. Special thanks to Boaz Barak for suggesting the use of complexity
leveraging in a similar way to [9] to achieve 2 round protocols. I am also very
grateful to Alon Rosen for helpful comments. Finally, I would like to thank the
anonymous referees.

References
1. Boaz Barak, “How to Go Beyond the Black-Box Simulation Barrier”, 42nd FOCS,
pp. 106–115, 2001
2. Boaz Barak, Yehuda Lindell “Strict polynomial-time in simulation and extraction”,
34th STOC, pp. 484–493, 2002
3. Dan Boneh, Moni Naor, “Timed Commitments”, Crypto00, Springer LNCS 1880,
pp. 236–254, 2000
4. Manuel Blum, “Coin Flipping by Telephone”, Crypto81, ECE Report 82-04, ECE
Dept., UCSB, pp. 11–15, 1982
5. M. Blum, “How to prove a theorem so no one else can claim it”, Proc. of the
International Congress of Mathematicians, pp. 1444–1451, 1986
6. Ran Canetti, “Universally Composable Security: A New Paradigm for Cryptographic Protocols”, 42nd FOCS, pp. 136–145, 2001
7. Ran Canetti, Marc Fischlin, “Universally Composable Commitments”, Crypto01,
Springer LNCS 2139, pp. 19–40, 2001
8. Ran Canetti, Oded Goldreich, Shai Halevi, “The Random Oracle Methodology,
Revisited (Preliminary Version)”, 30th STOC, pp. 209–218, 1998
9. R. Canetti, O. Goldreich, S. Goldwasser and S. Micali, “Resettable ZeroKnowledge”, 32nd STOC, pp. 235–244, 2000
10. Ran Canetti, Joe Kilian, Erez Petrank, Alon Rosen, “Black-box concurrent zeroknowledge requires Omega (log n) rounds”, 33rd STOC, pp. 570–579, 2001

176

R. Pass

11. Ronald Cramer, Ivan Damg˚
ard, Berry Schoenmakers, “Proofs of Partial Knowledge
and Simpliﬁed Design of Witness Hiding Protocols”, Crypto94, Springer LNCS 839,
pp. 174–187, 1994
12. Y. Damg˚
ard, “Eﬃcient Concurrent Zero-Knowledge in the Auxilliary String
Model”, EuroCrypt00, Springer LNCS 1807, pp 418–430, 2000
13. Cynthia Dwork, Larry J. Stockmeyer, “2-round zero knowledge and proof auditors”, 34th STOC, pp 322–331, 2002
14. C. Dwork, M. Naor, A. Sahai, “Concurrent zero-knowledge ”, 30th STOC pp.
409–418, 1998
15. Cynthia Dwork, Moni Naor, “Zaps and Their Applications”, 40th FOCS, pp. 283–
293, 2000
16. Cynthia Dwork, Moni Naor, “Pricing via Processing or Combatting Junk Mail”,
Crypto92, Springer LNCS 740, pp. 139–147, 1992
17. U. Feige, D. Lapidot, A. Shamir, “Multiple Noninteractive Zero Knowledge Proofs
under General Assumptions”, Siam J. Comput. 29(1), pp. 1–28, 1999
18. Uriel Feige, Adi Shamir, “Zero Knowledge Proofs of Knowledge in Two Rounds”,
Crypto89, Springer LNCS 435, pp. 526–544, 1989
19. Uriel Feige, Adi Shamir, “Witness Indistinguishable and Witness Hiding Protocols”, 22nd STOC, pp. 416–426, 1990
20. O. Goldreich, “Foundations of Cryptography”, Cambridge University Press, 2001
21. Oded Goldreich, Ariel Kahan, “How to Construct Constant-Round ZeroKnowledge Proof Systems for NP”, Jour. of Cryptology 9(3), pp. 167–190, 1996
22. Oded Goldreich, Hugo Krawczyk, “On the Composition of Zero-Knowledge Proof
Systems”, SIAM J. Comput. 25(1), pp. 169–192, 1996
23. Oded Goldreich, Leonid A. Levin, “A Hard-Core Predicate for all One-Way Functions”, 21st STOC, pp. 25–32, 1989
24. Oded Goldreich, Silvio Micali, Avi Wigderson, “Proofs that Yield Nothing But
Their Validity or All Languages in NP Have Zero-Knowledge Proof Systems”,
JACM 38(3), pp. 691–729, 1991
25. Oded Goldreich, Yair Oren, “Deﬁnitions and Properties of Zero-Knowledge Proof
Systems”, Jour. of Cryptology 7(1), pp. 1–32, 1994
26. Shaﬁ Goldwasser, Silvio Micali, “Probabilistic Encryption”, JCSS 28(2), pp. 270–
299, 1984
27. Shaﬁ Goldwasser, Silvio Micali, Charles Rackoﬀ, “The Knowledge Complexity of
Interactive Proof Systems”, SIAM J. Comput. 18(1), pp. 186–208, 1989. Preliminary version in STOC 1985. Earlier versions date to 1982.
28. Louis C. Guillou, Jean-Jacques Quisquater, “A Practical Zero-Knowledge Protocol
Fitted to Security Microprocessor Minimizing Both Trasmission and Memory”,
EuroCrypt88, Springer LNCS 330, pp. 123–128, 1988
29. Rafael Pass, “How to Use Random Oracles Properly”, Submitted.
30. Rafael Pass, “On the Limits of the Common Reference String Model, and Implications on Universal Composability”, Submitted.
31. Charles Rackoﬀ, Daniel R. Simon, “Non-Interactive Zero-Knowledge Proof of
Knowledge and Chosen Ciphertext Attack”, Crypto91, Springer LNCS 576, pp.
433–444, 1991
32. Ransom Richardson, Joe Kilian, “On the Concurrent Composition of ZeroKnowledge Proofs”, EuroCrypt99, Springer LNCS 1592 , pp. 415–431, 1999
33. C.P. Schnorr, “Eﬃcient Identiﬁcation and Signatures for Smart Cards”, Crypto89,
Springer LNCS 435, pp. 235–251, 1989

