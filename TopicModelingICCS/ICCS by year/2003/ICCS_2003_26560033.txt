A Toolbox for Cryptanalysis: Linear and Aﬃne
Equivalence Algorithms
Alex Biryukov, Christophe De Canni`ere , An Braeken , and Bart Preneel
Katholieke Universiteit Leuven, Dept. ESAT/SCD-COSIC,
Kasteelpark Arenberg 10,
B–3001 Leuven-Heverlee, Belgium
{alex.biryukov, christophe.decanniere,
an.braeken, bart.preneel}@esat.kuleuven.ac.be

Abstract. This paper presents two algorithms for solving the linear
and the aﬃne equivalence problem for arbitrary permutations (S-boxes).
For a pair of n × n-bit permutations the complexity of the linear
equivalence algorithm (LE) is O(n3 2n ). The aﬃne equivalence algorithm
(AE) has complexity O(n3 22n ). The algorithms are eﬃcient and allow to
study linear and aﬃne equivalences for bijective S-boxes of all popular
sizes (LE is eﬃcient up to n ≤ 32). Using these tools new equivalent
representations are found for a variety of ciphers: Rijndael, DES,
Camellia, Serpent, Misty, Kasumi, Khazad, etc. The algorithms are
furthermore extended for the case of non-bijective n to m-bit S-boxes
with a small value of |n − m| and for the case of almost equivalent
S-boxes. The algorithms also provide new attacks on a generalized
Even-Mansour scheme. Finally, the paper deﬁnes a new problem of
S-box decomposition in terms of Substitution Permutations Networks
(SPN) with layers of smaller S-boxes. Simple information-theoretic
bounds are proved for such decompositions.
Keywords: Linear, aﬃne equivalence algorithm, S-boxes, Block-ciphers,
Rijndael, DES, Cryptanalysis, Algebraic attacks, S-box decomposition,
Side-channel attacks.

1

Introduction

In this paper we study invariant properties of permutations (S-boxes) under the
action of groups of linear or aﬃne mappings. By using a cryptanalytic approach
to this problem we provide eﬃcient algorithms for detecting linear and aﬃne
equivalences. Linear/aﬃne equivalence problems are of interest in various areas
of mathematics. It is also a natural problem for a cryptanalyst/cipher designer
The work described in this paper has been supported in part by the Commission of
the European Communities through the IST Programme under Contract IST-199912324 and by the Concerted Research Action (GOA) Meﬁsto.
F.W.O. Research Assistant, sponsored by the Fund for Scientiﬁc Research – Flanders
(Belgium).
E. Biham (Ed.): EUROCRYPT 2003, LNCS 2656, pp. 33–50, 2003.
c International Association for Cryptologic Research 2003

34

A. Biryukov et al.

to look at, since basic properties of S-boxes, such as diﬀerential [7] and linear
properties [20] are invariant under these transformations. An eﬃcient algorithmic tool allows to study the properties of a whole equivalence class by analyzing
a single representative. Further motivations to study this problem are: deeper
understanding of Rijndael (AES) [13] – a block cipher with nice algebraic structure; recent interest in potential algebraic attacks [10,22]; and the discovery of a
variety of equivalent representations for the AES [4,15] and other ciphers. Such
representations help to describe ciphers with simpler systems of low-degree equations, allow more eﬃcient implementations, and are very useful in the design of
countermeasures against side-channel attacks. These problems show that it is
essential to have a toolbox of generic algebraic algorithms for the analysis and
design of block ciphers. This paper makes one step in this direction.
We provide algorithms that can quickly test if two S-boxes S1 and S2 are
equivalent, i.e., if there exist (linear or aﬃne) mappings A1 , A2 such that A2 ◦S1 ◦
A1 = S2 . The complexity of our linear equivalence algorithm (LE) is O(n3 2n ),
and the aﬃne equivalence algorithm (AE) has complexity O(n3 22n ). Within
these complexities, both algorithms will either return the mappings A1 and A2 ,
2
or detect that the S-boxes are inequivalent. This should be compared with O(2n )
for a naive algorithm that guesses one of the mappings. We solve the aﬃne
equivalence problem by ﬁnding unique representatives for the linear equivalence
classes – a method of interest in itself. The eﬃciency of the given algorithms
allows to ﬁnd linear equivalences for n up to 32 and aﬃne equivalences for n up
to 17, which covers most of the S-boxes used in modern symmetric primitives
and allows to study partial functions composed of several S-boxes and portions
of the mixing layers. We extend our results for the case of non-bijective S-boxes
with n input bits and m output bits when the input/output deﬁciency |n − m|
is small. Another interesting extension is the search for almost equivalent Sboxes, which is as eﬃcient as the basic algorithms. This tool will be of interest
to the cryptanalyst/cipher designer since it allows to check quickly if a certain
S-box is close to the set of aﬃne functions or if two S-boxes, one with unknown
structure and the other with known algebraic structure are almost equivalent.
This approach induces an interesting metric in the space of aﬃne equivalence
classes of S-boxes.
Using our toolbox of algorithms we ﬁnd that many S-boxes of popular ciphers
are self-aﬃne equivalent, which allows to produce equivalent representations of
these ciphers. Among the examples are: AES (for which we show more non-trivial
dual ciphers than in “The Book of Rijndaels” [4]), DES, Serpent, Misty, Kasumi,
Khazad, etc. We also compare the original S-boxes of DES and the strengthened
set S 5 DES [18]. It is easy to observe that there is much less variety in the set of
classes of the more recent S-boxes, which is a consequence of the introduction of
additional design criteria.
We also show that our algorithms can be viewed as attack algorithms against
a generalized Even-Mansour scheme (with secret aﬃne mappings instead of
XORs of constant secret keys). Finally we introduce a new S-box decomposition
problem: the problem of ﬁnding SPNs with layers of smaller S-boxes equivalent

A Toolbox for Cryptanalysis: Linear and Aﬃne Equivalence Algorithms

35

to a single large S-box. This problem is natural in the context of algebraic attacks on ciphers and also in the context of eﬃcient hardware implementations
for large lookup tables. We show simple lower bounds for this S-box decomposition problem. For 8-bit S-boxes the bound is 20 layers of 4-bit S-box SPNs,
which may imply that 8-bit S-boxes are too small to withstand potential algebraic attacks [10]. Exactly how relevant the algebraic attacks are and whether
suboptimal S-box decomposition algorithms exist is a matter of future research.
This paper is organized as follows: in Sect. 2 and 3 we describe our linear
equivalence and aﬃne equivalence algorithms. In Sect. 4 we describe extensions
of these algorithms to non-bijective S-boxes and to almost-equivalent S-boxes.
In Sect. 5 we discuss self-equivalences found in S-boxes of various ciphers and
corresponding equivalent representations of AES, DES, Camellia, Serpent, Misty,
Kasumi and Khazad. In Sect. 6 we apply our algorithms to a generalized EvenMansour scheme. Sect. 7 provides a few results on the S-box decomposition
problem. Finally Sect. 8 summarizes the paper.

2

The Linear Equivalence Algorithm (LE)

In this section we provide an eﬃcient algorithm for solving the linear equivalence
problem for n × n-bit S-boxes. Here and in the rest of this paper, by linear
mapping we mean a mapping L(x) over GF (2)n that satisﬁes L(x + y) = L(x) +
L(y). It will be useful to think of L as an n × n matrix. A mapping is called
aﬃne if it can be written as A(x) = L(x) + c with some constant c ∈ GF (2)n .
The algorithms we will describe can be generalized to arbitrary ﬁelds. Note that
the algorithm in this section is very similar to the “to and fro” algorithm used
to solve the polynomial isomorphism problem for systems of quadratic equations
in [23]. This fact was pointed out to us by an anonymous referee.
Let us consider the problem of checking linear equivalence between two permutations (S-boxes) S1 and S2 . The problem is to ﬁnd two invertible linear
mappings L1 and L2 , such that L2 ◦ S1 ◦ L1 = S2 . A naive approach would
be to guess one of the mappings, for example L1 . Then one can extract L2
−1
from the equation: L2 = S2 ◦ L−1
1 ◦ S1 , and check if it is a linear, invertible
2
mapping. There are O(2n ) choices of invertible linear mappings over n-bit vectors. For each guess one will need about n3 steps to check for linearity and
invertibility using Gaussian elimination. For large n we could beneﬁt from the
asymptotically faster Coppersmith-Winograd’s method [11] of O(n2.376 ). However, for n ≤ 32, which is of main practical interest, we can use 32-bit processor
instructions to bring the complexity to n2 steps. In total the naive algorithm
2
would require O(n3 2n ) steps (a similar naive aﬃne equivalence algorithm will
use O(n3 2n(n+1) )). For n = 6 this approach will require about 244 steps.
Improving the naive approach is easy: we need only n equations in order
to check L2 for invertibility and linearity. If one guesses only log2 n vectors
from L1 one may span a space of n points (by trying all linear combinations
of the guessed vectors), evaluate the results through L1 , S1 and S2 and have n
constraints required to check for linearity of L2 . If the n new equations are not

36

A. Biryukov et al.

independent one will need to guess additional vectors of L1 . Such an algorithm
would require guessing of n log2 n bits of L1 and the total complexity would be
O(n3 2n log n ). Below we will show a much more eﬃcient algorithm, which stays
feasible for much higher values of n (up to n = 32).
Another natural approach to the linear equivalence problem would be to
follow a reduction from a Boolean linear equivalence problem. Recently a new
heuristic algorithm for the Boolean equivalence problem was described by Fuller
and Millan in [15]. They propose an algorithm based on the distribution of
the Walsh-Hadamard transform and the autocorrelation. The complexity of this
algorithm is roughly nn , which is already a higher complexity than for the algorithms we present in this paper. Trying to adapt Fuller-Millan’s approach, one
might decide to build diﬀerence distribution [7] (or linear approximation [20])
tables for the two S-boxes and to match the frequencies between the tables after
applying small changes to the S-boxes. However, the construction of a diﬀerence distribution table for a n × n-bit S-box requires O(22n ) steps and memory;
creating a linear approximation table takes O(n22n ) steps and O(22n ) memory.
Thus an algorithm using frequencies in such tables seems to be lower bounded by
O(22n ) steps. Note that for strong ciphers frequency proﬁles in such tables are
artiﬁcially ﬂattened, which will make any such algorithm even harder to apply.
2.1

Our Linear Equivalence Algorithm

In our algorithm we exploit two ideas. The ﬁrst one we call a needlework eﬀect in
which guesses of portions from L1 provide us with free knowledge of the values of
L2 . These new values from L2 allow us to extract new free information about L1 ,
etc. This process is supported by a second observation, which we call exponential
ampliﬁcation of guesses, which happens due to the linear (aﬃne) structure of the
mappings. The idea is that knowing k vectors from the mapping L1 , we know
2k linear combinations of these vectors for free. Now we are ready to describe
our algorithm.
In the description we use the following notation: the linear mappings L1 and
L2 will be denoted by A and B −1 respectively. The sets CA , CB are the sets of
checked points for which the mapping (A or B respectively) is known. By construction, these sets will also contain all the linear combinations of known points.
The sets UA , UB are the sets of yet unknown points. The sets NA , NB describe
all the new points for which we know the mapping (either A or B, respectively),
but which are linearly independent from points of CA or CB , respectively. The
sets C, N and U are always disjoint. We introduce the following natural notation
for operations on sets:
F (W ) = {F (x) | x ∈ W }
W ⊕ c = {x ⊕ c | x ∈ W } .

(1)
(2)

Starting with the empty sets CA , CB (no points known), and the complete unknown sets UA , UB , we make initial guesses for the value A(x) for some point x,
and place it into NA . Usually two guesses would be suﬃcient in order to start

A Toolbox for Cryptanalysis: Linear and Aﬃne Equivalence Algorithms

37

the exponential ampliﬁcation process. However we can do better if S1 (0) = 0
and thus S2 (0) = 01 . In such a case we can add the value of 0 to both NA
and NB . Using the fact that A(0) = B(0) = 0 we can start with less initial
guessing, which saves us a factor of 2n in complexity. The algorithm follows the
implications of the initial guess until we have enough vectors for A or B to either reach a contradiction or have n independent vectors completely deﬁning the
mapping. If we obtain a mapping that is either non-invertible or non-linear, we
reject the incorrect guess. Otherwise we check all the points of both mappings
to avoid degenerate cases of “almost” aﬃne mappings (we exploit this feature
in Sect. 4.3).
Linear Equivalence (LE)
UA ⇐ {0, 1}n ; UB ⇐ {0, 1}n
NA ⇐ ∅; NB ⇐ ∅
CA ⇐ ∅; CB ⇐ ∅
while (UA = ∅ and UB = ∅) or (All guesses rejected) do
if NA = ∅ and NB = ∅ then
If previous guess rejected, restore CA , CB , UA , UB .
Guess A(x) for some x ∈ UA
Set NA ⇐ {x}, UA ⇐ UA \ {x}
end if
while NA = ∅ do
Pick x ∈ NA ; NA ⇐ NA \ {x}; NB ⇐ S2 (x ⊕ CA ) \ CB
CA ⇐ CA ∪ (x ⊕ CA )
if |NB | + log2 |CB | > const · n then
if B is invertible linear mapping then
Derive A and check A, B at all points, that are still left in UA and UB .
else
Reject latest guess; NA ⇐ ∅; NB ⇐ ∅
end if
end if
end while
while NB = ∅ do
Pick y ∈ NB ; NB ⇐ NB \ {y}; NA ⇐ S2 −1 (y ⊕ CB ) \ CA
CB ⇐ CB ∪ (y ⊕ CB )
if |NB | + log2 |CB | > const · n then
if A is invertible linear mapping then
Derive B and check A, B at all points, that are still left in UA and UB .
else
Reject latest guess; NA ⇐ ∅; NB ⇐ ∅
end if
end if
end while
UA ⇐ UA \ CA ; UB ⇐ UB \ CB
end while
1

If one S-box maps zero to zero and the other does not, they cannot be linearly
equivalent.

38

A. Biryukov et al.

Fig. 1. The relations between the diﬀerent sets for the LE algorithm.

The complexity of this approach is about n3 · 2n steps (for S-boxes that do
not map zero to zero, and n3 · 22n otherwise). In practice our algorithms are
faster by taking into account 32-bit operations, which reduce the complexity to
O(n2 2n ) as long as n ≤ 32. For 8-bit S-boxes it is about 214 steps. For 16-bit
S-boxes it is 224 steps. Table 2 in Appendix A lists the complexities for n ≤ 32.

3

The Aﬃne Equivalence Algorithm (AE)

In this section we generalize the equivalence problem to the aﬃne case. This
time we want an algorithm that takes two n × n-bit S-boxes S1 and S2 as input,
and checks whether there exists a pair of invertible aﬃne mappings A1 and A2
such that A2 ◦ S1 ◦ A1 = S2 . Each of these aﬃne mappings can be expressed as
a linear transform followed by an addition, which allows us to rewrite the aﬃne
equivalence relation as B −1 S1 (A · x ⊕ a) ⊕ b = S2 (x) , ∀x ∈ {0, 1}n with A and
B invertible n × n-bit linear mappings and with n-bit constants a and b.
3.1

Basic Algorithm

As the problem is very similar to the linear equivalence problem, it seems natural
to try to reuse the linear algorithm described above. A straightforward solution
would be:
for all a do
for all b do
check whether S1 (x ⊕ a) and S2 (x) ⊕ b are linearly equivalent
end for
end for
This approach adds a factor 22n to the complexity of the linear algorithm, bringing the total to O(n3 23n ). This algorithm is rather ineﬃcient as the linear equivalence needs to be checked for each pair (a, b).2 In a second approach, we try
2

Another solution is to avoid guessing the constants by considering linear combinations consisting of only an odd number of points. We need three guesses to initiate
this process, hence the total complexity is the same.

A Toolbox for Cryptanalysis: Linear and Aﬃne Equivalence Algorithms

39

to avoid this by assigning a unique representative to each linear equivalence
class. Indeed, if we ﬁnd an eﬃcient method to identify this representative for a
given permutation, then we can check for aﬃne equivalence using the following
algorithm:
for all a do
insert the representative of the lin. equiv. class of S1 (x ⊕ a) in a table T1
end for
for all b do
insert the representative of the lin. equiv. class of S2 (x) ⊕ b in a table T2
end for
if T1 ∩ T2 = ∅ then
conclude that S1 and S2 are aﬃne equivalent
end if
The complexity of this second algorithm is about 2n times the work needed
for ﬁnding the linear representative. If the latter requires less than O(n3 22n ),
then the second approach will outperform the ﬁrst. Next, we present an algorithm
that constructs the representative in O(n3 2n ). As a result, the total complexity
of ﬁnding aﬃne equivalences is brought down to O(n3 22n ). Table 2 shows these
complexities for values of n ≤ 32. The same complexity estimation holds for the
case of inequivalent S-boxes.
An additional interesting property of this approach is that it can eﬃciently
solve the problem of ﬁnding mutual equivalences in a large set of S-boxes. Due
to the fact that the main part of the computation is performed separately for
each S-box, the complexity will grow only linearly with the number of S-boxes
(and not with the number of possible pairs).

3.2

Finding the Linear Representative

The eﬃciency of an algorithm that ﬁnds the linear representative RS for an
S-box S depends on how this unique representative is chosen. In this paper,
we decide to deﬁne it as follows: if all S-boxes in a linear equivalence class are
ordered lexicographically according to their lookup tables, then the smallest is
called the representative of the class. With this order the smallest permutation
is the identity, and for example, permutation [0, 1, 3, 4, 7, 2, 6, 5] is smaller than
the permutation [0, 2, 1, 6, 7, 4, 3, 5].
In order to construct the representative RS for the linear class containing a
given S-box S, we use an algorithm that is based on the same principles as the
algorithm in Sect. 2.1: after making an initial guess, we incrementally build the
linear mappings A and B such that RS = B −1 ◦S ◦A is as small as possible. This
is repeated and the representative RS is obtained by taking the smallest RS over
all possible guesses. When explaining the algorithm, we will refer to the same sets
CA , CB , NA , NB , UA and UB as in Sect. 2.1, but as their function throughout
the algorithm is slightly diﬀerent, we ﬁrst reformulate their deﬁnition:

40

A. Biryukov et al.

Fig. 2. The relations between the diﬀerent sets for the AE algorithm.

Sets DA and DB – values for which A or B are known respectively. As A is
a linear mapping, any linear combination of points of DA will also reside in
DA . The same is true for DB . Note that DA and DB always include 0.
Sets CA and CB – points of DA that have a corresponding point in DB and
−1
are
vice versa, i.e., S ◦ A (CA ) = B (CB ). For these values, RS and RS
known respectively.
Sets NA and NB – remaining points of DA and DB . We have that S ◦A (NA )∩
B (NB ) = ∅.
Sets UA and UB – values for which A and B can still be chosen. It is important
to note that the algorithm will update sets DA and UA in such a way that
d < u for any d ∈ DA and u ∈ UA .
The main part of the algorithm that ﬁnds a candidate RS consists in repeatedly picking the smallest input x for which RS is not known and trying to assign
it to the smallest available output y. Using the deﬁnitions above, this may be
written as:
while NA = ∅ do
pick x = mint∈NA (t) and y = mint∈UB (t)
complete B such that B(y) = S ◦ A(x) and thus RS (x) = y
update all sets according to their deﬁnitions
while NA = ∅ and NB = ∅ do
pick x = mint∈UA (t) and y = mint∈NB (t)
complete A such that A(x) = S −1 ◦ B(y) and thus RS (x) = y
update all sets according to their deﬁnitions
end while
end while
When this algorithm ﬁnishes, NA and NB are both empty. If UA and UB turn
out to be empty as well, then RS is completely deﬁned. In the opposite case, we
need to guess A for the smallest point in UA . This will add new elements to NA ,
such that we can apply the algorithm once again. To be sure to ﬁnd the smallest
representative, we must repeat this for each possible guess.
In most cases, we will only need to guess A for a single point, which means
that about 2n possibilities have to be checked. Completely deﬁning RS for a
particular guess takes about 2n steps. However, most guesses will already be

A Toolbox for Cryptanalysis: Linear and Aﬃne Equivalence Algorithms

41

rejected after having determined only slightly more than n values, because at that
point RS will usually turn out to be larger than the current smallest candidate.
Due to this, the total complexity of ﬁnding the representative is expected to be
O(n3 2n ).
We now explain how the sets are updated in the previous algorithm. We only
consider the case where NA = ∅ and x = mint∈NA (t), but the other case is
very similar. The ﬁrst step is to use the value of B(y) to derive B for all linear
combinations of y and DB . This implies that:
DB ⇐ DB ∪ (DB ⊕ y)
UB ⇐ UB \ (DB ⊕ y) .

(3)
(4)

Next, the algorithm checks whether any new point inserted in DB has a corresponding point in DA and updates CB , NB , CA and NA accordingly:
CB ⇐ CB ∪ B −1 [B (DB ⊕ y) ∩ S ◦ A (NA )] ,
NB ⇐ N B ∪ B
CA ⇐ CA ∪ A
NA ⇐ NA \ A

−1

−1

−1

[B (DB ⊕ y) \ S ◦ A (NA )] ,

(6)

−1

[B (DB ⊕ y) ∩ S ◦ A (NA )] ,

(7)

−1

[B (DB ⊕ y) ∩ S ◦ A (NA )] .

(8)

◦S
◦S

(5)

The resulting sets are depicted in dashed lines in Fig. 2.
3.3

A Diﬀerent Approach Using the Birthday Paradox

The eﬃciency gain obtained in the previous subsections is due to the fact that
the computation is split into two parts, each of which depends on a single S-box
S1 or S2 only. In this subsection, we apply the same idea in a diﬀerent way
and present a second algorithm which is directly based on the birthday method
from [23].
In order to explain the algorithm, we will denote the input and corresponding
output values of S1 by xi1 and y1i , with y1i = S1 (xi1 ). For the second S-box
S2 , we use the notations xi2 and y2i . Suppose now that we are given a set of
pairs (xi1 , y1i ) and a second set of pairs (xi2 , y2i ), and are asked to determine
whether both ordered sets are related by aﬃne transforms, i.e., xi1 = A1 (xi2 )
i
and y1i = A−1
2 (y2 ) for all i. A straightforward method would be to collect n + 1
independent equations xi1 = A1 (xi2 ), perform a Gaussian elimination in order
to recover the coeﬃcients of A1 , and verify if this transform holds for the other
values in the sets. If it does, this procedure can be repeated for A2 .
We can as well take a diﬀerent approach, however. The main observation now
is that any linear relation between diﬀerent xi1 , containing an even number of
terms, must hold for the corresponding values xi2 as well, given that xi1 = A1 (xi2 ).
This implies that we can ﬁrst derive linear relations for xi1 and xi2 separately (or
for y1i and y2i ), and then check for conﬂicts. If conﬂicts are found, we conclude
that the sets are not related by aﬃne transforms.

42

A. Biryukov et al.

This second approach allows to construct an eﬃcient probabilistic algorithm
for ﬁnding aﬃne equivalences, given that they exist. For both S1 and S2 , we start
with 23·n/2 sets of 3 random pairs (xij , yji ), with i = 1, 2, 3 and j = 1 or 2 for S1 or
S2 respectively. Out of these, two sets are likely to exist, such that xi1 = A1 (xi2 )
i
and thus y1i = A−1
2 (y2 ) for i = 1, 2, 3 (due to the birthday paradox). We will call
this a collision. If we were able to detect these collisions, we would immediately
obtain linear equations relating the coeﬃcients of A1 and A−1
2 and could start
the ampliﬁcation process described earlier. Applying the approach described in
the previous paragraph to small sets of 3 pairs would result in a lot of false
collisions, however. We therefore ﬁrst need to expand the sets. In order to do
this, we take all odd linear combinations of the values xi1 and compute their
image after applying S1 . This will yield new y1i values. We can then successively
repeat this process in backward and forward direction, until the sets have the
desired size. Note that this process assures that two expanded sets are still related
by the aﬃne transforms A1 and A2 , given that the original sets were.
The algorithm is expected to require about O(n3 · 23·n/2 ) computations. Note
that this algorithm is probabilistic (it will fail if no collisions occur), though its
success probability can easily be increased by considering a larger number of
random sets. It cannot be used to determine with certainty that two S-boxes are
not equivalent, however, and this is an important diﬀerence with the previous
deterministic algorithms. More details about this algorithm will be available in
extended version of the paper.

4

Extensions

This section presents some useful extensions of the LE and AE algorithms.
4.1

Self-Equivalent S-Boxes

The aﬃne equivalence algorithm was designed to discover equivalence relations
between diﬀerent S-boxes, but nothing prevents us from running the algorithm
for a single S-box S. In this case, the algorithm will return aﬃne mappings A1
and A2 such that A2 ◦ S ◦ A1 = S. The number of diﬀerent solutions for this
equation (denoted by s ≥ 1) can be seen as a measure for the symmetry of
the S-box. We call S-boxes that have at least one non-trivial solution (s > 1)
self-equivalent S-boxes.
4.2

Equivalence of Non-invertible S-Boxes

So far, we only considered equivalences between invertible n × n-bit S-boxes, but
similar equivalence relations exist for (non-invertible) n to m-bit S-boxes with
m < n. This leads to a natural extension of our equivalence problem: ﬁnd an
n × n-bit aﬃne mapping A1 and an m × m-bit aﬃne mapping A2 such that
A2 ◦ S1 ◦ A1 = S2 for two given n × m-bit S-boxes S1 and S2 .

A Toolbox for Cryptanalysis: Linear and Aﬃne Equivalence Algorithms

43

The main problem when trying to apply the algorithms described above in
this new situation, is that the exponential ampliﬁcation process explicitly relies
on the fact that the S-boxes are invertible. In cases where the diﬀerence n − m is
not too large, slightly adapted versions of the algorithms still appear to be very
useful, however.
The diﬀerence between the extended and the original algorithm resides in
the way information about A1 is gathered. In the original algorithm, each iteration yields a number of additional distinct points which can directly be used
to complete the aﬃne mapping A1 . This time, the S-boxes are not uniquely
invertible and the information obtained after each iteration will consist of two
unordered sets of about 2n−m values which are known to be mapped onto each
other. In order to continue, the algorithm ﬁrst needs to determine which are the
corresponding values in both sets. This can be done exhaustively if 2n−m is not
too large, say less than 8. Once the order has been guessed, 2n−m points are
obtained. Since slightly more than n points should suﬃce to reject a candidate
for the representative, one would expect that the total complexity is:
n3 · 2n · 2n−m !

n
2n−m

.

(9)

In order to test the extended algorithm, we applied it to the eight 6 × 4-bit
S-boxes of DES. The algorithm showed that no aﬃne equivalences exist between
any pair of S-boxes, with the single exception of S4 with itself. The equivalence
relation was found to be B −1 S4 (A · x ⊕ a) ⊕ b = S4 (x) with A = I and B a
simple bit permutation [4, 3, 2, 1], a = 1011112 and b = 01102 . Note that this
speciﬁc property of S4 was already discovered by Hellman et al. [17] by looking
at patterns in the lookup table.
4.3

Almost Aﬃne Equivalent S-Boxes

Another interesting problem related to equivalence is the problem of detecting
whether two S-boxes are almost equivalent. The S-boxes S1 and S2 are called
almost equivalent if there exist two aﬃne mappings A1 and A2 such that A2 ◦
S1 ◦ A1 and S2 are equal, except in a few points (e.g., two values in the lookup
table are swapped, or some ﬁxed fraction of the entries are misplaced).
A solution to this problem can be found by observing that the linear equivalence algorithm of Sect. 2.1 requires only about O(n) S-box queries to uniquely
determine the mappings A and B that correspond with a particular guess. After the mappings are discovered it is a matter of a simple consistency test to
check all the other values, however for the “almost” equivalent case we may tolerate inconsistencies up to a given fraction f of the whole space. The algorithm
should make sure that the defect points are not chosen for the construction of
the mappings. If the fraction of defect points is small, it is suﬃcient to run our
algorithm about (1 − f )−const·n times with randomized order of guesses and pick
the mappings with the minimal number of inconsistencies. For example for n = 8
and the fraction of defects 20%, one will need about 10 iterations of our basic
algorithm.

44

A. Biryukov et al.

5

Equivalent Descriptions of Various Ciphers

In this section we apply our tools to various ciphers in order to ﬁnd equivalent
descriptions.

5.1

Rijndael

When our AE tool is run for the 8-bit S-box S used in Rijndael [13], as many
as 2040 diﬀerent self-equivalence relations are revealed (see Appendix B.2). Although this number might seem surprisingly high at ﬁrst, we will show that
it can easily be explained from the special algebraic structure of the S-box of
Rijndael.
To avoid the confusion of working in GF (28 ) and GF (2)8 simultaneously,
we ﬁrst introduce the notation [a], which denotes the 8 × 8-bit matrix that
corresponds to a multiplication by a in GF (28 ). Similarly, we denote by Q the
8 × 8-bit matrix that performs the squaring3 operation in GF (28 ). Considering
the fact that the Rijndael S-box is deﬁned as S(x) = A(x−1 ) with A a ﬁxed
aﬃne mapping (not to be confused with A1 or A2 ), we can now derive a general
expression for all pairs of aﬃne mappings A1 and A2 that satisfy A2 ◦S ◦A1 = S:
A1 (x) = [a] · Qi · x ,
−i

A2 (x) = A Q

(10)
−1

· [a] · A

(x) , with 0 ≤ i < 8 and a ∈ GF (2 ) \ {0}. (11)
8

Since i takes on 8 diﬀerent values4 and there are 255 diﬀerent choices for a,
we obtain exactly 2040 diﬀerent solutions, which conﬁrms the output of the AE
algorithm.
The existence of these aﬃne self-equivalences in Rijndael implies that we can
insert an additional aﬃne layer before and after the S-boxes without aﬀecting
the cipher. Moreover, since the mixing layer of Rijndael only consists of additions
i
and multiplications with constants in GF (28 ), and since [a] · Qi · [c] = [c2 ] · [a] ·
Qi , we can easily push the input mapping A1 through the mixing layer. This
allows us to combine A1 with the output mapping of a previous layer of S-boxes,
with the plaintext, the round constants or with the key. The resulting ciphers
are generalizations5 of the eight “squares” of Rijndael, obtained in a somewhat
diﬀerent way by Barkan and Biham [4]. By modifying the ﬁeld polynomial used
in these 2040 ciphers, one should be able to expand the set of 240 dual ciphers
in The Book of Rijndaels [5] to a set of 61,200 ciphers.
Note that these ideas also apply to a large extent to other ciphers that use
S-boxes based on power functions. These include Camellia, Misty and Kasumi
(see Appendix B.2).
3
4
5

Note that this is possible since squaring is a linear operation in GF (28 ) (see also [4]).
One can easily check that Q8 = I and thus Q−i = Q8−i .
For a = 1 we obtain the 8 square ciphers constructed in [4].

A Toolbox for Cryptanalysis: Linear and Aﬃne Equivalence Algorithms

5.2

45

Other SPN Ciphers

All aﬃne equivalences in the Rijndael S-box are directly related to its simple
algebraic structure, but using our general AE tool, we can also build equivalent representations for S-boxes that are harder to analyze algebraically. Two
examples are Serpent [6] and Khazad [2].
An interesting property that is revealed by the AE algorithm is that the
set of eight S-boxes used in Serpent (see Appendix B.2) contains three pairs
of equivalent S-boxes ({S2 , S6 }, {S3 , S7 }, {S4 , S5 }) and one pair of inversely
equivalent S-boxes ({S0 , S1−1 }). Moreover, four of the S-boxes are self-equivalent.
This allows to apply speciﬁc modiﬁcations to the mixing layer and to change the
order in which the S-boxes are used, and this without aﬀecting the output of
the cipher. Notice also that the two inversely equivalent S-boxes (S0 and S1 ) are
used in consecutive rounds. The mixing layer probably prevents this property
from being exploited, however.
In the case of Khazad, both 4 × 4-bit S-boxes P and Q are found to be selfand mutually equivalent. This implies that the complete cipher can be described
using aﬃne mappings and a single non-linear 4 × 4-bit lookup table. Note that
this is not necessarily as bad as it sounds: each cipher can be described with
aﬃne mappings and a single non-linear 2 × 1-bit AND.
5.3

DES

Sect. 4.2 already mentions that one of the 6 × 4-bit S-boxes used in DES (S4 )
is self-equivalent and that no other equivalences exist. All DES S-boxes have
the special property that they can be decomposed into four 4 × 4-bit S-boxes.
Hence, it might be interesting to look for equivalences in these smaller S-boxes
as well. This time, many equivalences and self-equivalences are found (we refer
to Appendix B.1 for more details). To our knowledge these were not previously
known.

6

Application to Generalized Even-Mansour Scheme

In this section we apply our algorithms to a generalized Even-Mansour scheme.
In [14] Even and Mansour proposed the following construction: given a ﬁxed
n × n-bit pseudo-random permutation F , one adds two n-bit secret keys K1 and
K2 at the input and at the output of the scheme, i.e., C = F (K1 ⊕ P ) ⊕ K2 . The
result is provably secure against a known plaintext attack with O(2n ) steps and
a chosen plaintext attack with O(2n/2 ) steps. The chosen plaintext attack which
matches the lower bound was shown by Daemen in [12], and a known plaintext
with the same complexity was given by Biryukov and Wagner in [9].
Consider a generalized Even-Mansour scheme, in which key additions are
replaced by secret aﬃne transforms A1 , A2 , i.e., C = A2 (F (A1 (P ))). It seems
that a standard application of Daemen’s attack, or a slide-with-a-twist attack to
this cipher will not work. However a simple application of our aﬃne equivalence

46

A. Biryukov et al.

algorithm provides an attack on such a construction. Indeed, the attacker is given
two black boxes for which he has only oracle access: the box S1 that implements
the cipher S1 = A2 (F (A1 (P ))), and the box S2 that implements the pseudorandom permutation S2 = F . The attacker knows that S1 and S2 are aﬃne
equivalent, and his goal is to ﬁnd the equivalence, which is the secret key. In this
formulation it is exactly the problem that can be solved by our AE algorithm.
The complexity of this adaptive chosen plaintext/adaptive chosen ciphertext
attack is O(n3 22n ) steps. This compares very favorably to an exhaustive search
2
of O(2n ) steps.

7

Decomposition of Large S-Boxes Using Smaller S-Boxes

In this section we consider the following problem: given an n × n-bit S-box,
represent it with an SPN network of smaller m × m-bit S-boxes. How many Sbox layers of SPN one has to provide? The natural motivation for this question
is twofold: S-boxes that allow SPN-representations with few layers may allow a
simple representation as systems of low-degree equations, which in term might
be exploited by algebraic attacks or other cryptanalytic approaches. Another
obvious motivation is more eﬃcient hardware/software implementations. This
section gives a lower bound for the number of S-box layers of an SPN network
when representing an arbitrary n × n-bit S-box based on a simple counting
argument. We also show how to solve this problem for SPNs consisting of three
S-box layers separated by two aﬃne layers.
We look for representations of an n×n-bit S-box by an SPN of k smaller m×
m-bit S-boxes. We derive a relation between n, m, k, and the number l of S-box
layers of SPN, which gives us a lower bound for the number of S-box layers one
has to provide. An SPN network with l layers, each layer consisting of k parallel
m × m-bit S-boxes and an aﬃne transformation, gives rise to approximately
(2m !)k

1
k!

2m !
2m
m
m−1
2 (2 − 2
)2 · · · (2m − 1)2

k

l−1

2n (2n − 2n−1 ) · · · (2n − 1)

diﬀerent S-boxes. This number is obtained by ﬁrst taking k arbitrary m ×
m-bit S-boxes. In each of the following l − 1 rounds there are 2n (2n −
2n−1 ) · · · (2n −1) diﬀerent choices for an aﬃne transformation and approximately
2m !
22m (2m −2m−1 )2 ···(2m −1)2 diﬀerent choices for an S-box because the S-box has to
belong to a diﬀerent aﬃne equivalence class.6 If we compare this number with
the total number of n × n-bit S-boxes 2n !, we get a lower bound for the number
of S-box layers. Results for the most typical cases are shown in Table 1.
One of the conclusions that may be drawn from this table is that popular
8-bit S-boxes might be vulnerable to simple representations with 4-bit S-boxes.
6

Here we use the approximation for the number of equivalence classes, however for
small m the approximation is not valid and we used exact values, found by careful
counting of equivalence classes (see Table 5 in Appendix C).

A Toolbox for Cryptanalysis: Linear and Aﬃne Equivalence Algorithms

47

Table 1. Number of SPN layers for various choices of parameters n and m.
Original S-box size
Small S-box size
Small S-boxes
Layers of SPN

:
:
:
:

n
m
k = n/m
l

6
3
2
8

8
4
2
20

9
3
3
43

10 12 12
5
3
4
2
4
3
39 276 246

12 16 16
6
4
8
2
4
2
75 3196 285

On the other hand, 12-bit and 16-bit S-boxes look less vulnerable to S-box
decomposition.
If we know that a large S-box has the internal structure of an SPN with
three S-box layers, we can apply a very eﬃcient multiset attack described by
Biryukov and Shamir in [8] to recover the hidden structure. Such an attack uses
22m queries to the S-box and k23m steps of analysis and is very eﬃcient for all
m-bit S-boxes of practical importance. For example this approach would be able
to recover the structure of the S-boxes of Khazad [2] and Whirlpool [3] if these
S-boxes would be presented just by an 8 × 8-bit lookup table. Extension of this
approach beyond ﬁve layers is still an open problem.

8

Summary

In the view of rising interest in algebraic properties of various symmetric primitives, this paper provided several generic algorithms for the toolbox of a cryptanalyst/cipher designer. We developed very eﬃcient algorithms for detecting
linear and aﬃne equivalence of bijective S-boxes. We also studied extensions of
these algorithms for the case of non-bijective S-boxes with small input/output
deﬁciency, and to the case of checking for almost equivalence between S-boxes.
This notion of almost equivalence introduces an interesting metric over S-box
equivalence classes. We have shown that our aﬃne equivalence algorithm may be
viewed as an attack on a generalized Even-Mansour scheme with XORs replaced
by secret aﬃne mappings. We also described new equivalences found in many
popular ciphers: Rijndael, DES, Camellia, Misty, Kasumi, Khazad. Finally, we
discussed the problem of S-box decomposition into small S-box SPN (a property
of interest to some algebraic attacks and to hardware designers) and provided
simple lower bounds for this problem.
Acknowledgements. We would like to thank Jasper Scholten for his helpful
advice as well as the anonymous referees, whose comments helped to improve
this paper.

References
1. K. Aoki, T. Ichikawa, M. Kanda, M. Matsui, S. Moria, J. Nakajima, T. Tokita,
Camellia: A 128-Bit Block Cipher Suitable for Multiple Platforms – Design and
Analysis, submitted to NESSIE, 2000. Available at
http://www.cryptonessie.org.

48

A. Biryukov et al.

2. P.S.L.M. Baretto, V. Rijmen, The Khazad Legacy-Level Block Cipher, submitted
to NESSIE, 2000. Available at http://www.cryptonessie.org.
3. P.S.L.M. Baretto, V. Rijmen, The Whirlpool Hashing Function, submitted to
NESSIE, 2000. Available at http://www.cryptonessie.org.
4. E. Barkan, E. Biham, In how Many Ways Can You Write Rijndael, Proceedings
of Asiacrypt 2002, LNCS, to appear. Earlier version at IACR eprint server,
http://eprint.iacr.org/.
5. E. Barkan, E. Biham, The Book of Rijndaels, Available on IACR eprint server,
http://eprint.iacr.org/.
6. E. Biham, R.J. Anderson, L.R. Knudsen, Serpent: A New Block Cipher Proposal,
Proceedings of Fast Software Encryption’98, LNCS 1372, pp. 222–238, SpringerVerlag, 1998.
7. E. Biham, A. Shamir, Diﬀerential cryptanalysis of the Data Encryption Standard,
Springer-Verlag 1993.
8. A. Biryukov, A. Shamir, Structural Cryptanalysis of SASAS, LNCS 2045, Proceedings of Eurocrypt 2001, pp. 394–405, Springer-Verlag, 2001.
9. A. Biryukov, D. Wagner, Advanced Slide Attacks, Proceedings of Fast Software
Encryption 2000, LNCS 1807, pp. 589–606, Springer-Verlag, 2000.
10. N. Courtois, J. Pieprzyk, Cryptanalysis of Block Ciphers with Overdeﬁned Systems
of Equations, Proceedings of Asiacrypt’2002, LNCS, to appear. Earlier version at
IACR eprint server, http://eprint.iacr.org/.
11. D. Coppersmith, S. Winograd, Matrix Multiplication via Arithmetic Progressions,
Proceedings of the Nineteenth Annual ACM Symposium on Theory of Computing,
pp. 1–6, 1987.
12. J. Daemen, Limitations of the Even-Mansour Construction, Proceedings of Asiacrypt’91, LNCS 739, pp. 495–499, Springer-Verlag, 1991.
13. J. Daemen, V. Rijmen, The Design of Rijndael, Springer-Verlag, 2002.
14. S. Even, Y. Mansour, A Construction of a Cipher from a Single Pseudorandom
Permutation, Journal of Cryptology, Vol. 10, no. 3, pp. 151–161, Springer-Verlag,
1997.
15. J. Fuller, W. Millan, On linear Redundancy in the AES S-Box, Available online on
http://eprint.iacr.org/, 2002.
16. M. A. Harrison, On the Classiﬁcation of Boolean Functions by the General Linear
and Aﬃne Group, Journal of the Society for Industrial and Applied Mathematics,
Vol. 12, pp. 284–299, 1964.
17. M.E. Hellman, R. Merkle, R. Schroppel, L. Washington, W. Diﬃe, S. Pohlig,
P. Schweitzer, Results of an initial attempt to cryptanalyze the NBS Data Encryption Standard. Technical report, Stanford University, U.S.A., September 1976.
18. K. Kim, S. Lee, S. Park, D. Lee, Securing DES S-boxes Against Three Robust
Cryptanalysis, Proceedings of SAC’95, pp. 145–157, 1995.
19. C.S. Lorens, Invertible Boolean Functions, Space General Corporation Report,
1962.
20. M. Matsui, Linear Cryptanalysis Method for DES Cipher, Proceedings of Eurocrypt’93, LNCS 765, pp. 386–397, Springer-Verlag, 1993.
21. M. Matsui, New Block Encryption Algorithm MISTY, Proceedings of Fast Software
Encryption ’97, LNCS 1267, pp. 54–68, Springer-Verlag, 1997.
22. S. Murphy, J.B. Robshaw, Essential Algebraic Structure Within the AES, Proceedings of CRYPTO 2002, LNCS 2442, pp. 17–38, Springer-Verlag 2002.
23. J. Patarin, L. Goubin, N. Courtois, Improved Algorithms for Isomorphisms of Polynomials, Proceedings of Eurocrypt’98, LNCS 1403 , pp. 184–200, Springer-Verlag,
1998.

A Toolbox for Cryptanalysis: Linear and Aﬃne Equivalence Algorithms

49

Table 2. Complexities of linear and aﬃne algorithms.
Dimension
LE
AE
AE (n − m = 1)
AE (n − m = 2)
AE (n − m = 3)

A

:
:
:
:
:
:

n
n2 2n
n2 22n
n
2n n2 (2!) 2
n
n 2 2 22
2 n (2 !)
n
n 2 3 23
2 n (2 !)

4
28
212
210
213
216

5
210
215
212
215
219

6
211
217
214
218
223

7
213
220
216
221
226

8
214
222
218
223
229

9
215
224
220
226
233

10
217
227
222
228
236

12
219
231
225
233
242

16
224
240
232
242
255

24
233
257
245
261
279

32
242
274
258
279
2103

Complexities of LE and AE Algorithms

In this appendix we compute the complexities of the LE and AE algorithms
together with complexities of the AE algorithm for the non-bijective case, which
are shown in Table 2. Note that we use n2 for the complexity of the Gaussian
elimination since n ≤ 32 and we assume an eﬃcient implementation using 32-bit
operations.

B

Equivalent S-Boxes in Concrete Ciphers

In this appendix we brieﬂy discuss the aﬃne equivalences found between S-boxes
of various ciphers.
B.1

DES and S 5 DES

As mentioned in Sect. 4.2, there are no aﬃne equivalences between the 6 × 4-bit
S-boxes of DES, except for S4 . However, when each S-box is decomposed into
its four 4 × 4-bit S-boxes, then additional equivalences appear. The relations are
summarized in the extended version of the paper. The most noticeable properties
are the fact that all 4 × 4-bit S-boxes of S4 (S4,0 , S4,1 , S4,2 and S4,3 ) belong to
the same class, and that a relatively large number of S-boxes are equivalent to
their inverse.
After the introduction of DES, diﬀerent sets of alternative S-boxes have been
proposed. In 1995, Kwangjo Kim et al. suggested to use the so-called S 5 DES
S-boxes, which were designed with additional criteria in order to achieve immunity against diﬀerential, linear, and Improved Davies’ cryptanalysis. The table
showing how this inﬂuences the equivalence relations is omitted due to space
limits and can be found in the extended version of the paper. A ﬁrst conclusion
is that the new set contains considerably more equivalent 4 × 4-bit S-boxes.7 In
addition, there is a clear increase of s, the number of self-equivalences. Given the
fact that the size of an equivalence class is proportional to 1/s, we conclude that
the new design criteria considerably reduce the space from which the S-boxes or
their inverses are chosen.
7

Note that none of these S-boxes is equivalent to any of the original DES S-boxes due
to the additional design criteria.

50

A. Biryukov et al.

B.2

Serpent, Khazad, Rijndael, Camellia, Misty, and Kasumi

The aﬃne equivalences found in the 4 × 4-bit S-boxes of Serpent and Khazad
are shown in Table 3. Note that there are no equivalences between these S-boxes
and the 4 × 4-bit S-boxes of DES or S 5 DES.
Table 3. Serpent and Khazad.
Cipher
Serpent

Khazad

Members
S0 , S1−1
S0−1 , S1
S2 , S2−1 , S6 , S6−1
S3 , S3−1 , S7 , S7−1
S4 , S5
S4−1 , S5−1
P , P −1 , Q, Q−1

s
4
4
4
1
1
1
4

Table 4. Rijndael, Camellia, Misty and Kasumi.
Cipher
Rijndael/Camellia
Misty/Kasumi

Members
s
S, S −1 2040 = 8 × 255
S7
889 = 7 × 127
S9
4599 = 9 × 511

Table 5. Number of linear and aﬃne equivalence classes of permutations.
Dimension
#Lin. Eq. Classes
#Af. Eq. Classes

1
2
1

2
2
1

3
10
4

4
52,246
302

5
2,631,645,209,645,100,680,144
2,569,966,041,123,963,092

Table 4 lists the number of self-equivalences s for the 8 × 8-bit S-box of
Rijndael and the 7 × 7-bit and 9 × 9-bit S-boxes of Misty (which are aﬃne
equivalent to the ones used in Kasumi). An explanation for the large number of
self-equivalences in Rijndael is given in Sect. 5.1. A similar reasoning applies to
S7 and S9 , as both are designed to be aﬃne equivalent with a power function
over GF (27 ) and GF (29 ) respectively.

C

The Number of Equivalence Classes

Another problem related to linear and aﬃne equivalences is the problem of counting equivalence classes. This problem was solved in the 1960s by Lorens [19] and
Harrison [16] using Polya theory, by computing the cycle index polynomial of
the linear and aﬃne groups. Results were given for n ≤ 5 (see Table 5).
We implemented a similar algorithm for counting the number of equivalence
classes for larger n and veriﬁed that this number is very well approximated by
2n !/|G|2 , where |G| is the size of the linear or aﬃne group. These results were
used in Sect. 7 for the computation of Table 1: for S-box sizes 3 and 4 we used
exact values and for the larger sizes we used the approximation.

