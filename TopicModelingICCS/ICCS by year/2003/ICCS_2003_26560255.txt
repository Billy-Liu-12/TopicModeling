A Forward-Secure Public-Key Encryption
Scheme
Ran Canetti1 , Shai Halevi1 , and Jonathan Katz2
1

2

IBM T.J. Watson Research Center, Hawthorne, NY.
{canetti,shaih}@watson.ibm.com
Dept. of Computer Science, University of Maryland, College Park, MD.
jkatz@cs.umd.edu

Abstract. Cryptographic computations are often carried out on insecure devices for which the threat of key exposure represents a serious
and realistic concern. In an eﬀort to mitigate the damage caused by exposure of secret data (e.g., keys) stored on such devices, the paradigm of
forward security was introduced. In a forward-secure scheme, secret keys
are updated at regular periods of time; furthermore, exposure of a secret
key corresponding to a given time period does not enable an adversary to
“break” the scheme (in the appropriate sense) for any prior time period.
A number of constructions of forward-secure digital signature schemes,
key-exchange protocols, and symmetric-key schemes are known.
We present the ﬁrst constructions of a (non-interactive) forward-secure
public-key encryption scheme. Our main construction achieves security
against chosen plaintext attacks under the decisional bilinear DiﬃeHellman assumption in the standard model. It is practical, and all
complexity parameters grow at most logarithmically with the total
number of time periods. The scheme can also be extended to achieve
security against chosen ciphertext attacks.
Keywords: Bilinear Diﬃe-Hellman, Encryption, Forward security, Key
exposure.

1

Introduction

Exposure of secret keys can be a devastating attack on a cryptosystem since such
an attack typically implies that all security guarantees are lost. Indeed, standard
notions of security oﬀer no protection whatsoever once the secret key of the
system has been compromised. With the threat of key exposure becoming more
acute as cryptographic computations are performed more frequently on small,
unprotected, and easily-stolen devices such as smart-cards or mobile phones, new
techniques are needed to deal with this concern.
A variety of methods (including secret sharing [33], threshold cryptography
[13], and proactive cryptography [30,20]) have been introduced in an attempt
to deal with this threat. One promising approach – which we focus on here –
is to construct cryptosystems which are forward secure. This notion was ﬁrst
E. Biham (Ed.): EUROCRYPT 2003, LNCS 2656, pp. 255–271, 2003.
c International Association for Cryptologic Research 2003

256

R. Canetti, S. Halevi, and J. Katz

proposed in the context of key-exchange protocols by G¨
unther [18] and Diﬃe,
et al. [14]: a forward-secure key-exchange protocol guarantees that exposure of
long-term secret information does not compromise the security of previouslygenerated session keys. We remark that a forward-secure key-exchange protocol
naturally gives rise to a forward-secure interactive encryption scheme in which
the sender and receiver ﬁrst generate a shared key K, the sender then encrypts
his message using K, and both parties promptly erase the shared key.
Subsequently, Anderson [3] suggested forward security for the more challenging non-interactive setting. Here, as in the case of forward-secure signature
schemes (formalized by Bellare and Miner [6] and constructed there and in [26,
1,22,27,25]), the lifetime of the system is divided into N intervals (or time periods) labeled 0, . . . , N − 1. The decryptor initially stores secret key SK0 and this
secret key “evolves” with time. At the beginning of time period i, the decryptor applies some function to the “previous” key SKi−1 to derive the “current”
key SKi ; key SKi−1 is then erased and SKi is used for all secret cryptographic
operations during period i. The public encryption key remains ﬁxed throughout
the lifetime of the system; this is crucial for making such a scheme viable. A
forward-secure encryption scheme guarantees that even if an adversary learns
SKi (for some i), messages encrypted during all time periods prior to i remain
secret. (Note that since the adversary obtains all secrets existing at time i, the
model inherently cannot protect the secrecy of messages encrypted at time i and
at all subsequent time periods.)
Forward security for non-interactive, symmetric-key encryption has also been
studied [7]. However, no forward-secure (non-interactive) public-key encryption
(PKE) schemes were previously known. Forward-secure PKE has the obvious
practical advantage that a break-in to the system does not compromise the
secrecy of previously-encrypted information; it is thus appropriate for use in
devices with low security guarantees, such as mobile devices. In particular, it
provides a practical encryption mechanism that is secure against adaptive adversaries.
1.1

Our Contributions

Forward secure encryption. We rigorously deﬁne a notion of security for
forward-secure public-key encryption and also give eﬃcient constructions of
schemes satisfying this notion. We prove semantic security of one scheme in the
standard model based on the decisional version of the bilinear Diﬃe-Hellman
assumption (cf. [24,9]). All salient parameters of this scheme are logarithmic in
N , the number of time periods. We also sketch a variant of this scheme with better complexity; in particular, the public-key size and key-generation/key-update
times are all independent of N . This variant is proven semantically-secure in the
random oracle model under the computational bilinear Diﬃe-Hellman assumption. Either of our schemes may be extended so as to achieve security against
adaptive chosen-ciphertext attacks. (Recall that a proof in the random oracle
model provides no guarantee as to the security of the protocol once the random

A Forward-Secure Public-Key Encryption Scheme

257

Table 1. Summary of dependencies on the total number of time periods N .

Key generation time
Encryption/Decryption time
Key update time
Ciphertext length
Public key size
Secret key size

Standard model Random oracle model
O(log N )
O(1)
O(log N )
O(log N )
O(log N )
O(1)
O(log N )
O(log N )
O(log N )
O(1)
O(log N )
O(log N )

oracle is instantiated with an eﬃciently computable function, such as a “cryptographic hash function”, and thus can only be regarded as a heuristic argument.)
The key parameters of the two schemes are summarized in Table 1. We stress
that both schemes are eﬃcient not only in an asymptotic sense; indeed, they are
roughly as eﬃcient as log2 N invocations of the Boneh-Franklin identity-based
encryption scheme [9] and are therefore practical for reasonable values of N .
Using the techniques of Malkin, et al. [27], our schemes can be adapted to cases
where the number of time periods is not known in advance. This has the added
advantage that the eﬃciency and security of the schemes depend only on the
number of time periods elapsed thus far. We also sketch two ways to extend our
schemes to achieve security against adaptive chosen ciphertext attacks [31,15,8].
One method is based on Sahai’s construction [28,32] and works in the standard
model. The other is based on the Fujisaki-Okamoto transformation [16] and is
analyzed in the random oracle model.
Other contributions and applications. Our constructions are based on the
Gentry and Silverberg [17] construction of a hierarchical identity-based encryption (HIBE) scheme [21,17]. As a ﬁrst step towards our construction, we deﬁne
a relaxed variant of HIBE which we call binary tree encryption (BTE). We show
how to modify the Gentry-Silverberg construction to yield a BTE scheme without adding much complexity. Remarkably, the modiﬁed construction works in
the standard model and can handle trees of polynomial depth. (In contrast, the
main construction of Gentry and Silverberg is analyzed only in the random oracle
model, and only for trees of constant depth.) We then construct a forward-secure
encryption scheme from any BTE scheme. In addition, the BTE primitive may
prove interesting in its own right.
The technique that we use for achieving O(1) key generation and key update
time appears to be new, and can be used to improve the eﬃciency of the key
generation/key update steps from O(log N ) to O(1) in all known tree-based
forward-secure signature schemes [6,1,27].
Forward-secure PKE may be used to drastically improve the eﬃciency of
non-interactive adaptively secure encryption in the context of secure multi-party
protocols. In such protocols, an adaptive adversary may choose to corrupt a
player at some point in the protocol, after that player had already received several encrypted messages. Learning the player’s secret key will (in general) allow

258

R. Canetti, S. Halevi, and J. Katz

the adversary to read all past messages, thereby making it much harder to prove
any simulation-based notion of security. In all known adaptively secure noninteractive encryption schemes (e.g., [4,11,5,12]) the size of the decryption key
must exceed the total length of messages to be decrypted throughout the lifetime of the system. Furthermore, Nielsen has recently shown that this property
is essential for encryption schemes that are not key-evolving [29]. (This holds
even if the model allows data erasures.) Forward-secure encryption enables us to
circumvent this lower bound, by having each player update its (short) key after
every message. This way, an adversary who corrupts a player at some point in
the protocol will be unable to read past messages that were sent to this player,
thereby enabling a simulation-based proof of security.
Organization. In Section 2 we deﬁne and construct our underlying primitive,
BTE, and prove its security under the decisional bilinear Diﬃe-Hellman assumption (also described in that section). Then in Section 3 we deﬁne forward secure
public key encryption and show how it can be constructed from any BTE scheme.
Putting these two results together, we get a construction with the advertised security and eﬃciency parameters.

2

A Binary Tree Encryption Scheme

This section deﬁnes binary tree encryption (BTE), and presents a construction
based on the bilinear Diﬃe-Hellman assumption. As discussed in the introduction, a BTE scheme is a relaxed version of hierarchical identity-based encryption (HIBE) [21,17]. In addition to being an essential step in our construction
of forward-secure encryption, BTE may be an interesting primitive by itself. In
particular, we also show how to implement a full-blown HIBE from BTE, and
since we describe a BTE whose security can be proven in the standard model,
this also implies a secure HIBE in the standard model (albeit, with a somewhat
weaker notion of security than that considered in [17]).
As in HIBE, in BTE too we have a public key associated with a tree, and
each node in this tree has a corresponding secret key. To encrypt a message
destined for some node, one uses both the tree public key and the name of the
target node. The resulting ciphertext can then be decrypted using the secret
key of the target node. Moreover, just as in HIBE, the secret key of a node can
also be used to derive the secret keys of the children of that node. The only
diﬀerence between HIBE and BTE is that in the latter we insist that the tree
be a binary tree, where the children of a node w are labeled w0 and w1. (Recall
that in HIBE, the tree can have arbitrary degree, and a child of node w can be
labeled w.s for any arbitrary string s.) The formal functional deﬁnition follows.
Deﬁnition 1. A binary tree public-key encryption (BTE) scheme is a 4-tuple of
ppt algorithms (Gen, Der, Enc, Dec) such that:
– The key generation algorithm Gen takes as input a security parameter 1k ,
and returns a public key P K and an initial (root) secret key SKε .

A Forward-Secure Public-Key Encryption Scheme

259

– The key derivation algorithm Der takes the name of a node w ∈ {0, 1}∗ and
its associated secret key SKw , and returns the two secret keys SKw0 , SKw1
for the two children of w.
– The encryption algorithm Enc takes a public key P K, the name w of a node,
and a message m. It returns a ciphertext c.
– The decryption algorithm Dec takes as input a public key P K, a node
name w, its secret key SKw , and a ciphertext c. It returns a message m.
We make the standard correctness requirement; namely, for any (P K, SKε ) output by Gen, any node w ∈ {0, 1}∗ , and a secret key SKw correctly generated for
node w, and all m, we have m = Dec(P K, w, SKw , Enc(P K, w, m)).
The security notion that we present here for BTE is somewhat weaker than
the standard notion for HIBE, in that we require that the an attacker commits
to the node to be attacked even before seeing the public key. We call this attack
scenario selective-node attack (cf. “selective forgery” of signatures [19]). For simplicity, we formally deﬁne here only security against chosen plaintext attacks.
Security against adaptive chosen ciphertext attacks is deﬁned analogously.
Deﬁnition 2 (SN-CPA security). Let W ⊂ {0, 1}∗ be a set that is closed
under preﬁx. A BTE scheme is secure against selective-node, chosen-plaintext
attacks (SN-CPA) with respect to W if any ppt adversary succeeds in the following game with probability at most negligibly over one half:
1. The adversary generates a name w∗ ∈ W of a node in the tree.
2. Algorithm Gen(1k , N ) is run, with output (P K, SKε ), and the adversary is
given P K. In addition, the algorithm Der(· · ·) is run to generate the secret
keys of all the nodes on the path from the root to w∗ , as well as the children
of w∗ . The adversary gets the secret key SKw of any node w ∈ W such that
– either w = w b, where w b is a preﬁx of w∗ (a sibling);
– or w = w∗ 0 or w = w∗ 1 (a child).
(Note that this allows the adversary to compute SKw for any node w ∈ W
that is not a preﬁx of w∗ .)
3. The adversary generates a request challenge(m0 , m1 ). In response, a random
bit b is selected and the adversary is given c∗ = Enc(P K, w∗ , mb ).
4. The adversary outputs a guess b ∈ {0, 1}. It succeeds if b = b.
2.1

The Bilinear Diﬃe-Hellman Assumption

The security of our binary tree encryption scheme is based on the diﬃculty of the
bilinear Diﬃe-Hellman (BDH) problem as formalized by Boneh and Franklin [9]
(see also [24]). The computational version of this assumption has been used for
a number of cryptographic constructions (e.g., [23,10,34,21,17]); furthermore, as
noted in [9], the decisional version of the assumption (called the BDDH assumption there) is also believed to hold. We review the relevant deﬁnitions as they
appear in [9,17]. Let G1 and G2 be two cyclic groups of prime order q, where
G1 is represented additively and G2 is represented multiplicatively. We assume
a map eˆ : G1 × G1 → G2 for which the following hold:

260

R. Canetti, S. Halevi, and J. Katz

1. The map eˆ is bilinear ; that is, for all P0 , P1 ∈ G1 and all α, β ∈ Zq we have
eˆ(αP0 , βP1 ) = eˆ(P0 , P1 )αβ .
2. There is an eﬃcient algorithm to compute eˆ(P0 , P1 ) for any P0 , P1 ∈ G1 .
A BDH parameter generator IG is a randomized algorithm that takes a
security parameter 1k , runs in polynomial time, and outputs the description of
two groups G1 , G2 and a map eˆ satisfying the above conditions. We deﬁne the
computational BDH problem with respect to IG as the following: given (G1 , G2 , eˆ)
output by IG along with random P, αP, βP, γP ∈ G1 , compute eˆ(P, P )αβγ .
We say that IG satisﬁes the computational BDH assumption if the following is
negligible (in k) for all ppt algorithms A:
Pr

(G1 , G2 , eˆ) ← IG(1k ); P ← G1 ; α, β, γ ← Zq :
.
A(G1 , G2 , eˆ, P, αP, βP, γP ) = eˆ(P, P )αβγ

Informally speaking, the decisional BDH problem is to distinguish between
tuples of the form (P, αP, βP, γP, αβγP ) and (P, αP, βP, γP, µP ) for random
P, α, β, γ, µ. More formally, we say that IG satisﬁes the decisional BDH assumption (BDDH) if the following is negligible (in k) for all ppt algorithms
A:
Pr

(G1 , G2 , eˆ) ← IG(1k ); P ← G1 ; α, β, γ, ← Zq :
A(G1 , G2 , eˆ, P, αP, βP, γP, αβγP ) = 1

− Pr

(G1 , G2 , eˆ) ← IG(1k ); P ← G1 ; α, β, γ, µ ← Zq :
A(G1 , G2 , eˆ, P, αP, βP, γP, µP ) = 1

.

The decisional BDH assumption immediately implies that it is computationally
infeasible to distinguish between tuples of the form (P, αP, βP, γP, eˆ(P, P )αβγ )
and (P, αP, βP, γP, r) for random P, α, β, γ, r.
BDH parameter generators believed to satisfy the above assumptions can
be constructed from Weil and Tate pairings associated with super-singular elliptic curves or Abelian varieties. As our results do not depend on any speciﬁc
instantiation, we refer the interested reader to [9] for details.
2.2 A Construction
Theorem 1. There exists a BTE scheme that is secure in the sense of SN-CPA
under the BDDH assumption.
To prove Theorem 1 we describe such a BTE scheme. The starting point for
our construction is the hierarchical identity-based encryption scheme of Gentry
and Silverberg [17]. Our construction, unlike the original scheme, can be proven
secure in the standard model. (In fact, from our argument it follows that in the
random oracle model, the scheme of [17] is itself a secure BTE.) The HIBE of
Gentry and Silverberg (as well as the IBE scheme of Boneh and Franklin [9]) uses
two random oracles: one is used to derive random elements from the identities,
and the other is used to achieve CCA security of the encryption. The latter use
of the random oracle can be removed when one considers only CPA security.

A Forward-Secure Public-Key Encryption Scheme

261

Below we show that in the context of selective node security, one can replace the
ﬁrst random oracle by a fully speciﬁed “t-wise independent” hash function.
Notations and conventions. In the description below we denote the i-bit
preﬁx of a word w1 w2 . . . w by w|i . Namely, w|i = w1 . . . wi . In deﬁning our
scheme, we use a (2t + 1)-wise independent, eﬃciently sampleable family H of
functions H : {0, 1}≤t → G1 . By eﬃciently sampleable we mean that, given
elements x1 , . . . , xk ∈ {0, 1}≤t and g1 , . . . , gk ∈ G1 (with k ≤ 2t + 1), it is
possible to eﬃciently sample a random H ∈ H such that H(xi ) = gi for i =
1, . . . , k.) One possible instantiation is to let H = {Hh0 ,...,h2t (x)}h0 ,...,h2t ∈G1 ,
def

˜h1 + · · · + x
˜2t h2t and x
˜ represents
where Hh0 ,...,h2t (x) = h0 + x
≤t
one-to-one encoding of x ∈ {0, 1} as an element in Zq . Let
parameter generator for which the decisional BDH assumption
construction we need an upper bound on the height of the tree,
this bound by t. The construction is described below.
Gen(1k , t) does the following:

some standard
IG be a BDH
holds. For our
and we denote

1. Run IG(1k ) to generate groups G1 , G2 of prime order q and bilinear map eˆ.
2. Select a random generator P ∈ G1 and a random α ∈ Zq . Set Q = αP .
3. Choose a random function H ∈ H. Note that this merely requires choosing
2t + 1 random elements h0 , . . . , h2t ∈ G1 .
4. The public key is P K = (G1 , G2 , eˆ, P, Q, t, H) (where H is represented by
h0 , . . . , h2t ). The root secret key is Sε = αH(ε).
Der(P K, w, SKw ) takes as input the tree public key and the secret key associated
with node w, and outputs the secret keys for nodes w0 and w1. In general, for
w = w1 . . . w , the secret key of node w consists of + 1 group elements, SKw =
(Rw|1 , Rw|2 , . . . , Rw , Sw ). The algorithm Der(P S, w, SKw ) runs as follows:
1. Choose random ρw0 , ρw1 ∈ Zq . Set Rw0 = ρw0 P and Rw1 = ρw1 P , and also
Sw0 = Sw + ρw0 H(w0) and Sw1 = Sw + ρw1 H(w1).
2. Output SKw0 = (Rw|1 , . . . , Rw , Rw0 , Sw0 ) and SKw1 = (Rw|1 , . . . , Rw , Rw1 ,
Sw1 ).
Enc(P K, w, m) (where m ∈ G2 ) does the following:
1. Let w = w1 . . . w . Select random γ ∈ Zq .
2. Output C¯ = (γP, γH(w|1 ), γH(w|2 ), . . . , γH(w), m · d), where d = eˆ(Q,
H(ε))γ .
¯ does the following: Let w = w1 · · · w , skw = (Rw| , . . ., Rw ,
Dec(P K, w, skw , C)
1
¯
Sw ), and C = (U0 , U1 , . . . , U , v). Compute m = v/d, where
d=

eˆ(U0 , Sw )
i=1

eˆ(Rw|i , Ui )

We now verify that decryption is performed correctly. When encrypting, we
have d = eˆ(Q, H(ε))γ = eˆ(P, H(ε))αγ . When decrypting, we have U0 = γP , and
Ui = γH(w|i ) for i ≥ 1. Hence,

262

R. Canetti, S. Halevi, and J. Katz

d =

i=1

=

eˆ γP, αH(ε) +

eˆ(U0 , Sw )
eˆ(Rw|i , Ui )

eˆ(P, H(ε))αγ ·
i=1

=

i=1

γρw|i

eˆ (P, H(w|i ))

eˆ (P, H(w|i ))

ρw|i H(w|i )

eˆ ρw|i P, γH(w|i )

i=1

γρw|i

i=1

= eˆ(P, H(ε))γα

and thus decryption succeeds in recovering m. The security of this scheme is
established below.
Proposition 1. If IG satisﬁes the decisional BDH assumption, the above BTE
scheme is secure against SN-CPA.
Proof. Assume a ppt adversary A attacking the above scheme in the SN-CPA
attack scenario, and denote the probability that A succeeds by PrA [Succ]. We
construct a new adversary B which attempts to solve the decisional BDH problem with respect to IG. Relating the advantage of B to the advantage of A will
give the desired result. In the description below we denote by w|i the sibling of
w|i , namely the string consisting of the (i − 1)-bit preﬁx of w, followed by the
negations of the i’th bit. (In other words, w|i and w|i agree on their ﬁrst i − 1
bits, and diﬀer only the last bit.)
B is given the bound t, the output (G1 , G2 , eˆ) of IG, and also (P, Q =
αP, Iε = βP, U0 = γP, V = µP ), where P, α, β, γ are chosen at random,
and B’s goal is to determine if µ was also chosen at random, or was it set to
µ = αβγ. B attempts to simulate an instance of the encryption scheme for
A as follows: B initiates a run of A, waiting for A to commit to the target
node. Denote this target node by w∗ = w1∗ w2∗ . . . w∗ (with ≤ t). Next, for
i = 1 . . . min(t, + 1), B randomly chooses χi , χi , ϕi , ϕi ∈ Zq . Now, B chooses
the function H : {0, 1}≤t → G1 at random from the family H, subject to the
following constraints:
H(ε) = Iε
H(w∗ |i ) = χi P, for i = 1, . . . ,
H(w∗ |i ) = χi P − ϕ1i Iε for i = 1, . . . , , and
if < t then also H(w0) = χ +1 P − ϕ 1+1 Iε and H(w1) = χ

+1 P

−

1
ϕ

+1

Iε

Since H was constructed to be eﬃciently sampleable, B can eﬃciently select a
(random) H ∈ H satisfying the above set of at most 2t + 1 equations. Furthermore, from the point of view of A a random H chosen subject to the above
constraints is distributed identically to H chosen uniformly from H (as in the
real experiment). B sets P K = (G1 , G2 , eˆ, P, Q, t, H) and gives P K to A.
We show how B can generate the secret key skw for the sibling of any node
w on the path from the root to w∗ , as well as for the two children of w∗ in the
tree if < t. (Recall that from these secret keys, A can derive the secret key skw
for any other node w which is not a preﬁx of w∗ .)

A Forward-Secure Public-Key Encryption Scheme

263

For i = 1 . . . , B sets Rw∗ |i = ϕi Q, and Rw∗ |i = ϕi Q, and if < t then also
Rw∗ 0 = ϕ +1 Q and Rw∗ 1 = ϕ +1 Q. Also, for w = w∗ |i or w = w∗ 1, B sets
i−1

Sw = ϕi χi Q +

ϕj χj Q
j=1

where i = |w|. (For i = 1, the upper limit of the summation is less than the
lower limit; by convention, we let the sum in this case be 0.) For w = w∗ 0, B
+1
sets Sw∗ 0 = j=1 ϕj χj Q. The secret key skw for node w = w∗ |i or w = w∗ 0 or
w = w∗ 1 is then just (Rw|1 , Rw|2 , . . . , Rw , Sw ).
We now verify that these keys have the correct distribution. For i = 1 . . . ,
def
def
def
deﬁne ρw∗ |i = αϕi , and ρw∗ |i = αϕi , and if < t then also ρw∗ 0 = αϕ +1
def

and ρw∗ 1 = αϕ +1 . The ρw ’s are all random and independent in Zq , and we
indeed have Rw = ρw P for any w = w∗ |i or w = w∗ |i or w = w∗ 0 or w = w∗ 1.
As for the Sw ’s, recall that in the scheme we have for any w = w1 . . . wi Sw =
i
αH(ε) + j=1 ρw|j H(w|j ). For w = w∗ |i or w = w∗ 1, substituting αϕ and αϕ
for the ρ’s and the right expressions for the H(·)’s (and letting i = |w|), this
means
i

Sw = αH(ε) +

ρw|j H(w|j )
j=1

i−1

αϕj (χj P ) + αϕi χi P −

= αIε +
j=1

1
Iε
ϕi

i−1

=

ϕj χj Q + ϕi χi Q
j=1

For w = w∗ 0 we have the same expression ,except that χi , ϕi are replaced by
χi , ϕi , respectively.
Challenge query. B responds to the query challenge(m0 , m1 ) by choosing random bit b and returning
C¯ = (U0 , χ1 U0 , . . . , χ U0 , eˆ(P, V ) · mb ) = (γP, χ1 γP, . . . , χ γP, eˆ(P, µP ) · mb )
= (γP, γH(w∗ |1 ), . . . , γH(w∗ ), eˆ(P, P )µ · mb )
Recalling that Q = αP and H(ε) = Iε = βP , we can re-write the last compoµ/αβγ
· mb . If µ = αβγ then C¯ is indeed a random
nent of C¯ as (e(Q, H(ε))γ )
encryption of mb , and µ is random then the last element is a random element in
G2, regardless of b, and therefore C¯ is independent of b.
Analysis of B. When µ = αβγ, A’s view in the simulated experiment is distributed identically to A’s view in the real experiment. Hence Pr[B outputs 1] =
PrA [Succ]. On the other hand, when µ is uniformly distributed in Zq , A has no
information about the value of b and hence it outputs b = b with probability
of at most 1/2. The advantage of B is therefore at least PrA [Succ] − 1/2. If IG
satisﬁes the decisional BDH assumption, then the advantage of B is negligible,
and therefore so is the advantage of A. This concludes the proofs of Proposition 1
and Theorem 1.

264

R. Canetti, S. Halevi, and J. Katz

Eﬃciency parameters. In the construction above, a secret key of node w at
level in the tree consists of + 1 elements of G2. However, only two of these
elements are “new” (i.e., Rw and Sw ), all the others already appear in the secret
key of the parent of w. Thus, the secret keys of all the nodes on the path from
the root to w can be stored using only 2 + 1 group elements.
The Gen algorithm takes time polynomial in the security parameter k (to
run IG) and linear in the height bound t (to choose a (2t + 1)-independent
hash function). The key derivation algorithm only takes a constant number of
multiplications in G1 and two applications of the hash function H(·). Encryption
for a node at level in the tree takes applications of the function H(·),
multiplications in G1, one application of eˆ(·, ·) and one multiplication and one
exponentiation in G2. (Note that it is possible to evaluate H(·) on points
in time O( log2 ), [2, Section 8.5].) Decryption at the same level takes + 1
applications of eˆ(·, ·), multiplications and one division in G2.
Applications to HIBE. We brieﬂy note that one can construct a full-blown
HIBE from any BTE scheme, simply by encoding in binary all the identities
in the system (possibly using a collision-intractable hashing at every level, to
improve eﬃciency). The full version of this work will contain a deﬁnition of SN
security for HIBE, and a proof of the following theorem in the standard model :
Theorem 2. If there exists an SN-CPA secure BTE scheme, then there also
exists an SN-CPA secure HIBE scheme.
Corollary 1. There exists a HIBE scheme that is secure in the sense of SNCPA under the BDDH assumption.
Construction in the random oracle model. It can be seen that the above
scheme remains secure when the function H is modeled as a random oracle
(a proof of security is immediate since a random oracle, in particular, acts as a
(2t+1)-wise independent function). When the random oracle is instantiated with
a “cryptographic hash function” whose complexity is (essentially) independent of
N (as opposed to the O(t) = O(log N ) complexity of a (2t + 1)-wise independent
hash function), the complexity of several parameters of the scheme improves
from O(log N ) to O(1).
Once we are working in the random oracle model, the scheme may be further
modiﬁed so that its security is based on the computational BDH assumption
rather than the decisional version: simply replace the component M · eˆ(Q, H(ε))r
of the ciphertext by M ⊕ H (ˆ
e(Q, H(ε))r ), where H : G2 → {0, 1}n is also
modeled as an independent random oracle.
Achieving chosen-ciphertext security. We sketch how our schemes may be
modiﬁed so as to achieve security against adaptive chosen-ciphertext attacks. In
the standard model, we may apply the technique of Sahai ([32], based on [28]) to
construct a new scheme as follows: The public key consists of two independentlygenerated public keys P K1 , P K2 for a BTE scheme secure in the sense of SNCPA, along with a random string r. To encrypt a message M for node w, the

A Forward-Secure Public-Key Encryption Scheme

265

sender computes C1 ← EncP K1 (w, M ) and C2 ← EncP K2 (w, M ), and sends
w, C1 , C2 , π ; here, π is a simulation-sound NIZK proof of consistency (i.e., a
proof that C1 and C2 are both encryptions of the same message M for node
w) with respect to string r (generic NIZK is typically implemented using trapdoor permutations; however, it is not hard to see that the BDDH assumption is
suﬃcient for NIZK as well). A proof that this scheme is secure against chosen
ciphertext attacks follows along the lines of [32].
In the random oracle model, we can achieve a more eﬃcient scheme which is
secure in the sense of SN-CCA by applying, e.g., the Fujisaki-Okamoto transformation [16]. We note that small modiﬁcations of the Fujisaki-Okamoto transformation are necessary to achieve our goal (in particular, the node name w must
be included in the hash). Further details will appear in the ﬁnal version.

3

Forward-Secure Public-Key Encryption

We deﬁne and construct forward-secure encryption schemes. After deﬁning security against chosen plaintext attacks and chosen ciphertext attacks for such
schemes, we start by presenting two “trivial” schemes with linear complexity.
We then describe our main construction of a CPA-secure forward secure encryption scheme with logarithmic complexity, given any CPA-secure BTE scheme. If
the underlying BTE scheme is CCA-secure, then the same construction yields a
forward CCA secure encryption scheme.
3.1

Deﬁnitions

We deﬁne key-evolving public-key encryption schemes, and what it means for
such a scheme to be forward-secure. The former deﬁnition is a straightforward
adaptation of [6] and is reminiscent of the deﬁnition of binary tree encryption;
the latter, however, is new and requires some care.
Deﬁnition 3. A key-evolving public-key encryption scheme ke-PKE is a 4-tuple
of ppt algorithms (Gen, Upd, Enc, Dec) such that:
– The key generation algorithm Gen takes as input a security parameter 1k
and the total number of time periods N . It returns a public key P K and an
initial secret key SK0 .
– The key update algorithm Upd takes a secret key SKi−1 as well as the index
i of the current time period. It returns a secret key SKi for period i.
– The encryption algorithm Enc takes a public key P K, the index i of the
current time period, and a message M . It returns a ciphertext C for period
i.
– The decryption algorithm Dec takes as input a secret key SKi and a ciphertext i, C . It returns a message M . We denote this by M := DecSKi ( i, C ).
For correctness we require that for any (P K, SKε ) output by Gen, any secret key SKi correctly generated for time i, and all M , we have M =
DecSKi (EN C(P K, i, M )).

266

R. Canetti, S. Halevi, and J. Katz

Our deﬁnitions of forward-secure public-key encryption generalize the standard notions of security for PKE, similar to the way in which the deﬁnitions of
[6] generalize the standard notion of security for signature schemes.
Deﬁnition 4. A key-evolving public-key encryption scheme is forward-secure
against chosen plaintext attacks (fs-CPA) if any ppt adversary succeeds in the
following game with probability at most negligibly over one half:
Setup: Gen(1k , N ) is run, with output (P K, SK0 ). The adversary is given P K.
Attack: The adversary issues one breakin(i) query and one challenge(j, M0 , M1 )
query, in either order, subject to 0 ≤ j < i < N . These queries are answered as:
– On query breakin(i), key SKi is computed via Upd(· · · Upd(SK0 , 1), · · · , i).
This key is then given to the adversary.
– On query challenge(j, M0 , M1 ) a random bit b is selected and the adversary
is given C ∗ = EncP K (j, Mb ).
Guess: The adversary outputs a guess b ∈ {0, 1}. It succeeds if b = b.
Deﬁnition 5. A key-evolving public-key encryption scheme is forward-secure
against chosen ciphertext attacks (fs-CCA) if any ppt adversary has only negligible advantage in the following game:
Setup: Gen(1k , N ) is run, yielding (P K, SK0 ). The adversary is given P K.
Attack: The adversary issues one breakin(i) query, one challenge(j, M0 , M1 )
query, and multiple decrypt(k, C) queries, in either order, subject to 0 ≤ j < i <
N and k ≤ N . These queries are answered as follows:
– On query breakin(i), key SKi is computed via Upd(· · · Upd(SK0 , 1), · · · , i).
This key is then given to the adversary.
– On query challenge(j, M0 , M1 ) a random bit b is selected and the adversary
is given C ∗ = EncP K (j, Mb ).
– A query decrypt(k, C) is answered as follows. If a challenge query was already
made (at time unit j), C = C ∗ , and j = k, then the answer is ⊥. Otherwise,
the answer is DecSKk (k, C).
Guess: The adversary outputs a guess b ∈ {0, 1}. It succeeds if b = b.
The advantage of the adversary is deﬁned as the absolute value of the diﬀerence
between its success probability and 1/2.
Remark 1: On the order of the breakin and the challenge queries.
Deﬁnition 4 allows the adversary to make the breakin and the challenge queries in
any order. However, without loss of generality we may assume that the adversary
makes the breakin query ﬁrst. (Speciﬁcally, given an adversary that makes the
challenge query before the breakin query, it is easy to construct an adversary that
makes the breakin query ﬁrst and achieves exactly the same advantage.)

A Forward-Secure Public-Key Encryption Scheme

267

Interestingly, assuming that the adversary makes the challenge query ﬁrst
seems to result in a slightly weaker concrete security. Speciﬁcally, transforming
an adversary that ﬁrst makes the breakin query into an adversary that ﬁrst
makes the challenge query results in an N -fold loss in the advantage. (When N
is polynomial in the security parameter, this reduction in security is tolerable.
Still, it is better to avoid it.)
Remark 2: Relaxing chosen-ciphertext security. Note that Deﬁnition
5 allows the adversary to make decryption queries for various time periods in
arbitrary order (not necessarily chronological). Furthermore, the adversary is
allowed to obtain the decryption of the challenge ciphertext C ∗ , as long as the
decryption is for a diﬀerent time period than the one in which the ciphertext was
generated. This extra power given to the adversary results in a deﬁnition that is
probably stronger than what is needed in most settings, and can potentially be
relaxed and still provide adequate security. Still, we present this notion since it
is the strongest natural interpretation of the CCA paradigm and our scheme in
the random oracle model achieves it.
Remark 3: The random oracle model. In order to adapt our deﬁnitions
to the random oracle model, we additionally allow the adversary to make a
polynomially-bounded number of queries to the random oracle. These queries
may be interleaved in any order with the other queries. The answers of these
oracles are computed based on the same instance of the random oracle.
3.2

Schemes with Linear Complexity

For completeness, we discuss some simple approaches to forward-secure PKE.
These approaches yield schemes with linear complexity in at least some parameters.
One trivial solution is to generate N independent public-/private- key pairs
{(ski , pki )} and to set P K = (pk0 , . . . , pkN −1 ). In this scheme, the key SKi for
time period i will simply consist of (ski , . . . , skN −1 ). Algorithms for encryption,
decryption, and key update are immediate. The drawback of this trivial solution
is an N -fold increase in the sizes of the public and secret keys, as well as in the
key-generation time. Anderson [3] noted that a somewhat improved solution can
be built from an identity-based encryption scheme. Here, the public key is the
“master public key” of the identity-based scheme, and ski is computed as the
“personal secret key” of a user with identity i (the scheme is otherwise identical
to the above). This solution achieves O(1) public key size, but still has O(N )
secret key size and key-generation time.
In fact, one could improve this last solution even more: instead of a large
secret key, it is enough if the user keeps a large non-secret ﬁle containing one
record per period. The record for period i stores the secret key ski encrypted
(under the public key) for time period i − 1. At the beginning of period i, the
user obtains record i, uses key ski−1 to recover ski , and then erases ski−1 . This
solution achieves essentially the same eﬃciency as the “simple forward secure

268

R. Canetti, S. Halevi, and J. Katz

signatures” of Krawczyk [26] (and in particular requires O(N ) non-secret storage
and key-generation time).
3.3

A Construction with Logarithmic Complexity

We construct a fs-CPA (resp., fs-CCA) encryption scheme from any SN-CPA
(resp., SN-CCA) BTE scheme. For this purpose, we use a BTE scheme with full
tree of depth log N , together with a tree-traversal technique to assign nodes to
time periods. This is somewhat similar to prior forward-secure signature schemes
[6,1,27], except that we utilize all the nodes in the tree, rather than only the
leaves. This results in complexity gain (from O(log n) to O(1)) in some of the
parameters. We remark that our tree traversal method can be applied also to [6,
1,27], with similar complexity gain.
The scheme is very simple: For a forward-secure scheme with N = 2n+1 time
periods, use a BTE with full binary tree of N nodes and depth n. (That is, use
the set W = {0, 1}≤n .) At time i, the “active node”, denoted wi , is the ith node
in a pre-order traversal of the BTE tree. (Pre-order traversal can be deﬁned as
follows: w1 = ε. For i > 1, if wi is an internal node (|wi | < n), then wi+1 = wi 0.
If wi is a leaf (|wi | = n), then wi+1 = w1, where w is the longest string such
that w0 is a preﬁx of wi .) Encryption in time period i uses the tree public key
and the name of node wi . Ciphertexts for time unit i are decrypted using the
secret key of node wi . In addition, in time unit i we also keep in memory the
secret keys of the “right siblings” of the nodes on the path from the root to wi .
That is, whenever w 0 is a preﬁx of wi , we keep in memory the secret key of
node w 1. At the end of period i, we compute the secret key of wi+1 and erase
the secret key of wi . Note that wi+1 is either the left child of wi , or one of the
nodes whose secret keys were stored in memory. Hence, we need at most one
application of the Der function to compute the new secret key.
Formally, given a BTE scheme (Gen, Der, Enc, Dec), construct a key-evolving
scheme (Gen , Upd, Enc , Dec ) as follows.
– Algorithm Gen (1k , N ) runs Gen(1k ), and obtains P K, SKε . It then outputs
P K = P K, and SK0 = SKε .
– Algorithm Upd(i+1, SKi ): The secret key SKi is organized as a stack of node
keys, with the secret key SKwi on top. We ﬁrst pop the current secret key,
SKwi , oﬀ the stack. If wi is a leaf (|wi | = n) then we are done; the next key
on top of the stack is SKwi+1 . Otherwise (wi is an internal node, |wi | < n),
we set (SKwi 0 , SKwi 1 ) ← Der(P K, wi , SKwi ), and push SKwi 1 and then
i
SKw
0 onto the stack. The new top is SKwi 0 (and indeed wi+1 = wi 0). In
either case, Upd erases the key SKwi .
– Algorithm Enc (P K , i, M ) runs Enc(P K, wi , M ).
– Algorithm Dec (SKi , i, M ) runs Dec(SKwi , wi , M ).
Theorem 3. The scheme (Gen , Upd, Enc , Dec ) is fs-CPA secure (resp., fsCCA secure), assuming that the underlying scheme (Gen, Der, Enc, Dec) is a
CPA-secure (resp., CCA-secure) BTE scheme.

A Forward-Secure Public-Key Encryption Scheme

269

Proof. The proof proceeds via straightforward reduction. Assume we have an
adversary A that has advantage ε in a CPA (resp., CCA) attack against the
forward-secure scheme (Gen , Upd, Enc , Dec ). We construct an adversary A that
obtains advantage ε/N in the corresponding attack against the underlying BTE
scheme (Gen, Der, Enc, Dec). Adversary A proceeds as follows.
1. A chooses at random a time period i∗ ∈r {1..N }, and declares that the BTE
∗
node to be attacked is wi . Next, A obtains the public key P K and the
appropriate secret keys for the BTE scheme.
2. A runs A , giving it public key P K.
3. When A generates a challenge (i, M0 , M1 ), if i = i∗ then A outputs a random
bit and halts. If i = i∗ then A generates a challenge (M0 , M1 ), obtains the
∗
ciphertext C ∗ = Enc(P K, wi , Mb ) and hands it over to A .
4. When A generates a breakin query for time unit i, if i ≤ i∗ then A outputs a
random bit and halts. If i > i∗ then A hands A the secret key SKi . (Observe
that SKi can be computed from the secret keys known to A.)
5. (This activity is only relevant to the case of CCA security.) When A generates a decryption request for a ciphertext C = C ∗ at time unit i for which A
has the corresponding decryption key SKwi , then A decrypts C and hands
the answer to A . If A does not have the corresponding decryption key then
it hands (C, wi ) to its own decryption oracle, and forwards the answer to
A.
6. When A outputs a prediction bit b , A outputs b and halts.
Analyzing A, it is straightforward to see that, conditioned on the event that
i = i∗ , the copy of A running within A has exactly the same view as in a real
CPA (resp., CCA) interaction with a BTE scheme. Consequently, A predicts the
bit b with advantage ε/N .
Extension to an unbounded number of time periods. In our description
of the various schemes thus far, the number of time periods N was assumed to
be known at the time of key generation. As in [27], we can modify our schemes
to support an “unbounded” number of time periods (i.e., the number of time
periods need not be known in advance). This has the added advantage that
the eﬃciency and security of the scheme depend only on the number of periods
elapsed thus far.
A proof of security for the “unbounded” scheme in the random oracle model
is immediate, but in the standard model we must have an a priori upper-bound
N ∗ on the total number of time periods so that (setting t = log N ∗ ) a 2t-wise
independent family H is used. However, this restriction is not very serious since
we may set t = ω(log k) (where k is the security parameter) and thus obtain a
super-polynomial bound on the number of time periods while all parameters of
the scheme remain polynomial in k.
Analysis of complexity parameters. Each of the four operations (key generation, update, encryption, decryption) requires at most one operation of the
underlying BTE scheme. Thus, the complexity of our scheme is essentially the
same as that of our BTE construction, as discussed in Section 2. This justiﬁes
the claims given in Table 1.

270

R. Canetti, S. Halevi, and J. Katz

Acknowledgments. The third author is very grateful to Craig Gentry for helpful discussions regarding [17] and for providing him with a preliminary version
of that work.

References
1. M. Abdalla and L. Reyzin. A new forward-secure digital signature scheme. Asiacrypt ’00, LNCS vol. 1976, pp. 116–129, Springer-Verlag, 2000.
2. A. Aho, J. Hopcroft, and J. Ullman. The Design and Analysis of Computer Algorithms. Addison-Wesley, 1975.
3. R. Anderson. Two remarks on public key cryptology. Invited Lecture, ACM-CCS
’97. http://www.cl.cam.ac.uk/ftp/users/rja14/forwardsecure.pdf.
4. D. Beaver and S. Haber. Cryptographic protocols provably secure against dynamic
adversaries. In Eurocrypt ’92, LNCS vol. 658, pp. 307–323, Springer-Verlag, 1992.
5. D. Beaver, Plug and play encryption, Advances in Cryptology – Crypto ’97, LNCS
vol. 1294, pp. 75–89, Springer-Verlag, 1997.
6. M. Bellare and S. K. Miner. A forward-secure digital signature scheme. Advances
in Cryptology – Crypto ’99, LNCS vol. 1666, pp. 431–448, Springer-Verlag, 1999.
7. M. Bellare and B. Yee. Forward security in private-key cryptography. Topics in
Cryptology – CT-RSA 2003, to appear. Preliminary version at
http://eprint.iacr.org/2001/035/.
8. M. Bellare, A. Desai, D. Pointcheval, and P. Rogaway, Relations Among Notions of
Security for Public-Key Encryption Schemes, Advances in Cryptology – Crypto’98,
Lecture Notes in Computer Science Vol. 1462, pp. 26–45, Springer-Verlag, 1998.
9. D. Boneh and M. Franklin. Identity based encryption from the Weil pairing.
Advances in Cryptology – Crypto 2001, LNCS vol. 2139, pp. 213–229, SpringerVerlag, 2001. Full version to appear in SIAM J. Computing and available at
http://eprint.iacr.org/2001/090.
10. D. Boneh, B. Lynn, and H. Shacham. Short signatures from the Weil pairing.
Asiacrypt ’01, LNCS vol. 2248, pp. 514–532, Springer-Verlag, 2001.
11. R. Canetti, U. Feige, O. Goldreich and M. Naor, Adaptively Secure Computation,
STOC ’96, pp. 639–648, ACM, 1996. Also MIT-LCS-TR #682, 1996.
12. I. Damgaard and J. B. Nielsen, Improved non-committing encryption schemes
based on general complexity assumption, Advances in Cryptology – Crypto ’00,
LNCS vol. 1880, pp. 432–450, Springer-Verlag, 2000.
13. Y. Desmedt and Y. Frankel. Threshold cryptosystems. Advances in Cryptology –
Crypto ’89, LNCS vol. 435, pp. 307–315, Springer-Verlag, 1989.
14. W. Diﬃe, P. C. Van-Oorschot, and M. J. Weiner. Authentication and authenticated
key exchanges. Designs, Codes, and Cryptography 2:107–125, 1992.
15. D. Dolev, C. Dwork and M. Naor, Non-malleable cryptography, SIAM. J. Computing, Vol. 30, No. 2, 2000, pp. 391-437. Preliminary version in 23rd Symposium
on Theory of Computing (STOC), ACM, 1991.
16. E. Fujisaki and T. Okamoto. Secure integration of asymmetric and symmetric
encryption schemes. Crypto ’99, LNCS 1666, pp. 537–554, Springer-Verlag, 1999.
17. C. Gentry and A. Silverberg. Hierarchical identity-based cryptography. Asiacrypt
2002, LNCS vol. 2501, pp. 548–566, Springer-Verlag, 2002.
18. C. G. G¨
unther. An identity-based key-exchange protocol. Advances in Cryptology
– Eurocrypt ’89, LNCS vol. 434, pp. 29–37, Springer-Verlag, 1989.

A Forward-Secure Public-Key Encryption Scheme

271

19. S. Goldwasser, S. Micali, and R. Rivest. A digital signature scheme secure against
adaptive chosen-message attacks. SIAM J. Computing, 17(2):281–308, April 1988.
20. A. Herzberg, M. Jakobson, S. Jarecki, H. Krawczyk, and M. Yung. Proactive
public key and signature systems. Proceedings of 4th Conference on Computer and
Communications Security, pp. 100–110, ACM, 1997.
21. J. Horwitz and B. Lynn. Toward hierarchical identity-based encryption. Eurocrypt
’02, LNCS vol. 2332, pp. 466–481, Springer-Verlag, 2002.
22. G. Itkis and L. Reyzin. Forward-secure signatures with optimal signing and verifying. Crypto ’01, LNCS vol. 2139, pp. 499–514, Springer-Verlag, 2001.
23. A. Joux. A one round protocol for tripartite Diﬃe-Hellman. 4th International Symposium on Algorithmic Number Theory, LNCS vol. 1838, pp. 385–394, SpringerVerlag, 2000.
24. A. Joux and K. Nguyen. Separating decision diﬃe-hellman from diﬃe-hellman in
cryptographic groups. Manuscript, January 2001. Available at
http://eprint.iacr.org/2001/003/.
25. A. Kozlov and L. Reyzin. Forward-secure signatures with fast key update. Proc.
3rd Conference on Security in Communication Networks, LNCS vol. 2576, pp. 247–
262, Springer-Verlag, 2002.
26. H. Krawczyk. Simple forward-secure signatures from any signature scheme. Proc.
7th ACM-CCS, pp. 108–115, ACM, 2000.
27. T. Malkin, D. Micciancio, and S. K. Miner. Eﬃcient generic forward-secure signatures with an unbounded number of time periods. Advances in Cryptology –
Eurocrypt 2002, LNCS vol. 2332, pp. 400–417, Springer-Verlag, 2002.
28. M. Naor and M. Yung, Public key cryptosystems provably secure against chosen
ciphertext attacks, 22nd STOC, 427-437, 1990.
29. J. B. Nielsen. Separating random oracle proofs from complexity theoretic proofs:
The non-committing encryption case. Crypto ’02, LNCS vol. 2442, pp. 111–126,
Springer-Verlag, 2002.
30. R. Ostrovsky and M. Yung. How to withstand mobile virus attacks. 10th Annual
Symposium on Principles of Distributed Computing, pages 51–59, ACM, 1991.
31. C. Rackoﬀ and D. Simon, Non-interactive zero-knowledge proof of knowledge and
chosen ciphertext attack, Crypto ’91, LNCS vol. 576, pp. 433–444, Springer-Verlag,
1991.
32. A. Sahai. Non-malleable non-interactive zero-knowledge and adaptive chosenciphertext security. Proc. of the 40th Annual Symposium on Foundations of Computer Science, pages 543–553, IEEE, 1999.
33. A. Shamir. How to share a secret. Comm. of the ACM 22(11):612–613, 1979.
34. E. R. Verheul. Self-blindable credential certiﬁcates from the Weil pairing. Asiacrypt
2001, LNCS vol. 2248, pp. 533–551, Springer-Verlag, 2001.

