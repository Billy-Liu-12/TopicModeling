Two-Threshold Broadcast and Detectable
Multi-party Computation
Matthias Fitzi1 , Martin Hirt2 , Thomas Holenstein2 , and
J¨
urg Wullschleger2 **
1
2

University of California, Davis, USA, fitzi@cs.ucdavis.edu
ETH Zurich, Switzerland, {hirt,holenst,wjuerg}@inf.ethz.ch

Abstract. Classical distributed protocols like broadcast or multi-party
computation provide security as long as the number of malicious players
f is bounded by some given threshold t, i.e., f ≤ t. If f exceeds t then
these protocols are completely insecure.
We relax this binary concept to the notion of two-threshold security:
Such protocols guarantee full security as long as f ≤ t for some small
threshold t, and still provide some degraded security when t < f ≤ T for
a larger threshold T . In particular, we propose the following problems.
◦ Broadcast with Extended Validity: Standard broadcast is
achieved when f ≤ t. When t < f ≤ T , then either broadcast is achieved,
or every player learns that there are too many faults. Furthermore, when
the sender is honest, then broadcast is always achieved.
◦ Broadcast with Extended Consistency: Standard broadcast is
achieved when f ≤ t. When t < f ≤ T , then either broadcast is achieved,
or every player learns that there are too many faults. Furthermore, the
players agree on whether or not broadcast is achieved.
◦ Detectable Multi-Party Computation: Secure computation is
achieved when f ≤ t. When t < f ≤ T , then either the computation
is secure, or all players detect that there are too many faults and abort.
The above protocols for n players exist if and only if t = 0 or t + 2T < n.

1

Introduction

1.1

Broadcast

A broadcast protocol allows a sender to distribute a value among a set of players
such that even a malicious sender cannot make diﬀerent players receive diﬀerent
values, i.e., a broadcast protocol must satisfy two properties: validity, meaning
that an honest sender’s intended value is received by all players, and consistency,
meaning that all players receive the same value even when the sender is malicious.
The ﬁrst broadcast protocols were proposed by Lamport, Shostak, and
Pease [LSP82], once for the model with n players connected with bilateral authenticated channels where at most t < n/3 players are corrupted, and once for
Partially supported by the Packard Foundation.
Supported by the Swiss National Science Foundation, project no. 2000-066716.01/1.
E. Biham (Ed.): EUROCRYPT 2003, LNCS 2656, pp. 51–67, 2003.
c International Association for Cryptologic Research 2003

52

M. Fitzi et al.

the model with a public-key infrastructure (PKI) and at most t < n corruptions.
Both bounds are tight [LSP82,KY84]. The ﬁrst eﬃcient broadcast protocols were
given in [DS82,DFF+ 82]. Note that a PKI setup can also allow for unconditional
security, as shown by Pﬁtzmann and Waidner [PW96]. More generally, a precomputation phase where broadcast is temporarily achievable can be exploited such
that broadcast unconditionally secure against any number of corrupted players
is achievable after the precomputation [BPW91,PW96].
1.2

Multi-party Computation

Secure multi-party computation (MPC) protocols allow a set of n players to
securely compute any agreed function on their private inputs, where the following
properties must be satisﬁed: privacy, meaning that the corrupted players do not
learn any information about the other players’ inputs (except for what they
can infer from the function output), and correctness, meaning that the protocol
outputs the correct function value, even when the malicious players misbehave.
The MPC problem was proposed by Yao [Yao82] and ﬁrst solved by Goldreich, Micali, and Wigderson [GMW87]. This protocol is secure with respect to
a computationally bounded adversary corrupting up to t < n/2 players, which is
optimal. When secure bilateral channels are available, security is achievable with
respect to an unbounded adversary that corrupts up to t < n/3 players [BGW88,
CCD88]; also this bound is tight. For a model assuming broadcast, non-robust
protocols for MPC computationally secure against t < n corrupted players are
given in [GMW87,BG89a,Gol01].
Broadcast is a key ingredient for MPC protocols, and must be simulated with
a respective subprotocol. It fact, the necessary conditions for MPC are due to
the requirement of broadcast simulation. When secure broadcast channels are
given, then unconditionally secure MPC is achievable even for t < n/2 [Bea89,
RB89,CDD+ 99]. Recent results [FGM01,FGMR02] imply that MPC unconditionally secure against t < n/2 corruptions is achievable even without assuming
broadcast channels in a way that all security conditions are satisﬁed except for
robustness, so called detectable MPC.
1.3

Previous Work on Multi-threshold Security

The ﬁrst steps towards multi-threshold security were taken by Lamport [Lam83]
by analyzing the “weak Byzantine generals” problem, where standard broadcast
must be achieved when no player is corrupted (t = 0), but agreement among the
recipients must be achieved for up to T corruptions. He proved that, deterministically, even this weak form of broadcast is not achievable for T ≥ n/3.
In [FGM01,FGMR02] a probabilistic protocol called detectable broadcast was
given that achieves broadcast when no player is corrupted (t = 0), but when
any minority of the players is corrupted (T < n/2) still guarantees that either
broadcast is achieved or that all correct players safely abort the protocol. This
bound was improved to T < n in [FGH+ 02].

Two-Threshold Broadcast and Detectable Multi-party Computation

53

In another line of research, Vaidya and Pradhan [VP93] proposed “degradable agreement”, where broadcast must be achieved when up to t players are corrupted, and some weakened validity and consistency conditions must be achieved
when up to T players are corrupted, namely that all players receive either the
sent value or ⊥. However, even when f ≤ t, the players do not reach agreement
on the fact whether or not all players have received the sent value. Degradable
agreement is achievable if and only if 2t + T < n.
1.4

Contributions

We generalize the standard notion of threshold security to two-threshold security
where, for two thresholds t and T with t ≤ T , full security must be achieved
when at most f ≤ t players are corrupted, and some alleviated form of security
must be achieved when f ≤ T players are corrupted. This notion is applied to
broadcast, resulting in two-threshold broadcast with the following two variants:
– broadcast with extended validity: Standard broadcast is achieved
when at most f ≤ t players are corrupted. When up to f ≤ T players
are corrupted then still validity is guaranteed, i.e., that a correct sender can
distribute a value of his own choice among the players.
– broadcast with extended consistency: Standard broadcast is achieved
when at most f ≤ t players are corrupted. When up to f ≤ T players are
corrupted then still consistency is guaranteed, i.e., that all players receive
the same value, even if the sender is corrupted.
We prove that two-threshold broadcast among n players is achievable if and
only if t = 0 or t + 2T < n, and construct eﬃcient protocols for all achievable
cases (solutions for the special case t = 0 were known before [Hol01,FGH+ 02,
GL02]). Moreover, the proposed protocols additionally achieve detection for the
case that full broadcast cannot be achieved. The protocol with extended validity
additionally achieves that, in case that consistency has not been reached, all
players learn this fact (consistency detection); and the protocol with extended
consistency additionally achieves agreement about the fact whether or not validity has been achieved (validity detection).
Finally, we apply the generalized notion to secure multi-party computation
(MPC), respectively to detectable precomputation [FGM01,FGMR02]: If up to
t players are corrupted then the precomputation succeeds and all correct players accept the precomputation. If up to T players are corrupted then all correct
players either commonly accept or commonly reject the precomputation, whereas
acceptance implies that the precomputation succeeded. If such a precomputation succeeds then broadcast with full resilience (t < n) and secure multi-party
computation for t < n/2 will be achievable from now on. In other words, with
help of detectable precomputation, any protocol in a model with pairwise communication and broadcast can be transformed into a non-robust protocol in the
corresponding model without broadcast. Detectable precomputation is achievable
if and only if t = 0 or t + 2T < n.

54

M. Fitzi et al.

2

Preliminaries

2.1

Models

We consider a set P = {p1 , . . . , pn } of players, connected by a complete synchronous network of pairwise authenticated (or secure) channels. There is no
PKI set up among the players and we assume the presence of an adaptive active
adversary. The adversary’s computational power is assumed to be unlimited —
however, our results are proven tight even with respect to a non-adaptive probabilistic polytime adversary. The model with authenticated channels is denoted
by Maut ; the model with secure channels is denoted by Msec . When referring
to their corresponding models from the literature where broadcast channels are
bc
additionally given among the players we use the notations Mbc
aut and Msec .
2.2

Deﬁnitions

A broadcast protocol allows a player (the sender) to consistently send a message
to all other players such that all correct players receive the sender’s intended
value if the sender is correct, but guaranteeing that all correct players receive
the same value even when the sender is corrupted.
Deﬁnition 1 (Broadcast BC). Let P = {p1 , . . . , pn } be a set of n players
and let D be a ﬁnite domain. A protocol Ψ among P where player ps ∈ P (called
the sender) holds an input value xs ∈ D and every player pi ∈ P ﬁnally decides
on an output value yi ∈ D achieves broadcast (or is a broadcast protocol) with
respect to threshold t, if it satisﬁes the following conditions:
Validity: If at most t players are corrupted and the sender ps is correct
then all correct players pi decide on the sender’s input value, yi = xs .
Consistency (or Agreement): If at most t players are corrupted then all
correct players decide on the same output value, i.e., if pi , pj ∈ P are
correct then yi = yj .
In this paper, we focus on binary broadcast (domain D = {0, 1}) since broadcast for any ﬁnite domain D can be eﬃciently reduced to the binary case [TC84].
Our ﬁrst generalization of standard broadcast demands validity even when
the number f of corrupted players exceeds t, called broadcast with extended
validity. We directly give a strengthened deﬁnition that allows the players to
learn whether or not consistency has been achieved. For this we have the players
pi decide on an additional binary grade value gi , gi = 1 implying (but not
being equivalent with) the fact that consistency has been achieved.1 It can be
guaranteed that consistency is always detected if f ≤ t (“completeness”) but
never incorrectly detected if f ≤ T (“soundness”).
1

Note that, for the interesting case T ≥ n/3, it is not possible to achieve that gi = 1
is equivalent with having achieved consistency since this would immediately imply
standard broadcast for T ≥ n/3.

Two-Threshold Broadcast and Detectable Multi-party Computation

55

Deﬁnition 2 (ExtValBC). A protocol Ψ among P where player ps ∈ P (called
the sender) holds an input value xs ∈ D and every player pi ∈ P ﬁnally decides
on an output value yi ∈ D and a grade value gi ∈ {0, 1} achieves broadcast
with extended validity and consistency detection (ExtValBC) with respect to
thresholds t and T (T ≥ t) if it satisﬁes the following conditions:
Broadcast: If at most f ≤ t players are corrupted then every correct player
pi decides on the same pair of outputs (y, 1), i.e., yi = y and gi = 1.
Furthermore, if the sender ps is correct then yi = xs .
Extended Validity: If f ≤ T and the sender ps is correct then every correct player pi decides on the sender’s input value, yi = xs .
Consistency Detection: If f ≤ T and any correct player pi computes
gi = 1 then every correct player pj computes yj = yi .
Our second generalization of standard broadcast demands consistency even
when the number f of corrupted players exceeds t, called broadcast with extended
consistency. Again, we directly give a strengthened deﬁnition that allows the
players to learn whether or not validity has been achieved. In contrast to the
inherently non-common consistency detection in ExtValBC for T ≥ n/3, here
we require that the players decide on the same grade output gi . If f ≤ t then
validity is always detected (“completeness”), and if f ≤ T then the detection of
validity always implies validity (“soundness”).
Deﬁnition 3 (ExtConsBC aka Detectable Broadcast). A protocol Ψ
among P where player ps ∈ P (called the sender) holds an input value xs ∈ D
and every player pi ∈ P ﬁnally decides on an output value yi ∈ D and a grade
value gi ∈ {0, 1} achieves broadcast with extended consistency and validity detection (ExtConsBC) with respect to thresholds t and T (T ≥ t) if it satisﬁes
the following conditions:
Broadcast: If at most f ≤ t players are corrupted then every correct player
pi decides on the same pair of outputs (y, 1), yi = y and gi = 1. Furthermore, if the sender ps is correct then yi = xs .
Extended Consistency: If f ≤ T then every correct player pi decides on
the same pair of outputs (y, g), yi = y and gi = g.
Validity Detection: If f ≤ T , the sender ps is correct, and any correct
player pi computes gi = 1, then yi = xs .
Along the lines of [BPW91,PW96] detectable broadcast can be turned into a
“detectable precomputation” for future broadcast unconditionally secure against
any number of corrupted players, t < n.
Deﬁnition 4 (Detectable Precomputation). A protocol among n players
where every player pi ∈ P computes some private data ∆i and ﬁnally decides on
a decision bit gi ∈ {0, 1} achieves detectable precomputation for broadcast (or
detectable precomputation, for short) with respect to thresholds t and T (T ≥ t)
if it satisﬁes:

56

M. Fitzi et al.

Validity (or Robustness): If at most f ≤ t players are corrupted then
the correct players accept (gi = 1).
Consistency (or Correctness): If f ≤ T then all correct players commonly accept (gi = 1) or commonly reject (gi = 0) the protocol; moreover,
if the private data ∆i held by all correct players is inconsistent in the sense
that it does not guarantee for arbitrarily resilient broadcast then the correct
players reject (gi = 0).
Independence (or Fairness): At the time of the precomputation, a correct player does not yet need to know the value to be broadcast later.

2.3

Protocol Notation

Protocols are speciﬁed with respect to player set P (where |P | = n) and stated
with respect to the local view of player pi , meaning that all players pi ∈ P
execute this code in parallel with respect to their own identity i. Player pi ’s
input is called xi . Player pi ’s output value is written as yi , or gi , or pair (yi , gi )
and will always be obvious from the context. For simplicity, it is not explicitly
stated how to handle values received from corrupted players that are outside the
speciﬁed domain. Such a value is always implicitly assumed to be replaced by a
default value inside the speciﬁed domain.

3

Broadcast with Extended Validity

In this section, we present an eﬃcient solution for broadcast with extended
validity and consistency detection, ExtValBC. The model is Maut and the given
protocol achieves perfect security. Since, for the special case t = 0, eﬃcient and
optimally resilient protocols were already given in [Hol01,FGH+ 02], we focus on
protocols for t > 0.
The construction in this section works along the lines of the phase-king
paradigm of [BG89b,BGP89]. An important building block for phase-king protocols is graded consensus, a derivative of graded broadcast [FM97].
Deﬁnition 5 (Graded Consensus GC). A protocol among P where every
player pi ∈ P holds an input value xi ∈ D and ﬁnally decides on an output
value yi ∈ D and a grade gi ∈ {0, 1} achieves graded consensus with respect to
threshold t if it satisﬁes the following conditions:
Validity (or Persistency): If at most t players are corrupted and all correct players pi hold the same input value xi = v then all correct players pi
decide on it, yi = v, and get grade gi = 1.
Consistency Detection: If at most t players are corrupted and any correct
player pi gets grade gi = 1 then all correct players pj decide on the same
output value, yi = yj .

Two-Threshold Broadcast and Detectable Multi-party Computation

57

We now generalize graded consensus to ExtValGC in the same way as broadcast was generalized to ExtValBC in Section 2.2. Since graded consensus already
involves a grade gi for consistency detection, we do not add an additional grade
value for ExtValGC but simply extend the grade range to gi ∈ {0, 1, 2} whereas
gi = 1 implies consistency detection if at most f ≤ t players are corrupted and
gi = 2 implies consistency detection if at most f ≤ T players are corrupted.
Deﬁnition 6 (ExtValGC). A protocol among P where each player pi ∈ P
holds an input value xi and ﬁnally decides on an output value yi and a grade value
gi ∈ {0, 1, 2} achieves graded consensus with extended validity and consistency
detection (ExtValGC) with respect to thresholds t and T (T ≥ t) if it satisﬁes
the following conditions:
Validity: If at most f ≤ T players are corrupted and every correct player
pi enters the protocol with the same input value xi = v then every correct
player pi computes outputs yi = v and gi ≥ 1, and in particular, gi = 2 if
at most t players are corrupted.
Consistency Detection: If f ≤ t and any correct player pi computes gi ≥
1 then every correct player pj computes yj = yi . If f ≤ T and any correct
player pi computes gi = 2 then every correct player pj computes yj = yi .
Protocol 1 ExtValGC(P, xi , t, T )

1. SendToAll(xi ); P : Receive(x1i , . . . , xn
i );
2. Si0 := j ∈ {1, . . . , n} | xji = 0 ; Si1 := j ∈ {1, . . . , n} | xji = 1 ;

3. if |Sixi | ≥ n − T then zi := xi else zi :=⊥ fi;
4. SendToAll(zi ); P : Receive(zi1 , . . . , zin );
5. Ui0 := j ∈ {1, . . . , n} | zij = 0 ; Ui1 := j ∈ {1, . . . , n} | zij = 1 ;
6.
7.
8.
9.
10.

if |Ui0 | ≥ |Ui1 | then yi := 0 else yi := 1 fi;
if |Uiyi | ≥ n − t then gi := 2
elseif |Uiyi | ≥ n − T then gi := 1
else gi := 0 fi;
return (yi , gi );

Lemma 1 (“Two-threshold weak consensus”). In model Maut , if t+2T <
n, Protocol 1 satisﬁes the following properties.
Validity: If at most f ≤ T players are corrupted and every correct player
pi holds the same input value xi = v then every correct player holds value
zi = xi = v after step 3 of the protocol.
Consistency: If f ≤ t and any correct player pi holds value zi ∈ {0, 1} after
step 3 then every correct player pj holds value zj ∈ {zi , ⊥} after step 3.
Proof. If at most f ≤ T players are corrupted and every correct player pi holds
the same input value xi = v then, for every correct player pi , it holds that
|Siv | ≥ n − T and hence every such pi computes zi = xi = v.

58

M. Fitzi et al.

If f ≤ t and any correct player pi holds value zi ∈ {0, 1} after step 3 then
|Sizi | ≥ n−T and thus, for every correct player pj , it holds that |Sjzi | ≥ n−T −t >
T and thus zj ∈ {zi , ⊥} after step 3.
Lemma 2 (ExtValGC). In model Maut , if t+2T < n (and T ≥ t), Protocol 1
achieves perfectly secure ExtValGC with respect to thresholds t and T .
Proof.
Validity: Suppose that f ≤ T , and that every correct player pi enters the
protocol with the same input value xi = v. Then, by Lemma 1 (validity), every
correct player pi holds value zi = v at the end of step 3 and thus value v is
redistributed by all correct players in step 4. Thus |Uiv | ≥ n − T > T , and every
correct player computes yi = v and gi ≥ 1. Furthermore, if only f ≤ t players
are corrupted then |Uiv | ≥ n − t, and every correct player pi computes gi = 2.
Consistency Detection: Suppose that f ≤ t, and that some correct player
pi computes gi ≥ 1 and yi = v ∈ {0, 1}.
Let C be the set of corrupted players, S v be the set of correct players who
sent value v in step 1, and let U v be the set of correct players who sent value v
in step 4. Note that S v = Sjv \C and U v = Ujv \C for any j.
Since gi ≥ 1 we have that |Uiv | ≥ n − T and thus that |U v | ≥ n − T − t.
Since a correct player pj can only change to zj :=⊥, it follows that |U v | ≤ |S v |.
Therefore, for every player pj , |Sjv | ≥ |S v | ≥ n − T − t. The bound n > 2T + t
now implies that |Sj1−v | ≤ T + t < n − T and therefore that U 1−v = ∅. Thus,
|Uj1−v | ≤ |C| ≤ t and |Ujv | ≥ |S v | ≥ n − T − t > T , and yj = yi .
Assuming that at most f ≤ T players are corrupted and that gi = 2, it
follows that |U v | ≥ n − t − T . This implies that U 1−v = ∅ and that, again,
|Ujv | > |Uj1−v |.
The ﬁnal protocol for ExtValBC can now be built from ExtValGC according
to the phase-king paradigm [BG89b,BGP89]. The only diﬀerence to the standard phase-king structure is an additional round of ExtValGC at the end of the
protocol in order to allow for consistency detection.
Protocol 2 ExtValBCp1 (P, x1 , t, T )
1.
2.
3.
4.
5.
6.
7.
8.
9.

if i = 1 then SendToAll(x1 ) fi; P : Receive(yi );
for k := 2 to t + 1 do
(yi , hi ) := ExtValGC (P, yi , t, T );
if i = k then SendToAll(yi ) fi; P : Receive(yik );
if hi = 0 then yi := yik fi;
od;
(yi , hi ) := ExtValGC (P, yi , t, T );
if hi = 2 then gi := 1 else gi := 0 fi;
return (yi , gi );

Two-Threshold Broadcast and Detectable Multi-party Computation

59

Theorem 1 (ExtValBC). In model Maut , if t + 2T < n (and T ≥ t), Protocol 2 eﬃciently achieves perfectly secure ExtValBC (with sender p1 ) with respect
to thresholds t and T .
Proof. To prove that the conditions for broadcast and extended validity hold,
we show that validity holds for f ≤ T , and consistency for f ≤ t.
Validity: Suppose that at most f ≤ T players are corrupted and that the
sender p1 is correct. Then, by the validity property of ExtValGC, every correct
player pi ﬁnally computes yi = x1 at the end of the protocol.
Consistency: If f ≤ t then there is a player p ∈ {p1 , . . . , pt+1 } that is correct.
At the end of phase k = , every correct player pi holds the same value yi = y =
v which, by the validity property of ExtValGC, stays persistent until step 7 of
the protocol and every correct player ﬁnally computes yi = v, hi = 2, and thus
gi = 1.
Consistency Detection: Assume that f ≤ T and some correct player pi
computes gi = 1 at the end of the protocol. This implies that hi = 2 after the
invocation of ExtValGC in step 7, and by the consistency-detection property of
ExtValGC, that every correct player pj computed yj = yi during this invocation
and thus terminated the protocol with yj = yi .
Theorem 2 (Impossibility of ExtValBC). In standard models Msec and
Maut , ExtValBC among a set of n players P = {p0 , . . . , pn−1 } is impossible
if t > 0 and t + 2T ≥ n. For every protocol there exists a value x0 ∈ {0, 1}
such that, when the sender holds input x0 , the adversary can make the protocol
fail with a probability of at least 1/6 if it is computationally bounded, and with a
probability of at least 1/3 if it is computationally unbounded.
Proof. Assume Ψ to be a protocol for ExtValBC among n players p0 , . . . , pn−1
with sender p0 that tolerates t > 0 and t + 2T ≥ n.
Let Π = {π0 , . . . , πn−1 } be the set of the players’ corresponding processors
with their local programs. As follows from the impossibility of standard broadcast it must hold that t < n/3, and thus, that T ≥ n/3. Hence, it is possible to
˙ 1 ∪Π
˙ 2 = Π, such that 1 ≤ |Π0 | ≤ t,
partition the processors into three sets, Π0 ∪Π
1 ≤ |Π1 | ≤ T , and hence 1 ≤ |Π2 | ≤ T . Note that, hence, |Π0 ∪ Π1 | ≥ n − T ,
|Π1 ∪ Π2 | ≥ n − t, and |Π2 ∪ Π0 | ≥ n − T .
Furthermore, for each i ∈ {0, . . . , n − 1}, let πi+n be an identical copy of
processor πi . For every πi (0 ≤ i ≤ 2n−1) let the type of processor πi be deﬁned as
the number i mod n. Finally, for each k ∈ {0, 1, 2}, let Πk+3 = {πi+n | πi ∈ Πk }
form identical copies of the sets Πk .
Along the lines of [FLM86], instead of connecting the original processors as
required for the broadcast setting, we build a network involving all 2n processors
(i.e., the original ones together with their copies) by arranging the six processor
sets Πk in a circle. In particular, for all sets Πk (0 ≤ k ≤ 5), every processor
πi ∈ Πk is connected (exactly) by one channel with all processors in Πk \{πi },
Π(k−1) mod 6 , and Π(k+1) mod 6 . Hence, each processor πi in the new system is
symmetrically connected with exactly one processor of each type (diﬀerent from

60

M. Fitzi et al.
Π0
Π1

t
T T

Π0
Π2

Π1
(b) Π2

(a)

Π5

Π0
Π1

Π5

t

T

T

t

T

T

(c) Π2

Π4

Π3

Fig. 1. Rearrangement of processors in the proof of Theorem 2

his own one) as in the original system. We say that Πk and Π are adjacent
processor sets if and only if ≡ k ± 1 (mod 6).
Now, for every set Πk ∪ Π(k+1) mod 6 (0 ≤ k ≤ 5) in the new system and
without the presence of an adversary, their common view is indistinguishable
from their view as the set of processors Πk mod 3 ∪ Π(k+1) mod 3 in the original
system with respect to an adversary who corrupts all (up to either t or T )
processors of the remaining processor set Π(k+2) mod 3 in an admissible way.
Let now π0 and πn be initialized with diﬀerent inputs. We now argue that,
for each run of the new system, there are at least two pairs Πk ∪ Π(k+1) mod 6
(0 ≤ k ≤ 5) such that the conditions of ExtValBC are not satisﬁed for them:
By the extended-validity property of ExtValBC, the at least n − T processors
pi ∈ Π0 ∪ Π1 must compute yi = x0 , the processors pi ∈ Π0 ∪ Π5 must compute
yi = x0 , and the processors pi ∈ Π3 ∪ Π2 and pi ∈ Π3 ∪ Π4 must compute
yi = xn = 1 − x0 . By the broadcast property of ExtValBC, the at least n − t
processors pi ∈ Π1 ∪ Π2 must compute the same value yi = v and the processors
pi ∈ Π4 ∪ Π5 the same value yi = w.
Hence, for any possible run of the new system on inputs x0 and xn = 1 −
x0 , chosen a pair (Πk , Π(k+1) mod 6 ) of processor sets uniformly at random, the
probability that the conditions for ExtValBC are violated for this pair is at least
1
/3 . In particular, there is a pair (Πk , Π(k+1) mod 6 ) in the new system such that,
over all possible runs on inputs x0 = 0 and xn = 1 the probability that the
conditions for ExtValBC are violated for (Πk , Π(k+1) mod 6 ) is at least 1/3 .
If the adversary is unbounded, given any protocol Ψ , it can compute such
a pair (Πk , Π(k+1) mod 6 ) and act accordingly by corrupting the processors in
Π(k+2) mod 3 in the original system, hence forcing the protocol to fail on input
x0 =

0 , if 0 ∈ {k, k + 1} , and
1 , else ,

with a probability of at least 1/3 . If the adversary is computationally bounded
then it can still make the protocol fail with a probability of at least 1/6 .

4

Broadcast with Extended Consistency

We directly present an eﬃcient solution for detectable precomputation which is
strictly stronger than broadcast with extended consistency. Since, for the spe-

Two-Threshold Broadcast and Detectable Multi-party Computation

61

cial case t = 0, eﬃcient and optimally resilient protocols were already given
in [FGH+ 02], we focus on protocols for t > 0. In order to achieve unconditional
security, model Msec is required.2
Recall that the Pﬁtzmann-Waidner protocol [PW96], in model Mbc
sec , eﬃciently precomputes for future broadcast in plain model Msec (without broadcast) unconditionally secure against any number of corrupted players. Our protocol for detectable precomputation basically consists of an instance of this protocol (designed for model Mbc
sec ) wherein each invocation of a broadcast channel
is replaced by an invocation of ExtValBC (designed for model Maut ).
Protocol 3 DetPrecomp(P )

1. Execute the Pﬁtzmann-Waidner protocol for b + n future broadcasts wherein
each invocation of broadcast is replaced by ExtValBC Protocol 2 with respect
to thresholds t and T . Of these instances, b are computed with respect to the
intended senders s ∈ {1, . . . , n} of the future broadcasts. Of the other n instances, one is computed with respect to each player pi ∈ P as a future sender.
2. Every player pi computes Γi := Gi = k gik where the gik are all grades received
during an invocation of ExtValBC in step 1.
2
Synchronize: Wait and start executing the next step at round n (9t+10)
+ 1.
2

3. Send value Gi to each other player; receive the values G1i , . . . , Gn
i .
4. For every player pj ∈ P an instance of Pﬁtzmann-Waidner broadcast with
resilience T is invoked based on the (not necessarily consistent) PKI consisting
of the information exchanged during step 1 of the protocol — where pj inputs
Γj as a sender.3 Store the received values Γij (j ∈ {1, . . . , n}).
5. Compute gi = 1 if |{j | Gji = 1}| > T ∧ |{j | Γij = 1}| ≥ n − t and gi = 0,
otherwise.

Theorem 3 (Detectable precomputation). In model Msec , for any integer
b > 0 and security parameter κ > 0, if t + 2T < n (and T ≥ t), Protocol 3
achieves unconditionally secure detectable precomputation for b later broadcasts
among n players with respect to thresholds t and T with the following properties:
Protocol 3 has computation and communication complexities polynomial in
n, b, and linear in κ. The error probability of any future broadcast is ε < 2−κ .
The correct players all terminate the protocol during the same communication
round. Furthermore, the computation and communication complexities can be
reduced to polynomial in n, log b, and linear in κ.
Proof.
Validity: Suppose that f ≤ t players are corrupted. Hence, according to the
deﬁnition of ExtValBC, all invocations of Protocol 2 achieve broadcast (when
neglecting the grade outputs) and that every correct player pi computes gi = 1.
2
3

For the case of computational security, there is a simpler solution for model Maut .
Note that such an instance does not necessarily achieve broadcast. However, even
then, it will always eﬃciently terminate after T + 1 rounds as can be seen by examination [DS82].

62

M. Fitzi et al.

Thus, the players share a consistent PKI, all correct players pi compute Gi = 1,
and all broadcast invocations in step 4 indeed achieve broadcast. Thus, in steps 3
and 4, the players pi compute values Gji and Γij such that |{j | Gji = 1}| ≥ n−t >
T and |{j | Γij = 1}| ≥ n − t. Finally, all correct players pi compute gi = 1.
Consistency: Suppose f ≤ T . If every correct player pi rejects by computing
gi = 0 then consistency is satisﬁed. Thus, suppose that some correct player pi
accepts by computing gi = 1, implying that some correct player pk computed
Gk = 1. Thus, according to the deﬁnition of ExtValBC, all invocations of Protocol 2 achieved broadcast (when neglecting the grade outputs), and the players
share a consistent PKI. Hence, all broadcast invocations in step 4 indeed achieve
broadcast and all correct players pj compute the same set of values Γj1 , . . . , Γjn .
Since gi = 1, for every correct player p it holds that |{j | Γ j = 1}| ≥ n − t and
thus that |{j | Gj = 1}| ≥ n − t − T > T , and all players p compute g = 1.
Independence, error probability, and complexities: Independence follows from the structure of the Pﬁtzmann-Waidner protocol.
Executing the Pﬁtzmann-Waidner protocol with security parameter κ guarantees each single of the b + n broadcasts to have an error probability of
ε < 2−κ [PW96]. The error probability of each of the b “net” broadcasts is
given by the probability that one of the n broadcasts during step 4 fails and the
probability that the one broadcast fails given that those n broadcasts reliably
worked, which is bounded by (n + 1) times the error probability of one single broadcast precomputed for with the Pﬁtzmann-Waidner protocol. Executing
the Pﬁtzmann-Waidner protocol with security parameter κ0 ≥ κ + log(n + b)
hence bounds the error probability of any single “net” broadcast to ε < 2−κ .
Eﬃciency follows from [PW96] and the construction of Protocol 3. That all
players terminate the protocol during the same communication round is ensured by the synchronization procedure at the end of step 2: in the PﬁtzmannWaidner protocol, the worst-case number of rounds for any player is at most
n2 (9t+10)
[PW96]. Finally, in order to get polylogarithmic dependence on b,
2
the regeneration techniques in [PW96] can be applied.
The above construction for detectable precomputation immediately allows
for broadcast with extended consistency and validity detection:
Theorem 4 (ExtConsBC). In model Msec eﬃcient unconditionally secure
ExtConsBC with respect to thresholds t and T is possible if t + 2T < n (and
T ≥ t).
Proof. In order to achieve ExtConsBC, the players ﬁrst execute a detectable precomputation with Protocol 3. If the precomputation fails (there are more than
t corrupted players), then every player pi sets his output value to yi =⊥ and his
grade to gi = 0. If the precomputation succeeds (which is guaranteed if at most t
players are corrupted), then a valid setup for further Pﬁtzmann-Waidner broadcast is established. Then the players invoke an instance of Pﬁtzmann-Waidner
broadcast (using this setup), which tolerates any number of corrupted players,
and set gi = 1.

Two-Threshold Broadcast and Detectable Multi-party Computation

63

Theorem 5 (Impossibility of ExtConsBC). In standard models Msec and
Maut , ExtConsBC among a set of n players P = {p1 , . . . , pn } is impossible if
t > 0 and t + 2T ≥ n. For every protocol there exists a value xs ∈ {0, 1} such
that, when the sender ps holds input xs , the adversary can make the protocol
fail with a probability of at least 1/6 if it is computationally bounded, and with a
probability of at least 1/3 if it is computationally unbounded.
Proof. Note that a direct proof similar to the one for Theorem 2 would be possible. However, here we use a reduction argument: For the sake of contradiction,
assume that ExtConsBC is possible with respect to thresholds t and T such that
t > 0 and t + 2T ≥ n (and error probability below 1/6 , respectively 1/3 ). Such
a protocol can be transformed into a broadcast protocol with extended validity
(with the same error probabilities) as follows: If ExtConsBC with sender ps succeeds (which can be consistently detected by all players) with player pi receiving
yi , then pi outputs yi and terminates. If ExtConsBC fails (there are more than t
corrupted players), then the sender ps sends his input xs to all players, and every
player outputs the received value. Obviously, this protocol achieves broadcast for
up to t corrupted players and extended validity with consistency detection for
up to T corrupted players. According to Theorem 2, such a protocol cannot
exist with respect to the stated thresholds t and T . Hence ExtConsBC is not
achievable with respect to these thresholds.

5

Detectable Multi-party Computation

Detectable precomputation immediately allows to turn any protocol Ψ (e.g., a
bc
protocol for multi-party computation) in model Mbc
aut (or Msec ) into a “detectable version” for standard model Maut (or Msec ) without broadcast channels. For the case that f ≤ t players are corrupted this transformation preserves
any security properties of Ψ except for zero-error. For the case that f ≤ T players are corrupted the transformation still preserves any security properties of
Ψ except for zero-error and robustness. Robustness is lost since detectable precomputation cannot guarantee validity for T (at least for the interesting cases
where T ≥ n/3). Zero-error is lost since there is no deterministic protocol for
detectable precomputation as follows from Lamport’s result [Lam83].
In particular, it is possible to deﬁne the “detectable” version of multi-party
computation along the lines of [FGMR02].
Deﬁnition 7 (Detectable precomputation for MPC). Let Ψ be an MPC
bc
bc
protocol among P in a model assuming broadcast, model Mbc
∗ ∈ {Maut , Msec },
bc
and let M∗ ∈ {Maut , Msec } be the same model as M∗ but without broadcast. A
protocol among P where every player pi ∈ P computes some private data ∆i and
ﬁnally decides on a decision bit gi ∈ {0, 1} achieves detectable precomputation
for MPC with Ψ with respect to thresholds t and T (T ≥ t), and t , if it satisﬁes
the following conditions:
Robustness: If at most f ≤ t players are corrupted then the correct players
accept (gi = 1).

64

M. Fitzi et al.

Correctness: If f ≤ T then all correct players commonly accept (gi = 1)
or commonly reject (gi = 0) the protocol; moreover, if the private data
∆i held by all correct players is inconsistent in the sense that it does not
guarantee for MPC secure against t corrupted players in model M∗ then
the correct players reject (gi = 0).
Independence: At the time of the precomputation, a correct player does
not yet need to know his input values for the later multi-party computations.
Together with [Bea89,RB89,CDD+ 99], detectable precomputation for broadcast trivially allows for detectable MPC such that only robustness is lost since
non-zero error is necessary for multi-party computation secure against t ≥ n/3
corrupted players [DDWY93]. The following theorem follows immediately from
Theorem 3:
Theorem 6 (Detectable precomputation for MPC). Let Ψ be the MPC
protocol in [CDD+ 99] for model Mbc
sec unconditionally secure against a faulty
minority of corrupted players. In model Msec , detectable precomputation for unconditionally secure MPC with Ψ among n players with respect to thresholds t
and T (T ≥ t), and t , is eﬃciently achievable if (t + 2T < n ∨ t = 0) and
t < n/2.
For the case that t > 0 and t + 2T ≥ n, and t ≥ n/3, detectable precomputation for MPC is not even achievable with respect to computational security.
Proof. Achievability follows from [Bea89,RB89,CDD+ 99] and Theorem 3. Impossibility follows from Theorem 5 together with the impossibility of broadcast
for t ≥ n/3 if no consistent PKI is given.
Alternatively to this theorem, there are protocols for non-robust MPC without fairness for model Mbc
aut [GMW87,BG89a,Gol01] computationally secure
against any number of corrupted players. These protocols can be detectably
precomputed with help of Protocol 3 (or its more eﬃcient computational analogue), which directly leads to corresponding protocols for the weaker model
Maut without broadcast (and without need for a PKI setup).

6

General Adversaries

In contrast to threshold adversaries, general adversaries are characterized by the
possible subsets of players which might be corrupted at the same time. More
precisely, a general adversary is characterized by a collection Z of subsets of the
player set P , i.e., Z ⊆ 2P . A Z-adversary can corrupt the players of one of the
sets in Z. It is known that broadcast secure against a Z-adversary is achievable
if and only if no three sets in Z add up to P [HM97,FM98]. Under the same
condition, secure multi-party computation is possible [HM97]. When no PKI is
set up these bounds are tight.

Two-Threshold Broadcast and Detectable Multi-party Computation

65

Our results on two-threshold security can immediately be generalized to general adversaries. We consider two adversary structures Z and Z ∗ , where Z ⊆ Z ∗ ,
corresponding to the threshold case with t and T , where t ≤ T . A protocol is
(Z, Z ∗ )-secure if it provides full security against an adversary corrupting a set
Z ∈ Z, and degraded security against an adversary corrupting a set Z ∈ Z ∗ . A
broadcast protocol with extended validity (consistency) achieves normal broadcast when any set Z ∈ Z is corrupted, and still provides validity (consistency)
when a set Z ∈ Z ∗ is corrupted. (Z, Z ∗ )-secure broadcast is achievable if and
only if
∀Z1 ∈ Z, Z2 ∈ Z ∗ , Z3 ∈ Z ∗ : Z1 ∪ Z2 ∪ Z3 = P.
Given the constructions for two-threshold broadcast in this paper, the construction of such a protocol with respect to general adversaries is straight-forward.
The above results immediately generalize to detectable multi-party computation.

7

Conclusions

We generalized the standard notion of broadcast to two-threshold broadcast, requiring standard broadcast for the case that f ≤ t players are corrupted and
either validity or consistency when t ≤ f ≤ T . We showed that, for both cases,
(eﬃcient) unconditionally secure two-threshold broadcast is achievable among n
players if and only if t = 0 or t + 2T < n. Our protocol with extended validity
additionally achieves that, when consistency is not reached, all players agree on
this fact (consistency detection); our protocol with extended consistency additionally achieves agreement about the fact whether or not validity is achieved
(validity detection).
In the same way, detectable precomputation can be generalized with respect
to two thresholds t and T . In a model with pairwise channels but without broadcast (and no PKI among the players), such a protocol achieves the following:
– if f ≤ T players are corrupted then either all correct players accept or they
all reject the protocol outcome. If the correct players accept the protocol
outcome then broadcast secure against t < n corrupted players and MPC
secure against t < n/2 corrupted players are achievable from now on.
– if f ≤ t then all correct players accept the protocol outcome.
Detectable precomputation is (eﬃciently) achievable if and only if t + 2T < n or
t = 0.
Acknowledgments. We thank the anonymous referees for their helpful comments.

66

M. Fitzi et al.

References
[Bea89]

D. Beaver. Multiparty protocols tolerating half faulty processors. In
CRYPTO ’89, vol. 435 of LNCS, pp. 560–572. Springer-Verlag, 1989.
[BG89a]
D. Beaver and S. Goldwasser. Multiparty computation with faulty majority. In Proc. 30th FOCS, pp. 468–473. IEEE 1989.
[BG89b]
P. Berman and J. Garay. Asymptotically optimal distributed consensus.
In Proc. 16th International Colloquium on Automata, Languages and Programming, vol. 372 of LNCS, pp. 80–94. Springer-Verlag, 1989.
[BGP89]
P. Berman, J. A. Garay, and K. J. Perry. Towards optimal distributed
consensus. In Proc. 30th FOCS, pp. 410–415. IEEE, 1989.
[BGW88]
M. Ben-Or, S. Goldwasser, and A. Wigderson. Completeness theorems for
non-cryptographic fault-tolerant distributed computation. In Proc. 20th
STOC, pp. 1–10. ACM, 1988.
[BPW91]
B. Baum-Waidner, B. Pﬁtzmann, and M. Waidner. Unconditional Byzantine agreement with good majority. In Proc. 8th Theoretical Aspects of
Computer Science, vol. 480 of LNCS, pp. 285–295. Springer-Verlag, 1991.
[CCD88]
D. Chaum, C. Cr´epeau, and I. Damg˚
ard. Multiparty unconditionally
secure protocols. In Proc. 20th STOC, pp. 11–19. ACM, 1988.
[CDD+ 99] R. Cramer, I. Damg˚
ard, S. Dziembowski, M. Hirt, and T. Rabin. Eﬃcient
multiparty computations secure against an adaptive adversary. In EUROCRYPT ’99, vol. 1592 of LNCS, pp. 311–326. Springer-Verlag, 1999.
[DDWY93] D. Dolev, C. Dwork, O. Waarts, and M. Yung. Perfectly secure message
transmission. Journal of the ACM, 40(1):17–47, 1993.
[DFF+ 82]
D. Dolev, M. J. Fischer, R. Fowler, N. A. Lynch, and H. R. Strong. An
eﬃcient algorithm for Byzantine agreement without authentication. Information and Control, 52(3):257–274, 1982.
[DS82]
D. Dolev and H. R. Strong. Polynomial algorithms for multiple processor
agreement. In Proc. 14th STOC, pp. 401–407. ACM, 1982.
[FGH+ 02] M. Fitzi, D. Gottesman, M. Hirt, T. Holenstein, and A. Smith. Byzantine
agreement secure against faulty majorities from scratch. In Proc. 21st
PODC, ACM, 2002.
[FGM01]
M. Fitzi, N. Gisin, and U. Maurer. Quantum solution to the Byzantine
agreement problem. Physical Review Letters, 87(21), 2001.
[FGMR02] M. Fitzi, N. Gisin, U. Maurer, and O. von Rotz. Unconditional Byzantine
agreement and multi-party computation secure against dishonest minorities from scratch. In EUROCRYPT 2002, vol. 2332 of LNCS. SpringerVerlag, 2002.
[FLM86]
M. J. Fischer, N. A. Lynch, and M. Merritt. Easy impossibility proofs for
distributed consensus problems. Distributed Computing, 1:26–39, 1986.
[FM97]
P. Feldman and S. Micali. An optimal probabilistic protocol for synchronous Byzantine agreement. SIAM Journal on Computing, 26(4):873–
933, 1997.
[FM98]
Matthias Fitzi and Ueli Maurer. Eﬃcient Byzantine agreement secure
against general adversaries. In Proc. 12th DISC, vol. 1499 of LNCS,
pp. 134–148. Springer-Verlag, 1998.
[GL02]
S. Goldwasser and Y. Lindell. Secure computation without agreement.
In Proc. 16th DISC’02, vol. 2508 of LNCS, pp. 17–32. Springer-Verlag,
2002.

Two-Threshold Broadcast and Detectable Multi-party Computation
[GMW87]
[Gol01]
[HM97]

[Hol01]
[KY84]
[Lam83]
[LSP82]

[PW96]

[RB89]
[TC84]

[VP93]

[Yao82]

67

O. Goldreich, S. Micali, and A. Wigderson. How to play any mental game.
In Proc. 19th STOC, pp. 218–229, ACM, 1987.
O. Goldreich. Secure multi-party computation, working draft, version 1.3,
June 2001.
Martin Hirt and Ueli Maurer. Complete characterization of adversaries
tolerable in secure multi-party computation. In Proc. 16th PODC, pp. 25–
34. ACM 1997. Full version in Journal of Cryptology, 13(1):31–60, 2000.
T. Holenstein. Hybrid broadcast protocols. Master’s Thesis, ETH Zurich,
October 2001.
A. Karlin and A. C. Yao. Manuscript, 1984.
L. Lamport. The weak Byzantine generals problem. Journal of the ACM,
30(3):668–676, 1983.
L. Lamport, R. Shostak, and M. Pease. The Byzantine generals problem. Transactions on Programming Languages and Systems, 4(3):382–401.
ACM, 1982.
B. Pﬁtzmann and M. Waidner. Information-theoretic pseudosignatures
and Byzantine agreement for t ≥ n/3. Research Report RZ 2882
(#90830), IBM Research, 1996.
T. Rabin and M. Ben-Or. Veriﬁable secret sharing and multiparty protocols with honest majority. In Proc. 21st STOC, pp. 73–85. ACM, 1989.
R. Turpin and B. A. Coan. Extending binary Byzantine Agreement
to multivalued Byzantine Agreement. Information Processing Letters,
18(2):73–76, 1984.
N. H. Vaidya and D. K. Pradhan. Degradable agreement in the presence
of Byzantine faults. In Proc. 13th International Conference on Distributed
Computing Systems, pp. 237–245. IEEE, 1993.
A. C. Yao. Protocols for secure computations. In Proc. 23rd FOCS, pp.
160–164. IEEE, 1982.

