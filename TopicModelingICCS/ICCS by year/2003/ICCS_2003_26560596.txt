Eﬃcient Multi-party Computation over Rings
Ronald Cramer1 , Serge Fehr1 , Yuval Ishai2 , and Eyal Kushilevitz2
1

BRICS

, Department of Computer Science, ˚
Arhus University, Denmark
{cramer,fehr}@brics.dk
2
Computer Science Department, Technion, Israel
{yuvali,eyalk}@cs.technion.ac.il

Abstract. Secure multi-party computation (MPC) is an active research
area, and a wide range of literature can be found nowadays suggesting
improvements and generalizations of existing protocols in various directions. However, all current techniques for secure MPC apply to functions
that are represented by (boolean or arithmetic) circuits over ﬁnite ﬁelds.
We are motivated by two limitations of these techniques:
– Generality. Existing protocols do not apply to computation over
more general algebraic structures (except via a brute-force simulation of computation in these structures).
– Efficiency. The best known constant-round protocols do not eﬃciently scale even to the case of large ﬁnite ﬁelds.
Our contribution goes in these two directions. First, we propose a basis
for unconditionally secure MPC over an arbitrary ﬁnite ring, an algebraic object with a much less nice structure than a ﬁeld, and obtain
eﬃcient MPC protocols requiring only a black-box access to the ring operations and to random ring elements. Second, we extend these results
to the constant-round setting, and suggest eﬃciency improvements that
are relevant also for the important special case of ﬁelds. We demonstrate
the usefulness of the above results by presenting a novel application of
MPC over (non-ﬁeld) rings to the round-eﬃcient secure computation of
the maximum function.

1

Introduction

Background. The goal of secure multi-party computation (MPC), as introduced
by Yao [37], is to enable a set of players to compute an arbitrary function f of
their private inputs. The computation must guarantee the correctness of the
result while preserving the privacy of the players’ inputs, even if some of the
players are corrupted by an adversary and misbehave in an arbitrary malicious
way. Since the initial plausibility results in this area [38,24,6,10], much eﬀort has
been put into enhancing these results, and nowadays there is a wide range of
literature treating issues like improving the communication complexity (e.g., [22,
23,26]) or the round complexity (e.g., [1,5,3,28]), and coping with more powerful
(e.g., [34,9,8]) or more general (e.g., [25,19,13]) adversaries.
Basic Research in Computer Science (www.brics.dk), funded by the Danish National
Research Foundation.
E. Biham (Ed.): EUROCRYPT 2003, LNCS 2656, pp. 596–613, 2003.
c International Association for Cryptologic Research 2003

Eﬃcient Multi-party Computation over Rings

597

A common restriction on all these results is that the function f is always
assumed to be represented by an arithmetic circuit over a ﬁnite ﬁeld, and hence
all computations “take place” in this ﬁeld. Thus, it is natural to ask whether
MPC can also be eﬃciently implemented over a richer class of structures, such
as arbitrary ﬁnite rings. This question makes sense from a theoretical point of
view, where it may be viewed as a quest for minimizing the axioms on which
eﬃcient secure MPC can be based, but also from a practical point of view, since
a positive answer would allow greater freedom in the representation of f , which
in turn can lead to eﬃciency improvements. Unfortunately, general rings do not
enjoy some of the useful properties of ﬁelds on which standard MPC protocols
rely: non-zero ring elements may not have inverses (in fact, a ring may even not
contain 1, in which case no element is invertible), there might exist zero-divisors,
and the multiplication may not be commutative. Indeed, already over a relatively
“harmless” ring like Zm , Shamir’s secret sharing scheme [36], which serves as the
standard building block for MPC, is not secure a-priori. For instance, if m is even
and if p(X) is a polynomial over Zm hiding a secret s as its free coeﬃcient, then
the share s2 = p(2) is odd if and only if the secret s is odd. Thus, even the
most basic tools for secure MPC have to be modiﬁed before applying them to
the case of rings. A step in this direction was taken in [18,15], where additively
homomorphic secret sharing schemes for arbitrary Abelian groups have been
proposed. However, this step falls short of providing a complete solution to our
problem (which in particular requires both addition and multiplication of shared
secrets), and so the question of MPC over rings remains unanswered.
An additional limitation of current MPC techniques which motivates the current work is related to the eﬃciency of constant-round protocols. Without any
restriction on the number of rounds, most protocols from the literature generalize smoothly to allow arithmetic computation over arbitrary ﬁnite ﬁelds. This is
particularly useful for the case of “numerical” computations, involving integers
or (ﬁnite-precision) reals; indeed, such computations can be naturally embedded
into ﬁelds of a suﬃciently large characteristic. However, in the constant-round
setting the state of aﬀairs is quite diﬀerent. All known protocols for eﬃciently
evaluating a circuit in a constant number of rounds [38,5,11,32] are based on
Yao’s garbled circuit construction, which does not eﬃciently scale to arithmetic
circuits over large ﬁelds.1 The only constant-round protocols in the literature
which do eﬃciently scale to arithmetic computation over large ﬁelds apply to
the weaker computational models of formulas [1] or branching programs [29],
and even for these models their complexity is (at least) quadratic in the representation size. Hence, there are no truly satisfactory solutions to the problem of
constant-round MPC over general ﬁelds, let alone general rings.
1

It is obviously possible to apply the brute-force approach of simulating each ﬁeld
operation by a boolean circuit computing it. However, this approach is unsatisfactory
both from a theoretical point of view (as its complexity grows super-linearly in the
length of a ﬁeld element) and from a practical point of view. The same objection
applies to the implementation of ring operations using ﬁeld or boolean operations.

598

R. Cramer et al.

Our results. In this paper, we propose a basis for obtaining unconditionally
secure MPC over arbitrary ﬁnite rings. In particular, we present an eﬃcient MPC
protocol that requires only black-box access to the ring operations (addition,
subtraction, and multiplication) and the ability to sample random ring elements.
It is perfectly secure with respect to an active adversary corrupting up to t < n/3
of the n players, and its complexity is comparable to the corresponding ﬁeldbased solutions. This is a two-fold improvement over the classical ﬁeld-based
MPC results. It shows that MPC can be eﬃciently implemented over a much
richer class of structures, namely arbitrary ﬁnite rings, and it shows that there
exists in fact one “universal” protocol that works for any ﬁnite ring (and ﬁeld).
Finally, the tools we provide can be combined with other work on MPC, and
hence expand a great body of work on MPC to rings.
On the constant-round front, we make two distinct contributions. First, we
show that the feasibility of MPC over black-box rings carries over to the constantround setting.2 To this end, we formulate and utilize a garbled branching program
construction, based on a recent randomization technique from [29]; however, as
the algebraic machinery which was originally used in its analysis does not apply to general rings, we provide a combinatorially-oriented presentation and
analysis which may be of independent interest. As a second contribution, we
suggest better ways for evaluating natural classes of arithmetic formulas and
branching programs in a constant number of rounds. In particular, we obtain
protocols for small-width branching programs and balanced formulas in which
the communication complexity is nearly linear in their size. The former protocols are based on the garbled branching program construction, and the latter
on a combination of a complexity result from [12] with a variant of randomization technique from [3]. While the main question in this context (namely, that
of obtaining eﬃcient constant-round protocols for arithmetic circuits) remains
open, our techniques may still provide the best available tools for eﬃciently realizing “numerical” MPC tasks that arise in speciﬁc applications. Furthermore,
these techniques may also be beneﬁcial in the two-party setting of [35] (via
the use of a suitable homomorphic encryption scheme) and in conjunction with
computationally-secure MPC (using, e.g., [14]).
We conclude with an example for the potential usefulness of secure MPC over
non-ﬁeld rings. Speciﬁcally, we show how to eﬃciently compute the maximum
of n integers with better round complexity than using alternative approaches.
Organization. Section 2 deals with the model. The main body of the paper
has two parts corresponding to our two main contributions: the ﬁrst deals with
general MPC over rings (Section 3) and the other concentrates on constantround protocols (Section 4). Finally, in Section 5 we describe an application of
MPC over non-ﬁeld rings. A longer version of this paper, which in particular
contains some proofs that were omitted from this version, can be found in [16].
2

This is not clear a-priori, and in fact most randomization techniques used in the
context of constant-round MPC (e.g.,[1,20,3,28]) clearly do not apply to this more
general setting.

Eﬃcient Multi-party Computation over Rings

2

599

Model

We consider the secure-channels model, as introduced in [6,10], where a set
P = {P1 , . . . , Pn } of n players is connected by bilateral, synchronous, reliable
secure channels. For the case of constant-round secure computation, a broadcast
channel is also assumed to be available, while it has to be implemented otherwise. Our goal is to obtain a protocol for securely computing a function given
by an arithmetic circuit over an arbitrary ring R. (In Section 4 we will also be
interested in functions represented by formulas and branching programs over
a ring R.) By default, we consider unconditional or perfect security against an
adaptive, active adversary. The reader is referred to, e.g., [7] for a deﬁnition of
secure protocols in this setting. Such a protocol is black-box if: (1) its description
is independent of R and it only makes black-box calls to the ring operations
(addition, subtraction and multiplication) and to random ring elements; and (2)
its security holds regardless of the underlying ring R, in the sense that each adversary attacking the protocol admits a simulator having only a black-box access
to R.

3
3.1

Multi-party Computation over Rings
Mathematical Preliminaries

We assume the reader to be familiar with basic concepts of group and ring theory.
However, we also make use of the notions of a module and of an algebra, which we
brieﬂy introduce here. Let Λ be a commutative ring with 1. An (additive) Abelian
group G is called a Λ-module if a number multiplication Λ×G → G, (λ, a) → λ·a
is given such that 1 · a = a, λ · (a + b) = (λ · a) + (λ · b), (λ + µ) · a = (λ · a) + (µ · a)
and (λ · µ) · a = λ · (µ · a) for all λ, µ ∈ Λ and a, b ∈ G. Hence, loosely speaking,
a module is a vector space over a ring (instead of over a ﬁeld). An arbitrary
ring R is called a Λ-algebra if (the additive group of) R is a Λ-module and
(λ · a) · b = λ · (a · b) = a · (λ · b) holds for all λ ∈ Λ and a, b ∈ R. For example,
every Abelian group G is a Z-module and every ring R is a Z-algebra; the number
multiplication is given by 0 · a = 0, λ · a = a + · · · + a (λ times) if λ > 0, and
λ · a = −((−λ) · a) if λ < 0. We also write λa or aλ instead of λ · a.
3.2

Span Programs over Rings and Linear Secret Sharing

Monotone span programs over (ﬁnite) ﬁelds were introduced in [30] and turned
out to be in a one-to-one correspondence to linear secret sharing schemes (over
ﬁnite ﬁelds). This notion was extended in [15] to monotone span programs over
(possibly inﬁnite) rings, and it was shown that integer span programs, i.e. span
programs over Z, have a similar correspondence to black-box secret sharing (over
arbitrary Abelian groups). We brieﬂy recall some deﬁnitions and observations.
Deﬁnition 1. A subset Γ of the power set 2P of P is called an access structure
on P if ∅ ∈ Γ and if Γ is closed under taking supersets: A ∈ Γ and A ⊇ A
implies that A ∈ Γ . A subset A of 2P is called an adversary structure on P if
its complement Ac = 2P \ A is an access structure.

600

R. Cramer et al.

Let Λ be an arbitrary (not necessarily ﬁnite) commutative ring with 1. Consider a matrix M over Λ with, say, d rows and e columns (this will be denoted
as M ∈ Λd×e ), a labeling function ψ : {1, . . . , d} → P and the target vector
ε = (1, 0, . . . , 0)T ∈ Λe . The function ψ labels each row of M with a number
corresponding to one of the players. If A ⊆ P then MA denotes the restriction
of M to those rows i with ψ(i) ∈ A, and, similarly, if x denotes an arbitrary
d-vector then xA denotes the restriction to those coordinates i with ψ(i) ∈ A. In
case A = {Pi }, we write Mi and xi instead of MA and xA . Finally, im(·) denotes
the image and ker(·) the kernel (or null-space) of a matrix.
Deﬁnition 2. Let M = (Λ, M, ψ, ε) be a quadruple as above, and let Γ be an
access structure on P. Then, M is called a (monotone)3 span program (over Λ)
for the access structure Γ , or, alternatively, for the adversary structure A = Γ c ,
if for all A ⊆ P the following holds.
• If A ∈ Γ , then ε ∈ im(MAT ), and
• if A ∈ Γ , then there exists κ = (κ1 , . . . , κe )T ∈ ker(MA ) with κ1 = 1.
If Λ = Z then M is called an integer span program, ISP for short. Finally,
size(M) is deﬁned as d, the number of rows of M .
By basic linear algebra, the existence of κ ∈ ker(MA ) with κ1 = 1 implies
that ε ∈ im(MAT ), however the other direction generally only holds if Λ is a ﬁeld.
Let G be an arbitrary ﬁnite Abelian group that can be seen as a Λ-module.
As a consequence, it is well deﬁned how a matrix over Λ acts on a vector with
entries in G. Then, a span program M = (Λ, M, ψ, ε) for an access structure Γ
gives rise to a secret sharing scheme for secrets in G:
To share s ∈ G, the dealer chooses a random vector b = (b1 , . . . , be )T ∈ Ge of
group elements with b1 = s, computes s = M b and, for every player Pi ∈ P,
hands si (privately) to Pi . This is a secure sharing of s, with respect to the access
structure Γ . Namely, if A ∈ Γ then there exists an (A-dependent) vector λ, with
entries in Λ, such that MAT λ = ε. It follows that s can be reconstructed from sA
by sTA λ = (MA b)T λ = bT MAT λ = bT ε = s. On the other hand, if A ∈ Γ then
there exists an (A-dependent) vector κ ∈ Λe with MA κ = 0 and κ1 = 1. For
arbitrary s ∈ G deﬁne s = M (b + κ(s − s)). The secret deﬁned by s equals
s , while on the other hand sA = sA . Hence, the assignment b = b + κ(s − s)
provides a bijection between the random coins (group elements) consistent with
sA and s and those consistent with sA and s . This implies (perfect) privacy.
Note that since every Abelian group G is a Z-module, an ISP gives rise to a
black-box secret sharing scheme [15]. Furthermore, the above applies in particular
to (the additive group of) a ring R which can be seen as a Λ-algebra.
3.3

Multiplicative Span Programs and Secure MPC

The multiplication property for a span program over a ﬁeld has been introduced
in [13]. It essentially requires that the product of two shared secrets can be written as a linear combination of locally computable products of shares. However,
3

Since we consider only monotone span programs, we omit the word “monotone”.

Eﬃcient Multi-party Computation over Rings

601

in our setting (where, given the span program, it is not clear from what ring R
the secret and the shares will be sampled), we deﬁne the multiplication property
as a sole property of the span program.
Let Λ be a commutative ring with 1, and let M = (Λ, M, ψ, ε) be a span
program over Λ for an adversary structure A.
Deﬁnition 3. The span program M is called multiplicative if there exists a
block-diagonal matrix D ∈ Λd×d such that M T DM = εεT , where block-diagonal
is to be understood as follows. Let the rows and columns of D be labeled by ψ,
then the non-zero entries of D are collected in blocks D1 , . . . , Dn such that for
every Pi ∈ P the rows and columns in Di are labeled by Pi .
M is called strongly multiplicative if, for every player set A ∈ A, M restricted
to the complement Ac of A is multiplicative.
As in the case of span programs over ﬁelds (see [13]), for every adversary
structure A there exists a (strongly) multiplicative span program M over Λ for
A if and only if A is Q2 (Q3 ), meaning that no two (three) sets of A cover
the whole player set P [25]. Furthermore, there exists an eﬃcient procedure to
transform any span program M over Λ for a Q2 adversary structure A into a
multiplicative span program M (over Λ) for the same adversary structure A,
such that the size of M is at most twice the size of M.4
Similarly to the ﬁeld case, the multiplication property allows to securely
compute a sharing of the product of two shared secrets. Indeed, let R be a
ﬁnite ring which can be seen as a Λ-algebra, and let s = M b and s = M b
be sharings of two secrets s, s ∈ R. Then, the product ss can be written as
ss = bT ε εT b = bT M T DM b = (M b)T DM b = sT Ds = i sTi Di si , i.e.,
by the special form of D, as the sum of locally computable values. Hence the
multiplication protocol from [23] can be applied: To compute securely a sharing
s = M b of the product ss , every player Pi shares pi = sTi Di si , and then
every player Pi adds up its shares of p1 , . . . , pn , resulting in Pi ’s share si of ss .
Given a multiplicative span program over Λ for a Q2 adversary structure A
(where the multiplication property can always be achieved according to a remark above), it follows that if R is a Λ-algebra, then any circuit over R can be
computed securely with respect to a passive adversary that can (only) eavesdrop
the players of an arbitrary set A ∈ A. Namely, every player shares its private
input(s) using the secret sharing scheme described in Section 3.2, and then the
circuit is securely evaluated gate by gate, the addition gates non-interactively
based on the homomorphic property of the secret sharing scheme, and the multiplication gates using the above mentioned multiplication protocol. Finally, the
(shared) result of the computation is reconstructed. We sketch in Section 3.4
how to achieve security against an active Q3 adversary. Note that a broadcast
channel can be securely implemented using, e.g., [21]. All in all, this proves
4

A similar result concerning the strong multiplication property is not known to exist,
not even in the ﬁeld case.

602

R. Cramer et al.

Theorem 1. Let Λ be a commutative ring with 1, and let M be a (strongly)5
multiplicative span program over Λ for a Q3 adversary structure A. Then there
exists an A-secure MPC protocol to evaluate any arithmetic circuit C over an
arbitrary ﬁnite ring R which can be seen as a Λ-algebra.
Concerning eﬃciency, the communication complexity of the MPC protocol
(in terms of the number of ring elements to be communicated) is polynomial
in n, in the size of M, and in the number of multiplication gates in C.
Corollary 1. Let M be a (strongly) multiplicative ISP for a Q3 adversary structure A. Then there exists an A-secure black-box MPC protocol to evaluate any
arithmetic circuit C over an arbitrary ﬁnite ring R.
The black-box MPC result from Corollary 1 exploits the fact that every ring
R is a Z-algebra.6 If, however, additional information about R is given, it might
be possible to view R as an algebra over another commutative ring Λ with 1.
For example, if the exponent of (the additive group of) R is given, then we
can exploit the fact that R is an algebra over Λ = Z . In many cases, this leads
to smaller span programs and thus to more eﬃcient MPC protocols than in the
black-box case. For instance, if the exponent of R is a prime p then R is an
algebra over the ﬁeld Fp , and we can apply standard techniques to derive span
programs over Fp (or an extension ﬁeld). If the exponent is not prime but, say,
square-free, we can use Chinese Remainder Theorem to construct suitable span
programs. See also Proposition 1 for the case of a threshold adversary structure.
3.4

Adversary Achieving Security against an Active Adversary

Following the paradigm of [13], security against an active adversary can be
achieved by means of a linear distributed commitment and three corresponding auxiliary protocols: a commitment transfer protocol (CTP), a commitment
sharing protocol (CSP) and a commitment multiplication protocol (CMP). A linear distributed commitment allows a player to commit to a secret, however, in
contrast to its cryptographic counterpart, a distributed commitment is perfectly
hiding and binding. A CTP allows to transfer a commitment for a secret from
one player to another, a CSP allows to share a committed secret in a veriﬁable
way such that the players will be committed to their shares, and a CMP allows
to prove that three committed secrets s, s and s satisfy the relation s = ss , if
this is indeed the case. These protocols allow to modify the passively secure MPC
protocol, sketched in Section 3.3, in such a way that at every stage of the MPC
every player is committed to its current intermediary results. This guarantees
detection of dishonest behaviour and thus security against an active adversary. It
is straightforward to verify that the ﬁeld based solutions of [13] can be extended
5
6

Perfect security requires a strongly-multiplicative span program, while an (ordinary)
multiplicative span program is suﬃcient for unconditional security (see Section 3.4).
Note that the corresponding number multiplication can eﬃciently be computed using
standard “double and add”, requiring only black-box access to the addition in R.

Eﬃcient Multi-party Computation over Rings

603

to our more general setting of MPC over an arbitrary ring (please consult the
full version [16] for a more detailed description). As in [13], the perfectly secure
CMP requires a strongly multiplicative span program whereas an ordinary span
program suﬃces for unconditional security.
3.5

Threshold Black-Box MPC

Consider a threshold adversary structure At,n = {A ⊆ P : |A| ≤ t} with 0 < t < n.
Proposition 1. Let Λ be a commutative ring with 1. Assume there exist units
ω1 , . . . , ωn ∈ Λ such that all pairwise diﬀerences ωi − ωj (i = j) are invertible
as well. Then there exists a span program M = (Λ, M, ψ, ε) for At,n of size n,
which is (strongly) multiplicative if and only if t < n/2 (t < n/3): the i-th row
of M is simply (1, ωi , ωi2 , . . . , ωit ), labeled by Pi , and ε = (1, 0, . . . , 0)T ∈ Λt+1 .
The resulting secret sharing scheme (with the secret and shares sampled from
a Λ-module G), formally coincides with the well known Shamir scheme [36],
except that the interpolation points ω1 , . . . , ωn have to be carefully chosen
(from Λ). The security of this generalized Shamir scheme has been proven in
[18,17]. A full proof of Proposition 1 that includes the claim concerning the
(strong) multiplication property can be found in the full version [16].
To achieve black-box MPC over an arbitrary ﬁnite ring R, it suﬃces, by
Corollary 1, to have a (strongly multiplicative) ISP for At,n . Unfortunately, the
ring Λ = Z does not fulﬁll the assumption of Proposition 1 (except for n = 1),
and hence Proposition 1 does not provide the desired ISP. However, by Lemma 1
below, it is in fact suﬃcient to provide a span program over an extension ring
Λ of Z, as it guarantees that any such span program can be “projected” to an
ISP.7 The remaining gap is then closed in Lemma 2 by exhibiting an extension
ring Λ of Z that satisﬁes the assumption of Proposition 1.
Lemma 1. Let f (X) ∈ Z[X] be a monic, irreducible polynomial of non-zero
degree m, and let Λ be the extension ring Λ = Z[X]/(f (X)) of Z. Then, any
span program M over Λ can be (eﬃciently) transformed into an integer span
¯ for the same adversary structure such that size(M)
¯ = m · size(M).
program M
¯
Furthermore, if M is (strongly) multiplicative then this also holds for M.
The ﬁrst part of this lemma appeared in [15]. A full proof of Lemma 1, also
covering the multiplication property, can be found in the full version [16]. For a
proof of Lemma 2 below we refer to [18].
7

Alternatively, one could also “lift” R to an extension ring S ⊇ R which can be seen
as an algebra over Λ ⊇ Z, and then do the MPC over S, using some mechanism that
ensures that the inputs come from the smaller ring R. This approach, which has
also been used in [18] in the context of secret sharing over arbitrary Abelian groups,
would lead to a somewhat more eﬃcient implementation of the MPC protocols;
however, we feel that our approach serves better conceptual simplicity.

604

R. Cramer et al.

Lemma 2. Consider the polynomials ωi (X) = 1 + X + · · · + X i−1 ∈ Z[X] for
i = 1, . . . , n. Then ω1 (X), . . . , ωn (X) and all pairwise diﬀerences ωi (X) − ωj (X)
(i = j) are invertible modulo the cyclotomic polynomial Φq (X) = 1 + X + · · · +
X q−1 ∈ Z[X], where q is a prime greater than n.
Hence, if t < n/3 then by Proposition 1 there exists a strongly-multiplicative
span program M for At,n over the extension ring Λ = Z[X]/(Φq (X)) where
q > n. The size of M is n, and q can be chosen linear in n by Bertrand’s
Postulate. Together with Lemma 1, this implies a strongly-multiplicative ISP of
size O(n2 ), and hence Corollary 1 yields
Corollary 2. For t < n/3, there exists an At,n -secure black-box MPC protocol
to evaluate any arithmetic circuit C over an arbitrary ﬁnite ring R.
A threshold ISP of size O(n log n) was presented in [15] (and proven optimal).
As this construction too is related to Shamir’s scheme, it is not hard to see that
also this ISP is (strongly) multiplicative if and only if t < n/2 (t < n/3).
Hence, it gives rise to another instantiation of the MPC protocol claimed in
Corollary 2. Its communication complexity turns out to coincide asymptotically
with the classical protocols of [6,2,22], up to a possible loss of a factor log n,
which is due to the fact that over large ﬁelds there exist threshold span programs
of size n. Furthermore, our protocol is compatible with improvements to the
communication complexity of non-black-box MPC over ﬁelds [27,26].

4

Constant-Round Protocols

In this section we present constant-round MPC protocols over arbitrary rings.
Our motivation is twofold. First, we complement the results of the previous section by showing that they carry over in their full generality to the constant-round
setting. This does not immediately follow from previous work in the area. Second,
we point out some improvements and simpliﬁcations to previous constant-round
techniques, which also have relevance to the special case of ﬁelds. In particular,
we obtain constant-round protocols for small-width branching programs and balanced formulas in which the communication complexity is nearly linear in their
size.
4.1

Randomizing Polynomials over Rings

The results of the previous section may be viewed as providing a general “compiler”, taking a description of an arithmetic circuit C over some ring R and
producing a description of an MPC protocol for the functionality prescribed by
C. While the communication complexity of the resultant protocol is proportional
to the size of C, its round complexity is proportional to its multiplicative depth.8
8

Multiplicative depth is deﬁned similarly to ordinary circuit depth, except that addition gates and multiplications by constant do not count.

Eﬃcient Multi-party Computation over Rings

605

In particular, constant-degree polynomials over R can be securely evaluated in
a constant number of rounds using black-box access to R. The notion of randomizing polynomials, introduced in [28], provides a convenient framework for
representing complex functions as low-degree polynomials, thereby allowing their
round-eﬃcient secure computation. In the following we generalize this notion to
apply to any function f : Rn → D, where R is an arbitrary ring and D is an
arbitrary set.9
A randomizing polynomials vector over the ring R is a vector p = (p1 , . . . , ps )
of s multivariate polynomials over R, each acting on the same n + m variables
x = (x1 , . . . , xn ) and r = (r1 , . . . , rm ). The variables x are called inputs and
r are called random inputs. The complexity of p is the total number of inputs
and outputs (i.e., s + n + m). Its degree is deﬁned as the maximal degree of its
s entries, where both ordinary inputs and random inputs (but not constants)
count towards the degree.10
Representation of a function f by p is deﬁned as follows. For any x ∈ Rn ,
let P (x) denote the output distribution of p(x, r), induced by a uniform choice
of r ∈ Rm . Note that for any input x, P (x) is a distribution over s-tuples of
ring elements. We say that p represents a function f if the output distribution
P (x) is “equivalent” to the function value f (x). This condition is broken into
two requirements, correctness and privacy, as formalized below.
Deﬁnition 4. A randomizing polynomials vector p(x, r) is a said to represent
the function f : Rn → D if the following requirements hold:
• Correctness. There exists an eﬃcient11 reconstruction algorithm which,
given only a sample from P (x), can correctly compute the output value f (x).
• Privacy. There exists an eﬃcient simulator which, given the output value
f (x), can emulate the output distribution P (x).
We will also consider the relaxed notion of δ-correct randomizing polynomials,
where the reconstruction algorithm is allowed to output “don’t know” with probability δ (but otherwise must be correct).
The application of randomizing polynomials to secure computation, discussed
in [28], is quite straightforward. Given a representation of f (x) by p(x, r), the
secure computation of f can be reduced to the secure computation of the randomized function P (x). The latter, in turn, reduces to the secure computation
def
of the deterministic function p (x, r1 , . . . , ra ) =p(x, r1 + . . . + ra ), where a is the
size of some set A ∈ A, by assigning each input vector rj to a distinct player in
A and instructing it to pick rj at random. Note that the degree of p is the same
as that of p. Moreover, if the reconstruction procedure associated with p requires
only black-box access to R, then this property is maintained by the reduction.
9

10
11

In this section the parameter n is used to denote an input length parameter rather
than the number of players. The input, taken from Rn , may be arbitrarily partitioned
among any number of players.
It is crucial for the MPC application that random inputs count towards the degree.
The eﬃciency requirement can only be meaningfully applied to a family of randomizing polynomials, parameterized by the input size n and the ring R.

606

R. Cramer et al.

Hence, using the results of the previous section, the problem of getting roundeﬃcient MPC over rings reduces to that of obtaining low-degree representations
for the functions of interest.
In the following we describe two constructions of degree-3 randomizing polynomials over rings, drawing on techniques from [29,3].
4.2

Branching Programs over Rings

Branching programs are a useful and well-studied computational model. In particular, they are stronger than the formula model (see Section 4.3). We start by
deﬁning a general notion of branching programs over an arbitrary ring R.
Deﬁnition 5. A branching program BP on inputs x = (x1 , . . . , xn ) over R is
deﬁned by: (1) a DAG (directed acyclic graph) G = (V, E); (2) a weight function
w, assigning to each edge a degree-1 polynomial over R in the input variables. It
is convenient to assume that V = {0, 1, . . . , }, where is referred to as the size of
BP, and that for each edge (i, j) ∈ E it holds that i < j. The function computed
by BP is deﬁned as follows. For each directed path φ = (i1 , i2 , . . . , ik ) in G, the
weight of φ is deﬁned to be the product w(i1 , i2 ) · w(i2 , i3 ) · . . . · w(ik−1 , ik ) (in the
prescribed order). For i < j, we denote by W (i, j) the total weight of all directed
paths from i to j (viewed as a function of x). Finally, the function f : Rn → R
computed by BP is deﬁned by f (x) = W (0, )(x). We refer to W (0, ) as the
output of BP.
Note that, using a simple dynamic programming algorithm, the output of BP
can be evaluated from its edge weights using O(|E|) black-box ring operations.
To represent a branching program by randomizing polynomials, we rely on
a recent construction from [29]. However, applying this construction to general
rings requires a diﬀerent analysis. In particular, the original analysis relies on
properties of the determinant which do not hold in general over non-commutative
rings. Below we provide a more combinatorial interpretation of this construction,
which may be of independent interest.
How to garble a branching program. Given a branching program BP =
(G, w) of size , we deﬁne a randomized procedure producing a “garbled” branch˜ = (G,
˜ w)
˜ will always be the
ing program BP
˜ of the same size . The graph G
˜ We will
complete DAG, i.e., each (i, j) where 0 ≤ i < j ≤ is an edge in G.
sometimes also view G as a complete graph, where w(i, j) = 0 if (i, j) is not
originally an edge. The randomization of BP proceeds in two phases.
Main phase. Let rij , 0 ≤ i < j < , be 2 random and independent ring
elements. Each rij naturally corresponds to an edge. The main randomization
phase modiﬁes each original weight w(i, j) as follows: ﬁrst, if j < , it increases it
by rij . Then, regardless of whether j = , it decreases it by rih · w(h, j) for each
h lying strictly between i and j. That is, the updated weights w (i, j) obtained
at the end of this phase are deﬁned by
j−1

w (i, j) =

w(i, j) + rij − h=i+1 rih · w(h, j), j <
j−1
w(i, j) − h=i+1 rih · w(h, j),
j=

Eﬃcient Multi-party Computation over Rings

607

Note that each w (i, j) is a degree-2 polynomial in the inputs x and the random
inputs rij .
Cleanup phase. In the main phase the weights of the edges entering were not
fully randomized. In some sense, these edges served as “garbage collectors” for
the randomization of the remaining edges. To eliminate the unwanted residual
information about x, the following operation is performed. Let r1 , . . . , r −1 be
independent random ring elements. The new weights w
˜ are the same as w for
(i, j) such that j < , and else are deﬁned by:
−1

w(i,
˜
)=

w (i, ) − j=i+1 w (i, j) · rj ,
i=0
−1
w (i, ) + ri − j=i+1 w (i, j) · rj , i > 0

Note that the weights w(i,
˜
) are degree-3 polynomials in x, r, r and the remaining weights are all of degree 2. Still, each weight w
˜ is of degree 1 in x, and hence
˜ a branching program according to our
any ﬁxed choice of r, r indeed makes BP
deﬁnition.
We deﬁne a randomizing polynomials vector p(x, r, r ) representing BP by the
weights w.
˜ It has degree 3 and complexity O( 2 ). It can
concatenation of all +1
2
be evaluated using O(|E| ) ring operations assuming that each original weight
w depends on a single input variable. We prove its correctness and privacy.
˜ equals
Correctness. It suﬃces to show that on any input x, the value of BP
that of BP, for any choice of r, r . For this, it suﬃces to show that the positive
and negative contributions of each random input cancel each other. Consider the
eﬀect of a speciﬁc random input rij in the main phase. It is involved in two types
of operations: (1) it is added to w(i, j); and (2) rij · w(j, k) is subtracted from
each weight w(i, k) such that k > j. We now compare the contribution of (1)
and (2) to the output W (0, ). Since (1) aﬀects exactly those paths that traverse
the edge (i, j), the positive contribution of (1) is
W (0, i) · rij · W (j, ) .
(Note that, by the distributive law, the above expression covers exactly all directed paths from 0 to passing through (i, j).) Similarly, the negative contribution of (2) is:
W (0, i) · (rij · w(j, k)) · W (k, ) = W (0, i) · rij
k>j

w(j, k) · W (k, )
k>j

= W (0, i) · rij · W (j, )
Hence, the positive and negative contributions of each rij exactly cancel each
other, as required. A similar argument applies to the cleanup phase operations
involving ri (details omitted). To conclude, it suﬃces for the reconstruction
˜ (x, r, r ), which requires
procedure to evaluate the garbled branching program BP
2
O( ) ring operations.
Privacy. We argue that, for any ﬁxed x, the distribution of w
˜ induced by the
random choice of r, r is uniform among all weight assignments having the same

608

R. Cramer et al.

output value as BP on x. First, note that the number of possible choices of
+1
r, r is |R|(2)+( −1) , which is exactly equal to |R|( 2 )−1 , the number of possible
weight assignments in each output class.12 It thus suﬃces to prove that, for any
+1
ﬁxed weight assignment w, the eﬀect of r, r on w (as a function from R( 2 )−1
+1
to R( 2 ) ) is one-to-one. Consider two distinct vectors of random inputs, (r, r )
and (ˆ
r, rˆ ). Order each of them by ﬁrst placing the rij entries in increasing
lexicographic order and then the ri entries in decreasing order. Consider the
ﬁrst position where the two ordered lists diﬀer. It is not hard to verify that if
the ﬁrst diﬀerence is rij = rˆij , where j < , then the weight of (i, j) will diﬀer
after the main phase. (Note that since j < , this weight is untouched in the
cleanup phase.) The second case, where the ﬁrst diﬀerence is ri = rˆi , is similar.
In this case the two random inputs will induce the same change to the weight
of (i, ) in the main phase, and a diﬀerent change in the cleanup phase. Thus,
the garbled weight function is indeed uniformly random over its output class.
Given the above, a simulator may proceed as follows. On output value d ∈ R, the
simulator constructs a branching program BP with w(0, ) = d and w(i, j) = 0
˜ of BP.
elsewhere, and outputs a garbled version BP
Combining the above with the results of the previous section, we have:
Theorem 2. Let BP be a branching program over a black-box ring R, where BP
has size and m edges. Then BP admits a perfectly secure MPC protocol, communicating O( 2 ) ring elements and performing O(m ) ring operations (ignoring
polynomial dependence on the number of players). The protocol may achieve an
optimal security threshold, and its exact number of rounds corresponds to that
of degree-3 polynomials.
Trading communication for rounds. For large branching programs, the
quadratic complexity overhead of the previous construction may be too costly.
While this overhead somehow seems justiﬁed in the general case, where the
description size of BP may also be quadratic in its size , one can certainly
expect improvement in the typical case where BP has a sparse graph. A useful
class of such branching programs are those that have a small width. BP is said
to have length a and width b if the vertices of its graph G can be divided into a
levels of size≤ b each, such that each edge connects two consecutive levels. For
instance, for any binary regular language, the words of length n can be recognized
by a constant-width length-n branching program over Z2 (speciﬁcally, the width
is equal to the number of states in the corresponding automaton).
For the case of small-width branching programs, we can almost eliminate the
quadratic overhead at the expense of a moderate increase in the round complexity. We use the following recursive decomposition approach. Suppose that the
length of BP is broken into s segments of length a/s each. Moreover, suppose
that in each segment all b2 values W (i, j) such that i is in the ﬁrst level of that
12

+1
Indeed, among the |R|( 2 ) possible ways of ﬁxing the weights, there is an equal
representation for each output. A bijection between the weight functions of two
output values d1 , d2 can be obtained by adding d1 − d2 to the weight of (0, ).

Eﬃcient Multi-party Computation over Rings

609

segment and j is in the last level are evaluated. Then, the output of BP can
be computed by a branching program BP of length s and width b, such that
the edge weights of BP are the b2 s weights W (i, j) as above. Thus, the secure
computation of BP can be broken into two stages: ﬁrst evaluate in parallel b2 s
branching programs13 of length a/s and width b each, producing the weights
W (i, j), and then use these weights as inputs to the length-s, width-b branching
program BP , producing the ﬁnal output. This process requires to hide the intermediate results produced by the ﬁrst stage, which can be done with a very small
additional overhead. In fact, a careful implementation (following [3]) allows the
second stage to be carried out using only a single additional round of broadcast.
If the width b of BP is constant, an optimal choice for s is s = O(a2/3 ),
in which case the communication complexity of each of the two stages becomes
O(a4/3 ). This is already a signiﬁcant improvement over the O(a2 ) complexity
given by Theorem 2. Moreover, by recursively repeating this decomposition and
tuning the parameters, the complexity can be made arbitrarily close to linear
while maintaining a (larger) constant number of rounds. In particular, this technique can be used to obtain nearly-linear perfect constant-round protocols for
iterated ring multiplication or for Yao’s millionaires’ problem [37], both of which
admit constant-width linear-length branching programs.

4.3

Arithmetic Formulas

An arithmetic formula over a ring R is deﬁned by a rooted binary tree, whose
leaves are labeled by input variables and constants (more generally, by degree-1
polynomials), and whose internal nodes, called gates, are labeled by either ‘+’
(addition) or ‘×’ (multiplication). If R is non-commutative, the children of each
multiplication node must be ordered. A formula is evaluated in a gate-by-gate
fashion, from the leaves to the root. Its size is deﬁned as the number of leaves
and its depth as the length of the longest path from the root to a leave. A formula
is balanced if it forms a complete binary tree.
We note that the branching program model is strictly stronger than the
formula model. In particular, any formula (even with gates of unbounded fanin) can be simulated by a branching program of the same size. Thus, the results
from Section 4.2 apply to formulas as well.
We combine a complexity result due to Cleve [12] with a variant of a randomization technique due to Beaver [3] (following Kilian [31] and Feige et al. [20])
to obtain an eﬃcient representation of formulas by degree-3 randomizing polynomials. If the formula is balanced, the complexity of this representation can
be made nearly linear in the formula size. However, in contrast to the previous
construction, the current one will not apply to a black-box ring R and will not
oﬀer perfect correctness. Still, for the case of balanced arithmetic formulas, it
can provide better eﬃciency.
13

It is possible to avoid the b2 overhead by modifying the garbled branching program
construction so that all weights W (i, j) in each segment are evaluated at once.

610

R. Cramer et al.

From formulas to iterated matrix product. In [12], it is shown that an
arithmetic formula of depth d over an arbitrary ring R with 1 can be reduced
2
to the iterated product of O((2d )1+ b ) matrices of size c = O(2b ) over R, for
any constant b. Each of these matrices is invertible, and its entries contain only
variables or constants.14 The output of the formula is equal to the top-right
entry of the matrix product. Note that if the formula is balanced, then the total
size of all matrices can be made nearly linear in the formula size.
Next, we consider the problem of randomizing an entry of an iterated matrix
product as above. Having already established the possibility of constant-round
MPC over black-box rings, we focus on eﬃciency issues and restrict our attention
to the special case of ﬁelds. Indeed, the following construction does not apply to
black-box rings (though may still apply with varied eﬃciency to non-ﬁeld rings).
In what follows we let K denote a ﬁnite ﬁeld, K c×c the set of c × c matrices over
K, and GLc (K) the group of invertible c × c matrices over K.
Randomizing an iterated product of invertible matrices. To represent
an iterated matrix product by degree-3 randomizing polynomials, we modify a
randomization technique from [3]. See [16] for a proof of the next proposition.
ˆ 1 be a nonzero row vector
Proposition 2. Let M2 , . . . , Mk−1 ∈ GLc (K), let M
ˆ
and Mk a nonzero column vector. Suppose that at most a (δ/2k)-fraction of the
c × c matrices over K are singular. Then,
ˆ 1 S1 , S2 S1 , S2 M2 S3 , S4 S3 , S4 M3 S5 , . . . , S2k−2 S2k−3 , S2k−2 M
ˆ k ),
(M
where S1 , . . . , S2k−2 are uniformly random matrices, is a δ-correct degree-3 repˆ 1 M2 · · · Mk−1 M
ˆ k.
resentation for the iterated product M
Note that if the ﬁeld K is small, the correctness probability can be boosted
by working over an extension ﬁeld (thereby increasing the probability of picking
invertible matrices).
ˆ 1 and M
ˆ k to be unit vectors, Proposition 2 can be used to
By choosing M
represent a single entry in an iterated product of invertible matrices, as required
for applying Cleve’s reduction. Thus, we have:
Theorem 3. Let F be an arithmetic formula of depth d over a ﬁnite √ﬁeld K.
Then, F admits a constant-round
MPC protocol communicating 2d+O( d) ﬁeld
√
O( log s)
elements (i.e., s · 2
elements if F is a balanced formula of size s). The
protocol can either have a minimal round complexity (corresponding to degree-3
polynomials) with O(|K|−1 ) failure probability, or alternatively achieve perfect
correctness and privacy in an expected constant number of rounds (where the
expected overhead to the number of rounds can be made arbitrarily small).

5

Application: Securely Computing the MAX Function

Aside from its theoretical value, the study of MPC over non-ﬁeld rings is motivated by the possibility of embedding useful computation tasks into their richer
14

The requirement that R has 1 can be dispensed with by using an appropriate extension of R.

Eﬃcient Multi-party Computation over Rings

611

structure. In this section we demonstrate the potential usefulness of this approach by describing an application to the round-eﬃcient secure computation of
the maximum function.
Suppose there are n players, where each player Pi holds an integer yi from
the set {0, 1, . . . , M }. (We consider M to be a feasible quantity.) Our goal is
to design a protocol for securely evaluating max(y1 , . . . , yn ) with the following
optimization criteria in mind. First, we would like the round complexity to be as
small as possible. Second, we want to minimize the communication complexity
subject to the latter requirement.
Our solution proceeds as follows. Let k be a (statistical) security parameter,
and ﬁx a ring R = ZQM where Q is a k-bit prime. We denote the elements of R
by 1, 2, . . . , QM = 0. Consider the degree-2 randomizing polynomial
n

p(x1 , . . . , xn , r1 , . . . , rn ) =

ri xi
i=1

over R. It is not hard to verify that: (1) the additive group of R has exactly
M +1 subgroups, and these subgroups are totally ordered with respect to containment;15 and (2) the output distribution P (x1 , . . . , xn ) is uniform over the maximal (i.e., largest) subgroup generated by an input xi . Speciﬁcally, P (x1 , . . . , xn )
is uniform over the subgroup generated by Qj , where j is the maximal integer
from {0, 1, . . . , M } such that Qj divides all xi .
We are now ready to describe the protocol. First, each player i maps its input
yi to the ring element xi = QM −yi . Next, the players securely sample an element
z from the output distribution P (x1 , . . . , xn ). This task can be reduced to the
secure evaluation of a deterministic degree-2 polynomial over R (see Section 4.1).
Finally, the output of the computation is taken to be the index of the minimal
subgroup of R containing z; i.e., the output is 0 if z = 0 and otherwise it is
M − max{ j : Qj divides z}. Note that the value of z reveals no information
about the inputs yi except what follows from their maximum, and the protocol
produces the correct output except with probability 1/Q ≤ 2−(k−1) . We stress
that an active adversary (or malicious players) cannot gain any advantage by
picking “invalid” inputs x∗i to the evaluation of P . Indeed, any choice of x∗i is
equivalent to a valid choice of xi generating the same subgroup.
We turn to analyze the protocol’s eﬃciency. Recall that our main optimization criterion was the round complexity. The protocol requires the secure evaluation of a single degree-2 polynomial over R. Using oﬀ-the-shelf MPC protocols
(adapted to the ring R as in Section 3), this requires fewer rounds than evaluating degree-3 polynomials or more complex functions.16 The communication
complexity of the protocol is linear in M and polynomial in the number of players. In [16] we discuss several alternative approaches for securely evaluating the
15
16

This should be contrasted with the ﬁeld of the same cardinality, which has 2M
partially ordered additive subgroups.
The exact number of rounds being saved depends on the speciﬁc setting, e.g. on
whether a broadcast channel is available.

612

R. Cramer et al.

maximum function. All of these alternatives either require more rounds, require
a higher communication complexity (quadratic in M ), or fail to remain secure
against an active adversary.
Acknowledgements. We would like to thank Ivan Damg˚
ard and Tal Rabin
for helpful discussions.

References
1. J. Bar-Ilan and D. Beaver. Non-cryptographic fault-tolerant computing in a constant number of rounds of interaction. In Proc. of 8th PODC, pp. 201–209, 1989.
2. D. Beaver. Eﬃcient multiparty protocols using circuit randomization. In Proc. of
CRYPTO ’91, LNCS 576, pp. 420–432, 1991.
3. D. Beaver. Minimal-latency secure function evaluation. In Proc. of EUROCRYPT
’00, LNCS 1807, pp. 335–350, 2000.
4. D. Beaver, J. Feigenbaum, J. Kilian, and P. Rogaway. Security with low communication overhead (extended abstract). In Proc. of CRYPTO ’90, LNCS 537, pp.
62–76, 1990.
5. D. Beaver, S. Micali, and P. Rogaway. The round complexity of secure protocols
(extended abstract). In Proc. of 22nd STOC, pp. 503–513, 1990.
6. M. Ben-Or, S. Goldwasser, and A. Wigderson. Completeness theorems for noncryptographic fault-tolerant distributed computation. In Proc. of 20th STOC, pp.
1–10, 1988.
7. R. Canetti. Security and composition of multiparty cryptographic protocols. In J.
of Cryptology, 13(1):143–202, 2000.
8. R. Canetti. Universally Composable Security: A New Paradigm for Cryptographic
Protocols. In Proc. of 42nd FOCS, pp. 136–145, 2001.
9. R. Canetti, U. Feige, O. Goldreich and M. Naor. Adaptively secure computation.
In Proc. of 28th STOC, pp. 639–648, 1996.
10. D. Chaum, C. Crepeau, and I. Damg˚
ard. Multiparty unconditional secure protocols. In Proc. of 20th STOC, pp. 11–19, 1988.
11. C. Cachin, J. Camenisch, J. Kilian, and J. Muller. One-round secure computation
and secure autonomous mobile agents. In Proc. of 27th ICALP, pp. 512–523, 2000.
12. R. Cleve. Towards Optimal Simulations of Formulas by Bounded-Width Programs.
In Computational Complexity 1: 91–105, 1991.
13. R. Cramer, I. Damg˚
ard, and U. Maurer. General secure multi-party computation
from any linear secret-sharing scheme. In Proc. of EUROCRYPT ’00, LNCS 1807,
pp. 316–334, 2000.
14. R. Cramer, I. Damg˚
ard, and J. Nielsen. Multiparty computation from threshold
homomorphic encryption. In Proc. of EUROCRYPT ’01 , LNCS 2045, pp. 280–299,
2001.
15. R. Cramer and S. Fehr. Optimal black-box secret sharing over arbitrary Abelian
groups. In Proc. of CRYPTO ’02, LNCS 2442, 272–287, 2002.
16. R. Cramer, S. Fehr, Y. Ishai, and E. Kushilevitz. Eﬃcient multi-party computation
over rings. Cryptology ePrint Archive, Report 2003/030, 2003.
17. A. De Santis, Y. Desmedt, Y. Frankel, and M. Yung. How to share a function
securely. In Proc. of 26th STOC, pp. 522–533, 1994.

Eﬃcient Multi-party Computation over Rings

613

18. Y. G. Desmedt and Y. Frankel. Homomorphic zero-knowledge threshold schemes
over any ﬁnite Abelian group. In SIAM Journal on Discrete Mathematics, 7(4):667–
679, 1994.
19. M. Fitzi, M. Hirt, and U. Maurer. Trading correctness for privacy in unconditional
multi-party computation. In Proc. of CRYPTO ’98, LNCS 1462, pp. 121–136,
1998.
20. U. Feige, J. Kilian, and M. Naor. A minimal model for secure computation. In
Proc. of 26th STOC, pp. 554–563, 1994.
21. M. Fitzi and U. Maurer Eﬃcient Byzantine agreement secure against general
adversaries. In Proc. of DISC ’98, LNCS 1499, pp. 134–148, 1998.
22. M. Franklin and M. Yung. Communication complexity of secure computation. In
Proc. of 24th STOC, pp. 699–710, 1992.
23. R. Gennaro, M. O. Rabin, and T. Rabin. Simpliﬁed VSS and fast-track multiparty
computations with applications to threshold cryptography. In Proc. of 17th PODC,
pp. 101–111, 1998.
24. O. Goldreich, S. Micali, and A. Wigderson. How to play any mental game (extended
abstract). In Proc. of 19th STOC, pp. 218–229, 1987.
25. M. Hirt and U. Maurer. Complete characterization of adversaries tolerable in secure
multi-party computation (extended abstract). In Proc. of 16th PODC, 1997, pp.
25–34.
26. M. Hirt and U. Maurer. Robustness for free in unconditional multi-party computation. In Proc. of CRYPTO ’01, LNCS 2139, pp. 101–118, 2001.
27. M. Hirt, U. Maurer, and B. Przydatek. Eﬃcient secure multi-party computation.
In Proc. of ASIACRYPT ’00, LNCS 1976, pp. 143–161, 2000.
28. Y. Ishai and E. Kushilevitz. Randomizing polynomials: A new representation with
applications to round-eﬃcient secure computation. In Proc. of 41th FOCS, pp.
294–304, 2000.
29. Y. Ishai and E. Kushilevitz. Perfect constant-round secure computation via perfect
randomizing polynomials. In Proc. of 29th ICALP, pp. 244–256, 2002.
30. M. Karchmer and A. Wigderson. On span programs. In Proc. of 8th Conference
on Structure in Complexity Theory, pp. 102–111, 1993.
31. J. Kilian. Founding cryptography on oblivious transfer. In Proc. of 20th STOC,
pp. 20–31, 1988.
32. Y. Lindell. Parallel coin-tossing and constant-round secure two-party Computation. In Proc. of CRYPTO ’01, LNCS 2139, pp. 171–189, 2001.
33. M. Naor, and K. Nissim. Communication Preserving Protocols for Secure Function
Evaluation. In Proc. of 33rd STOC, pp. 590–599, 2001.
34. R. Ostrovsky and M. Yung. How to withstand mobile virus attacks. In Proc. of
10th PODC, pp. 51–59, 1991.
35. T. Sandler, A. Young, and M. Yung. Non-interactive cryptocomputing for NC1 .
In Proc. of 40th FOCS, pp. 554–567, 1999.
36. A. Shamir. How to share a secret. CACM, 22(11):612–613, 1979.
37. A. C. Yao. Protocols for secure computations. In Proc. of 23th FOCS, pp. 160–164,
1982.
38. A. C. Yao. How to generate and exchange secrets. In Proc. of 27th FOCS, pp.
162–167, 1986.

