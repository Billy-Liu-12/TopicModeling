A Signature Scheme as Secure as the
Diﬃe-Hellman Problem
Eu-Jin Goh and Stanislaw Jarecki
Computer Science Department, Stanford University, Stanford CA 94305-9045
eujin@cs.stanford.edu, stasio@theory.stanford.edu

Abstract. We show a signature scheme whose security is tightly related
to the Computational Diﬃe-Hellman (CDH) assumption in the Random Oracle Model. Existing discrete-log based signature schemes, such
as ElGamal, DSS, and Schnorr signatures, either require non-standard
assumptions, or their security is only loosely related to the discrete logarithm (DL) assumption using Pointcheval and Stern’s “forking” lemma.
Since the hardness of the CDH problem is widely believed to be closely
related to the hardness of the DL problem, the signature scheme presented here oﬀers better security guarantees than existing discrete-log
based signature schemes. Furthermore, the new scheme has comparable
eﬃciency to existing schemes.
The signature scheme was previously proposed in the cryptographic literature on at least two occasions. However, no security analysis was
done, probably because the scheme was viewed as a slight modiﬁcation
of Schnorr signatures. In particular, the scheme’s tight security reduction
to CDH has remained unnoticed until now. Interestingly, this discrete-log
based signature scheme is similar to the trapdoor permutation based PSS
signatures proposed by Bellare and Rogaway, and has a tight reduction
for a similar reason.
Keywords: Signature Schemes. Computational Diﬃe-Hellman. Discrete
Logarithm. Exact Security. Tight Reductions. Random Oracle Model.

1

Introduction

From the computational complexity view of cryptography, a proof of security for
a signature scheme follows if there exists a polynomial time reduction algorithm
with the following ability: the reduction algorithm can use a poly-time algorithm
that forges a signature to construct another poly-time algorithm that solves a
hard computational problem. If no poly-time algorithm that solves the computational problem exist, then the existence of such a reduction implies that the
signature scheme is also unbreakable in poly-time.
However, such security arguments are asymptotic. In the case of discrete-log
signature schemes, forging signatures is infeasible in prime order groups where
the prime is larger than some threshold length. In practice, we would like to
know exactly how long a prime to use in order to impose a suﬃciently infeasible
computational bound on an adversary.
E. Biham (Ed.): EUROCRYPT 2003, LNCS 2656, pp. 401–415, 2003.
c International Association for Cryptologic Research 2003

402

E.-J. Goh and S. Jarecki

For this purpose, Bellare and Rogaway started an exact method of security
analysis [BR96] where more attention is paid to the computational eﬃciency of
the reduction algorithm. This method allows us to quantify the relation between
the diﬃculty of forging signatures and the hardness of the underlying computational problem. As Micali and Reyzin [MR02] put it, if the reduction is eﬃcient
and hence the relative hardness of forging and that of breaking the underlying
computational assumption is close, we call the reduction tight. If the reduction
is less eﬃcient, we call it close, and if it is signiﬁcantly less eﬃcient, we call it
loose. These terms are imprecise and should be only used to compare diﬀerent
reduction algorithms to deduce the relative strength of diﬀerent security claims.
State of research on signature schemes. The standard deﬁnition of the
security of signature schemes, together with the ﬁrst construction that satisﬁes it, was given by Goldwasser, Micali, and Rivest [GMR88]. The results of
Naor, Yung, and Rompel [NY89,Rom90] imply a signature scheme based on
the discrete-log assumption, but the construction is ineﬃcient and not stateless.
Recently, practical signatures schemes [GHR99,CS00] based on the strong RSA
assumption were proposed.
There are practical signature schemes whose security is tightly related to
weaker computational assumptions such as RSA and factoring, but their security is (so far) proven only in the Random Oracle model. The Random Oracle
model was implicitly considered by Fiat and Shamir [FS86] and rigorously deﬁned by Bellare and Rogaway [BR93]. In this model, we assume that the adversarial algorithms work equally well when a hash function like SHA-1 or MD5 is
replaced by a true random function. This restriction on the adversarial capability appears arbitrary [CGH98], but in practice, given a carefully implemented
hash function, there are no examples of adversarial algorithms which break cryptographic schemes by exploiting the properties of a hash function. An eﬃcient
signature scheme with a tight security reduction to trapdoor permutations was
given in this model by Bellare and Rogaway [BR96]. Recently, Micali and Reyzin
[MR02] showed a number of signature schemes whose security is tightly related
to factoring in this model.
Loose security of discrete-log based signatures. Some discrete-log based
signature schemes, such as ElGamal [ElG85] and DSS [NIS94], require nonstandard assumptions. Other schemes, such as Schnorr signatures [Sch89], the
“Modiﬁed ElGamal” signatures of Pointcheval and Stern [PS96], and some DSS
variants [BPVY00], have security proofs that are only loosely related to the
discrete-log problem. The latter schemes with loose reductions follow a FiatShamir methodology [FS86], which is used to convert any commit-challengerespond identiﬁcation scheme into a signature scheme secure in the Random
Oracle model. The only known reduction converting a forging algorithm for a
Fiat-Shamir based signature scheme into an algorithm that breaks the underlying
computational problem is the “forking” lemma [PS96]. However, this reduction
is ineﬃcient: to break the computational problem with a probability comparable
to the success probability of the signature forger, the reduction algorithm needs

A Signature Scheme as Secure as the Diﬃe-Hellman Problem

403

to execute a full run of the forging algorithm qH times, where qH denotes the
number of hash function queries made by the forger.
If we take 2n hash function evaluations as our infeasible computational
bound, the adversarial algorithm is allowed to make qH = 2n hash function
queries. The forking lemma then implies that if an adversary that breaks Schnorr
signatures in 2n steps exists, then there is an algorithm that computes discrete
logarithms in 22n steps. Therefore, to be provably secure, all signature schemes
based on the discrete-log problem with security parameter n must work in a
group where the discrete-log problem is believed secure with security parameter
2n. In a traditional discrete-log system of a prime ﬁeld Z∗p , the index-calculus
method of breaking the discrete-log problem works in time about O(exp( 3 |p|)).
Hence, a factor of α increase in the security parameter implies a α3 increase
in the length of the modulus p. For example, if the discrete-log problem in a
prime ﬁeld is believed to be infeasible for 1000 bit primes, the “forking” lemma
reduction tells us that Schnorr signatures are secure only in a ﬁeld modulo a
8000 bit prime.
Our contribution: signatures as secure as Diﬃe-Hellman. In this paper,
we present a signature scheme whose security is tightly related to the Computational Diﬃe-Hellman (CDH) assumption in the Random Oracle model. This
signature scheme was previously considered by Chaum and Pedersen [CP92],
and by Jakobsson and Schnorr [JS99]. However, the scheme appeared without
a security analysis, probably because it was viewed as a slight modiﬁcation of
Schnorr signatures. In particular, the scheme’s tight security reduction to CDH
has remained unnoticed until now.
Since the hardness of the CDH problem is widely believed to be closely related
to the hardness of the DL problem [Sho97,BL96,MW99], our signature scheme
oﬀers better security guarantees than well-known discrete-log based signature
schemes. Moreover, by the results of Maurer and Wolf [MW99], we can relate
the security of our signature scheme directly to the hardness of the discretelog problem for a large class of groups in which the discrete-log problem is
believed hard. The resulting security degradation is a factor of about 243 for
log2 (log2 (q)) ≈ 7, where q is the group size.1 This degradation is much better
than the qH = 280 security degradation carried by the forking lemma, which so
far is the only known security argument for discrete-log based schemes in the
Random Oracle model.
Related Work. The main technical trick allowing us to avoid the forking lemma
in the security proof is the replacement of a zero-knowledge proof of knowledge
with a zero-knowledge proof of equality of discrete logarithms. Using a zero
knowledge proof of equality allows for a one-pass simulation in the security
proof, and hence results in a tight security reduction. It is interesting to note
that the same technical idea was used by Gennaro and Shoup to achieve a
1

The size of q recommended by Lenstra [LV01] for the year 2003 is 129 bits long.

404

E.-J. Goh and S. Jarecki

one-pass simulation in a proof of CCA security for a variant of an ElGamal
encryption [SG98].
Recently, Micali and Reyzin showed a diﬀerent way of avoiding the forking
lemma in the security reduction of signature schemes built using the Fiat-Shamir
method [MR02]. Their idea works for a class of signature schemes based on
factoring, and results in tight security reductions for such signatures. However,
their method does not apply to discrete-log based schemes.
Our scheme is similar to the PSS signature scheme [BR96] which has security
that is tightly related to the security of a trap-door permutation (e.g. RSA
or factoring). Our scheme is also similar to the undeniable signature scheme
proposed by Okamoto and Pointcheval [OP01], and to the BLS short signature
scheme [BLS01], both secure under the “Gap Diﬃe-Hellman” assumption.
We remark that in the Generic Group model introduced in the work of
Shoup [Sho97], Schnorr signatures are as secure as the discrete-log problem.
However, the security results in the generic group model imply security only
against a restricted class of adversarial algorithms. Namely, this model considers only algorithms that are oblivious to the representation of the elements in
the group. This is a signiﬁcant restriction because there are known adversarial
algorithms, such as the index-calculus method for ﬁnding discrete logarithms in
Z∗p , which do not fall into this category.

2

Deﬁnitions

In this section, we present some deﬁnitions and notational conventions. We ﬁrst
recall the deﬁnition of a signature scheme.
Deﬁnition 1 (Signature Scheme).
A signature scheme (Gen,Sign,Ver) is a triple of probabilistic algorithms:
– The key generation algorithm Gen that when given a security parameter 1n
as input, outputs a private key (sk) and a public key (pk).
– The signature algorithm Sig that when given sk and a message M as inputs,
produces a signature σ as output.
– The (usually deterministic) veriﬁcation algorithm Ver that when given input (pk, M, σ), either accepts or rejects, such that if (sk, pk) ← Gen(1n ) and
σ ← SIG(sk, M ), then Ver(pk, M, σ) = accept.
We consider signature schemes that are secure against existential forgery under an adaptive chosen message attack (CMA) in the Random Oracle model.
This deﬁnition is an adaptation of the standard existential CMA security deﬁnition [GMR88] to the Random Oracle model. In the deﬁnition below, the “hash
function oracle” is an ideal random function.
Deﬁnition 2 (Existential CMA Security of a Signature Scheme).
A probabilistic algorithm F is said to (t, qH , qsig , )-break a signature scheme
if after running in at most t steps, making at most qH adaptive queries to the

A Signature Scheme as Secure as the Diﬃe-Hellman Problem

405

hash function oracle, and requesting signatures on at most qsig adaptively chosen
messages, F outputs a valid forgery (M, σ) on some new message M (i.e. a
message on which F has not requested a signature) with probability at least ,
where the probability is taken over the coins of F, the Gen and Sig algorithms,
and the hash function oracle.
We say that a signature scheme is (t, qH , qsig , )-secure if no forger can
(t, qH , qsig , )-break it.
Discrete-Log Setting and Notation. We consider groups where the discretelog problem is hard. For notational convenience, we only consider prime order
subgroups of the multiplicative group Z∗p with prime p. However, our results also
carry over to other groups, such as those built on elliptic curves.
Let p and q be large primes. Also let g be a generator of subgroup Gg,p =
{g 0 , . . . , g q−1 } with order q in the multiplicative group Z∗p . We use the triple
(g, p, q) to describe the group Gg,p . All the algorithms discussed in this paper
implicitly take the triple (g, p, q) as input.
Group operations in Gg,p are always modulo p and operations on secret values
are always modulo q. For notational convenience, we will omit the “(mod p)”
and “( mod q)” markers. We denote the bit length of q by |q| = nq . The notation
R

a ← S means that a is picked uniformly at random from set S.
The security of our signature scheme relies on the hardness of the Computational Diﬃe-Hellman (CDH) problem [DH76]:
Deﬁnition 3 (CDH assumption).
A probabilistic algorithm A is said to (t, )-break CDH in a group Gg,p if on
input (g, p, q) and (g a , g b ) and after running in at most t steps, A computes the
Diﬃe-Hellman function, DHg,p (g a , g b ) = g ab , with probability at least , where
the probability is over the coins of A and (a, b) chosen uniformly from Zq × Zq .
We say that group Gg,p is a (t, )-CDH group if no algorithm (t, )-breaks
CDH in Gg,p .
As previously mentioned, there is strong evidence that the CDH problem is
closely related to the hardness of computing discrete logarithms. In particular,
we know an eﬃcient reduction from the discrete-log problem to the CDH problem
for many easily constructible groups Gg,p [MW99].

3

The EDL Signature Scheme

We present the EDL signature scheme and prove that its security is tightly related to the CDH problem. In the introduction, we mentioned that the EDL
signature scheme was previously proposed in the literature [CP92,JS99]. However, the security properties of this scheme have not been examined.
The scheme proceeds as follows: the private key is x ∈ Zq and the public key
is y = g x . To sign a message m, the signer hashes the message m with a random
string r of size nr = 111 to obtain H(m, r) = h, computes z = hx , and outputs

406

E.-J. Goh and S. Jarecki

as a signature (z, r) together with a non-interactive zero-knowledge proof (ZKP)
that DLg (y) = DLh (z).2
We now describe the EDL scheme in full detail: let (p, q, g) be a discretelog triple deﬁning a group Gg,p . Let nr = 111. Let H and H be (ideal) hash
functions where H : {0, 1}∗ → Gg,p and H : (Gg,p )6 → Zq .
– Key Generation Algorithm (Gen)
R
Pick a random x ← Zq as the private key. The corresponding public key is
y ← gx .
– Signing Algorithm (Sign)
The inputs are a secret key x ∈ Zq and a message M ∈ {0, 1}∗ .
R

First pick a random r ← {0, 1}nr . Compute h ← H(m, r) and z ← hx .
Next, prepare a non-interactive ZKP that DLh (z) = DLg (y): pick a random
R

k ← Zq . Compute u ← g k , v ← hk , c ← H (g, h, y, z, u, v) ∈ Zq , and
s ← k + cx.
The signature is σ ← (z, r, s, c).
– Veriﬁcation Algorithm (Ver)
The inputs are a public key y, a message M , and a signature σ = (z, r, s, c).
First compute h ← H(m, r), u ← g s y −c , and v ← hs z −c . Then compute
c = H (g, h, y, z, u, v). If c = c , output valid. Otherwise, output invalid.
Similarity to PSS. The EDL signature scheme is similar to the PSS signature scheme [BR96] (and the RSA identiﬁcation protocol): the veriﬁer sends a
random value h, and the prover responds with z = hx . Recall that in the RSA
identiﬁcation protocol, the inverse of the secret key x in the exponent group Zq
is the public key, and veriﬁcation is done by checking if z (1/x) = h. However, in
the EDL signature scheme, the public key is g x and veriﬁcation is achieved by a
zero-knowledge proof that DLg (y) = DLh (z).
Because EDL and PSS have a similar structure, they both have tight security
reductions to the underlying hard problem of “exponentiating to the secret x
committed in the public key”. In the case of PSS, the hard problem is inverting
the RSA trap-door permutation. And in the case of EDL, the hard problem is
computing the CDH function. Note that a successful forgery in the EDL scheme
requires computing hx on a random public key y = g x , and a random h returned
by the hash function. On input g x , g w , a simulator easily embeds g w into the h
values returned by the hash oracle, and then recovers the CDH value (g w )x from
the successful forgery. This simulator only needs one pass of the simulated CMA
attack to provide a successful forgery for recovering g wx . Hence, the reduction
from the CDH problem to security of the EDL scheme is tight.
Avoiding the Proof of Knowledge. All known signature schemes whose security is reducible to the discrete-log assumption [PS96,OO98,BPVY00] are based
on zero-knowledge proofs of knowledge. Replacing the zero-knowledge proof of
knowledge with a zero-knowledge proof (of discrete-log equality) allows us to
2

Section 4 explains the derivation of the randomness size nr .

A Signature Scheme as Secure as the Diﬃe-Hellman Problem

407

avoid using the “forking lemma” [PS96] in the security proof. Therefore, EDL
does not suﬀer from the 1/qH degradation in security during the reduction
(where qH is the number of hash queries made by the forger).3
The public-coin proof underlying the EDL scheme is the proof of equality of
two discrete logarithms. This proof proceeds as follows: the prover picks k ∈ Zq ,
sends u = g k , v = hk to the veriﬁer. The veriﬁer picks a public random challenge
c ∈ Zq , and the prover responds with s = k + cx. The veriﬁer checks that
g s = uy c and hs = vz c . This proof system is public-coin zero-knowledge because
a simulator given inputs g, h, y, z can pick c and s at random in Zq and compute
u and v from them. This proof system is also a proof of knowledge of x such
that g x = y and hc = z, but we do not rely on this property in our security
analysis. In our analysis, it is suﬃcient that this proof system is an interactive
proof where the prover’s probability of cheating is at most 1/q. This condition
is suﬃcient because if x = DLg (y) is not equal to x = DLh (z), then the prover
can pass only if the public coin c is (k − k )/(x − x), where k = DLg (u) and
k = DLh (v).
This proof system was ﬁrst proposed [CEvdG87] in a slightly diﬀerent variant of zero-knowledge against any veriﬁer and only 1/2 soundness.4 This proof
system can also be viewed as an extension of Schnorr’s public-coin proof of knowledge of discrete logarithm [Sch89], and it is indeed also a proof of knowledge.
However, we do not use the proof-of-knowledge property of this proof system in
our scheme.
Eﬃciency Considerations. The signature size and the signing and veriﬁcation
costs of our scheme are larger than for traditional discrete-log based signature
schemes like DSS or Schnorr, but only if one compares these costs for the two
schemes working in the same group Gg,p . Our construction oﬀers better security
guarantees than the traditional discrete-log based schemes, and can therefore be
used in much smaller groups. Section 4.1 has more details about the complexity/size vs. security bound trade-oﬀs implied by our work.
The signature size is |p| + 2|q| + nr . Signing takes three exponentiations and
veriﬁcation takes two multi-exponentiations [BGMW92]. The cost of a single
(two-element) multi-exponentiation is about 20% more than the cost of a single exponentiation, assuming Montgomery squaring is used. In Section 4, we
3

4

Intuitively, the security of signature schemes based on zero-knowledge proofs of
knowledge relies on the simulator’s ability to re-run the forger several times. If the
simulator gets a successful forgery on the same message on any two runs, the simulator can extract the secret key x from the forger by the proof of knowledge property of
the proof system. Hence, the simulator can solve the discrete logarithm problem of
ﬁnding DLg (y). The forking lemma [PS96] shows that the probability of the simulator obtaining two such forgeries is at least 1/qH of the forger’s probability of success
(because the simulator has to guess the speciﬁc message among the qH messages
submitted to the hash oracle by the forger that will be used by the forger to output
a signature).
See also [CS97] for a modern presentation of this protocol and for techniques for
constructing discrete-log proof systems.

408

E.-J. Goh and S. Jarecki

will compare EDL with other signature schemes, taking into account both the
eﬃciency and the security parameters.
We point out two possible eﬃciency improvements. Firstly, if the signature
includes element v (with the signature size increasing to 2|p| + 2|q| + nr ), the
veriﬁcation time can be reduced to a single (ﬁve element) multi-exponentiation.
The cost of this ﬁve element multi-exponentiation is about 70% more than the
cost of a single exponentiation. Hence, we obtain a 30% reduction in veriﬁcation
cost. Veriﬁcation is done using a simple trick similar to those used to batch
signature veriﬁcation [BGR98]: the veriﬁer picks a random α ∈ Zq , computes
u as g s y −c hsα z −cα v −α , and then carries out the normal veriﬁcation procedure
with u and v. This trick negligibly increases the probability of accepting an
invalid signature by 1/q.
Secondly, unlike the Schnorr signature scheme, EDL signatures are not eﬃcient on-line. However, using the trick of signing random commitments [ST01],
the EDL signature scheme can be as eﬃcient on-line as the Schnorr signature.
The oﬀ-line cost increases to ﬁve exponentiations and the veriﬁcation cost increases to about two exponentiations.
3.1

Security Proof

The following theorem proves a tight security reduction from the hardness of the
CDH problem to the CMA security of the EDL scheme in the Random Oracle
model. We denote the cost of a long exponentiation in Gg,p by Cexp (Gg,p ). Since
the exponentiation cost is the primary factor in the cost of reduction, we ignore
the costs of other operations in the theorem below.
Theorem 1. If G is a (t , )-CDH group then the EDL signature scheme is
(t, qH , qsig , )-secure against existential forgery on adaptive chosen message attack in the Random Oracle model, where
t ≤ t − qH · Cexp (Gg,p )
≥ + qsig · qH · 2−nr + qH · 2−nq
Proof. Let F be a forger that (t, qH , qsig , )-breaks EDL. We construct a “simulator” algorithm S which takes (p, q, g) and (g a , g b ) as inputs. Algorithm S
uses the F algorithm to compute the DHg,p (g a , g b ) function in t steps and
probability where
t ≈ t + (qH + 4.4 · qsig ) · Cexp (Gg,p )
= −

qsig · qH · 2−nr + qsig · (qH + qsig ) · 2−2·nq + 2−nq + qH · 2−nq

(1)
(2)

and the probability goes over (a, b) in Zq × Zq and the randomness used by S
2−2nq for suﬃciently large nq .
and F. Since nr < nq , it follows that 2−nr
Assuming that qH
qsig
1, the theorem follows.
Algorithm S simulates a run of a signature scheme EDL to the forger F.
Algorithm S answers F’s hash function queries, signature oracle queries, and it

A Signature Scheme as Secure as the Diﬃe-Hellman Problem

409

tries to translate F’s possible forgery (m, σ) into an answer to the DHg,p (g a , g b )
function. Algorithm S starts the simulation by providing (p, q, g) and the public
key y = g a as input to F. Then algorithm S answers F’s queries as follows.
Answering H-oracle Queries. If the forger F provides a new query (m, r)
as input to the H-oracle, algorithm S embeds g b into its answer by picking d at
random in Zq , and outputting H(m, r) as h = (g b )d .
Answering H -oracle Queries. The simulator S answers all new answers
queries to the H oracle completely at random.
Answering Signature Queries. Suppose the forger asks for a signature on
message m. Algorithm S has to create a valid signature tuple without knowing
the secret key. In the process, algorithm S deﬁnes some values of the two hash
functions H and H . The simulator proceeds as follows:
R

1. S picks a random r ← {0, 1}nr . If H has been queried on inputs (m, r), it
aborts.
R
2. Otherwise, S picks a random κ ← Zq , sets z = y κ and h = g κ , and deﬁnes
H(m, r) h. Note that DLh (z) = DLg (y) where h = H(m, r).
3. S simulates the non-interactive proof of discrete logarithm equality in a
R
R
standard way: S picks random c ← Zq , s ← Zq , sets u = g s y −c and v =
hs z −c .
4. If H has been queried on inputs (g, h, y, z, u, v) before, S aborts. Otherwise,
it sets H (g, h, y, z, u, v) c and returns the tuple (z, r, s, c) as the signature
of m.
Solving the CDH Problem. If the forger F returns a valid message and
signature pair (m, σ) (where σ = (z, r, s, c)) for some previously unsigned m,
then algorithm S tries to translate this forgery into computing g ab as follows: If
F has not queried the H oracle on (m, r), S aborts. Otherwise h = H(m, r) = g bd
for some d known to simulator S, and the simulator S outputs z 1/d and stops.
If it holds that DLg (y) = DLh (z), then z = ha and hence z = g abd , in which
case algorithm S’s output is equal to g ab .
Let abort be the probability that algorithm S aborts the simulation and let
DL be the probability that F produces a valid forgery but DLg (y) = DLh (z).
Observe that the computational view shown to the forger by the simulator
has the same distribution as the forger’s conversation with an actual signature
scheme and random hash functions except for the probability abort . Hence the
probability that S outputs a correct solution to the CDH challenge DHg,p (g a , g b )
is at least − ( abort + DL ). We now upper bound the abort + DL term.
1. The simulator S might abort at Step 1 of the signature oracle simulation.
This event occurs if S chooses a r that was previously given as input to the
H-oracle. Since there are at most qH such r’s, the probability of aborting is
at most qH · 2−nr . Therefore, the probability that the simulator aborts at
Step 1 for any of the qsig signature queries is less than qsig · qH · 2−nr .

410

E.-J. Goh and S. Jarecki

2. Similarly, simulator S only aborts at Step 4 if it has run into an input
string (g, h, y, z, u, v) on which H has been already queried. Note that this
input string can be represented as (g, g k , y, y k , u, uk ), where u, k are chosen
at random in Gg,p × Zq . Since there are at most qH + qsig such strings on
which H was previously queried on, the probability of collision is at most
(qH + qsig ) · 2−2·nq . Thus, the probability of S aborting at any time in the
simulation at this step is at most approximately qsig · (qH + qsig ) · 2−2·nq .
3. Let N H be the event that the forger F does not query the H-oracle on the
(m, r) which it outputs as part of the forgery. Let N Q be the event that
DLg (y) = DLh (z). We want to compute an upper bound for the probability
Pr[N H ∨ N Q]. Together with the probability of aborting in the signature
simulation phase, this allows us to derive an upper bound for abort + DL .
Observe that Pr[N H ∨ N Q] = Pr[N H ∧ ¬N Q] + Pr[N Q]. We ﬁrst calculate
Pr[N H ∧ ¬N Q]. Pr[N H ∧ ¬N Q] is given by the probability that the forger
F outputs a z such that z −x = h = H(M, r) on a successful forgery. This
probability is 2−nq .
We now calculate Pr[N Q]. Let u = g k , v = hk , y = g x , and z = hx = hx .
Since the signature is valid, we must have u = g s y −c and v = hs z −c for
c = H (g, h, y, z, u, v). Considering only exponents, we have k = s − xc and
k = s − x c. Hence, H (g, h, g x , hx , g k , hk ) = c = (k − k )/(x − x). Since
H is a random oracle, the probability that this equation holds for an input
to H is 1/|Zq | = 2−nq . Therefore, the probability that F ﬁnds such a c in
qH oracle queries is at most qH · 2−nq .
Summing the probabilities, we see that algorithm S solves the CDH problem
with probability (approximately) at least − qsig · qH · 2−nr + qsig · (qH + qsig ) ·
2−2·nq − 2−nq + qH · 2−nq which gives us equation (2).
Running Time of S. The running time of algorithm S is that of running the
forger F and a number of modular exponentiations with exponents belonging
to Zq . Each query to the H-oracle requires one exponentiation. Each query to
the signature oracle requires two exponentiations and two multi-exponentiations.
Adding these values gives the running time in equation (1).

4

Security and Eﬃciency Analysis

Minimum required randomness size. Assume the EDL signature scheme
is (t, qH , qsig , )-broken by some algorithm A. This adversary A can be run repeatedly, and the expected time to produce a forgery is t/ . Let n = log t and
e = log(1/ ). Thus, the security parameter of the EDL scheme is nss ≤ log(t/ ) =
n + e.
A customary bound on the number of signatures that an instance of a signature scheme can generate is qsig ≤ 230 . If we assume that evaluating a hash
function is a unit operation, there can be at most qH ≤ t = 2n hash oracle

A Signature Scheme as Secure as the Diﬃe-Hellman Problem

411

queries. We also assume that an exponentiation in Gg,p takes about 100 times
longer than one hash query. Using these assumptions in Theorem 1, we obtain
t ≈ t + qH · Cexp (Gg,p ) ≈ 2n+7
and
≈ − (qsig · qH · 2−nr + qH · 2−nq ) = 2−e − (2n+30−nr + 2n−nq ).
√
Because of the O( q) security of discrete-log in Gg,p , we have nq > 2n,
and 2n−nq < 2−nq /2 is negligible. Therefore, for
to be at least /2, we
need −e > (n + 30 − nr ), and hence also require that nr > nss + 30. Setting
nr = nss + 31 and assuming that computations that take time greater than 280
are infeasible, we get nr = 111.
Relative “tightness” and its implications. Note that the bound on the
reduction time is t ≈ t · 27 and ≈ /2, which means that our reduction carries
a small factor of 28 decrease in security. Therefore, to get a provable 280 hardness
bound on our signature scheme in the random oracle model, we need a group
Gg,p with at least 288 security of the CDH problem. Recall that other discretelog based signatures encounter a qH = 280 security degradation via the “forking
lemma” reduction. Hence, to achieve the same 280 hardness bound, they require
a group Gg,p with a 2160 security of the discrete-log problem. If we assume a
widely held belief that the CDH and DL problems have comparable security, our
scheme is as secure as the standard discrete-log based schemes over groups with
half the security parameter for the DL or CDH problem.
Moreover, by the results of Maurer and Wolf [MW99], our scheme achieves
better provable security under the DL assumption alone than traditional
discrete-log based signatures (in a large class of groups). Maurer and Wolf show
that for a large class of groups, there exist an eﬃcient reduction from DL to CDH.
Their reduction algorithm solves the DL problem by invoking a perfect CDH oracle O((log q)5 ) times, where q is the (prime) size of the group. Since a forger
against our signature scheme implements a perfect oracle, taking log q ≈ 128,
the Maurer and Wolf reduction encounters a (128)5 = 235 decrease in the security parameter. Combining the two reductions show that our scheme provably
achieves (in the Random Oracle model) the 280 bound in a group Gg,p with
a 280+35+8 = 2123 security of the DL problem, provided that the DL to CDH
reduction of Maurer and Wolf holds for this group.
In summary, we call our scheme tightly related to the CDH problem because
the 28 security degradation is small, and closely related to the DL problem
because the 235+8 = 243 degradation is medium. At the same time, we call
other discrete-log based schemes loosely related to the DL problem because the
280 degradation is large. Indeed, the terms tight, close, and loose are used only
comparatively.

412

4.1

E.-J. Goh and S. Jarecki

Security vs. Eﬃciency Trade-Oﬀs

Signature size increases or stays constant. Signatures produced by our
scheme are tuples in (Gq × {0, 1}111 × Zq × Zq ). In other discrete-log schemes,
like DSS or Schnorr, the signature is a pair of elements in Zq . In a traditional
discrete-log setting over a ﬁeld Z∗p , taking |p| ≈ 1000 and |q| ≈ 160, our signatures
are 4 to 5 times longer, but with much better security guarantees. If we instead
require security guarantees for traditional signature schemes that are comparable
to EDL, then assuming CDH ≈ DL, traditional discrete-log signatures need
|q| = |Gg,p | values that are two times larger than EDL signatures. In this case,
our signatures are 2 to 2.5 times longer.
The signature size comparison is more favorable for our scheme in elliptic
curve systems where elements in Gg,p have a representation of similar size to
elements in Zq . Assuming that the two schemes work over the same curve, our
signature is about twice the size of traditional discrete-log signatures. But if we
require similar security guarantees based on the CDH ≈ DL assumption, our
signatures become slightly smaller than the traditional discrete-log signatures
implemented over elliptic curves.
Signature generation and veriﬁcation time decrease. The computational
costs in our scheme are three exponentiations for the signer and about two exponentiations for the veriﬁer. Traditional signatures require one exponentiation for
signing and veriﬁcation. However, if we compare the signature schemes based on
similar levels of security (assuming CDH ≈ DL), traditional signatures need to
use larger groups. Recall that the cost of exponentiation in a ﬁeld of q elements
is proportional to |q| times the multiplication cost. The best multiplication algorithms have a cost of at least O(|p|1.6 ). Therefore, a factor of α increase in |q|
and a factor of β increase in |p| results in a α · β 1.6 increase in the exponentiation
cost.
In the traditional discrete-log setting of a prime ﬁeld Z∗p , the index-calculus
method of breaking the discrete-log problem works in time about O(exp( 3 |p|)).
Hence, a factor of 2 increase in the security parameter implies β = 23 increase in
the length of the modulus p. The size of the group |q| increases by factor α = 2
because of baby-step/giant-step algorithm which works in time O(exp(|q|/2)).
Therefore, under the CDH ≈ DL assumption, the exponentiation cost in a
traditional signature scheme with security guarantees matching our scheme is
2 · 81.6 ≈ 56 times than in our scheme. Our signature operation is thus about
56/3 ≈ 18 times faster and the veriﬁcation is 56/2 = 27 times faster. For elliptic
curve groups, to match the security guarantees of the new scheme, we need a
α = β = 2 factor increase in the size of the representation of the group. Hence,
the exponentiation cost for traditional schemes on elliptic curves matching the
security bounds of our scheme is 2 · 21.6 ≈ 6 times larger, which still makes our
signer two times faster and the veriﬁer three times faster.

A Signature Scheme as Secure as the Diﬃe-Hellman Problem

5

413

Open Problems

We see several interesting open problems: (1) One question is to ﬁnd a signature
scheme that has a tight security reduction to CDH or DL, but whose signature
size and signing and veriﬁcation times are the same as those in the traditional
signature schemes, even when the two schemes work in the same group. (2)
Another question is to ﬁnd a signature scheme that improves on the “forking
lemma” reduction to the DL assumption for a larger class of groups than those
of Maurer and Wolf [MW99]. (3) Another interesting question is to ﬁnd a blind
signature scheme with a tight security reduction to the CDH problem.
Acknowledgments. The authors thank Dan Boneh and the anonymous referees for their helpful comments. The authors were supported by a Packard
Foundation Fellowship and NSF grant CCR-0205733.

References
[BGMW92] Ernest Brickell, Daniel Gordon, Kevin McCurley, and David Wilson. Fast
exponentiation with precomputation. In R.A. Rueppel, editor, Proceedings of Eurocrypt 1992, volume 0658 of LNCS, pages 200–207. SpringerVerlag, May 1992.
[BGR98]
Mihir Bellare, Juan Garay, and Tal Rabin. Fast batch veriﬁcation for
modular exponentiation and digital signatures. In K. Nyberg, editor,
Proceedings of Eurocrypt 1998, volume 1403 of LNCS, pages 236–250.
Springer-Verlag, May 1998.
[BL96]
Dan Boneh and Richard Lipton. Algorithms for black-box ﬁelds and
their application to cryptography. In Neal Koblitz, editor, Proceedings
of Crypto 1996, volume 1109 of LNCS, pages 283–297. Springer-Verlag,
May 1996.
[BLS01]
Dan Boneh, Ben Lynn, and Hovav Shacham. Short signatures from the
Weil pairing. In C. Boyd, editor, Proceedings of Asiacrypt 2001, volume
2248 of LNCS, pages 514–532. Springer-Verlag, December 2001.
[BPVY00]
Ernest Brickell, David Pointcheval, Serge Vaudenay, and Moti Yung. Design validations for discrete logarithm based signature schemes. In Hideki
Imai and Yuliang Zheng, editors, Proceedings of PKC 2000, volume 1751
of LNCS, pages 276–292. Springer-Verlag, January 2000.
[BR93]
Mihir Bellare and Phillip Rogaway. Random oracles are practical: a
paradigm for designing eﬃcient protocols. In Proceedings of the 1st
ACM conference on Computer and Communications Security, pages 62–
73. ACM Press, 1993.
[BR96]
Mihir Bellare and Phillip Rogaway. The exact security of digital signatures - How to sign with RSA and Rabin. In Ueli Maurer, editor,
Proceedings of Eurocrypt 1996, volume 1070 of LNCS, pages 399–416.
Springer-Verlag, May 1996.
[CEvdG87] David Chaum, Jan-Hendrik Evertse, and Jeroen van de Graaf. An improved protocol for demonstrating possession of discrete logarithms and
some generalizations. In David Chaum and Wyn Price, editors, Proceedings of Eurocrypt 1987, volume 0304 of LNCS, pages 127–142. SpringerVerlag, May 1987.

414

E.-J. Goh and S. Jarecki

[CGH98]

[CP92]

[CS97]

[CS00]

[DH76]

[ElG85]

[FS86]

[GHR99]

[GMR88]

[JS99]

[LV01]
[MR02]
[MW99]

[NIS94]
[NY89]

[OO98]

Ran Canetti, Oded Goldreich, and Shai Halevi. The random oracle
methodology, revisited. In Proceedings of the 30th annual ACM symposium on Theory of Computing, pages 209–218. ACM Press, 1998.
David Chaum and Torben Pryds Pedersen. Wallet databases with observers. In Ernest Brickell, editor, Proceedings of Crypto 1992, volume
0740 of LNCS, pages 89–105. Springer-Verlag, August 1992.
Jan Camenisch and Markus Stadler. Proof systems for general statements
about discrete logarithms. Technical Report 260, Institute for Theoretical
Computer Science, ETH Z¨
urich, March 1997.
Ronald Cramer and Victor Shoup. Signature schemes based on the strong
RSA assumption. ACM Transactions on Information and System Security, 3(3):161–185, 2000.
Whitﬁeld Diﬃe and Martin Hellman. New directions in cryptography.
IEEE Transactions on Information Theory, 22(6):644–654, November
1976.
Taher ElGamal. A public key cryptosystem and a signature scheme
based on discrete logarithms. IEEE Transactions on Information Theory,
31(4):469–472, July 1985.
Amos Fiat and Adi Shamir. How to prove yourself: Practical solutions to
identiﬁcation and signature problems. In Andrew Odlyzko, editor, Proceedings of Crypto 1986, volume 0263 of LNCS, pages 186–194. SpringerVerlag, August 1986.
Rosario Gennaro, Shai Halevi, and Tal Rabin. Secure hash-and-sign signatures without the random oracle. In Jacques Stern, editor, Proceedings
of Eurocrypt 1999, volume 1592 of LNCS, pages 123–139. Springer-Verlag,
May 1999.
Shaﬁ Goldwasser, Silvio Micali, and Ronald Rivest. A digital signature
scheme secure against adaptive chosen-message attacks. SIAM Journal
on Computing, 17(2):281–308, 1988.
Markus Jakobsson and Claus-Peter Schnorr. Eﬃcient oblivious proofs of
correct exponentiation. In Bart Preneel, editor, Proceedings of the IFIP
Conference on Communications and Multimedia Security 1999, volume
152, pages 71–86. Kluwer, September 1999.
Arjen Lenstra and Eric Verheul. Selecting cryptographic key sizes. Journal of Cryptology, 14(4):255–293, 2001.
Silvio Micali and Leonid Reyzin. Improving the exact security of digital
signature schemes. Journal of Cryptology, 15(1):1–18, 2002.
Ueli Maurer and Stefan Wolf. The relationship between breaking the
Diﬃe-Hellman protocol and computing discrete logarithms. SIAM Journal on Computing, 28(5):1689–1721, 1999.
NIST. Digital Signature Standard (DSS). Publication 196, Federal Information Processing Standards, November 1994.
Moni Naor and Moti Yung. Universal one-way hash functions and their
cryptographic applications. In Proceedings of the 21st annual ACM symposium on Theory of Computing, pages 33–43. ACM Press, 1989.
Kazuo Ohta and Tatsuaki Okamoto. On concrete security treatment of
signatures derived from identiﬁcation. In Hugo Krawczyk, editor, Proceedings of Crypto 1998, volume 1462 of LNCS, pages 354–369. SpringerVerlag, August 1998.

A Signature Scheme as Secure as the Diﬃe-Hellman Problem
[OP01]

[PS96]

[Rom90]

[Sch89]

[SG98]

[Sho97]

[ST01]

415

Tatsuaki Okamoto and David Pointcheval. The Gap-Problems: A new
class of problems for the security of cryptographic schemes. In Kwangjo
Kim, editor, Proceedings of PKC 2001, volume 1992 of LNCS, pages 104–
118. Springer-Verlag, February 2001.
David Pointcheval and Jacques Stern. Security proofs for signature
schemes. In Ueli Maurer, editor, Proceedings of Eurocrypt 1996, volume
1070 of LNCS, pages 387–398. Springer-Verlag, May 1996.
J. Rompel. One-way functions are necessary and suﬃcient for secure
signatures. In Proceedings of the 22nd annual ACM symposium on Theory
of Computing, pages 387–394. ACM Press, 1990.
Claus-Peter Schnorr. Eﬃcient identiﬁcation and signatures for smart
cards. In G. Brassard, editor, Proceedings of Crypto 1989, volume 0435
of LNCS, pages 239–252. Springer-Verlag, August 1989.
Victor Shoup and Rosario Gennaro. Securing threshold cryptosystems
against chosen ciphertext attack. In Kaisa Nyberg, editor, Proceedings
of Eurocrypt 1998, volume 1403 of LNCS, pages 1–16. Springer-Verlag,
May 1998.
Victor Shoup. Lower bounds for discrete logarithms and related problems.
In Walter Fumy, editor, Proceedings of Eurocrypt 1997, volume 1233 of
LNCS, pages 256–266. Springer-Verlag, May 1997.
Adi Shamir and Yael Tauman. Improved online/oﬄine signature schemes.
In Joe Killian, editor, Proceedings of Crypto 2001, volume 2139 of LNCS,
pages 355–367. Springer-Verlag, August 2001.

