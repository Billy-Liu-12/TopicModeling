Certiﬁcate-Based Encryption and the Certiﬁcate
Revocation Problem
Craig Gentry
DoCoMo USA Labs
cgentry@docomolabs-usa.com

Abstract. We introduce the notion of certiﬁcate-based encryption. In
this model, a certiﬁcate – or, more generally, a signature – acts not only
as a certiﬁcate but also as a decryption key. To decrypt a message, a
keyholder needs both its secret key and an up-to-date certiﬁcate from
its CA (or a signature from an authorizer). Certiﬁcate-based encryption
combines the best aspects of identity-based encryption (implicit certiﬁcation) and public key encryption (no escrow). We demonstrate how
certiﬁcate-based encryption can be used to construct an eﬃcient PKI
requiring less infrastructure than previous proposals, including Micali’s
Novomodo, Naor-Nissim and Aiello-Lodha-Ostrovsky.

1

Introduction

A (digital) certiﬁcate is a signature by a trusted certiﬁcate authority (CA)
that securely binds together several quantities. Typically, these quantities include at least the name of a user U and its public key P K. Often, the CA
includes a serial number SN (to simplify its management of the certiﬁcates),
as well as the certiﬁcate’s issue date D1 and expiration date D2 . By issuing
SigCA (U, P K, SN, D1 , D2 ), the CA basically attests to its belief that P K is
(and will be) user U ’s authentic public key from the current date D1 to the
future date D2 .
Since CAs cannot tell the future, circumstances may require a certiﬁcate to
be revoked before its intended expiration date. For example, if a user accidentally reveals its secret key or an attacker actively compromises it, the user itself
may request revocation of its certiﬁcate. Alternatively, the user’s company may
request revocation if the user leaves the company or changes position and is no
longer entitled to use the key.
If a certiﬁcate is revocable, then third parties cannot rely on that certiﬁcate
unless the CA distributes certiﬁcate status information indicating whether the
certiﬁcate is currently valid. This certiﬁcate status information must be fresh
– e.g., to within a day. Moreover, it must be widely distributed (to all relying parties). Distributing large amounts of fresh certiﬁcation information is the
“certiﬁcate revocation problem.” Solving this problem seems to require a lot of
infrastructure, and the apparent need for this infrastructure is often cited as a
reason against widespread implementation of public-key cryptography.
E. Biham (Ed.): EUROCRYPT 2003, LNCS 2656, pp. 272–293, 2003.
c International Association for Cryptologic Research 2003

Certiﬁcate-Based Encryption and the Certiﬁcate Revocation Problem

1.1

273

Some Previous Solutions to the Certiﬁcate Revocation Problem

The most well-known – and a very ineﬃcient – public-key infrastructure (PKI)
proposal is the certiﬁcate revocation list (CRL). A CRL is simply a list of certiﬁcates that have been revoked before their intended expiration date. The CA
issues this list periodically, together with its signature. Since the CA will likely
revoke many of its certiﬁcates – say, 10% if they are issued with an intended
validity period of one year [15] – the CRL will be quite long if the CA has
many clients. Nonetheless, the complete list must be transmitted to any party
that wants to perform a certiﬁcate status check. There are reﬁnements to this
approach, such as delta CRLs that list only those certiﬁcates that have been
revoked since the CA’s last update, but the transmission costs, and the infrastructural costs necessary to enable the transmission, are still quite high.
Another proposal is called the Online Certiﬁcate Status Protocol (OCSP).
The CA responds to a certiﬁcate status query by generating (online) a fresh
signature on the certiﬁcate’s current status. This reduces transmission costs to
a single signature per query, but it substantially increases computation costs. It
also decreases security: if the CA is centralized, it becomes highly vulnerable to
denial-of-service (DoS) attacks; if it is distributed and each server has its own
secret key, then compromising any server compromises the entire system [15].
A much more promising line of research, which has not received enough
attention from industry, was initiated by Micali [14], [15]. (See also [16], [1],
[12].) Similar to previous PKI proposals, Micali’s “Novomodo” system involves
a CA, one or more directories (to distribute the certiﬁcation information), and
the users. However, it achieves better eﬃciency than CRLs and OCSP, without
sacriﬁces in security.
Micali’s basic scheme (slightly oversimpliﬁed) is as follows. For each client,
the CA chooses a random 160-bit value X0 and repeatedly applies a public oneway hash function to it to obtain the 160-bit value Xn , where Xi = H(Xi−1 ).1
The CA includes Xn in the client’s certiﬁcate: SigCA (U, P K, SN, D1 , D2 , Xn ).
If U ’s certiﬁcate is still valid on the ith day after issuance, the CA sends the
value of Xn−i to the directories; otherwise, it does not. In the former case, third
party T can verify that U ’s certiﬁcate is still valid by querying a directory, and
then checking that H i (Xn−i ) (i times) equals Xn , the value embedded in U ’s
certiﬁcate.
The advantage of Novomodo over a CRL-based system is that a directory’s
response to a certiﬁcate status query is concise – just 160 bits (if T has cached
SigCA (U, . . . , Xn )). The length of a CRL, on the other hand, grows with the
number of certiﬁcates that have been revoked. Novomodo has several advantages
over OCSP. First, since hashing is computationally cheaper than signing, the
CA’s computational load in Novomodo is typically much lower. Second, unlike
the distributed components of an OCSP CA, the directories in Novomodo need
not be trusted. Instead of producing signatures that are relied on by third parties,
1

For example, the one-way hash may be SHA1, and n may equal 365 if the intended
validity period of a certiﬁcate is one year and we want a freshness of one day.

274

C. Gentry

the directories merely distribute hash preimages sent by the CA (which they
cannot produce on their own). Third, the lack of online computation by the
directories makes Novomodo less susceptible to DoS attacks. Finally, although
OCSP already has fairly low directory-to-user communication (one constantlength signature per query), Novomodo’s is typically even lower, since public-key
signatures are typically longer than 160 bits.
Following Micali’s proposal, Naor-Nissim [16] and Aiello-Lodha-Ostrovsky
[1] proposed diﬀerent hash-based systems with diﬀerent computation and communication tradeoﬀs. Essentially, both of these proposals use binary trees to
reduce the CA’s computation even further, as well as to reduce CA-directory
communication.
1.2

The Problem with Third-Party Queries

Novomodo and related proposals are improvements over CRLs and OCSP. However, the infrastructural requirements of these approaches can vary dramatically,
depending on how users use their keys. Suppose that users’ keys are used only to
generate and verify signatures (never to encrypt and decrypt). In this case, we
do not need any infrastructure to deal with third-party queries – i.e., queries by
one party on a diﬀerent party’s certiﬁcate status. Why not? – because a signer
can simply send its proof of certiﬁcate status to the veriﬁer simultaneously with
its signature. In other words, when a protocol allows a client to furnish its certiﬁcate status, no third-party queries are necessary. We only need infrastructure
that allows each client to obtain its own proof of certiﬁcation.
However, the situation may be diﬀerent if users use their keys for encryption
and decryption. In this case, third party T must obtain U ’s certiﬁcation status
before sending an encrypted message to U . Getting this information directly from
U may not be an option in high-latency applications like email (where U might
not respond promptly), or in applications where it is preferable to avoid the extra
round trip. Conceivably, T could obtain U ’s certiﬁcate status from some other
source – perhaps a server aﬃliated with U but not with the CA – but this seems
ad hoc, and it still requires an extra round trip. Novomodo and related proposals
would address this situation by allowing T to make a third-party query.
We would like to eliminate, or at least strongly disincentivize, third-party
queries for several reasons. First, since third party queries can come from anywhere and concern any client, every certiﬁcate server in the system must be able
to ascertain the certiﬁcate status of every client in the system. The situation
is much cleaner if third-party queries are eliminated. Each server only needs to
have certiﬁcation proofs for the clients that it serves. Moreover, these proofs
could be “pushed” to clients, and multicast might be used to dramatically reduce the CA’s transmission costs. Second, third party queries multiply the query
processing costs of the CA and/or its servers. For example, suppose each client
queries the certiﬁcation status of 10 other clients per day. Then, the system must
process 10N queries (where N is the number of clients), rather than just N (if
each client only retrieves its own daily proof of certiﬁcation). Third, nonclient
queries are undesirable from a business model perspective: if T is not a client

Certiﬁcate-Based Encryption and the Certiﬁcate Revocation Problem

275

of U ’s CA, what incentive does the CA have to give T fresh certiﬁcate status
information? Finally, there is a security consideration: if the CA must respond
to queries from nonclients, it becomes more susceptible to DoS attacks. In summary, eliminating third-party queries allows a CA to reduce its infrastructural
costs, simplify its business model and enhance security.
So, how can we eliminate third-party queries without constraining how users
use their keys? We will use an approach based on implicit certiﬁcation 2 – i.e.,
where T , without obtaining explicit information other than U ’s public key and
the parameters of U ’s CA, can encrypt its message to U so that U can decrypt
only if it is currently certiﬁed. 3 This will allow us to enjoy the infrastructural
beneﬁts of eliminating third-party queries, regardless of how users use their keys.
1.3

Identity-Based Encryption

One way to achieve implicit certiﬁcation in the encryption context is identitybased encryption (IBE). Shamir [18] originated the concept of identity-based
cryptography in 1984, describing an identity-based signature scheme in the same
article. However, fully practical IBE schemes have been discovered only recently.
We brieﬂy review IBE below.
An IBE scheme uses a trusted third party called a Private Key Generator
(PKG). To set up, the PKG generates a master secret s, and it publishes certain
system parameters params that include a public key that masks s. The PKG
may have many clients. Each client has some ID, which is simply a string that
identiﬁes it – e.g., the client’s email address. The main algorithms in IBE are as
follows.
1. Private key generation: For a given string ID, PKG uses (s, params, ID)
to compute the corresponding private key dID .
2. Encryption: Sender uses (params, ID, M ) to compute C, ciphertext for M .
3. Decryption: Client uses (params, dID , C) to recover M .
Notice that a client’s public key, ID, can be arbitrary, but standardizing
its format allows senders to “guess” the client’s public key rather than obtain it
from the client or a directory. Revocation is handled by including the DAT E (for
example) as part of ID, so that keys expire after one day. Notice also that the
PKG generates the private keys of all of its clients. This has several consequences.
The most important, for our purposes, is that certiﬁcation is implicit: a client
can decrypt only if the PKG has given a private key to it (in eﬀect, certifying the
client). However, there are two negative consequences: 1) private key escrow is
inherent in this system – i.e., a PKG can easily decrypt its clients’ messages; and
2

3

This should not be confused with “implicit certiﬁcation” in the context of selfcertiﬁed keys. In that context, T still must obtain explicit U -speciﬁc information
following each certiﬁcation update.
In some of our schemes, T must also obtain the long-lived certiﬁcate for U ’s public
key. (But T never needs to obtain U ’s fresh certiﬁcate status information.)

276

C. Gentry

2) the PKG must send client private keys over secure channels, making private
key distribution diﬃcult.
These two disadvantages of IBE, particularly escrow, may be unacceptable
for some applications, like email. Fortunately, we can get rid of both of them
without sacriﬁcing implicit certiﬁcation. The basic idea is simple, and is the
usual way of circumventing escrow: double encryption.
1.4

Our Results

We introduce the notion of certiﬁcate-based encryption (CBE), which combines
public-key encryption (PKE) and IBE while preserving most of the advantages of
each. As with PKE, each client generates its own public-key / secret-key pair and
requests a certiﬁcate from the CA. The main diﬀerence is that the CA uses an
IBE scheme to generate the certiﬁcate. This certiﬁcate has all of the functionality
of a conventional PKI certiﬁcate – e.g., it can be used explicitly as proof of current
certiﬁcation (even of a signature key) – but it can also be used as a decryption
key. This added functionality gives us implicit certiﬁcation – Alice can doubly
encrypt her message to Bob so that Bob needs both his personal secret key
and an up-to-date certiﬁcate from his CA to decrypt. Implicit certiﬁcation, in
turn, allows us to eliminate third-party queries on certiﬁcate status. There is no
escrow in CBE (since the CA does not know Bob’s personal secret key), and
there is no secret key distribution problem (since the CA’s certiﬁcate need not
be kept secret). We will introduce CBE more fully in Section 2, and describe a
pairing-based CBE scheme secure against chosen-ciphertext attack in Section 3.
By itself, ordinary CBE becomes ineﬃcient when the CA has a large number of clients (say, 250 million) and performs frequent certiﬁcate updates (say,
hourly). Such a CA must issue about 225 million certiﬁcates per hour (62500 per
second), assuming, as in [15], that about 10% of the CA’s clients have been revoked. By current standards, such a CA would need considerable computational
power.
In Sections 4 and 5, we describe how to reﬁne basic CBE to construct an exceptionally eﬃcient PKI. The scheme of Section 4 reduces the CA’s computation
through the use of subset covers. The CA embeds a serial number in each client’s
long-lived certiﬁcate that represents the position of the client’s leaf in a binary
tree. To reconﬁrm the validity of a client’s certiﬁcate, the CA publishes the certiﬁcate / decryption key of an ancestor of the client leaf. Using this scheme, the
CA only needs to compute an average of Rtotal log(N/Rtotal ) certiﬁcates, where
N is the number of clients and Rtotal is the total number of clients whose certiﬁcates have been revoked but have not yet expired. Each certiﬁcate is constant
length – as little as 160 bits – and can, if desired, also be used as explicit proof
of certiﬁcation. This scheme manages to achieve bandwidth-eﬃciency basically
identical to a scheme described by Aiello, Lodha and Ostrovsky [1], but with
CBE functionality. 4
4

Other tradeoﬀs are worth mentioning. Unlike ALO, the time need to verify an explicit
certiﬁcation proof in our scheme does not grow linearly with the number of time
periods, but ALO might still be faster since it uses hash chains.

Certiﬁcate-Based Encryption and the Certiﬁcate Revocation Problem

277

The scheme of Section 5 combines the use of subset covers with an incremental approach. Using incremental CBE, the CA can reduce its computation
dramatically; the CA needs to compute only Rperiod log(N/Rperiod ) certiﬁcates
per period, where Rperiod is the number of clients whose certiﬁcates have been
revoked in the period.5 Since Rhour ≈ .1N/(365 ∗ 24) ≈ 2850, the CA only needs
to compute an average of about 13 certiﬁcates per second even if updates are
hourly. Using supersingular elliptic curves, this computation is quite reasonable
– indeed, a single 1 GHz Pentium III PC can handle it easily – since each certiﬁcate generation essentially amounts to one elliptic curve point multiplication.
Each client consolidates its periodic certiﬁcates simply by adding them together,
and the consolidated certiﬁcate acts as the second decryption key. Of course, like
the other CBE schemes, this scheme also eliminates third-party queries.
In Section 6, we describe various extensions of the CBE schemes, such as
hierarchical CBE. Finally, we present a summary.

2

Certiﬁcate-Based Encryption

2.1

The Model

We now provide a formal security model for certiﬁcate-based encryption (CBE).
The two main entities involved in CBE are a certiﬁer and a client. Our deﬁnition
of CBE is somewhat similar to that of strongly key-insulated encryption [10], but,
among other diﬀerences, our model does not require a secure channel between
the two entities. (See Appendix D of [4] for a discussion of this secure channel
requirement.)
Deﬁnition 1. A certiﬁcate-updating certiﬁcate-based encryption scheme is a
6-tuple of algorithms (GenIBE , GenPKE , Upd1, Upd2, Enc, Dec) such that:
1. The probabilistic IBE key generation algorithm GenIBE takes as input a security parameter 1k1 and (optionally) the total number of time periods t. It
returns SKIBE (the certiﬁer’s master secret) and public parameters params
that include a public key P KIBE , and the description of a string space S.
2. The probabilistic PKE key generation algorithm GenPKE takes as input a
security parameter 1k2 and (optionally) the total number of time periods t.
It returns a secret key SKP KE and public key P KP KE (the client’s secret
and public keys).
3. At the start of time period i, the deterministic certiﬁer update algorithm
Upd1 takes as input SKIBE , params, i, string s ∈ S and P KP KE . It
returns Certi , which is sent to the client.
4. At the start of time period i, the deterministic client update algorithm Upd2
takes as input params, i, Certi , and (optionally) Certi−1 . It returns Certi .
5

Aiello, Lodha and Ostrovsky also describe a scheme in which the CA issues
Rperiod log(N/Rperiod ) certiﬁcates per period, but the size of a client’s explicit proof
of certiﬁcation grows linearly with the number of time periods, whereas the length
of the proof (a.k.a. the second decryption key) in our scheme tops out at log N .

278

C. Gentry

5. The probabilistic encryption algorithm Enc takes (params, i, s, P KP KE , M )
as input, where M is a message. It returns a ciphertext C on message M
intended for the client to decrypt using Certi and SKP KE (and possibly s).
6. The deterministic decryption algorithm Dec takes (params, Certi ,
SKP KE , C) as input in time period i. It returns either M or the special
symbol ⊥ indicating failure. We require
DecCerti ,SKP KE ,s (Enci,s,P KIBE ,P KP KE (M )) = M for the given params.
Remark 1. CBE does not necessarily have to be “certiﬁcate updating,” and it
can be useful for applications other than certiﬁcate management. In particular,
it may be useful in other situations where authorization or access control is an
issue. An encrypter can use CBE to encrypt its message so that the keyholder can
decrypt only after it has obtained certain signatures from one or more authorizers
on one or more messages.
Remark 2. It may seem strange that a certiﬁcate – or, more generally, a signature
– can be used as a decryption key. However, as noted by Moni Naor [6], any IBE
scheme immediately gives a public key signature scheme as follows: We set the
signer’s private key to be the master key in the IBE scheme. The signer signs M
by computing the IBE decryption key d for ID = M . The veriﬁer merely has to
check that d correctly decrypts messages encrypted with ID = M ; so, the veriﬁer
chooses a random message M , encrypts it with ID = M using the IBE scheme,
and then tries to to decrypt the resulting ciphertext with d. If the ciphertext
decrypts correctly, the signature is considered valid. Thus, an IBE decryption
key is also a signature (or a certiﬁcate). This certiﬁcate / decryption key can be
veriﬁed like a signature as explicit proof of certiﬁcation (even of signature keys),
or it can be used as a means for enabling implicit certiﬁcation in the encryption
context, as described in the Introduction.
As should be clear from Deﬁnition 1, we model CBE essentially as a combination of PKE and IBE, where the client needs both its personal secret
key and a certiﬁcate / decryption key from the CA to decrypt. The string s
may include a message that the certiﬁer “signs” – e.g., the certiﬁer may sign
clientinf o = clientname, P KP KE . (Notice that clientinf o contains only longlived information about the client; an encrypter need not know the client’s current certiﬁcate status.) Depending on the scheme, s may include other information, such as the client’s signature on its public key.
2.2

Security

Roughly speaking, we are primarily concerned about two diﬀerent types of attacks: 1) by an uncertiﬁed client and 2) by the certiﬁer. We want CBE ciphertexts
to be secure against each of these entities, even though each basically has “half”
of the secret information needed to decrypt. Accordingly, we deﬁne IND-CCA in
terms of two diﬀerent games. The adversary chooses one game to play. In Game
1, the adversary essentially assumes the role of an uncertiﬁed client. After proving knowledge of the secret key corresponding to its claimed public key, it can

Certiﬁcate-Based Encryption and the Certiﬁcate Revocation Problem

279

make Dec and Upd1 queries. In Game 2, the adversary essentially assumes the
role of the certiﬁer. After proving knowledge of the master secret corresponding
to its claimed params, it can make Dec queries. Roughly, we say that a CBE
scheme is secure if no adversary can win either game.
Game 1: The challenger runs GenIBE (1k1 , t), and gives params to the adversary.
The adversary then interleaves certiﬁcation and decryption queries with a single
challenge query. These queries are answered as follows:
– On certiﬁcation query (i, s, P KP KE , SKP KE ), the challenger checks that
s ∈ S and that SKP KE is the secret key corresponding to P KP KE . If so, it
runs Upd1 and returns Certi ; else it returns ⊥.
– On decryption query (i, s, P KP KE , SKP KE , C), the challenger checks that
s ∈ S and that SKP KE is the secret key corresponding to P KP KE . If so, it
generates Certi and outputs DecCerti ,SKP KE ,s (C); else it returns ⊥.
– On challenge query (i , s , P KP KE , SKP KE , M0 , M1 ), the challenger checks
that s ∈ S and that SKP KE is the secret key corresponding to P KP KE .
If so, it chooses random bit b and returns C = Enci ,s ,P KIBE ,P KP KE (Mb );
else it returns ⊥.
Eventually, the adversary outputs a guess b ∈ {0, 1}. The adversary wins the
game if b = b and (i , s , P KP KE , C ) was not the subject of a valid decryption
query after the challenge, and (i , s , P KP KE ) was not the subject of any valid
certiﬁcation query. The adversary’s advantage is deﬁned to be the absolute value
of the diﬀerence between 1/2 and its probability of winning.
Game 2: The challenger runs GenPKE (1k2 , t), and gives P KP KE to the adversary.
The adversary then interleaves decryption queries with a single challenge query.
These queries are answered as follows:
– On decryption query (i, s, params, SKIBE , C), the challenger checks that
s ∈ S and that SKIBE is the secret key corresponding to params. If so, it
generates Certi and outputs DecCerti ,SKP KE ,s (C); else it returns ⊥.
– On challenge query (i , s , params , SKIBE , M0 , M1 ), the challenger checks
that s ∈ S and that SKIBE is the secret key corresponding to params . If
so, it chooses random bit b and returns C = Enci ,s ,P KIBE ,P KP KE (Mb ); else
it returns ⊥.
The adversary guesses b ∈ {0, 1} and wins if b = b and (i , s , params , C ) was
not the subject of a valid decryption query after the challenge. The adversary’s
advantage is deﬁned as above.
Deﬁnition 2. A certiﬁcate-updating certiﬁcate-based encryption scheme is secure against adaptive chosen ciphertext attack (IND-CBE-CCA) if no PPT adversary has non-negligible advantage in either Game 1 or Game 2.
Remark 3. We require the adversary to reveal its secret key to the challenger,
because the challenger cannot, in general, otherwise be able to decrypt. By
placing constraints on the PKE and IBE schemes used, it may be possible to
eliminate this requirement.

280

C. Gentry

Remark 4. In the sequel, we narrow our focus to pairing-based CBE schemes.
In this context (and in the random oracle model), we construct CBE schemes
secure against adaptive chosen ciphertext attack, where the parties do not need
to reveal their secret keys.

3

A CBE Scheme Based on Boneh-Franklin

Roughly speaking, a CBE scheme is created by combining a PKE scheme and
an IBE scheme. Since Boneh and Franklin’s IBE scheme [6] is currently the
most practical, we explicitly describe a CBE scheme that uses it. This scheme
adds little online overhead to Boneh-Franklin: encryption complexity is increased
slightly, but decryption complexity and ciphertext length are the same as in
Boneh-Franklin.
3.1

Review of Pairings

Boneh-Franklin uses a bilinear map called a “pairing.” Typically, the pairing used
is a modiﬁed Weil or Tate pairing on a supersingular elliptic curve or abelian
variety. However, we describe pairings and the related mathematics in a more
general format here.
Let G1 and G2 be two cyclic groups of some large prime order q. We write
G1 additively and G2 multiplicatively.
Admissible pairings: We will call eˆ an admissible pairing if eˆ : G1 × G1 → G2
is a map with the following properties:
1. Bilinear: eˆ(aQ, bR) = eˆ(Q, R)ab for all Q, R ∈ G1 and all a, b ∈ Z.
2. Non-degenerate: eˆ(Q, R) = 1 for some Q, R ∈ G1 .
3. Computable: There is an eﬃcient algorithm to compute eˆ(Q, R) for any
Q, R ∈ G1 .
Notice that eˆ is also symmetric – i.e., eˆ(Q, R) = eˆ(R, Q) for all Q, R ∈ G1 –
since eˆ is bilinear and G1 is a cyclic group.
Bilinear Diﬃe-Hellman (BDH) Parameter Generator: As in [6], we say
that a randomized algorithm IG is a BDH parameter generator if IG takes a
security parameter k > 0, runs in time polynomial in k, and outputs the description of two groups G1 and G2 of the same prime order q and the description of
an admissible pairing eˆ : G1 × G1 → G2 .
The security of the pairing-based schemes in this paper are based on the
diﬃculty of the following problem:
BDH Problem: Given a randomly chosen P ∈ G1 , as well as aP , bP , and cP
(for unknown randomly chosen a, b, c ∈ Z/qZ), compute eˆ(P, P )abc .
For the BDH problem to be hard, G1 and G2 must be chosen so that there is
no known algorithm for eﬃciently solving the Diﬃe-Hellman problem in either
G1 or G2 . Note that if the BDH problem is hard for a pairing eˆ, then it follows
that eˆ is non-degenerate.

Certiﬁcate-Based Encryption and the Certiﬁcate Revocation Problem

281

BDH Assumption: As in [6], if IG is a BDH parameter generator, the advantage AdvIG (B) that an algorithm B has in solving the BDH problem is deﬁned
to be the probability that the algorithm B outputs eˆ(P, P )abc when the inputs
to the algorithm are G1 , G2 , eˆ, P, aP, bP, cP where (G1 , G2 , eˆ) is IG’s output for
large enough security parameter k, P is a random generator of G1 , and a, b, c are
random elements of Z/qZ. The BDH assumption is that AdvIG (B) is negligible
for all eﬃcient algorithms B.
3.2

BasicCBE and FullCBE

As mentioned previously, IBE enables signatures to be used as decryption keys.
For example, in Boneh-Franklin, a BLS signature [8] is used as a decryption key.
Similarly, in “BasicCBE”, we will use a two-signer BGLS aggregate signature [7]
as a decryption key. (See [7] for details on the aggregate signature scheme.) Let
k be the security parameter given to the setup algorithm, and let IG be a BDH
parameter generator.
Setup: The CA:
1. runs IG on input k to generate groups G1 , G2 of some prime order q and an
admissible pairing eˆ: G1 × G1 → G2 ;
2. picks an arbitrary generator P ∈ G1 ;
3. picks a random secret sC ∈ Z/qZ and sets Q = sC P ;
4. chooses cryptographic hash functions H1 : {0, 1}∗ → G1 and H2 : G2 →
{0, 1}n for some n.
The system parameters are params = (G1 , G2 , eˆ, P, Q, H1 , H2 ). The message
space is M = {0, 1}n . The CA’s secret is sC ∈ Z/qZ.
The CA uses its parameters and its secret to issue certiﬁcates. Assume that
Bob’s secret key / public key pair is (sB , sB P ), where sB P is computed according
to the parameters issued by the CA. Bob obtains a certiﬁcate from his CA as
follows.
Certiﬁcation:
1. Bob sends Bobsinf o to the CA, which includes his public key sB P and any
necessary additional identifying information, such as his name.
2. The CA veriﬁes Bob’s information;
3. If satisﬁed, the CA computes PB = H1 (sC P, i, Bobsinf o) ∈ G1 in period i.
4. The CA then computes CertB = sC PB and sends this certiﬁcate to Bob.
Before performing decryptions, Bob also signs Bobsinf o, producing sB PB
where PB = H1 (Bobsinf o). Now, notice that SBob = sC PB + sB PB is a twoperson aggregate signature, as deﬁned in [7]. Bob will use this aggregate signature
as his decryption key!
Encryption: To encrypt M ∈ M using Bobinf o, Alice does the following:
1. Computes PB = H1 (Bobsinf o) ∈ G1 .
2. Computes PB = H1 (Q, i, Bobsinf o) ∈ G1 .

282

C. Gentry

3. Chooses a random r ∈ Z/qZ.
4. Sets the ciphertext to be:
C = [rP, M ⊕ H2 (g r )] where g = eˆ(sC P, PB )ˆ
e(sB P, PB ) ∈ G2 .
Notice that the length of the ciphertext is the same as in Boneh-Franklin. Alice can reduce her computation through precomputation – e.g., eˆ(sB P, PB ) can
likely be precomputed, since it is long-lived.
Decryption: To decrypt [U, V ], Bob computes:
M = V ⊕ H2 (ˆ
e(U, SBob )).
Notice that Bob’s online decryption time is the same as in Boneh-Franklin.
BasicCBE is a one-way encryption scheme. It can be made secure (in the random oracle model) against adaptive chosen-ciphertext by, for example, using the
Fujisaki-Okamoto transform in a manner similar to [6]. The transformed scheme,
which we call “FullCBE”, uses two additional cryptographic hash functions H3
and H4 , and a semantically secure symmetric encryption scheme E:
Encryption: To encrypt M ∈ M using Bobinf o, Alice does the following:
1.
2.
3.
4.
5.

Computes PB = H1 (Bobsinf o) ∈ G1 .
Computes PB = H1 (Q, i, Bobsinf o) ∈ G1 .
Chooses random σ ∈ {0, 1}n .
Sets r = H3 (σ, M ).
Sets the ciphertext to be:
C = [rP, σ ⊕ H2 (g r ), EH4 (σ) (M )] where g = eˆ(sC P, PB )ˆ
e(sB P, PB ) ∈ G2 .

Decryption: To decrypt [U, V, W ], Bob
1.
2.
3.
4.

Computes σ = V ⊕ H2 (ˆ
e(U, SBob )).
−1
(W
).
Computes M = EH
4 (σ)
Sets r = H3 (σ, M ) and rejects the ciphertext if U = rP .
Outputs M as the plaintext.

We can prove that FullCBE is secure in the random oracle model against
adaptive chosen-ciphertext attack in two (quite diﬀerent) ways – by showing
such an attack implies 1) an existential forgery attack on the aggregate signature
scheme, or 2) an adaptive chosen-ciphertext attack on BasicPubhy (a public key
encryption scheme deﬁned in [6] and in Appendix A). We use the latter approach.
Lemma 1. Let A be a IND-CCA adversary that has advantage against FullCBE. Suppose that A makes at most qC certiﬁcation queries and qD decryption
queries. Then, there is an IND-CCA adversary B with running time O(time(A))
that has advantage at least e(1+qC +qD ) against BasicPubhy .
Our proof, given in Appendix A, is similar to Boneh and Franklin’s proof of
Lemma 4.6 in [6]. Just like an IBE adversary is allowed to choose its identity
adaptively, a CBE adversary is allowed to choose its information (including its
public key) adaptively. When combined with Theorem 4.5 and Lemma 4.3 of [6],
our Lemma 1 gives a reduction from the BDH problem to FullCBE, with time
and advantage bounds as in Theorem 4.4 of [6].

Certiﬁcate-Based Encryption and the Certiﬁcate Revocation Problem

4

283

Using Subset Covers to Reduce CA Computation

Using BasicCBE (or FullCBE), a CA that has N (currently valid) clients must
compute N certiﬁcates per period. BasicCBE may therefore become impractical
when N is large and updates are frequent – e.g., a CA with 225 million (currently
valid) clients that performs hourly updates must compute 225 million certiﬁcates
per hour (62500 per second) on average. In this section, we show how to reduce
the CA’s computation using subset covers.
4.1

The General Approach

Unlike in BasicCBE, we assume that the CA distributes a long-lived certiﬁcate to
each client, which it periodically reconﬁrms (if appropriate). Before encrypting
to Bob, Alice must obtain and verify Bob’s long-lived certiﬁcate. This assumption costs us little, since Alice likely can obtain Bob’s long-lived certiﬁcate when
she obtains Bob’s public key. (Recall that the main beneﬁt of CBE is that Alice
does not have to obtain fresh certiﬁcate status information; obtaining long-lived
information is a simpler problem.) We will not concern ourselves with what certiﬁcation scheme is used to generate the long-lived certiﬁcates, but we note that
producing long-lived certiﬁcates should not add much to the CA’s computational
burden, since their production is amortized over a long time (assuming clients
do not, say, sign-up “all at once.”)
The CA arranges its N < 2m clients as leaves in an m-level binary tree by
embedding a unique m-bit serial number (SN) in each client’s long-lived certiﬁcate. For each time period, each tree node (including interior nodes) corresponds
to an “identity,” and the CA computes each node’s decryption key according to
an IBE scheme. Speciﬁcally, in time period i, the node corresponding to the
(k ≤ m)-bit SN b1 · · · bk may be mapped to i, b1 · · · bk . The node’s associated
decryption key is the IBE decryption key for i, b1 · · · bk .
We call i, b1 · · · bk for 0 ≤ k ≤ m the ancestors of i, b1 · · · bm . In time
period i, the CA ﬁnds a cover of the non-revoked clients – i.e., a set S of nodes,
such that each of the N − R non-revoked clients has an ancestor in S, but none
of the R revoked clients does. Such a cover, consisting of at most R log(N/R)
nodes, can be found using the “Complete Subtree Method” described in [17].
The CA then publishes the decryption keys for each node in S; we call these
decryption keys reconﬁrmation certiﬁcates.
Now, assume that Alice has obtained and veriﬁed Bob’s long-lived certiﬁcate,
and therefore knows his public key and his SN. To encrypt to Bob, Alice does not
need Bob’s reconﬁrmation certiﬁcate. Instead, she encrypts her message m + 1
times, using (Bob’s public key and) each of the m+1 identities of Bob’s ancestors
in the tree. If the CA has published a reconﬁrmation certiﬁcate corresponding
to one of Bob’s ancestors, Bob will be able to decrypt one of Alice’s ciphertexts.
In summary, this scheme combines PKE and IBE just like BasicCBE, but
it imposes a structure on the identities that permits eﬃcient inclusion and exclusion (`
a la broadcast encryption). Though the complexity of encryption and
the length of the ciphertext is increased, the CA computes only R log(N/R)

284

C. Gentry

reconﬁrmation certiﬁcates, rather than N − R (in BasicCBE). Assuming that
long-lived certiﬁcates expire 1 year after creation and that the yearly revocation
rate is 10% (i.e., R = .1N ) as in [15] and [16], the CA’s computation is reduced
by a factor of about 3.
4.2

A Pairing-Based CBE Scheme Using Subset Covers

The general approach above, while simple, creates diﬃculties in proving security
against chosen-ciphertext attacks, since the same message is being encrypted
under diﬀerent keys. Below, we brieﬂy present a variant of BasicCBE using
subset covers, which deviates slightly from the general approach. As above, we
assume that Bob has already obtained his long-lived certiﬁcate, which contains
the serial number b1 · · · bm .
Certiﬁcation: The CA sets up as in BasicCBE and also uses H5 : {0, 1}∗ → G1
to map time periods to points. At the start of period i, the CA chooses random
x ∈ Z/qZ and ﬁnds a cover S of the non-revoked clients (using the Complete
Subtree Method). Bob’s reconﬁrmation certiﬁcate (if it exists) has the form
Si = sC Ti + xPk together with xP , where Ti = H5 (Q, i), Pk = H1 (b1 · · · bk ) and
b1 · · · bk ∈ S is an ancestor of b1 · · · bm .
Encryption: Alice has already veriﬁed Bob’s initial certiﬁcate, and therefore
knows Bobsinf o. Alice chooses random r ∈ Z/qZ. She sends the ciphertext
C = [rP, rP1 , . . . , rPm , V ], where V = M ⊕ H2 (g r ) and g = eˆ(Q, Ti )ˆ
e(sB P, PB ).
Decryption: Bob computes M = V ⊕ H2 (

eˆ(rP,Si +sB PB )
).
eˆ(xP,rPk )

Encryption involves m+1 point multiplications, but decryption involves only
two pairing computations. Bob’s reconﬁrmation certiﬁcate is concise: just two
elements of G1 . (Actually, since xP is common to all clients, we may say Bob’s
proof consists of just one element of G1 .) Elements of G1 may be quite short –
e.g., [8] proposes using an elliptic curve over F397 (about 154 bits) for the BLS
signature scheme.
We note again that this scheme assumes that the client has already obtained
a long-lived certiﬁcate. Thus, a Game 1 adversary cannot choose its public key
with complete freedom; it must choose one of the N keys initially certiﬁed (and
collude with the secret key holder). As with BasicCBE, the Fujisaki-Okamoto
transform can be used to achieve CCA2 security. We remark, however, that
gCCA2 security [2] may be considered preferable, because CCA2 security would
technically require Bob to conﬁrm that rPi = Ui for every i, even when k
m.
We discuss the chosen-ciphertext security of this scheme in detail in the full
version of the paper.

5

Incremental CBE Using Subset Covers

Intuitively, it seems like the CA’s computation should be less for periods when
few new revocations have occurred. However, this is not the case with the scheme
of Section 4: if updates are hourly, the CA must compute about R log(N/R)

Certiﬁcate-Based Encryption and the Certiﬁcate Revocation Problem

285

reconﬁrmation certiﬁcates per hour (where R is the total number of revoked
clients), even for hours when no client’s certiﬁcate status has changed. In this
section, we describe how to achieve “incremental CBE,” where the CA’s hourly
computation is roughly proportional to the number of revocations that occurred
during that hour. Speciﬁcally, the CA computes at most Rhour log(N/Rhour )
certiﬁcates per hour, where Rhour is the number of revocations during the previous hour. Assuming a 10% yearly revocation rate, a CA with 250 million
clients performing hourly updates only needs to compute about 13 reconﬁrmation certiﬁcates per second, a dramatic improvement over BasicCBE. (We discuss
incremental CBE’s performance characteristics in more detail in Section 5.3.)
5.1

Basic Incremental CBE

As will become clearer from the detailed description below, this scheme is essentially based on two insights. First, as noted above and in [1], the CA can
dramatically reduce its periodic computation by only revoking those clients that
have become invalid in the past period. This strategy, however, has a price: a
client cannot be considered currently certiﬁed (and must not be able to decrypt)
unless it has an unbroken chain of periodic reconﬁrmation certiﬁcates for every
period from the creation of its long-lived certiﬁcate to the present. At ﬁrst, this
seems to suggest that encryption and decryption complexity must be (at least)
proportional to the number of time periods that have passed. Fortunately, using
pairings, this is not the case: the second insight is an eﬃcient way for each client
to consolidate its periodic certiﬁcates into a single decryption key (consisting of
log N + 1 elements of G1 ), such that the encryption and decryption complexity
and the ciphertext length are about log N times that of BasicCBE, regardless of
how may periods have transpired since the client’s initial certiﬁcation.
We assume Bob has obtained a long-lived certiﬁcate containing his m-bit
serial number b1 · · · bm and the period t0 in which he was initially certiﬁed.
Certiﬁcation: The CA sets up as in BasicCBE and also uses H5 : {0, 1}∗ → G1
to map time periods to points. At the start of period i, the CA chooses random
x ∈ Z/qZ and ﬁnds a cover S of the clients not revoked during period i−1 (using
the Complete Subtree Method). Bob’s reconﬁrmation certiﬁcate (if it exists) has
the form Si = sC (Ti − Ti−1 ) + xPk together with xP , where Ti = H5 (Q, i),
Pk = H1 (b1 · · · bk ) and b1 · · · bk ∈ S is an ancestor of b1 · · · bm .
Consolidation: If the CA has continually reconﬁrmed Bob’s key from its initial
certiﬁcation to the start of period i, we want it to be the case that Bob can
compute a consolidated certiﬁcate of the form
Si = sC (Ti −Tt0 )+xi,1 P1 +· · ·+xi,m Pm

with

Qi,j = xi,j P for 1 ≤ j ≤ m ,

for some xi,j ∈ Z/qZ, 1 ≤ j ≤ m, where Pj = H1 (b1 · · · bj ). Assume he has a
consolidated certiﬁcate with the correct form at the start of period i − 1:
Si−1 = sC (Ti−1 − Tt0 ) + xi−1,1 P1 + · · · + xi−1,m Pm with Qi−1,j = xi−1,j P .

286

C. Gentry

Upon receiving Si and xP , Bob computes his new consolidated certiﬁcate as
follows: Si = Si−1 + Si , Qi,j = Qi−1,j for j = k, and Qi,k = Qi−1,k + xP .
Encryption: Alice has already veriﬁed Bob’s initial certiﬁcate, and therefore
knows Bobsinf o. Alice chooses random r ∈ Z/qZ. She sends the ciphertext C =
e(sB P, PB ).
[rP, rP1 , . . . , rPm , V ], where V = M ⊕ H2 (g r ) and g = eˆ(Q, Ti − Tt0 )ˆ
Decryption: Bob computes M = V ⊕ H2 (

eˆ(rP,Si +sB PB )
m
ˆ(rPj ,Qi,j ) ).
j=1 e

Remark 5. If the CA gives Bob (say) sC Tt0 +xt0 Pm with Qt0 ,m = xt0 P (for some
xt0 ∈ Z/qZ) at the time of initial certiﬁcation, and Bob consolidates this with his
periodic certiﬁcates, then “−Tt0 ” need not be included in the Encryption step.
However, the CA may prefer not to constrain how it handles initial certiﬁcation.
5.2

Security

In the full version of the paper, we prove (in the random oracle model, under the
Bilinear Diﬃe-Hellman Assumption, and using the Fujisaki-Okamoto transform)
that Bob needs an unbroken chain of reconﬁrmation certiﬁcates – from the time
of his initial certiﬁcation to the present – to decrypt. We could prove the scheme
secure against Game 2 adversaries using similar techniques.
Here, in lieu of proof, we provide some rough intuitive justiﬁcation for incremental CBE’s security. Si contains a time component of the form sC (Ti −Tt0 ) and
an identity component of the form x1 P1 +x2 P2 +· · ·+xm Pm . If Bob tries to consolidate his certiﬁcates without his reconﬁrmation certiﬁcate for day z, t0 < z ≤
i, the result will have the form sC (Ti −Tz +Tz−1 −Tt0 )+x1 P1 +x2 P2 +· · ·+xm Pm .
In other words, the time component of Si will have the incorrect form. If Bob tries
to substitute someone else’s day z reconﬁrmation point sC (Tz − Tz−1 ) + xk Pk ,
where Pk does not correspond to one of Bob’s ancestors, the result will have
the form sC (Ti − Tt0 ) + x1 P1 + x2 P2 + · · · + xm Pm + xk Pk . In other words, the
identity component of Si will have the incorrect form.
5.3

Performance Characteristics

Like the other CBE schemes, incremental CBE enjoys all the infrastructural beneﬁts of eliminating third-party queries. Also, the CA’s computation is minimal; it
computes only 13 reconﬁrmation certiﬁcates per second. Since each reconﬁrmation certiﬁcate is essentially equivalent (computation-wise) to a BLS signature,
which requires only 3.57 ms to compute on a Pentium III 1 GHz [3], a single PC
can easily handle the computation.
Distributing the reconﬁrmation certiﬁcates can be handled in a variety of
ways. Since CBE eliminates third-party queries, one interesting alternative to the
usual directories-based approach is to “push” certiﬁcates directly to the clients
they certify – i.e., the CA sends each client its reconﬁrmation certiﬁcate rather
than waiting for the client’s query. This would eliminate queries altogether.6 If
6

In practice, the CA would probably allow some queries, both by clients and thirdparties. However, CBE allows a CA to discourage queries – e.g., by using fees – so
that the number of queries is reduced to a desired level.

Certiﬁcate-Based Encryption and the Certiﬁcate Revocation Problem

287

the CA uses separate transmissions for each client, the CA’s required bandwidth
is (320 bits per cert)∗(225 million certs per hour)/(3600 seconds per hour) = 20
mbits/sec. This ﬁgure is a lower bound; it does not include overhead such as
packet headers. Such a large transmission may need to be delegated to a number
of servers.
Theoretically, however, if the CA pushes its certiﬁcates, it can dramatically
reduce its bandwidth requirements by using multicast. Recall that a reconﬁrmation certiﬁcate for node b1 · · · bk applies to all of b1 · · · bk ’s descendants. So,
if the CA sets up multicast address for each interior node, the CA’s expected
bandwidth requirements are very low – only about (160 bits per cert)∗(13 certs
per second) ≈ 2.1 kbits/sec. (The certiﬁcates are 160 bits in this case, since xP ,
the other 160-bit value, can be sent to all clients via one multicast). Even if the
CA sets up multicast addresses only for high-level nodes (close to the root), it
can signiﬁcantly reduce its bandwidth requirements.
For users, incremental CBE is somewhat expensive computationally: encryption and decryption cost about m = log N times that of Boneh-Franklin. This
may make the scheme impractical for some applications in the very near future.
It may not be a problem for other applications, like email, where fast online
computation is not such a concern. We expect that, in the future, computational
considerations will become less important relative to network considerations (like
the latency caused by the (ﬁxed) speed of light), making CBE’s advantages more
prominent. If desired, however, one can shift some user computation back to the
CA by “fattening” the binary tree (so that each node has more children), or
having the CA maintain several trees concurrently, as described in [1].
The total length of a client’s consolidated certiﬁcate, which can be used
as explicit proof of certiﬁcation (even of signature keys), never grows beyond
160(m + 1) bits. Even though CBE was not originally intended to improve the
eﬃciency of explicit certiﬁcation, we note that explicit proofs in incremental
CBE are more compact than in Aiello-Lodha-Ostrovsky’s incremental scheme
[1], where the length grows linearly with the number of time periods.

6
6.1

Extensions and Generalizations
High-Granularity CBE

Suppose a one hour time granularity is insuﬃcient; we want certiﬁcate revocation
to be practically instantaneous. One option is for Alice to encrypt using i + 1 as
the time period during period i. The drawback is that Bob, after receiving Alice’s
message, may need to wait an hour to decrypt it. Another option, called the SEM
architecture, is described in [5]. In SEM, revocation is instantaneous, and so is
Bob’s ability to decrypt, but he must interact with a “security mediator” for each
message decryption. Below, we brieﬂy describe a “high-granularity” version of
CBE, where revocation is practically instantaneous – say, within 1 second – but
where Bob’s interaction with the CA grows not with the number of messages he
decrypts, but rather with the number of his “sessions.”

288

C. Gentry

In our scheme, the CA uses a recent forward-secure encryption (FSE) scheme
[9], but in reverse – i.e., the CA relabels the time periods such that given the
FSE decryption key for period i, one can compute the decryption key for period j
if j < i, but not if j > i.7 Bob may download such a certiﬁcate a few times daily,
depending on how often he checks his messages, and use it to decrypt messages
from multiple previous time periods. As in [9], the size of this certiﬁcate is merely
logarithmic in the number of periods for which messages can be decrypted; thus,
we can make revocation highly granular without sacriﬁcing much eﬃciency. Also,
this scheme can be combined with (say) incremental CBE: the CA performs
hourly updates as in incremental CBE, but employs a subtree of 3600 seconds
for clients that request high-granularity certiﬁcates.
6.2

Hierarchical CBE

Though our previous schemes have used only one CA, adapting CBE to a hierarchy of CAs is fairly straightforward. Perhaps the more obvious approach is
simply to combine a HIBE scheme and a PKE scheme, much as CBE combines
IBE and PKE. However, using this approach, encryption and decryption complexity, as well as ciphertext length, are all about t times that of Boneh-Franklin,
where t is the level of the recipient in the hierarchy. Instead, we use the BGLS
aggregate signature scheme. The encryption complexity of this scheme is still
proportional to t, but the decryption complexity and ciphertext length are identical to Boneh-Franklin. Suppose Bob is at level t, that his public key is st P ,
and that the CAs above him have public keys sj P for 0 ≤ j ≤ t − 1.
Certiﬁcation of CAs: CAj certiﬁes sj+1 P as CAj+1 ’s public key by producing a signature of the form sj Pj+1 , where Pj+1 = H1 (sj P, CAj+1 inf o) and
CAj+1 inf o includes sj+1 P .
Certiﬁcation of Bob: Similarly, Bob’s parent CA produces a certiﬁcate of the
form st−1 Pt , where Pt = H1 (st−1 P, Bobsinf o) and Bobsinf o includes st P .
Aggregation: Bob signs his key to produce st PB and “aggregates” this
signature with the certiﬁcates in his chain simply by adding them together:
t
SAgg = st PB + j=1 sj−1 Pj .
Encryption: We assume Alice knows Bobsinf o and CAj inf o for 0 ≤ j ≤ t−1.
Alice chooses random r ∈ Z/qZ and sends C = [rP, V ], where V = M ⊕ H2 (g r )
t
and g = eˆ(PB , st P ) j=1 eˆ(Pj , sj−1 P ).
Decryption: Bob computes M = V ⊕ H2 (ˆ
e(rP, SAgg )).
Remark 6. To handle revocation, we can embed time periods in the various
certiﬁcates above. However, Alice must know the certiﬁcation “schedules” of all
of Bob’s ancestral CAs, which may make implementation diﬃcult in practice.
Remark 7. We note that the second scheme is useful outside of the PKI setting.
It provides a general way for making a keyholder’s decryption ability contingent
on that keyholder’s acquisition of multiple signatures / authorizations.
7

We omit the details of our scheme, since we would largely be rehashing [9].

Certiﬁcate-Based Encryption and the Certiﬁcate Revocation Problem

6.3

289

Other Generalizations

It is interesting that even “exotic” pairing-based signatures can typically be
used as decryption keys. For example, Alice can make Bob’s ability to decrypt
contingent on his possession of a BGLS ring signature [7].
Ring Signing: The signer is given public keys {Q1 = s1 P, . . . , Qn = sn P },
sk for some 1 ≤ k ≤ n, and message M . It computes PM = H1 (M ), chooses
random ai ∈ Z/qZ for i = k, and sends σ = σ1 , . . . , σn to Bob, where σk =
s−1
i=k ai Qi and σi = ai Qk for i = k.
k PM −
Ring Encryption: We assume that Alice knows Bob’s public key sB P , the
public keys {Q1 , . . . , Qn } and the message M . Alice chooses random r ∈ Z/qZ
and sends C = [rP, rQ1 , . . . , rQn , M ⊕ H2 (g r )], where g = eˆ(P, PM )ˆ
e(sB P, PB ).
Ring Decryption: Given the ciphertext [U, U1 , . . . , Un , V ], Bob computes
n
M = V ⊕ H2 (h), where h = eˆ(U, sB PB ) i=1 eˆ(Ui , σi ).

7

Summary

We described the notion of certiﬁcate-based encryption, and demonstrated how
it streamlines PKI. The key idea is that certiﬁcate-based encryption enables
implicit certiﬁcation without the problems of IBE, and that implicit certiﬁcation
allows us to eliminate third-party queries on certiﬁcate status, thereby reducing
infrastructural requirements. We also described an incremental CBE scheme that
reduces the CA’s computation and bandwidth requirements to exceptionally low
levels, even though the scheme does not use hash chains or trees like previous
PKI proposals.

References
1. W. Aiello, S. Lodha, and R. Ostrovsky. Fast Digital Identity Revocation. In Proc.
of Crypto 1998, LNCS 1462, pages 137–152. Springer-Verlag, 1998.
2. J.H. An, Y. Dodis and T. Rabin. On the Security of Joint Signature and Encryption. In Proc. of Eurocrypt 2002, LNCS 2332, pages 83–107. Springer-Verlag,
2002.
3. P.S.L.M. Barreto, H.Y. Kim, B. Lynn, and M. Scott. Eﬃcient Algorithms for
Pairing-Based Cryptosystems. In Proc. of Crypto 2002, LNCS 2442, pages 354–
368. Springer-Verlag, 2002.
4. M. Bellare and A. Palacio. Protecting against Key Exposure: Strongly KeyInsulated Encryption with Optimal Threshold. Available at http://eprint.iacr.org,
2002.
5. D. Boneh, X. Ding, G. Tsudik, M. Wong. A Method for Fast Revocation of Public
Key Certiﬁcates and Security Capabilities. In Proc. of 10th Annual USENIX Security Symposium, 2001, available at http://crypto.stanford.edu/˜dabo/pubs.html.
6. D. Boneh and M. Franklin. Identity-Based Encryption from the Weil pairing. In
Proc. of Crypto 2001, LNCS 2139, pages 213–229. Springer-Verlag, 2001.
7. D. Boneh, C. Gentry, B. Lynn, and H. Shacham. Aggregate and Veriﬁably Encrypted Signatures from Bilinear Maps. In Proc. of Eurocrypt 2003 (to appear).

290

C. Gentry

8. D. Boneh, B. Lynn, and H. Shacham. Short Signatures from the Weil Pairing. In
Proc. of Asiacrypt 2001, LNCS 2248, pages 514–532. Springer-Verlag, 2001.
9. R. Canetti, S. Halevi, J. Katz. A Forward-Secure Public-Key Encryption Scheme.
In Proc. of Eurocrypt 2003 (to appear).
10. Y. Dodis, J. Katz, S. Xu, and M. Yung. Key-Insulated Public Key Cryptosystems.
In Proc. of Eurocrypt 2002, LNCS 2332, pages 65–82. Springer-Verlag, 2002.
11. E. Fujisaki and T. Okamoto. Secure Integration of Asymmetric and Symmetric Encryption Schemes. In Proc. of Crypto 1999, LNCS 1666, pages 537–554. SpringerVerlag, 1999.
12. I. Gassko, P. S. Gemmell, and P. MacKenzie. Eﬃcient and Fresh Certiﬁcation.
In Proc. of Public Key Cryptography 2000, LNCS 1751, pages 342–353. SpringerVerlag, 2000.
13. C. Gentry and A. Silverberg. Hierarchical ID-Based Cryptography. In Proc. of
Asiacrypt 2002, LNCS 2501, pages 548–566. Springer-Verlag, 2002.
14. S. Micali. Eﬃcient Certiﬁcate Revocation. Technical Report TM-542b, MIT Laboratory for Computer Science, 1996.
15. S. Micali. Novomodo: Scalable Certiﬁcate Validation and Simpliﬁed PKI Management. In Proc. of 1st Annual PKI Research Workshop, 2002, available at
http://www.cs.dartmouth.edu/˜pki02/.
16. M. Naor and K. Nissim. Certiﬁcate Revocation and Certiﬁcate Update. In Proc.
of 7th Annual USENIX Security Symposium, 1998, available at
http://www.wisdom.weizmann.ac.il/˜kobbi/papers.html.
17. D. Naor, M. Naor, and J. Lotspiech. Revocation and Tracing Schemes for Stateless
Receivers. In Proc. of Crypto 2001, LNCS 2139, pages 41–62. Springer-Verlag 2001.
18. A. Shamir. Identity-Based Cryptosystems and Signature Schemes. In Proc. of
Crypto 1984, LNCS 196, pages 47–53. Springer-Verlag, 1985.

A

Proof of Lemma 1

First, we describe BasicPubhy , a public key cryptosystem that uses the FujisakiOkamoto transform to achieve chosen-ciphertext security under the BDH Assumption. Let k be the security parameter given to the setup algorithm, and let
IG be a BDH parameter generator.
Setup: The keyholder:
1. runs IG on input k to generate groups G1 , G2 of some prime order q and an
admissible pairing eˆ: G1 × G1 → G2 ;
2. picks arbitrary generators P, P1 ∈ G1 ;
3. picks a random secret sC ∈ Z/qZ and sets Q = sC P ;
4. chooses cryptographic hash functions H2 : G2 → {0, 1}n .
5. uses hash functions H3 and H4 and semantically secure encryption scheme
E, as speciﬁed in Fujisaki-Okamoto.
The public key is Kpub = (G1 , G2 , eˆ, n, P, P1 , Q, H2 , H3 , H4 , E), and the secret
key is sC P1 . The message space is M = {0, 1}n .
Encryption: To encrypt M ∈ M, the encrypter:
1. Chooses random σ ∈ {0, 1}n .

Certiﬁcate-Based Encryption and the Certiﬁcate Revocation Problem

291

2. Sets r = H3 (σ, M ).
3. Sets the ciphertext to be:
C = [rP, σ ⊕ H2 (g r ), EH4 (σ) (M )] where g = eˆ(Q, P1 ).
Decryption: To decrypt [U, V, W ], Bob
1.
2.
3.
4.

Computes σ = V ⊕ H2 (ˆ
e(U, sC P1 )).
−1
(W
).
Computes M = EH
4 (σ)
Sets r = H3 (σ, M ) and rejects the ciphertext if U = rP .
Outputs M as the plaintext.

Now, we show how to construct an adversary B that uses A to gain advantage
/e(1 + qC + qD ) against BasicPubhy . The game between the challenger and the
adversary B starts with the challenger ﬁrst generating a random public key by
running the key generation algorithm of BasicPubhy . The result is a public key
Kpub = (G1 , G2 , eˆ, n, P, P1 , Q, H2 , H3 , H4 , E) and a private key sC P1 , where G1
and G2 have order q and Q = sC P for sC ∈ Z/qZ. The challenger gives Kpub to
B. Now, B interacts with A as follows.
Setup: B gives A the FullCBE params = (G1 , G2 , eˆ, n, P, Q, H1 , H2 , H3 , H4 , E),
where H1 is a random oracle controlled by B.
H1 -queries: A can make an H1 -query at any time. There are two types of H1 queries. A Type-1 query (to compute PB in FullCBE) is of the form (ij , sj P, wj )
– where one may view ij as a time period, sj P as the public key that A wants
certiﬁed, and wj as other information that may be in a certiﬁcate (such as a
name). A Type-2 query (to compute PB in FullCBE) is of the form (sj P, wj ).
The query is parsed before processing. For consistency, B maintains an H1 -list
logging its H1 -query responses. This list is initially empty. B responds to A’s
H1 -query as follows:
1. If A made the same H1 -query previously, as indicated by the H1 -list, B
responds the same way as it did before.
2. If it is a Type-2 query:
a) B generates random bj ∈ Z/qZ and sets Pj = bj Q.
b) B adds tuple (sj P, wj , bj ) to the H1 -list, and returns Pj to A.
3. If it is a Type-1 query:
a) B runs a Type-2 query on (sj P, wj ) to recover bj .
b) B generates a random coinj ∈ {0, 1} so that Pr[coin = 0]= δ for δ to be
determined later.
c) B generates random cj ∈ Z/qZ. If coinj = 0, it sets Pj = cj P ; else, it
sets Pj = cj P1 − bj sj P .
d) B adds tuple (ij , sj P, wj , cj , coinj ) to the H1 -list, and returns Pj to A.
Note that Pj and Pj are uniform in G1 and independent of A’s view as required.
Phase 1 – Certiﬁcation Queries:
(ij , wj , sj P ) as follows:

B responds to A’s certiﬁcation query

292

C. Gentry

1. B runs the H1 -query response algorithm on (ij , wj , sj P ) to recover cj and
coinj . If coinj = 1, B terminates. The attack on BasicPubhy failed.
2. Otherwise, coinj = 0. B gives A its certiﬁcate: sC Pj = cj Q.
Phase 1 – Decryption Queries: Let (ij , sj P, wj , Cj ) be a decryption query
issued by A, where Cj = (Uj , Vj , Wj ). B responds as follows.
1. B runs the H1 -query response algorithm on (ij , wj , sj P ) to recover bj , cj and
coinj .
2. Suppose coinj = 0. Then, B computes the decryption key sC Pj + sj Pj =
cj Q + bj (sj P ), and uses it to decrypt Cj .
3. Suppose coinj = 1. Then, B sets Cj = (cj U, V, W ). B relays Cj to the
challenger, and relays the challenger’s response back to A.
Recall that the challenger’s private key is sC P1 . Now, notice that eˆ(cj U, sC P1 ) =
eˆ(rP, cj sC P1 ) = eˆ(rP, sC (cj P1 − bj sj P ) + sj bj Q) = eˆ(rP, sC Pj + sj Pj ), where
sC Pj + sj Pj is the FullCBE decryption key. Thus, the challenger provides the
correct decryption of Cj .
Challenge: Once A decides that Phase 1 is over, it requests a challenge ciphertext on (iz , sz P, wz ) for message M0 or M1 . B responds as follows:
1. B relays M0 and M1 to the challenger as the messages that it wants to be
challenged on. The challenger sends B a BasicPubhy ciphertext C = [U, V, W ]
such that C is an encryption Mx , x ∈ {0, 1}.
2. B runs the H1 -query response algorithm on (iz , sz P, wz ) to recover cz and
coinz . If coinz = 0, B terminates. The attack on BasicPubhy failed.
3. Otherwise, coinz = 1. B gives A its challenge ciphertext: C = [c−1
j U, V, W ].
Notice that eˆ(c−1
ˆ(c−1
ˆ(U, sC P1 ), where sC P1
j U, sC Pj + sj Pj ) = e
j U, cj sC P1 ) = e
it the challenger’s decryption key. Thus, the challenge ciphertext is an encryption
of Mx in FullCBE as required.
Phase 2 – Certiﬁcation Queries: B responds as in Phase 1.
Phase 2 – Decryption Queries: B responds as in Phase 1, except it terminates if the decryption query to be relayed to the challenger is equal to C.
Guess: A guesses x for x. B also uses x as its guess.
Claim: If algorithm B does not abort during the simulation, then algorithm
A’s view is identical to its view in the real attack. Furthermore, if B does not
abort then Pr[M = M ] ≥ . The probability is over the random bits used by A,
B and the challenger.
Proof of Claim: All responses to H1 -queries are as in the real attack since
each response is uniformly and independently distributed in G1 . All responses to
certiﬁcation and decryption queries are valid. Finally, the challenge ciphertext
C given to A is the FullCBE encryption of Mx under the the public key (and
other information) chosen by A. Therefore, by the deﬁnition of algorithm A, it
will output x = x with probability at least .
Probability: It remains to calculate the probability that B aborts during simulation. This analysis is identical to that in [6], and is therefore omitted.

Certiﬁcate-Based Encryption and the Certiﬁcate Revocation Problem

293

Remark 8. The above proves FullCBE secure (in the random oracle model, under
the BDH Assumption) against an adaptive chosen ciphertext attack by a Game
1 adversary. The proof for Game 2 adversaries is similar and therefore omitted.
Remark 9. Recall that, in Section 2, we required a Game 1 adversary to reveal
its personal secret key in its queries. However, this does not occur above; rather
than revealing sj , A “proves its knowledge” of sj through its ability to compute
sj Pj . Since the adversary does not need to reveal its secret key, the proof above
is slightly stronger than required. That is, BasicCBE conforms to Section 2’s
security model, even though clients do not actually reveal their personal secret
keys to the CA, which, indeed, would defeat the purpose of CBE.

