A Framework for Data Structure-Guided
Extraction of XML Association Rules
Juryon Paik1 , Junghyun Nam2 , SeungCheol Lee1 , and Ung Mo Kim1
1

Dept. of Computer Engineering, Sungkyunkwan University, Republic of Korea
quasa277@gmail.com, {eddie,umkim}@ece.skku.ac.kr
2
Dept. of Computer Science, Konkuk University, Republic of Korea
jhnam@kku.ac.kr

Abstract. Because of the widespread interest and use of semi-structured
data in XML format, the discovery of useful information from them is currently one of the main research topics on association rule extraction. Several encouraging approaches to developing methods for mining rules from
XML data have been proposed. However, eﬃciency and simplicity are still
barriers for further development due to the combinatorial explosion in the
number of tree nodes. What is needed is a clear and simple methodology for extracting the knowledge that is hidden in the heterogeneous tree
data. In this paper, we show that association rules can be unveiled and
provided from any XML documents using a special data structure, called
Simple and Eﬀective Lists Structure (SELS), avoiding the computationally intractable problem in the number of nodes. SELS is ﬂexible and powerful enough to represent both simple and complex structured association
relationships in XML data.
Keywords: XML mining, Association rules, XML association rule, Tree
structured data.

1

Introduction

Data Mining, one of the fast growing computer science ﬁelds, is used to extract
interesting knowledge from rich sources of data stored in data repositories. As
one of many ways to represent the knowledge, association rules [1] are eﬀective
in describing interesting relations in massive amounts of data.
Currently, XML [11] is being used to encode data virtually all areas of Internet
applications. The ability to extract knowledge from them becomes increasingly
important. Due to the inherent ﬂexibilities of XML ﬁnding knowledge in XML
data is more challenging than from traditional well-structured data. Hence, extracting association rules from the semi-structured XML data still remains a
major problem, which was ﬁrst introduced by Braga et al. [3].
This work was supported in part by the Ubiquitous Autonomic Computing and
Network Project, 21st Century Frontier R&D Program and by the university IT
Research Center project (ITRC), funded by the Korean Ministry of Information and
Communication.
Y. Shi et al. (Eds.): ICCS 2007, Part III, LNCS 4489, pp. 709–716, 2007.
c Springer-Verlag Berlin Heidelberg 2007

710

J. Paik et al.

Under the traditional framework for association rule, the basic unit of data
to deal with is database record, and the construct unit of a discovered association rule is item having an atomic value [5]. However, since the structure of
XML is a tree, it is required to have counterparts of record and item in association relationships. In the light of ﬂexibility and hierarchy of tree, the construct unit of an XML association rule is usually generated by repeated tree
joins which are performed by nodes combinations. The combinatorial time for
unit generations becomes an inherent bottleneck of mining XML association
rules.
In this paper,we deﬁne some fundamental concepts applied to the XML
association rules. Furthermore, we present a clear and simple methodology
for mining association rules from XML trees, which is guided by a special
data structure, called Simple and Eﬀective List Structure (SELS). The proposed structure not only reduces signiﬁcantly the number of combinatorial
times for obtaining desirable rules, but also simpliﬁes greatly the extraction
processes. To the best of our knowledge, this paper is the ﬁrst attempt: 1)
to deﬁne formally association rules from the tree-based data, 2) to provide a
data structure model for uncovering XML association rules, and 3) to propose
techniques for the data structure-guided extracting of association rules from
large XML data.

2

Related Work

Since the problem of extracting association rules was ﬁrst introduced in [1] upon
retail databases, a large amount of work has been done in various directions. The
famous Apriori algorithm for extracting association rules was published independently in [2] and in [9]. Then, a number of algorithms for extracting association
rules from multivariate data have been proposed [6,8]. Because a huge part of
the data available on the Internet is represented in XML, a couple of proposals
to exploit XML within data mining have been suggested. Singh et al. [7] proposed to mine association rules that relate structural data values to concepts
extracted from unstructured and/or semi-structured data. However, they do not
seem suitable for discovering association rules from XML documents. Because
their approach is not for the context of native XML documents and it considers just strict parent-child relations. Recently, tools for extracting association
rules from XML documents have been proposed in [4,10], but both of them are
approaching from the view point of a XML query language. This causes the
problem of language-dependent association rules mining.
In this paper, we focus on rules detection from a collection of XML documents currently prevailed over the web. Each of XML documents corresponds
to a database record, and possesses a tree structure. Accordingly, we extend the
notion of associated item to an XML tree, and build up associations among trees
rather than items.

A Framework for Data Structure-Guided Extraction

3
3.1

711

Preliminaries
Association Rules for Traditional Data

Association rule is one of data mining technique to discover interesting rules or
relationships among attributes in databases. It was ﬁrst introduced by Agrawal
et al. [1] to analyze customer habits in market basket transactions. It is an
implication of the form X ⇒ Y , where the rule body X and head Y are subsets
of the set I of items (I = {I1 , I2 . . . In }) within a set of transactions D and
X ∩ Y = φ. A rule X ⇒ Y states that the transactions T (T ∈ D) that contain
the items in X (X ⊂ T ) are likely to contain also the items in Y (Y ⊂ T ).
Association rules are characterized by two measures: the support, which measures
the percentage of transactions in D that contain both items X and Y (X ∪ Y );
the conﬁdence, which measures the percentage of transactions in D containing
the items X that also contain the items Y . More formally, given the function
freq(X, D), which denotes the percentage of transactions in D containing X,
we deﬁne: sup(X ⇒ Y ) = freq(X ∪ Y, D), conf(X ⇒ Y ) = freq(X∪Y,D)
freq(X,D) . The
problem of mining association rules from a set of transactions D consists of
generating all the association rules that have support and conﬁdence greater
than two user-deﬁned thresholds: minimum support (min sup) and minimum
conﬁdence (min conf ).
3.2

Association Rules for Tree-Structured XML Data

XML represents data as trees, and makes no requirement that the trees be
balanced. Indeed, XML is remarkably free-form, with the only requirements
being that 1) the root is the unique node denoting a whole document, 2) the other
internal nodes are labeled by tags, and 3) the leaves are labeled by contents or
attributes of tags. Thus, XML tree is often called rooted labeled tree. For brevity,
in the remaining of this paper, we call a rooted labeled tree as simply a tree. Let
T = (N, E) be a labeled rooted tree where N is a set of labeled nodes and E is
a set of edges.
Deﬁnition 1. Given a tree T = (N, E), we say that a tree F = (NF , EF ) is a
fragment of T , denoted as F
T , if and only if (i) NF ⊆ N , (ii) for all edges
(u, v) ∈ EF , u is an ancestor of v in T , and (iii) the label of any node v ∈ NF is
preserved in T .
Intuitively, as a fragment in this paper, any fragment F must not break the
ancestor-descendant relationship among the nodes in a tree T .
Deﬁnition 2. The basic construct unit of XML association rule is referred to as
tree-structured item, shortly titem. Any fragment is eligible for a titem because
the whole XML document consists of several fragments and the structure of
fragment is tree.
Assume that D = {T1 , T2 . . . Tn } is a collection of XML documents and |D| means
the number of documents in D. Let F = {Fi , i > 0 | Fi Tj , f or 0 < j ≤ n} be
a total set of fragments and I = {I1 , I2 . . . Im } be a set of titems, where I ⊆ F.

712

J. Paik et al.

Desktop

BestSeller

Details

Order

Printer

Brand Model Price Brand Price

…

Desktop

…

Desktop … Printer

Desktop
Company QuickInfor
Brand Price Model

Brand

Brand

“HP”

“HP”

“HP” “d530”“1230” “HP” “350”
“HP” “1230”“d530”

T1

min_sup = ྴ,

T2

(a) A set of XML trees

T3

Brand

Model

“HP”

“d530”

X

Desktop

Printer

ഩ

Printer

Brand

Brand

“HP”

“HP”

“HP”

X

Y

Y ,

ഩ

Brand

…

(b) Possible XML association rules

Fig. 1. Extraction of association rules from heterogeneous database D

Deﬁnition 3. An XML association rule is an implication of the form X ⇒ Y ,
which satisﬁes following two conditions: (i) X ∈ I, Y ∈ I, (ii) (X Y ) ∧ (Y
X).
Diﬀerent from traditional association rules where associated items are usually
denoted using simple tuple-based data, the items in XML association rules have
hierarchical tree structures (titem), as indicated by the ﬁrst clause of the deﬁnition. The second clause of the deﬁnition requires that titems are independent
each other in an XML association rule.
Lemma 1. If one of X or Y (X ⇒ Y ) is assigned the entire tree T (T ∈ D)
as a titem, the other should be assigned among titems I which is a subset of
fragment F , where F = F − {Fi , i > 0 | Fi T }.
Proof. Let assume the body X is a tree T2 in D and the head Y is FT2 , one of
fragments of T2 . The association rule T2 ⇒ FT2 , however, is against Deﬁnition 3.
Since FT2 is a fragment of T2 , it is included in T2 . Hence, they are not independent
each other, which is the second condition of Deﬁnition 1. Therefore, any fragment
of a tree T in D cannot be X or Y , if one of X or Y is a tree T .
Deﬁnition 4. Given D, the support and conﬁdence of an XML association rule
X∪Y |
, conf(X ⇒
X ⇒ Y are deﬁned as: sup(X ⇒ Y ) = freq(X ∪ Y, D) = |D|D|
X∪Y |
Y ) = freq(X∪Y,D)
= |D|D
, where DX∪Y = {Ti | Ij ∈ (X ∪ Y ) and Ij
freq(X,D)
X|
Ti , Ti ∈ D}, and DX = {Ti | Ij ∈ X, and Ij Ti , Ti ∈ D}.

Let us consider three XML trees in Fig. 1(a), where each diﬀerent information is provided from various data sources, e.g., ordering information (Order)
and the detailed information of a product (Details). Consider the extraction
of frequently occurring association rules in D that if a customer purchases HP
Desktop, usually s/he is likely to buy HP Printer depicted in Fig. 1(b). The
support of an association rule freq(X ∪ Y, D) is 0.66 because both titems X
and Y appear together in T1 and T3 out of three, i.e., in 66% of the cases. Likewise, freq(X, D) is 1 since the titem X is included in all of three trees, i.e., in
100% of the cases. Therefore, we can compute the conﬁdence of XML association
0.66
rule as: freq(X∪Y,D)
freq(X,D) = 1 , which returns 0.66; it means HP Desktop is usually
purchased at the rate of 66% in computer products together with HP Printer.

A Framework for Data Structure-Guided Extraction

4
4.1

713

Extracting Association Rules Using SELS
Design and Construction of SELS

The ﬂexibility of tree data comes from its hierarchical structure. The hierarchy,
however, causes technical problems to exploit or extract some valuable partial
data from the entire dataset. After some careful examination, we believe that
the bottleneck of hierarchy is at fragments generation and titem tests. If one can
only generate fragments which guarantee being proper titems, the rule mining
performance can be substantially improved. Simple and Eﬀective List Structure
(SELS) is devised to enable avoiding useless fragments generation, reduce computational complexity and enhance fast extraction of desired fragments. It is a
set of lists which includes all information of characteristics of trees, such as label,
node id, tree id, and parent/ancestor relationships among nodes.
Deﬁnition 5. Given a tree database D, node ids and tree ids are members of
a single list under each unique node label. The list is operationally divided into
two parts; one is for identifying list itself between a number of lists, and the other
is for storing all relevant frequency information in a tree database. The former
deals with a label of node and node ids being assigned the label. The latter is
mostly about frequency of a label; tree id is kept, but there is a special ﬁled for
hierarchy of nodes assigned the label in trees; parent node ids are stored. Because
complete single list is composed of ﬁnally node ids and tree ids, the list is called,
Node and Tree List (NaTL). In addition, the leading part for distinguishing each
NaTL is named head of NaTL, shortly ntlhead and the trailing part for counting
frequency of each label is body of NaTL, ntlbody .
Every ntlhead consists of three ﬁelds in which a label, node ids assigned the label,
and pointer to its corresponding ntlbody are included. As described in Deﬁnition
5, each ntlhead is unique due to the label in it thus, the label is called key of
SELS for database D. The corresponding ntlbody is a linkedlist of several elements. A single element is composed of one pointer ﬁeld for next element and
two id ﬁelds; one is for tree which contains node(s) assigned the label in ntlhead
and the other is for parent nodes of the node(s) in the tree. The number of
elements in a ntlbody means a total number of trees in D that assign the label
to their node(s). In other words, the count of elements gives the information of
the frequency of a label with respect to the database D, and represents size of
NaTL denoted as |ntl|. The size plays a key role to ﬁlter out some undesirable
NaTLs from SELS.
4.2

Method of Reﬁning SELS

Initially constructed SELS is composed of NaTLs of every unique node label.
Therefore, it is highly possible that some NaTLs having not frequently occurred
node labels are included in the SELS.

714

J. Paik et al.

Deﬁnition 6. Given a min sup, an NaTL is frequent if and only if size of its
body |ntlbody | is greater than or equal to |D| × min sup, otherwise unfrequent.
After ﬁltering out unfrequent NaTLs, only frequent NaTLs whose body sizes
satisfy the threshold are remained in SELS. This ﬁrstly ﬁltered SELS is called
shallowly-frequent SELS, shortly sfS. It is similar to having only frequent 1-size
subtrees which have only one node labeled by a key of SELS. In traditional
generate-and-test approaches, each frequent 1-size subtree is grown by joining
of subtrees or enumeration of subtrees. In our approach, however, due to SELS,
there is no need to grow subtrees. Instead, we verify each parent node in elements
of ntlbody if it is unfrequent or not. Because all nodes composing a tree must
be frequent in order the tree has to be frequent, as a ﬁrst step to expand a
single frequent node, the frequency of every parent node related to it should
be considered. However, it is not guaranteed in sfS. This is the reason why the
SELS is called shallowly-frequent after ﬁltration of some NaTLs.
To reﬁne sfS the unfrequent NaTLs are required. A candidate hash table is generated containing them, and it is built simultaneously with sfS. In the tabel, node
ids are keys of table, a labeling function plays a role of hash function, node labels
are indexes, and ntlbody s of unfrequent ntlhead s are records of indexes. Because
every node is assigned only one label and it is not changed until artiﬁcial manipulation is performed, we assume that the labeling function is same as a hashing
function. After ﬁnishing the reﬁnement, the hash table is removed from the memory. The purpose of second reﬁnement of SELS to deal with every parent node in
elements and to make sfS contain all frequent nodes. We call this acquired SELS,
deeply-frequent SELS, abbreviated dfS. To obtain dfS we proceed as follows: (1) a
parent node in an element is veriﬁed by the candidate hash table to detect if the
node is assigned by unfrequent label or not. (2) If so, the node is marked ‘replace’
and its record is retrieved to search a node id assigned by frequent node labels.
(3) Step (1) and (2) continues until the node id assigned by any frequent node label is found. (4) The original parent node id is replaced by the found node which
is actually an ancestor node of the original parent node. (5) Through step (1) to
(3), if no any other nodes are frequent, the original parent node id is replaced by
null. After applying above reﬁning procedure over all parent nodes in elements,
dfS holds only frequent node ids and associated labels (keys of dfS).
Given a dfS, both ntlhead s and ntlbody s are associated together depending on
ancestor-descendant relationship. Note that every node id is only assigned by
one of the keys of dfS. At least one big labeled tree 1 is derived from dfS. We
call this derived tree as Minimum Support Satisfying Trees (MSST). During the
construction of MSST, each edge has its own count which represents how much
often it is occurred. If the frequency does not satisfy σ × |D|, the corresponding
edge is deleted from MSST. After scanning all edges of MSST, tree(s) which
is(are) satisfying min sup is(are) derived. The stepwise reﬁnement of SELSD
and its derived MSST are illustrated in Fig. 2. Due to the lack of space, we only
show the preﬁx of labels in SELS and MSST; only heads of NaTLs and labels
in MSST .
1

To avoid derive graphs we duplicate nodes shared by diﬀerent parents/ancestors.

A Framework for Data Structure-Guided Extraction
shallowly-frequent SELSD, sfSD
16
B (4,10), 18, (27,29)
2,3 T1

keys of SELSD
24

T3 /

NaT-L (ntl)

B (4,10), 18, (27,29)

2,3

T1

T2

C

15

T2 /

Be

24
16

D

2, 15, 25

De

14

d5

8, 23

H (7,12), 19, (28,30)

16

1

T1

/

T2 /

5

14

T2

T1

21

T2 /

4,10 T1

18

T2

17

T2 /

2

T1

O

1

/

T1 /

P

(6,11), 20

2,3

T1

17

T2 /

24

T3 /

M

5, 21

Pr

3, 26

Q

17

1230
350

9, 22

13

1

T1

15

T2 /

6

T1

11

T1 /

20

ntlhead

25,26 T3
24

/

2, 15, 25

1

T1

14

T2

d5

8, 23

5

T1

21

T2 /

H (7,12), 19, (28,30)

T3 /

27,29 T3 /

4,10 T1

18

T2

T1

17

T2 /

M

5, 21

2

P

(6,11), 20

2,3

T1

17

T2 /

Pr

3, 26

1

T1

24

T3 /

1230

9, 22

6

T1

20

T2 /

deeply-frequent SELSD, dfSD
15
B (4,10), 18, (27,29)
2,3 T1
2, 15, 25

/

T1

/

T2

d5

8, 23

5

T1

21

T2 /

T2 /

4,10 T1

18

T2

T1

15

T2 /

M

5, 21

2

P

(6,11), 20

2,3

T1

15

T2 /

Pr

3, 26

/

T1

/

T3 /

1230

9, 22

6

T1

20

T2 /

(a) Initially constructed SELS

2,
2, 15,
15, 25
25

#2 #2
B
#2
H

M

25,26 T3 /
24

T3 /

27,29 T3 /

25,26 T3 /
/

T3 /

27,29 T3 /

(b) sfS and dfS

/

/
#2

#3
D

T2

D

H (7,12), 19, (28,30)

ntlbody

T2

D

715

/

T1

/

T2

#2
P

#2

/

T3 /

Pr

Pr

D

#2

#1

B

P

B

M

H

d5

P

B

#2

d5

1230

1230

(c) MSST before and after deleting some edges
Fig. 2. Stepwise Reﬁnement of SELS and Derived Trees

4.3

Correlating Concrete Contents with Structures

Let (hi , ehi ) and (hj , ehj ) be two NaTLs in MSST. The sizes of two elements,
|ehi | and |ehj |, are greater than |D|×min sup. Let ti and tj be the all tree indexes
included in ehi and ehj , respectively. The sizes of each ti and tj are exactly same
as the sizes of each ehi and ehj . We denote a path between them by Pij = (hi , hj )
where hi is an ancestor of hj by Deﬁnition 1. Let I = {I1 , . . . , Im } be a set of
titems. Assume that I1 = Pij = (hi , hj ) and I2 = Ppq = (hp , hq ) be titems. The
conﬁdence of I1 ⇒ I2 is computed as:
conf(I1 ⇒ I2 ) =

|ti ∩ tj ∩ tp ∩ tq |
freq(I1 ∪ I2 , D)
=
freq(I1 , D)
|ti ∩ tj |

(1)

Theorem 1. Given a min sup and MSST, all of XML association rules conforming to any min conf are extracted.
Proof. Let (hi , ehi ), (hj , ehj ) and (hk , ehk ) be three NaTLs in MSST. Assume
that |ti ∩ tk | = β, and |ti ∩ tj ∩ tk | = γ. Given min sup and min conf are sm
and cm , respectively, where 0 < sm , cm ≤ 1. Let x and y be a tree index in tj
and tk , respectively, for x = y.

716

J. Paik et al.

– titema (x ∈ ti ∧ y ∈
/ ti ): The hi and hj forms Pij . It is a titem Iij . The
support of titema is deﬁnitely greater than or equal to sm due to the characteristics of MSST.
– titemb (y ∈ ti ∧ x ∈
/ ti ): The hi and hk forms Pik . It is a titem Iik . The
support of titemb is also greater than or equal to sm .
– Association Rule The conﬁdence of an implication of the form Iij (titema)⇒
Iik (titemb ) is computed by using the equation (1):
conf(Iij ⇒ Iik ) =

5

γ
=
β

rules with conﬁdence ≥ cm if γ ≥ β × cm ,
rules with conﬁdence < cm if γ < β × cm .

Conclusion

This paper has presented a framework for data structure-guided association rules
extraction from XML trees. We are currently ﬁnishing touches of practical algorithms for our approach and evaluating the performance results.

References
1. Agrawal, R., Imielinski, T., Swami, A. N.: Mining Association Rules between Sets of
Items in Large Databases. Proc. of the ACM SIGMOD Intl. Conf. on Management
of Data (1993) 207–216
2. Agrawal, R., Srikant, R.: Fast Algorithms for Mining Association Rules. Proc. of
the 20th Intl. Conf. on VLDB (1994) 478–499
3. Braga, D., Campi, A., Klemettinen, M., Lanzi, P. L.: Mining Association Rules
from XML Data. Lecture Notes in Computer Scienec, Vol. 2454. Springer-Verlag,
Berlin Heidelberg New York (2002) 21–30
4. Braga, D., Campi, A., Ceri, S., Klemettinen, M., Lanzi, P. L.: A Tool for Extracing
XML Association Rules. Proc. of the 14th IEEE Intl. Conf. on Tools with Artiﬁcial
Intelligence (2002) 57–64
5. Feng, L., Dillon, T., Weigand, H., Chang, E.: An XML-Enabled Association Rule
Framework. Lecture Notes in Computer Scienec, Vol. 2736. Springer-Verlag, Berlin
Heidelberg New York (2003) 88–97
6. Han, J., Fu, Y.: Discovery of Multiple-Level Association Rules from Large
Databases. Proc. of the 21st Intl. Conf. on VLDB (1995) 420–431
7. Singh, L., Scheuermann, P., Chen, B.: Generating Association Rules from SemiStructured Documents Using an Extended Concept Hierarchy. Proc. of the 6th
Intl. Conf. on Information and Knowledge Management (1997) 193–200
8. Srikant R., Agrawal, R.: Mining Generalized Association Rules. Proc. of the 21st
Intl. Conf. on VLDB (1995) 409–419
9. Toivonen, H.: Sampling Large Databases for Association Rules. Proc. of the 22th
Intl. Conf. on VLDB (1996) 43–52
10. Wan, J. W. W., Dobbie, G.: Extracting Association Rules from XML Documents
Using XQuery. Proc. of the 5th ACM Intl. Workshop on Web Information and
Data Management (2003) 94–97
11. The World Wide Web Consortium (W3C). Extensible Markup Language (XML)
1.0 (Third Edition) W3C Recommendation, http://www.w3.org/TR/2004/RECxml-20040204/, 2004.

