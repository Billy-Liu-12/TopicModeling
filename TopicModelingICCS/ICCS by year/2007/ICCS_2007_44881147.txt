Description Logic Representation for Requirement
Specification∗
Yingzhou Zhang and Weifeng Zhang
College of Computer, Nanjing Univ. of Posts and Telecom., Nanjing 210003, China
zhangyz@njupt.edu.cn

Abstract. With the size and complexity of many software systems increasing,
they need to give a greater emphasis to capture and maintain requirement
knowledge within the software development process. This knowledge can be
captured by the requirement ontology. But the requirement analysis systems
must balance expressivity and inferential power with the real demands of requirement ontologies construction, maintenance, performance, and comprehensibility. Description logics (DLs) possess several features—a terminological
orientation, a formal semantics, and efficient reasoning procedures— which offer an effective tradeoff of these factors. In this paper, we use description logics
SHIQ to define the objects and their relations, and identify the subsumptions
capturing the constraints and relationships among the objects. We show how the
subsumptions can be used to answer some questions.

1 Introduction and Related Works
The requirement analysis plays an important role in the software engineering. But the
requirements are often ambiguous, incomplete and redundant; they are also changed
frequently during the design process due to the changes of technology and customer’s
objective [1]. To make sure that different engineers have a common understanding of
the terms to be used, the ontology-oriented requirements approach was presented in
[2 - 4]. An ontology [6, 7] is a collection of definitions of concepts and the shared
understanding [5]. The requirement ontology is a part of a more general ontology to
capture engineering design knowledge [8, 9].
The requirement ontology was formally described in [1] and [2], but their abilities
of reasoning were inefficient and undecidable. As requirement information grows in
scale, the requirement analysis systems must balance expressivity and inferential
power with the real demands of requirement ontologies construction, maintenance,
performance, and comprehensibility. Being one of decidable fragments of first-order
logic, description logics (DLs) [10-12] possess several features—a terminological
orientation, a formal semantics, and efficient reasoning procedures— which offer an
effective tradeoff of these factors [13]. In this paper, we will represent a requirement
specification through a requirement ontology that is described by description logics.
∗

This work was supported in part by the National Natural Science Foundation of China
(60503020), the Natural Science Research Plan for Jiang Su High School (05KJD520151).

Y. Shi et al. (Eds.): ICCS 2007, Part II, LNCS 4488, pp. 1147–1154, 2007.
© Springer-Verlag Berlin Heidelberg 2007

1148

Y. Zhang and W. Zhang

With the use of description logics, our approach not only can provide a design terminology to be easily shared by the corresponding engineers, but can define precisely
and unambiguously the meaning of the terminology.
The remainder of this paper is organized as follows. In section 2, we firstly briefly
review why it is necessary to represent requirement specification as requirement ontology. Then, we provide a brief introduction to description logics in section 3. In
section 4, we use description logics SHIQ to formally represent requirement specification. In section 5, we show how to use our representation method to answer some
common sense questions. Finally, section 6 gives the conclusions.

2 Requirement Ontology for Requirement Specification
As we all know, the requirements are often ambiguous, incomplete, redundant and
variational in the software engineering environment. Requirements generated by different engineers may be inconsistent since different designers may have different
perspectives on the system. This may bring about the same term is applied to different
concepts and different terms are used to denote the same entity. A suitable solution
was the use of ontologies which can make sure that different engineers have a common understanding of the terms to be used.
Originally, ontology was a concept in the philosophy. It describes the essence and
composition of the world, as said by the philosophers. In computer science, ontology
is mainly used for knowledge representation. It provides a means for knowledge sharing which is very much desirable in large-scale knowledge based projects, including
the traditional software engineering projects [3]. Nowadays, more and more software
engineers became interested in studying and using ontology concepts in their research
projects [8].
In [2], the five points for using ontology in requirement analysis were presented:
1.
2.
3.
4.
5.

Make relations as independent knowledge units
Organize the objects in ontologies.
Takes objects as basic components of ontologies.
Let ontologies form their own inheritance hierarchies.
Allow ontologies to be nested.

As the same to them, we are interested in a formal and rigorous approach to the
representation of knowledge. But we will adopt the description logics to define the
objects and their attributes, and identify the axioms capturing the constraints and
relationships among the objects.
Before providing a brief introduction to description logics (in next section), we
summarize their advantages for knowledge representation as following:
1. Translation to first-order predicate logic usually possible
2. Based on formal semantics: including declarative and compositional semantics;
standard Tarski-style interpretation I = ( ΔI , ⋅ I )
3. Inference problems decidable
4. Probably the most thoroughly understood set of formalisms in all of knowledge
representation

Description Logic Representation for Requirement Specification

1149

5. Wide range of logics developed: from very simple (no disjunction, no full negation) to very expressive (comparable to DAML + OIL)
6. Very tight coupling between theory and practice.

3 Description Logics
Description Logics (DLs) are knowledge representation formalisms that are able to
capture virtually almost all class-based representation formalisms used in Artificial
Intelligence, Software Engineering, and Databases. The basic elements of DLs are
concepts (also called classes) and roles, which denote sets of objects and binary relation, respectively. Concept expressions and role expressions (in the following simply
called concepts and roles) are formed by starting from a set of atomic concepts and
atomic roles, i.e., concepts and roles denoted simply by a name, and applying concept
and role constructs [13].
The most expressive DL that we refer to in this paper is called SHIQ [14-16]. In
such logic, concepts and roles are formed according to the following syntax:
C, D ::= A | C⊓D | C⊔D | ¬C | ∃R.C | ∀R.C | ≥ nR.C | ≤ nR.C .

(1)

R, S :: = P | R − | R ⊑ S .

(2)

where A and P denote respectively atomic concepts and atomic roles; C (or D) and R
(or S) denote respectively arbitrary concepts and roles with transitive role R+ ⊆ R; n
denotes a positive integer.
Syntax

Semantics

A

A I ⊆ ΔI

P

P I ⊆ ΔI × ΔI

C⊓D

C I ∩ DI

C⊔D

C I ∪ DI

¬C

ΔI \ C I

∃R.C

{x | ∃y. <x, y>∈ R I ∧ y∈ C I }

∀R.C

{x | ∀y. <x, y>∈ R I ⇒ y∈ C I }

≥ nR.C

{x | #{ y| <x, y>∈ R I ∧ y∈ C I } ≥ n }

≤ nR.C

{x | #{ y| <x, y>∈ R I ∧ y∈ C I } ≤ n }

R−

{<x, y> | <y, x>∈ R I }

R⊑S

RI ⊆ S I
Fig. 1. Formal Semantics of the SHIQ

1150

Y. Zhang and W. Zhang

The formal semantics of SHIQ is showed in Figure 1. In Figure 1, the superscript I
is an Standard Tarski-style interpretation I = ( ΔI , ⋅ I ) [17]; the notation #M denotes
the cardinality of the set M.
We also use the following abbreviations to increase readability:
⊥ ≡ A⊓¬A .

(3)

⊤ ≡ A⊔¬A .

(4)

( ≤ nR.C) ≡ ¬( ≥ n+1R.C ) .

(5)

(= nR.C) ≡ ( ≥ nR.C )⊓( ≤ nR.C) .

(6)

C⊔D ≡ ¬(¬ C⊓¬D) .

(7)

∃R.C ≡ ¬∀R. ¬C .

(8)

In next section, we will show how to use SHIQ to describe ontology in software
requirement.

4 Representation of Requirement Specification and Reasoning
in SHIQ
As mentioned above (Section 1 and 2), the high quality requirement ontologies are
crucial for the software design and development, and their construction, maintenance,
performance, and comprehensibility greatly depend on the availability of a welldefined semantics and powerful reasoning tools. Since DLs provide for both, they
should be ideal technologies to describe the requirement specifications. Furthermore,
some features of SHIQ make this DL expressive enough to represent the requirement
ontologies. These features include expressive number restrictions, the formulation of
complex terminological axioms, and especial roles (such as inverse roles, transitive
roles, and subroles) [5].
Subsumptions (e.g. C ⊑ D) are usually called inclusion assertions [13]. A finite set
of inclusion assertions is called a TBox (Terminological Box). The requirement ontology can be formalized in a TBox of SHIQ.
To express requirement ontology in SHIQ, we firstly restrict the possible worlds by
introducing restrictions on the interpretations of requirement specification. For the
example shown in [1]:
“There are three components of a desk spot lamp, namely Heavy_base, Small_head
and Short_arm”
we can use inclusion assertions:
Desk_spot_lamp ⊑ ∃has_component.Heavy_base ⊓ ∃has_component.
Small_head ⊓ ∃has_component. Short_arm .
where has_component is a transitive role (relation).

(9)

Description Logic Representation for Requirement Specification

1151

In addition, a designer introduces a hole as a feature to the arm of a desk spot lamp
so that an electrical cord can run through it, and two threaded bars as another feature.
This can be expressed as following:
Short_arm ⊑ ∃has_feature.Hole ⊓ ∃ ≥ 2 has_feature.Threaded_bar ⊓ ∃ ≤ 2
has_feature. Threaded_bar .

(10)

Then we can define the relevant notions of our software requirement using concept
definitions. For example, the two concepts: primitive and composite, can be defined
respectively as:
primitive ≡ ¬(∃has_component.⊤) .

(11)

composite ≡ ¬ primitive .

(12)

and

The requirements describe the properties of what being designed. Primitive requirements often come from the customer expressing his/her wishes. They are often
ambiguous, incomplete and redundant; they are also changed frequently during the
design process due to the changes of technology and customer’s objective. Our ontology-oriented requirements approach in SHIQ can overcome them conveniently. For
example, the following defines the requirement “the weight of desk spot lamp must be
less than 2.0 pound”:
Desk_spot_lamp ⊑ ∀has_weight.∀less_than.A1 .

(13)

where the atomic concept A1 denotes “2.0 pound”. If the requirement above be
changed to “the weight of the desk spot lamp must be within 2.0 ± 0.1 pound”, we can
define it easily as:
Desk_spot_lamp ⊑ ∀has_weight.∀less_than−.A2 ⊓ ∀has_weight.∀greater_
than−.A3 .

(14)

where A2 and A3 denotes respectively “1.9 pound” and “2.1 pound”; less_than− and
greater_than− is the inverse role of less_than and greater_than, respectively.
In addition, the customer may specify that the desk spot lamp should be able to
use for lighting more than half a square meter of room. This can also be described
easily as:
Desk_spot_lamp ⊑∀has_feature.Lighting_feature ⊓ ∀has_Lighting_area.
∀less_than−.A4 .

(15)

where A4 denotes “0.5 square meter”.
In a word, SHIQ (esp. its TBox) can, on the one hand, represent conveniently the
expression of concept hierarchies. On the other hand, new concepts can be defined
easily by the combination of already given ones. Furthermore, this SHIQ system provides us with various reasoning capabilities that let us deduce implicit knowledge
from the explicitly represented knowledge. These capabilities contain deciding satisfiability and subsumption of SHIQ-concepts w.r.t. TBoxes and role hierarchies,

1152

Y. Zhang and W. Zhang

checking consistency of SHIQ-TBox and checking instance of concepts and roles (for
more, please see [12, 14-16]).
For example, the instance
Desk_spot_lamp (x)
means that x belongs to the concept Desk_spot_lamp. From Axiom (9) we can obtain
the following instances:
has_component(x, y1), has_component(x, y2), has_component(x, y3)
where has_component(x, y1) denotes that the desk spot lamp x has a component y1; y1,
y2, and y3 belong respectively to Heavy_base, Small_head and Short_arm.

5 Queries in Description Logics
As shown in Section 4, we have used the description logic SHIQ to present the terminology and assertions for ontology centered on requirements in software engineering.
The advantages of our technology based on SHIQ are the convenient expression of
concept hierarchies, the ease of defining new concepts by the combination of already
given ones, and the efficient and decidable reasoning capabilities. In addition, this
requirement ontology described in SHIQ can be used for answering many common
sense questions, by deduction using queries in description logics. In this paper, these
queries are non-recursive queries whose predicates are the concepts and relations that
appear in the DLs knowledge base. For a comprehensive discussion on answering
queries in DLs, see [12,15,16,18].
A SHIQ knowledge base (KB) K is a SHIQ-TBox. And a query expression q over a
SHIQ knowledge base K is a nonrecursive query of the form
q(x) ← conj1(x, y1) ∨ … ∨ conjm (x, ym) .

(16)

where conji (x, yi) is a conjunction of atoms; x, yi are the variables appearing in the
conjunct; x perhaps is the set of x1, … , xi . Each atom has one of the forms C(t) and
R(t1, t2), where t, t1, t2 are variables in x and yi or objects of the knowledge base. A
query expression q is interpreted as the set qI of constants 〈c1, … , cn〉, such that, when
substituting each ci for xi, the formula
∃ y1. conj1(x, y1) ∨ …∨ ∃ ym. conjm (x, ym) .

(17)

computes to true in the given interpretation I .
For the example in [1]: “in a complex artifact, we may want to find out where a
specific type (or class) of parts are used, i.e. to find out those parts that have a component of the type (lets denote it by T )”. We can express it as the following query
expression:
q(x) ← conj(x, y) .

(18)

conj(x, y) ≡ has_component(x, y) ∧ T (y) .

(19)

Description Logic Representation for Requirement Specification

1153

6 Conclusion
In this paper we used description logic SHIQ to formally describe an ontology for
requirements in the engineering design domain. The advantages of our technology
based on SHIQ are the convenient expression of concept hierarchies, the ease of defining new concepts by the combination of already given ones, and the efficient and
decidable reasoning capabilities.
We showed how our requirement ontology addressed some issues on requirement
knowledge. The ontology provided communication of requirements by defining a
well-defined syntax and semantics. It allowed for checking for, completeness, consistency, and satisfiability. It provided a knowledge base for tools that perform document creation.

References
1. Jinxin, L., Mark, S.F., Taner B.: A Requirement Ontology for Engineering Design. In:
Concurrent Engineering: Research and Application, Vol. 4, No.3. (1996) 279-291
2. Lu, R., Jin, Z., Chen, G.: Ontology-Oriented Requirements Analysis. Chinese Journal of
Software, Vol. 11, No. 8. (2000) 1009-1017
3. Lu, R., Jin, Z.: Formal Ontology: Foundation of Domain Knowledge Sharing and Reusing.
Chinese Journal of Computer Science and Technology, Vol. 17, No. 5. (2002) 535-548
4. Jin, Z.: Ontology-Based Requirements Elicitation. Chinese Journal of Computers, Vol. 23,
No. 5. (2000) 486-492
5. Baader, F., Horrocks, I., Sattler, U.: Description Logics as Ontology Languages for the
Semantic Web. In: Proc. of the International Conference on Conceptual Structures (ICCS
2003). LNAI, 2003. To appear
6. Guarino, N.: Formal Ontology: Conceptual Analysis and Knowledge Representation. International Journal of Human-Computer Studies, Vol. 43, No. 5/6. (1995) 625-640
7. Gruber, T.R.: Towards Principles for the Design of Ontologies Used for Knowledge Sharing. Int. Journal of Human-Computer Studies, Vol. 43, No. 5/6. (1995) 907-928
8. Abran, A., Cuadrado-Gallego, J.J., García-Barriocanal, E., Mendes, O., Sánchez-Alonso,
S., Sicilia, M.A.: Engineering the Ontology for the Swebok: Issues and Techniques. In:
Calero, C., Ruiz, F., Piattini, M. (eds.): Ontologies for Software Engineering and Software
Technology. New York: Springer. (2006) 103-122
9. Sicilia, M.A., Cuadrado-Gallego, J.J., Rodríguez, D.: Ontologies of Software Artifacts and
Activities: Resource Annotation and Application to Learning Technologies. 2005 International Conference on Software Engineering Research and Practice, Taipei (Taiwan).
(2005) 145-150.
10. Calvanese, D., Lenzerini, M., Nardi, D.: Description Logics for Conceptual Data Modeling. In: Logics for Databases and Information Systems. Kluwer-Academic Pulisher, (1998)
229-264
11. Calvanese, D., Lenzerini, M., Nardi, D.: Unifying Class-based Representaion Formalisms.
Journal of Intelligence Research, Vol. 11. (1999) 199-240
12. Calvanese, D., Giacomo, G.D., Lenzerini, M., Nardi, D.: Reasoning in Expressive Description logics. In: Robinson, A., Vornonkov, A. (eds.): Handbook of Automated Reasoning.
Elsevier Science Publishers (North- Holland), Amsterdam. (2001) 1581-1634

1154

Y. Zhang and W. Zhang

13. Calvanese, D., Giacomo, G.D., Lenzerini, M.: Description Logics: Foundations for Classbased Knowledge Representation. Proc. of the 17th IEEE Sym. on Logic in Computer Science (LICS 2002). Copenhagen, Denmark (2002) 359-370
14. Horrocks, I., Sattler, U., Tobies, S.: Practical Reasoning for Expressive Description Logics. Proc. of the 6th International Conference on Logic for Programming and Automated
Reasoning. LNAI 1705. (1999) 161-180
15. Horrocks, I., Sattler, U.: Optimised Reasoning for SHIQ. In: Proc. of the 15th Eur. Conference On Artificial Intelligence (ECAI 2002). (2002) 277-281
16. Horrocks, I., Sattler, U., Tobies, S.: Reasoning with Individuals for the Description Logic
SHIQ. Proc. of the 17th Conference on Automated Deduction (CADE-17). LNCS 1831.
(2000) 482-496
17. Calvanese, D., Giacomo, G.D., Lenzerini, M.: A Framework for Ontology Integration.
Proc. of the First Int. Semantic Web Working Symposium (SWWS 2001). (2001) 303-316
18. Calvanese, D., Giacomo, G.D.: Answering Queries Using Views over Description Logics
Knowledge Base. Proc. of the 16th Nat. Conf. on Artificial Intelligence (AAAI 2000).
(2000) 386-391

