Available online at www.sciencedirect.com

Procedia Computer Science 4 (2011) 2246–2256

International Conference on Computational Science, ICCS 2011

Parallel GMRES Incomplete Orthogonalization Auto-Tuning
Pierre-Yves Aquilantia,b , Serge Petitonb , Henri Calandraa
a GSR/TG/MTG,

TOTAL Exploration Production, Pau, France
- UMR Lille 1/CNRS 8022
Cit´e Scientiﬁque - Bˆatiment M3
59655 Villeneuve d’Ascq C´edex - France
b LIFL

Abstract
Krylov linear solvers are widely used to solve various kind of scientiﬁc problems. They are entitled to many
optimization in order to reduce the processing time needed to attain solution. However, these optimisations are mainly
problems speciﬁc and do not always ﬁt well in parallel. Tuning them can sometimes require and heavy work to extract
sustainable performances. Auto-tuning helps the users to tune their solver with little eﬀort and at a small cost.
We present a general parallel auto-tuned linear solver approach in order to reduce the time of computation needed
for a solver to attain solution. Our new approach is based on the tuning of the Arnoldi incomplete orthogonalization
process within GMRES by monitoring the convergence thanks to a simple heuristic. We obtained promising results
by reducing signiﬁcantly the time of computation on diﬀerent cases in serial and parallel processing using a cluster,
involving both real and complex valued linear systems. Our work enlight the emergence of incomplete Arnoldi
orthogonalization auto-tuning as a possible optimization for iteratives methods.
Keywords: Krylov, Auto-Tuning, Orthogonalization, cluster, GMRES, Parallel

1. Introduction
As time goes by, scientiﬁc problems are becoming bigger and harder to solve, and thus require tools and computing
power in constant evolution. As a matter of fact, it became crucial to optimize those tools in parallel in order to extract
substantial performances from nowadays and future parallel hardware platforms.
The optimization of numerical software has been heavily studied during the last two decades and resulted in the
creation of numerical libraries, such as BLAST and SCALAPACK, which could help the user to partially hide the
cumbersome inducted by the complexity of parallel optimization of key numerical operations. However, with the
introduction of multi-core processors, heterogeneous computing and the growing complexity induced by massive parallelism, it became obvious that existing numerical software libraries, even newer ones like MAGMA and PLASMA
[1] or ATLAS [2], could not handle every optimizations aspects [3]. Indeed, it remains necessary for the user to heavily tune the software to extract the best performances of an algorithm with respect of a given hardware platform. Such
a tuning, to be eﬃcient, implicitly involves a tremendous amount of knowledge on the numerical optimizations and
parallelization process, and is not always aﬀordable for the end-user. However, there exist some auto-tuning software
libraries capable of handling a non negligible part of this in a goal of optimality by choosing the most appropriate
computing kernels, data structures and parameters in respect of the hardware, solver and application.
The Generalized Minimum Residual solver (GMRES) [4] is probably the most famous Krylov iterative solver
and is entitled to various optimizations of its algorithmic components and parameters which can be handled in an
1877–0509 © 2011 Published by Elsevier Ltd. Open access under CC BY-NC-ND license.
doi:10.1016/j.procs.2011.04.245

Pierre-Yves Aquilanti et al. / Procedia Computer Science 4 (2011) 2246–2256

2247

automatic fashion in order to reduce the time of computation with little eﬀort from the user. Parameters auto-tuning
showed promising results when applied to the GMRES subspace size parameter [5] or to the orthogonalization process
truncation [6]. However, there has been no study of such parameters auto-tuning in a parallel environment. For this
reason we propose an extensive experimental study on the auto-tuning of the GMRES orthogonalization process
truncation based on a new algorithm.
Firstly, in Section Two, we will present the diﬀerent auto-tuning technics and will introduce the GMRES incomplete orthogonalization process auto-tuning. Secondly, in Section Three, we will present the diﬀerent incomplete
orthogonalization strategies that we experimented and the algorithm that we designed to auto-tune the GMRES orthogonalization process truncation. We will highlight in Section Four the potential of our new algorithm using various
real and complex valued matrices in serial and then parallel processing in Section Five. We will then conclude on the
eﬃciency of such and auto-tuning approach in a parallel environment and show that this parameter auto-tuning is a
smart way to accelerate GMRES processing.
2. Motivations
As enlightened, scientiﬁc solvers, like Krylov iteratives methods, are subject to numerous optimisations to process
eﬃciently in parallel. Moreover, with the introduction of massive parallelism and heterogenous computing, it became
necessary to heavily tune those solvers to get the best performances, at the expense of an increasing complexity and
specialization. However, those optimisations, from the selection of computing kernels like the matrix-vector product
to the data storage structure and the selection of the most eﬃcient solver and attached parameters, can be achieved
with auto-tuning technics. In fact, those auto-tuning technics can be classiﬁed in a three category hierarchy according
to the fact it will be more or less related to the hardware platform or internal numeric of algorithms.
The ﬁrst category mainly focuses on the selection and conﬁguration of computing kernels and data structures and
more precisely the matrix-vector product [7], cache blocking [8], multicore issues [9] and the matrix storage data
structures [10]. Some existing libraries can manage most those optimisations like ATLAS for dense problems [2] or
PHiPAC [11] and OSKI [12, 13] for sparse linear algebra. This set of auto-tuning technics is close to the hardware
and, with regards to the diﬀerent parallelism gains and memory levels, they propose the most eﬃcient conﬁguration
of computing kernels and data structure regardless of the solvers and algorithms that will be used further.
The second auto-tuning category of our hierarchy represents the auto-tuning techniques more related to the underlying linear algebra than the ones of ﬁrst category. Thereby, this category encompass the technics of selection of
optimal solvers and algorithmic components at runtime depending on criterions external from the numeric such as
the time of computation or the improvements met over convergence. This selection can occur in parallel, as Barrett
and al. illustrated in their algorithmic bombardment [14], or in a more sequential fashion as proposed by Kuroda,
Katagiri and Kanada in [10] where it would arise by benchmarking diﬀerent orthonormalization methods at diﬀerent
intervals during runtime with the goal to select the most eﬃcient algorithm until the next evaluation occurs. In the
end, the sought goal of the use of such auto-tuning technics is to propose the most robust and most eﬃcient solver
conﬁguration from algorithmic building blocks with respect to a given hardware platform. The parallel implications
of this auto-tuning category are quite subjective because mostly depends on the solvers. Nevertheless, the selection
choices mostly depends on the eﬃciency criteria which, in fact, is related to the computing platform.
The last auto-tuning category represents the technics of selection of the optimal algorithms parameters at runtime.
One example of such an auto-tuning optimization is the dynamic variation of the subspace size of restarted Krylov
methods like GMRES(m) [4] which has been subject to many contributions [5, 15, 16, 17, 18]. However, this category
of auto-tuning is not so much used in practice because it has been presented as quite subjective to the application and
also by the fact that its parallel behavior has not fully been explored. Indeed, it is also possible to use parameters autotuning to other algorithmic modules whose conﬁguration is done prior to execution as incomplete orthogonalization
process which showed promising results on the reduction of time of computation using matrix properties [6, 19, 20].
Nevertheless, this auto-tuning category is seen as quite eﬃcient in the goal to reduce the number of computation and
the time for the solver to attain solution. Furthermore, there exist libraries which provide some auto-tuning capabilities
among iterative linear solvers with little eﬀort, Xabclib [21] is one of them.
Auto-tuning allows the user to eﬃciently tune an algorithm for a given hardware architecture and a particular
context but depending on the hierarchies category, there exist diﬀerent views on how to handle parallelism. For

2248

Pierre-Yves Aquilanti et al. / Procedia Computer Science 4 (2011) 2246–2256
q

/

,

p

(

)

example, the ﬁrst category will manage parallelism as one of the qualifying criterias of the kernels and data structures
selection in order to attain optimal performances on a parallelized hardware platform and, in this sight, has heavily
been explored. This is slightly diﬀerent for the second category which inﬂuence the parallelization process and
exploit it, in order to accelerate the modular selection of algorithms. The later and third category, on its side, will see
parallelism as a consequence of its choices of parameters and will try to ﬁnd the good balance between parameters in
the goal to accelerate convergence. However, for this last category the impact of parallelism on the parameter autotuned solver convergence has not been fully explored. This is why we propose an extensive study on the auto-tuning
of the orthogonalization process truncation in parallel for the GMRES solver.
We will ﬁrst suggest a well performing auto-tuning algorithm based on a simple heuristic allowing the algorithm
to be independent from the numerics. We will then explore the parallel capabilities of our orthogonalization process
auto-tuning algorithm. This will lead us to conclude on the possibilities of this auto-tuning in a parallel environment.
Our study is mainly experimental and will be conducted using diﬀerent real and complex valued matrices. However,
because Krylov iterative methods require some understanding we will try to expose the numerical points prior to any
explanation. We will try to keep our explanations as simple as possible, our study being more intended to the end-users
than the to experts.
3. Incomplete Orthogonalization of GMRES Method
A wide range of numerical problems are solved using linear algebra and are generally expressed by the linear
system of equations (equation 1) where the matrix A is the linear operator of size n × n, the vector b the right hand
side and the vector x the solution of the linear system, both vectors are of size n.
Ax = b

(1)

Krylov methods are iterative linear solvers which compute the solution of a given linear system (equation 1) in the
Krylov subspace (Equation 2). They minimize the residual norm over the subspace at every iteration. r0 is the initial
residual vector, x0 the initial guess (r0 ≡ b − Ax0 ) and m = 1, 2, . . . :
Km (A, r0 ) = span{r0 , Ar0 , A2 r0 , . . . , A(m−1) r0 }

(2)

The Generalized Minimum Residual (GMRES) [4] (Algorithm 1) is probably one of the most used Krylov methods
when solving nonsymmetric linear systems, it iterates within the Krylov subspace untill a stopping criteria is met (ie.
the residual norm is small enough) or it computes the exact solution (when m = n). However, iterations continue to
increase, storage and computation requirements are likely to do the same and this can become prohibitive because of
the limited computing and storage resources. A common choice to overcome this limitation is to restart the method
with the last computed solution as the new initial guess, this restarted variant is called GMRES(m) where m is the
subspace size more commonly known as the Krylov subspace size.
Algorithm 1 GMRES Algorithm
1:
2:
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:

x0 = Initial Solution
r0 = b − Ax0
h1 0 = r0 2
k=0
while (hk+1,k > 0) do
qk+1 = rk /hk+1,k
k =k+1
rk = Aqk
for i = 1, . . . , k do
hik = qTi rk
end for
hk+1,k = rk 2
xk = x0 + Qk yk where h10 e1 − H˜ k yk
end while
x = xk

2

= min

Pierre-Yves Aquilanti et al. / Procedia Computer Science 4 (2011) 2246–2256

2249

The GMRES Krylov subspace Km is built thanks to the Graham-Schmidt orthonormalization method which is
based on the Arnoldi orthogonalization method (Algorithm 2). This orthogonalization process is very expensive because each vector accumulated in the basis is orthogonalized against all previous ones. Thereby, the orthogonalization
process number of iterations k is bounded to the GMRES(m) subspace size, thus higher values of m will imply more
and more computations in order to create the Krylov orthonormalized vector basis. With the aim to reduce the cost
induced by the Arnoldi orthogonalization process, it is possible to truncate it by orthogonalizing each vector against a
subset of the basis vectors ie. the q precedent basis vectors (Algorithm 2). In this case, the resulting upper Hessenberg
matrix Hm is not fully orthogonalized and has the propriety to be banded of bandwidth q.
Algorithm 2: Arnoldi Iteration
1: Choose v1 of Norm 1.
2: for j = 1, . . . , m do
3:
w j = Av j
4:
for i =, . . . , j⊥1 do
5:
hi j = (w j , vi )
6:
w j = w j ⊥hi j vi
7:
end for
8:
h j+1, j = w j 2 if h j+1, j = 0 stop.
9:
v j+1 = w j /h j+1, j
10: end for

Algorithm 3: Incomplete Arnoldi Iteration
1: Choose v1 of Norm 1.
2: for j = 1, . . . , m do
3:
w j = Av j
4:
for i =max{ j, . . . , j⊥q + 1} do
5:
hi j = (w j , vi )
6:
w j = w j ⊥hi j vi
7:
end for
8:
h j+1, j = w j 2 if h j+1, j = 0 stop.
9:
v j+1 = w j /h j+1, j
10: end for

The Arnoldi orthogonalization process has been subject of diﬀerent truncation approachs, for example Saad and
Wu [6] presented the possibility to exploit the incomplete orthogonalization in order to reduce the memory requirement by reusing the memory devoted to store the columns of Vm much like a FIFO queue, thus allowing GMRES to
avoid the need to restart during the solving process. This work has been pursued by Wu who added for this GMRES
variant the possibility to restart on certain conditions [22]. However, this approach was not intended to auto-tune
the incomplete orthogonalization process but represented a ﬁrst step in this direction. An orthogonalization process
truncation auto-tuning premise has been proposed by Brown [20] through the IGMRES(m, q) method, a derivation of
the classical GMRES(m) but with truncation of the orthogonalization process. This contribution has later been used
by Jia [19] who submitted the idea to deﬁne the minimum number of vectors to truncate IGMRES, although, prior to
execution. His approach, tested on real matrices, could allow IGMRES to run 30% faster than the classical GMRES.
From those diﬀerent works emerges the possibility to auto-tune the orthogonalization process truncation in order to
enhance GMRES convergence. Futhermore, it has been demonstrated that when the classical GMRES convergence
was smooth and fast for a given problem, its truncated version would experience a small convergence delay [23] in
term of number of iterations but not in term of time of computation. This is a behavior that we observed in practice
but before giving any further details we will present our orthogonalization process truncation approach.
4. Incomplete Orthogonalization Auto-Tuning Algorithm
Auto-tuning algorithms are generally composed of two main parts : the heuristic and the tuner. The heuristic
(or listener) can be seen as an abstractor or an analyzing tool, more precisely it abstracts subjective information into
an objective data which is used further by the tuner. The tuner (or actor) on its side, will take the tuning decision
based on the heuristic abstracted data and its antecedent history of actions. In practice, the design of the two parts of
our auto-tuning algorithm took place in three stages : the selection of the orthonormalization method to truncate, the
strategy of truncation and then the heuristic of truncation. Each stage is developed in the next subsections. However,
our contribution being mostly based on experiments, we will ﬁrst present the environment we used for our empirical
study.
4.1. Test Bench
Our experiments were conducted using several matrices which are presented in Tables 1 and 2. Those matrices
are all part of the University of Florida Sparse Matrix Collection [24] at the exception of the Helmholtz matrices
that we generated from the Marmousi velocity model of the IFP [25] using Pinel [26] discretization scheme. As
previously said, our experiments were performed using diﬀerent number of processors, from 1 to 128 using SGI

2250

Pierre-Yves Aquilanti et al. / Procedia Computer Science 4 (2011) 2246–2256

Table 1: Real matrices
Matrix
cdde1
cdde3
rdb200
rdb968
rdb2048
rdb5000
watt 1
watt 2

N
961
961
2,00
968
2,048
5,000
1,856
1,856

Nnz
4,681
4,681
1,120
5,632
12,032
29,600
11,360
11,550

Domain
R
R
R
R
R
R
R
R

Kind
CFD
CFD
CFD
CFD
CFD
CFD
CFD
CFD

Table 2: Complex Matrices
Matrix
young1c
young4c
hel 161
hel 369

N
841
841
984,998
177,617

Nnz
4,089
4,089
6,842,820
886,609

Domain
C
C
C
C

Kind
Acous.
Acous.
Geophy.
Geophy.

Altix ICE8200EX cluster of Total Exploration Production. The software environment we used was composed of the
PETSc 3.0.0-p1 package [27] compiled with the fortran kernels option and without the debug ﬂag using the version
11.1.084 of the Intel Compiler with Intel MPT. Moreover, the matrix format we choosed was the Compressed Sparse
Row [28] because of its standardness. In addition, to allow auto-tuning capabilities within PETSc, we modiﬁed the
GMRES solver source code and added our auto-tuning related functions. Futhermore, each time of computation value
displayed in this paper is the average of three diﬀerent runs. Regarding the convergence stopping criteria, they were
choosen to be 10e−6 for the residual error precision and 105 for the maximum number of GMRES iterations.

4.2. Selecting the Orthogonalization Method
The GMRES solver encompasses an orthonormalization algorithm in order to create the Krylov subspace in which
will lie the solution of the linear system to solve. Two methods are usually used : Classical Graham-Schmidt (CGS)
and Modiﬁed Graham-Schmidt (MGS) [28]. Both methods are very similar and share the Arnoldi orthogonalization process. In fact they can be distinguished by the ordering of the calculations composing them and which in
practice makes MGS orthonormalization suﬀers less from numerical instability than CGS, but at the expense of less
parallelism. Thus, we choosed to proceed to the truncation process by reducing the number of vector to orthogonalize
against the last accumulated vector in place of the full basis as for IGMRES [19, 20]. Our experiments were performed
using two GMRES subspace sizes (30 and 100) and the matrices presented in Tables 2 and 2.
As a matter of fact, the results of our experiments showed an obvious distinction between both orthonormalization
methods with respect to the truncation process (Figures 1 and 2). The interpretation that we can make is that the
loss of orthogonality is not as much important as the numerical instability for GMRES convergence. In fact, this loss
of orthogonality can be recovered by the cost reduction of the orthogonalization process induced by the truncation
regardless of the GMRES subspace size. In eﬀect, when considering the hel 161, using m = 100 and q = 100 the
time of computation is of 592.3 seconds instead of 429.8 with q = 20. Moreover, for m = 30 and q = 30 the time of
computation is of 689.4 whereas for q = 14 the time of computation is of 592.8 seconds. However, it is not possible to
truncate below a minimum number of vectors because the lack of linear independence between vectors can conduct to
an increase of time of computation and number of iterations. For the rest of the study we made the choice to use MGS,
CGS being discarded because is has been shown as not suitable for the truncation of the orthogonalization process.
4.3. Orthogonalization Strategy
As previously noted, there is a clear diﬀerence on the solver convergence with respect to the truncation of CGS
and MGS. Yet we observed that the truncation of the orthogonalization process could lead to faster convergence over
full orthogonalization. Moreover, given that the distinction between the two orthonormalization methods (from a
numerical point of view) is the better numerical properties of MGS over CGS, one can suggest that the numerical
stability has more impact on the GMRES convergence than the loss of orthogonality induced by the truncation of
the orthogonalization process. Thus, using MGS we experimentally compared diﬀerent strategy of orthogonalization
truncation :
Later vectors Orthogonalization against the q previous vectors of the basis.
First vectors Orthogonalization of the iterated against the q ﬁrst vectors of the basis.

Pierre-Yves Aquilanti et al. / Procedia Computer Science 4 (2011) 2246–2256

2251

Figure 1: Number of Iteration Needed for GMRES to Converge

Figure 2: Time of Computation Needed for GMRES to C

With Regards to the Number of Orthogonalized Vectors for Matrix hel 161

verge With Regards to the Number of Orthogonalized Vectors
Matrix hel 161

Alternating vectors Orthogonalization against the full basis using the even or the odd vectors.
Alternated orthogonalization with later vectors Orthogonalization of the iterated vector against the full basis using
the even or the odd vectors but for the q previous vectors against which the iterated vector is orthogonalized
without alternation.
The ﬁrst strategy is the one we presented earlier and is also the more prevalent in the literature. It serves as a comparison basis. The second strategy, which is the inverse of the ﬁrst one, is used to study the partial orthogonalization of
the ﬁrst vectors subset compared to the later vectors ones. It helps to determine if it is more relevant to orthogonalize
against the ﬁrst or the later vectors basis. The third strategy is interesting because whatever the number of vectors basis
is, the iterated vector is orthogonalized against only half of the basis and thus consumes only half of the computing
power devoted to orthogonalization. The fourth strategy is a mix of the later vectors strategy and alternating vectors
strategy. The idea behind such a mix is to assess the behavioral impact of a strategy composition using a strategy that
we already experimented. In order to evaluate the orthogonalization strategies, we conducted our experiments using
the same test protocol as above but with some variations such as the use of MGS for strategies comparison and the
use of a ﬁxed number of vectors to orthogonalize. This number is deﬁned to the half of the GMRES subspace size
parameter (ie. q = 15 for m = 30 and q = 50 for m = 100).
The obtained results showed that the alternating orthogonalization and alternating with last vectors orthogonalization strategies (respectively Alt and AltLast in Figure 3) could not provide suﬃcient orthogonalization of the Krylov
basis for GMRES to converge. In fact those methods presented a clear discrepancy between the true residual (computed using the minimization process located at the line 13 of Algorithm 1) and the value of hk+1,k (see Algorithm 1
line 12) which is commonly used to monitor convergence between solver restarts. This behavior did not occur using
the other strategies. Futhermore, the other strategies did not showed a huge diﬀerence on the number of iterations
needed to converge (only a few iterations, one hundred at most). However, there is a relative improvement concerning
the time of computation (Figure 4). In fact, if the later vectors strategy produced a smooth convergence curve, the
ﬁrst vectors orthogonalization strategy produces a convergence curve much like a stair and which is created by the
stagnation of the residual after the orthogonalization of the ﬁrst q vectors. Moreover, the later vectors orthogonalization showed the best time of computation regardless of the matrix or the subspace size value. Moreover, we observed
that because the higher subspace size involves more computation, they are the ones that beneﬁciate the most of the
truncation process. In the end, it seems that the most interesting orthogonalization strategy is the later vectors one,
this corroborate the observations made in previous contributions.
4.4. Dichotomial Algorithm
When studying the diﬀerent orthonormalization methods we highlighted the fact that there was an optimal number
of vectors to select to reduce at best the time of computation needed for the GMRES solver to attain the solution of

2252

Pierre-Yves Aquilanti et al. / Procedia Computer Science 4 (2011) 2246–2256

Figure 3: Orthogonalization Strategy Comparison using matrix
hel 369 with m = 30 and q = 15 for a subset of 1000 GMRES
iterations.

Figure 4: Time of Computation for Converging Strategies us
m = 100 and m = 30 using the matrix hel 369.

a given linear system. This minimal number of vectors, to which we will refer as the optimal truncation parameter is
particular to each linear system, it is diﬃcult to deﬁne prior to the solving process [19]. Our new auto-tuning algorithm
approach is separated in two main parts : the listener, the actor. The listener is a monitoring heuristic that abstracts the
GMRES convergence in order to advise the actor on the convergence state. The actor choose the action to take next
by using the listener advice and its own state. This auto-tuning componental approach has the advantage of simplicity
and modularity. We now show how the two components are constructed.
4.4.1. Heuristic
The auto-tuning heuristic analyse the solver behavior and/or properties in order to abstract this information for the
auto-tuning algorithm. Our heuristic (Equation 3) uses the residual error norm r computed after a GMRES restart and
tracks the time t spent between two restarts in order to compute a ratio H characterizing the cost of a restart. Then it
computes a new value Heurist using two ratio H x and H x−1 . This new value is used by the auto-tuning algorithm to
act on the orthogonalization truncation value. As one can see, the heuristic takes a few restarts (three at most) in order
to compute a reliable Heurist value because no computation occurs prior to the solving process, this heuristic being
designed for runtime. However, it is possible to reduce this latency of three cycles to two which by running the solver
with full orthogonalization, then by truncating the orthogonalization value to its half. Data that is extracted during
this initialization process is used to compute the value H x before a third cycle. We will then use the neutral value of 1
for H x−1 to determine the ﬁrst heuristic value.
Heurist =

Hx
NN × T P
, Hx =
H x−1
NP × T N

(3)

4.4.2. Algorithm
The purpose of this auto-tuning algorithm is to search dichotomially the optimal orthogonalization truncation
parameter using its own state and the heuristic deﬁned by Equation 3. The algorithm deﬁnes two possible truncation
parameter values low and high around the current value qact between minimum and maximum boundaries qmin and
qmax. The choice of choosing one value or another between low and high to become the next truncation parameter
value qnext depends on the direction parameter deﬁned thanks to the heuristic. This direction parameter which is
based on heuristic advises the algorithm to continue in the same direction as previously (because of the decrease of
computation time between two restarts) or to change the direction of search (because last choice was not satisfying).
Indeed, with the iterations, the algorithm will constantly reduce the search space, until this space is narrowed to a
value. However, this algorithm is not restricted to a particular value and the search ﬂuctuates to the near values and
thus provide a relative dynamicity.

2253

Pierre-Yves Aquilanti et al. / Procedia Computer Science 4 (2011) 2246–2256

Algorithm 4 Actor Component Algorithm
Require: low, high, direction, heuristic
1: if heuristic ≥ 1 then
2:
direction = direction
3: else
4:
direction = −direction
5: end if
6: qholder = ceil(high − low)/2
7: high = qact + qholder/2
8: low = qact − qholder/2
9: if high ≥ qmax or high ≤ qmin then
10:
high = qmax
11: end if
12: if low < qmin then
13:
low = qmin
14: end if
15: if direction == 1 then
16:
qnext = high
17: else
18:
qnext = low
19: end if

4.4.3. Auto-Tuning Algorithm Evaluation
Concerning the study of the behavior of our orthogonalization truncation auto-tuning algorithm we ran diﬀerent
tests using the protocol and the matrices presented in 4.1. Therefore, we also deﬁned the diﬀerent parameters of
the algorithm using the following values : qmax = m, qmin = 10 for m = 30 and qmin = 20 for m = 100,
high = qmax, low = qmin. The choice of qmin was based on our previous experiments which showed a minimum
number of vectors to orthogonalize and below which the linear independence of the vectors could not be satisfying
enough for GMRES to converge in a decent time. The results of our evaluation showed (Tables 3 and 4) that the
improvements provided by the orthogonalization truncation auto-tuning algorithm would greatly depend on the matrix
and the subspace size parameter. In fact, the linear problems that beneﬁciate the most of the acceleration (in terms of
time of computation) are the bigger ones, regardless of the subspace size. Moreover, when considering small matrices,
there can be sometimes no truncation because of the size of the subspace that is too high (for example the young 1c
and young 4c matrices).
Table 3: Time Of computation for Full and Dichotomial Truncated Orthogonalization Depending on the Subspace Size in Seconds
Subspace Size
Matrix/Orth. Type
cdde1
cdde3
rdb200
rdb968
rdb2048
rdb5000
watt 1
watt 2
young1c
young4c
hel 161
hel 369

30
Full
0.2867
1.693
1.704
3.089
1.478
19.30
0.4502
0.4818
0.6607
1.537
1151
1524

Dic.
0.2711
1.331
0.8322
1.165
0.8486
6.591
0.4304
0.4266
0.7045
2.121
996.6
1479.9

100
Full
Dic.
0.2491
0.2428
2.632
0.4640
0.5529
0.5557
0.3100
0.2780
0.5530
0.5285
4.250
4.152
0.4077
0.4013
0.4197
0.4039
1.073
1.038
2.511
2.344
2016
1833
317.1
234.0

Table 4: Number of Iterations for Full and Dichotomial Tr
cated Orthogonalization Depending on the Subspace Size
Subspace Size
Matrix/Orth. Type
cdde1
cdde3
rdb200
rdb968
rdb2048
rdb5000
watt 1
watt 2
young1c
young4c
hel 161
hel 369

30
Full
236
2533
984
4646
975
5113
264
294
948
2517
1551
5304

100
Dic.
304
3087
1367
6433
1282
7348
354
407
1378
3817
1521
5454

Full
79
91
99
95
99
436
95
94
716
2051
1244
4692

Dic.
98
117
129
134
123
540
128
121
872
2502
1410
4860

We also noticed that our auto-tuning algorithm was not aﬀected by the linear system domain (real or complex)
and that the truncation could be eﬃcient for diﬀerent kinds of matrix. , this means that the truncation process can
be used regardless of the matrix domain. Moreover, our experiments showed that the improvements introduced by

2254

Pierre-Yves Aquilanti et al. / Procedia Computer Science 4 (2011) 2246–2256

the truncation of the orthogonalization process using our auto-tuning algorithm could be non negligible at all : for
example, using truncation with m = 30 can reduce the time of convergence up to 66% for the rdb5000 and rdb968
matrices.Concerning the optimal number of vectors to truncate, we noticed that it was depending on the matrix and
the subspace size. In fact, when using smaller subspace size we noticed that this number was likely to get close to the
kmin parameter which is the minimum number of vectors to orthogonalize. However, when using a larger subspace
(ie. m = 100) our auto-tuning algorithm had no diﬃculty to deﬁne the optimal number of vectors to truncate. For
example this number is of 41 for the hel 161 matrix and of 30 for hel 369 matrix. Our new auto-tuning algorithm
showed that one could auto-tune the truncation of the orthogonalization process. However, to use this algorithm one
need to ensure that the GMRES subspace size is not too important with regards to the size of the matrix. Futhermore,
the results were obtained in serial processing, they may vary with parallelization, this issue is studied in the last part
of this article.
5. Incomplete Orthogonalization In Parallel
The scientiﬁc problems are becoming increasingly complex to handle because of their size and the number of
parameters, in fact, address these problems requires an increasing computing power, for some time now, the increase
in computing power goes through parallelization. Nevertheless, the parallelization becomes more and more massive,
it becomes very diﬃcult to optimize a solver for a speciﬁc hardware platform, hence the importance of auto-tuning.
However, while certain aspects of auto-tuning are well mastered (computing kernels tuning, software modules tuning),
it is not the case for solvers parameters auto-tuning. Moreover, their inﬂuence on the calculation process is important,
and studying their behavior in parallel is therefore justiﬁed. Parallelism, in the case of linear iterative methods, is a
factor of numerical instability which increases with the number of nodes involved in solving a linear system. This
factor is even more important with the massive increase in parallelism. Regarding the orthogonalization, numerical
instability induced by the parallelism can make the Krylov base less orthogonal, which can lead to an increased
number of solver iterations (compared to serial processing).
In order to study the behavior of our auto-tuning algorithm in a parallel environment, we conducted several tests.
Our experiments were conducted using both Helmholtz matrix presented in Section 4.1. We used diﬀerent numbers
of processors (4 to 128) and used a subspace size of 30 for GMRES(m). The auto-tuning algorithm parameters are
the same as previously, namely m for qmax and 10 for qmin. The results of our experiments are presented in Tables 5
and 6. The results we obtained highlighted several things. The ﬁrst is the general increase in the number of iterations
using the incomplete orthogonalization process compared to the full orthogonalization process. The second is that
the use of the incomplete orthogonalization process leads to a reduction in computation time, if fact if the number of
iterations increases generate a reduced computation time. However, the incomplete orthogonalization cannot provide
any acceleration when the matrix is too small with regards to the number of nodes (see matrix hel 369 with 32 and 64
nodes).
Table 5: Time of Computation for Full and Dichotomial Truncated Orthogonalization Depending on the Number of Processors
in Seconds
Matrix
Orth. Type
4
8
16
32
64
128

hel 161
Full
Dic.
392.83
316.9
270.4
241.4
190.53
166.9
124.4
109.5
97.44
86.89
61.66
59.16

hel 369
Full
Dic.
63.36
39.76
44.28
34.28
49.76
32.29
40.87
40.42
30.79
30.82
30.56
30.41

Table 6: Number of Iterations for Full and Dichotomial Tr
cated Orthogonalization Depending on the Number of Process
Matrix
Orth. Type
4
8
16
32
64
128

hel 161
Full
Dic.
1004 1077
1011 1131
1013 1191
1022 1234
1025 1287
1033 1318

hel 369
Full
Dic.
3113
3131
3104
3173
3117
3132
3119
3142
3121
3137
3115
3138

6. Summary
Krylov linear solver are subject to an increased use on parallel hardware architectures and are subject to many optimizations. Auto-tuning is a smart way to simplify those optimizations and hide the growing complexity of numerical

Pierre-Yves Aquilanti et al. / Procedia Computer Science 4 (2011) 2246–2256

2255

tuning. Futhermore, auto-tuning can be classiﬁed in a hierarchy of three categories from the selection of computing
kernels to the selection of numerical method to ﬁnish to the auto-tuning of those numerical parameters. Moreover,
this auto-tuning hierarchy has a real mean when considering the growing number of parallelism levels which address
diﬀerent types of optimizations of more or less complexity. Hiding this complexity for the end-user does not not only
concerns the usability of more complex numerical tools but becomes more and more a necessity to exploit with the
most eﬃciency the actual and next to come hardware architectures.We presented a simple algorithm and heuristic to
auto-tune the Arnoldi incomplete orthogonalization process used in various Krylov solver among which GMRES. Our
experiments showed that this auto-tuning could be used in a parallel environment in order to reduce the time of computation. We do not claim that our heuristic is the most optimal to auto-tune the truncation of the orthogonalization
process. Nevertheless, it has been proved as eﬃcient enough to extract signiﬁcant improvements in terms of time of
computation for the GMRES linear solver. Our approach is simple and general and we are conﬁdent on the fact that
the incomplete orthogonalization auto-tuning could be used with other optimizations.
References
[1] E. Agullo, J. Demmel, J. Dongarra, B. Hadri, J. Kurzak, J. Langou, H. Ltaief, P. Luszczek, S. Tomov, Numerical Linear Algebra on Emerging
Architectures: The PLASMA and MAGMA projects, Journal of Physics: Conference Series 180 (1).
[2] R. C. Whaley, J. J. Dongarra, Automatically Tuned Linear Algebra Software, in: Proceedings of the 1998 ACM/IEEE conference on Supercomputing (CDROM), Supercomputing ’98, IEEE Computer Society, Washington, DC, USA, 1997, pp. 1–27.
[3] J. Dongarra, D. Gannon, G. Fox, K. Kennedy, The Impact of Multicore on Computational Science Software, CTWatch Quarterly 3 (1) (2007)
1–10.
[4] Y. Saad, M. H. Schultz, GMRES: A Generalized Minimal Residual Algorithm for Solving Nonsymmetric Linear Systems, SIAM Journal on
Scientiﬁc and Statistical Computing 7 (3) (1986) 856–869.
[5] A. Baker, E. R. Jessup, T. Kolev, A Simple Strategy for Varying the Restart Parameter in GMRES(m), Journal of Computational and Applied
Mathematics 230 (2) (2009) 751–761.
[6] Y. Saad, DQGMRES: a Quasi - Minimal Residual Algorithm Based on Incomplete Orthogonalization, Numerical Linear Algebra with
Applications 3 (1996) 329–343.
[7] H. Gahvari, M. Hoemmen, J. Demmel, K. Yelick, Benchmarking Sparse Matrix-Vector Multiply in Five Minutes, in: SPEC Benchmark
Workshop, 2007.
[8] R. Nishtala, R. W. Vuduc, J. W. Demmel, K. A. Yelick, When Cache Blocking of Sparse Matrix Vector Multiply Works and Why, Appl.
Algebra Eng., Commun. Comput. 18 (2) (2007) 297–311.
[9] S. Williams, L. Oliker, R. W. Vuduc, J. Shalf, K. Yelick, J. Demmel, Optimization of Sparse Matrix-Vector Multiplication on Emerging
Multicore Platforms, in: Proceedings of the 2007 ACM/IEEE conference on Supercomputing, SC ’07, ACM, New York, NY, USA, 2007, pp.
38:1–38:12.
[10] H. Kuroda, T. Katagiri, Y. Kanada, Performance of Automatically Tuned Parallel GMRES(m) Method on Distributed Memory Machines
(1999) 11–19.
[11] J. Bilmes, K. Asanovic, C.-W. Chin, J. Demmel, Optimizing Matrix Multiply Using PHiPAC: a Portable, High-Performance, ANSI C Coding
Methodology, ICS ’97, ACM, New York, NY, USA, 1997, pp. 340–347.
[12] R. W. Vuduc, J. Demmel, K. Yelick, OSKI: A Library of Automatically Tuned Sparse Matrix Kernels, Journal of Physics: Conference Series
16 (1) (2005) 521.
[13] R. W. Vuduc, Automatic Performance Tuning of Sparse Matrix Kernels, Ph.D. thesis, University of California, Berkeley (2003).
[14] R. Barrett, M. Berry, J. Dongarra, V. Eijkhout, C. Romine, Algorithmic Bombardment for the Iterative Solution of Linear Systems: A
Poly-Iterative Approach, Journal of Computational and Applied Mathematics 74 (1-2) (1996) 91 – 109.
[15] L. Zhang, T. Nodera, A New Adaptive Restart for GMRES (m) Method, in: R. May, A. J. Roberts (Eds.), Proc. of 12th Computational
Techniques and Applications Conference CTAC-2004, Vol. 46, 2005, pp. C409–C425.
[16] M. Sosonkina, A New Adaptive GMRES Algorithm for Achieving High Accuracy, Numerical Linear Algebra with Applications 5 (1998)
275–297.
[17] P. Brown, H. Walker, GMRES on (nearly) Singular Systems, SIAM Journal on Matrix Analysis and Applied Mathematics 18 (1) (1997)
37–51.
[18] M. Habu, T. Nodera, GMRES (m) Algorithm with Changing the Restart Cycle Adaptively, Proceedings of Algorithmy 2000 Conference on
Scientiﬁc Computing (2000) 254–263.
[19] Z. Jia, IGMRES(q): Incomplete Generalized Minimal Residual Methods for Large Unsymmetric Linear Systems (1994) 1–20.
[20] P. Brown, A. Hindmarsh, Matrix-Free Methods for Stiﬀ Systems of ODE’s, SIAM Journal on Numerical Analysis 23 (1986) 610–638.
[21] http://www.abc-lib.org/xabclib.
[22] K. Wu, Restarted Variants of DQGMRES, in: In Proceedings of 1997 International Worksop on Computational Science and Engineering,
1997.
[23] V. Simoncini, D. Szyld, The Eﬀect of Non-Optimal Bases on the Convergence of Krylov Subspace Methods, Numerische Mathematik.
[24] T. A. Davis, University of Florida Sparse Matrix Collection, NA Diges 92.
[25] IFP, Marmousi Model, Synthetic 2D Acoustic Model (1988).
[26] X. Pinel, A Perturbed Two-Level Preconditioner for the Solution of the Three-Dimensional Heterogeneous Helmholtz Problems with Applications to Geophysics, Ph.D. thesis, CERFACS (2010).

2256

Pierre-Yves Aquilanti et al. / Procedia Computer Science 4 (2011) 2246–2256

[27] S. Balay, K. Buschelman, W. D. Gropp, D. Kaushik, M. G. Knepley, L. C. McInnes, B. F. Smith, H. Zhang, PETSc Web page,
http://www.mcs.anl.gov/petsc (2009).
[28] G. H. Golub, C. F. V. Loan, Matrix Computations, Baltimore, MD, USA, 1996.

