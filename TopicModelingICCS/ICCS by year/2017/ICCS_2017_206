Available online at www.sciencedirect.com

ScienceDirect

This space is reserved for the Procedia header, do not use it
ThisProcedia
space Computer
is reserved
for 108C
the Procedia
header, do not use it
Science
(2017) 335–344
This space is reserved for the Procedia header, do not use it

International Conference on Computational Science, ICCS 2017, 12-14 June 2017,
Zurich, Switzerland

Parallel Learning Portfolio-based solvers
Parallel Learning Portfolio-based solvers
ParallelTarek
Learning
Menouer1Portfolio-based
and Souheib Baarir1 ,2solvers
1 and Souheib Baarir1 ,2
Tarek Menouer
1 Paris Nanterre University
1 and Souheib Baarir1 ,2
Tarek
Menouer
1
LIP6 Laboratory,
CNRS
UMR 7606, Paris, France

Paris Nanterre University
2
Kremlin-Bicłtre,
France
1Laboratory,
LIP6LRDE
Laboratory,
UMR
7606, Paris,
France
ParisCNRS
Nanterre
University
2 LRDE Laboratory, Kremlin-Bicłtre, France
Tarek.menouer@lip6.fr,Souheib.baarir@lip6.fr
LIP6 Laboratory, CNRS UMR 7606, Paris, France
2 LRDE Laboratory, Kremlin-Bicłtre, France
Tarek.menouer@lip6.fr,Souheib.baarir@lip6.fr
Tarek.menouer@lip6.fr,Souheib.baarir@lip6.fr

Abstract
Exploiting
Abstract multi-core architectures is a way to tackle the CPU time consumption when solving SATisfiability
problems.
Portfoliois isa way
one of
main
implements
thissolving
principle.
It
Exploiting
multi-core
architectures
to the
tackle
thetechniques
CPU time that
consumption
when
SATAbstract (SAT)
consists
in
making
several
solvers
competing,
on
the
same
problem,
and
the
winner
will
be
the
first
that
isfiability
problems.
Portfoliois isa way
one of
main
implements
thissolving
principle.
It
Exploiting(SAT)
multi-core
architectures
to the
tackle
thetechniques
CPU time that
consumption
when
SATanswers.
this work,
we improved
this
by
using
a learning
schema,
namely
the
consists
making
several
solvers
competing,
the
same
problem,
and
the
winner
will
beExplorationthe first that
isfiabilityinIn
(SAT)
problems.
Portfolio
is technique
one ofonthe
main
techniques
that
implements
this
principle.
It
Exploitation
using
Exponential
weight
smart
resource
allocations.
contribution
answers.
this
work,
we improved
this(EXP3),
technique
byallows
usingproblem,
a learning
schema,
namely
the
consists inInmaking
several
solvers
competing,
onthat
the
same
and
the
winner
willOur
beExplorationthe first that
is
adaptedIntothis
situations
where
we
have
to
solvethat
a by
bench
ofsmart
instances
issued
from
or several
Exploitation
using
Exponential
weight
allows
resource
allocations.
Our
contribution
answers.
work,
we
improved
this(EXP3),
technique
using
aSAT
learning
schema,
namely
theone
Explorationsequence
of
problems.
Our
experiments
show
that
our
approach
achieves
good
results.
is
adapted tousing
situations
where we
have(EXP3),
to solvethat
a bench
SATresource
instancesallocations.
issued from
one
or several
Exploitation
Exponential
weight
allowsofsmart
Our
contribution
sequence
Our
experiments
show
thataalgorithm,
our
approach
good
results.
is 2017
adapted
toproblems.
situations
where
have B.V.
to
solve
bench
ofParallelization
SATachieves
instances
issued
from one or several
Keywords:
Portfolio,
SATisfiability
boolean,
Learning
©
Theof
Authors.
Published
bywe
Elsevier
Peer-review
under
responsibility
of the
scientific
committee
of approach
the International
Conference
on Computational Science
sequence
problems.
Our experiments
show
thatalgorithm,
our
achieves
good results.
Keywords: of
Portfolio,
SATisfiability
boolean,
Learning
Parallelization
Keywords: Portfolio, SATisfiability boolean, Learning algorithm, Parallelization

1 Introduction
1 Introduction
The past few years have seen an enormous progress in SAT solving. Among others, this is due to
1
Introduction
evolution of hardware architectures such as multi-core and Many Integrated Cores machines. In this

The past few years have seen an enormous progress in SAT solving. Among others, this is due to
context,
parallel
SAT
[2, 12,
21]
have in
been
proposed.
They
are
mainly
basedis on
evolution
of hardware
architectures
such
as multi-core
and
Many
Integrated
Cores
machines.
In
this
The pastseveral
few
years
have
seensolvers
an enormous
progress
SAT
solving.
Among
others,
this
duetwo
to
approaches:
Divide-and-Conquer
(D&C)
and
Portfolio.
context,
parallelarchitectures
SAT solverssuch
[2, 12,
21] have been
They are
mainly
based on
evolutionseveral
of hardware
as multi-core
and proposed.
Many Integrated
Cores
machines.
In two
this
The principle
of the SAT
Divide-and-Conquer
technique
consists
in decomposing
the search
approaches:
Divide-and-Conquer
(D&C)
and 21]
Portfolio.
context,
several
parallel
solvers
[2, 12,
have been
proposed.
They are mainly
basedtree
on in
twoa
set
of
sub-trees,
then
assigning
each
sub-tree
to
a
computing
core
[12].
The
main
issue
with
such
The principle
of the Divide-and-Conquer
technique consists in decomposing the search tree inana
approaches:
Divide-and-Conquer
(D&C) and Portfolio.
approach
is
to
ensure
a
good
load
balancing
between
all computing
cores
[15].
towith
be atree
difficult
set of
assigning
each sub-tree to
a computing
corein
[12].
The This
mainturns
issue
suchinana
Thesub-trees,
principlethen
of the
Divide-and-Conquer
technique
consists
decomposing
the
search
problem,
making
the
approach
highly
unstable
and
behave
poorly
in
practices.
On
the
other
hand,
approach
is to ensure
good loadeach
balancing
between
all computing
be a difficult
set of sub-trees,
thenaassigning
sub-tree
to a computing
corecores
[12].[15].
The This
mainturns
issuetowith
such the
an
Portfolio
[21]
approach,
despite
its
extreme
simplicity,
gives
good
results.
It
consists
in
making
several
problem, is
making
the aapproach
unstable
and behave
poorly cores
in practices.
Onturns
the other
the
approach
to ensure
good loadhighly
balancing
between
all computing
[15]. This
to be ahand,
difficult
solvers
compete
the
samehighly
problem,
the
winner
will
one that
answers
The
SAT
Portfolio
approach,
despite
its
extreme
simplicity,
givesbeing
goodthe
results.
It consists
in first.
making
several
problem,in[21]
making
theonapproach
unstable
and behave
poorly
in practices.
On the
other
hand,
the
contests
organized
over
the
last
few
years
[23]
show
the
domination
of
the
solvers
of
this
class.
In
this
solvers
compete
on the
sameits
problem,
winner will
one that
answers
The
SAT
Portfolioin[21]
approach,
despite
extremethe
simplicity,
givesbeing
goodthe
results.
It consists
in first.
making
several
work,
improved
of this[23]
approach
for
solving
ofsolvers
one
and
problems.
contests
over
theefficiency
last few
years
show the
domination
thethat
of several
this
class.
this
solverswe’ve
inorganized
compete
on the
the
same
problem,
the
winner
will
beinginstances
theofone
answers
first.
TheInSAT
Currently,
SAT
solving
is
used
as
a
back-end
solution
engine
for
several
classical
problems.
Among
work,
we’ve
improved
of this[23]
approach
for solving
instances
one and
problems.
contests
organized
overthe
theefficiency
last few years
show the
domination
of theofsolvers
of several
this class.
In this
others,
we site:
planning,
hardware
designing,
model-checking,
software-checking,
theoremproblems.
proving,
Currently,
SAT
solving
is used asof
a back-end
solution
engine for
severalofclassical
Among
work,
we’ve
improved
the efficiency
this approach
for solving
instances
one andproblems.
several
etc.
Usually,
we
have
a
problem
pattern
from
which
several
instances
are
derived
and
solved
indeothers,
we site:SAT
planning,
software-checking,
theorem proving,
Currently,
solving hardware
is used as designing,
a back-endmodel-checking,
solution engine for
several classical problems.
Among
pendently.
For
example,
the
generation
of
a
schedule
in
some
organization,
where
the
structure
of
the
etc.
Usually,
have a problem
from model-checking,
which several instances
are derived theorem
and solved
indeothers,
we site:weplanning,
hardwarepattern
designing,
software-checking,
proving,
pendently.
Forwe
example,
generation
of from
a schedule
some organization,
structure
the
etc. Usually,
have a the
problem
pattern
whichinseveral
instances are where
derivedtheand
solved of
independently. For example, the generation of a schedule in some organization, where the structure of the1
1
1877-0509 © 2017 The Authors. Published by Elsevier B.V.
1
Peer-review under responsibility of the scientific committee of the International Conference on Computational Science
10.1016/j.procs.2017.05.140

336	

Parallel Learning Portfolio-based solvers
Tarek Menouer
Tarek Menouer et al. / Procedia Computer Science 108C (2017)
335–344 and Souheib Baarir

problem is the same, and only the constraints between the employees change from one instance to another every day, week and month. The formal verification field could also be cited as example: in this
case, the objective is to prove some property on some model/software. Here, we have to instantiate the
problem for several parameters of the model/software while keeping the same global problem’s structure. Each instance is then converted into a SAT problem, then solved using a Portfolio. In its classical
form, a Portfolio model will, iteratively, run several solvers for each derived instance. Then, for each
internal solver, the number of allocated cores is fixed statically at the beginning of the process. However,
we can show with a set of simple experiments that for a set of instances of the same problem, there is
almost always a solver that performs better than the others for solving the majority of instances. The
best solver is not necessary the best one for solving all instances of the problem. Changing the problem
will only change the best solver, but never the global observation. Furthermore, the statical allocation of
cores in a Portfolio will eventually lead to an underutilization of the abilities of the underlying solvers.
To overcome this drawback, we propose a new Portfolio model based on Exploration-Exploitation
using Exponential weights (EXP3) learning algorithm to fix the number of computing cores for each
solver according to previous experimentations. Our Portfolio will predict automatically, with a high
probability, the best number of computing cores for each solver to use in solving a set of instances of the
same problem. Accordingly, the resources are dynamically reallocated and the performances optimized.
The preliminary information pertaining to solving SAT problems and the research work related to
our contribution are presented in section 2. The proposed learning Portfolio model is presented in detail
in section 3. The experiments and results obtained using the proposed Portfolio model are discussed in
section 4. Finally, conclusion and some perspectives are presented in section 5.

2

SAT Solving Context

In this section, we explore some important points in the context of SAT solving. SAT problem is a
propositional formula represented in Conjunctive Normal Form (CNF) [11]. A CNF formula consists of
a conjunction of clauses, each of which consists of a disjunction of literals. A literal is either a boolean
variable xi or its complement ¬xi . A CNF formula can also be viewed as a set of clauses, and each one
can be viewed as a set of literals. When there exists a truth assignment for all variables of the problem,
such that all clauses are satisfied, then the problem is reported SAT. Otherwise, it is reported UNSAT.
Two main classes of approaches have been developed to solve a SAT problem in the sequential
execution, namely incomplete and complete algorithms. Basically, incomplete algorithms try to find
a solution to a SAT problem by adopting a stochastic strategy [24]. They are very efficient when the
problem has a solution, but if the problem is UNSAT, it cannot prove it. Complete algorithms, based
essentially on the well known Conflict-Driven Clause Learning (CDCL) schema [25], are decision procedures. They explore a decision tree implicitly. The algorithm keeps affecting truth values to variables
until all clauses of the problem are satisfied or a blocking situation is reached (variable is assigned with
a value and its reverse). In this case, a backtrack is operated to some point of the decision tree, and the
value of the variable at that point is revered to explore other branch of the tree. When all branches have
been explored without getting a solution, the problem is decided UNSAT. The effectiveness of this last
approach is due to the large variety of heuristics that have been developed in the last decade: branching
heuristics [20], restarts [14], clause elimination strategies [3], etc.

2.1

Parallel SAT Solving

During the last few decades, different studies have been dedicated to parallel SAT solving. In this
context, two main approaches are widely accepted: Divide-and-Conquer and Portfolio.
2

	

Parallel Learning Portfolio-based solvers
Tarek Menouer
Tarek Menouer et al. / Procedia Computer Science 108C (2017)
335–344and Souheib Baarir

The Divide-and-Conquer approach, based on a search space splitting, has two major challenges.
(1) Choosing the partition variables: for a given large SAT instance with hundreds of thousands of
variables it is difficult to find the most relevant set of variables to divide the search space, and (2)
load balancing: for some sub-problems, it is easier to prove (un)satisfiability than others. Since the
time needed to prove (un)satisfiability for the sub-problems cannot be predicated, the work cannot be
balanced prior to search. Therefore, dynamic work stealing is expected to balance the work between
computing cores. Without such procedure, some processors might quickly become idle, while others
take a long time to solve their sub-problems. As examples of solvers that implement this approach we
can cite (without being exhaustive): PSatz [16], GrADSAT [10], MiraXT [17] and Treengeling [8]. This
approach is applied only for one solver using one search algorithm. In the literature, several solvers exist
and each one is better than others for solving a specific problem. To enjoy this variety, another approach
exists called Portfolio. The Portfolio approach is much simpler in its concept. The principle consists
to execute in parallel several solvers on the same problem. These solvers can implement the same
algorithm or different ones. In the first case, the solvers will differ by their parametrisations. To each
solver a fix amount of resources is allocated. The first successful implementation of this approach was
proposed in the solver ManySAT [13]. Other extensions follow, as Glucose-update [2], Peneople [1],
Plingeling [8], etc. Despite its simplicity, the last SAT contests (http://www.satcompetition.org)
show that Portfolio dominates the competitions and outperforms the pure Divide-and-Conquer approach.
It is worth noting that many hybrid solvers appeared. They tried to combine these approaches to get
the best of the two worlds. In this context, we can cite: c-sat [21], SAT4J// [18], etc. These solvers got
mitigated success with respect to the one obtained with pure Portfolio.

2.2

A limit in Portfolio approach

As already mentioned, when running a Portfolio, the number of computing cores allocated to each
(internal) solver is decided and fixed, once for all, at the beginning of the resolution process. Thus, the
resources that are allocated to the solvers that behave poorly (on the treated problem) are clearly not
useful. This drawback is due to the inability to predicate the performances of solvers on the treated
problems, in the general case. However, when we treat several instances of the same problem, this
limitation is reduced. In the context of Constraint Programming (CP), the study of [19] shows that we
can predict the performances of a solver based on previous experimentations for solving one problem
with several instances. Hence, the resources allocation is dynamically adapted.
In this work, we propose a similar approach in the context of SAT. Unlike [19], that is proposed for
CP and based on Linear Reward Inaction (LRI) learning algorithm [22], we investigate the ExplorationExploitation using Exponential weights (EXP3) learning algorithm [4], that presents better convergences
properties [9]. Our approach is adapted for solving several instances of one or different problems.

3

Learning Portfolio-based Solvers

Compared to the classical Portfolio-based solvers, where the number of cores assigned to each solver is
fixed, our proposed learning Portfolio adapts, automatically, the number of computing cores assigned to
each solver using the EXP3 learning algorithm which have negligible overhead on the overall system.
EXP3 is a popular algorithm for adversarial multi-armed bandits, suggested and analysed in this setting
by [5]. It has been also widely used in the field of game theory [6]. Each time the game is repeated,
players must choose a strategy to play and they perceive at the end a reward. The goal is to update
the choice of strategies using a learning algorithm to improve the rewards. The algorithm relies on two
vectors, namely the probability vector π, and the weight vector ω, that are updated dynamically and
realize the learning schema.
3

337

338	

Parallel Learning Portfolio-based solvers
Tarek Menouer
Tarek Menouer et al. / Procedia Computer Science 108C (2017)
335–344 and Souheib Baarir

Algorithm 1 Learning Portfolio based-solvers
Require:
γ, the speed convergence constant (γ ∈ [0, 1])
K, the number of solvers used by the Portfolio
T , the total number of cores of the target system
X, a set of SAT instances of a the same problem
Ensure:
ω, the weight vector
π, the probability vector
for all instances of X do
for all s ∈ {1, . . . , K} do
π[s] = (1 − γ)( K ω[s] ) + Kγ
∑ ω[s]
s=1

end for
Execute each solver s with round(π[s] × T ) cores
b = Solver with theγ best execution time
(
)
ω[b] = ω[b] × e π[b]×K
end for
In our setting, each entry of π represents the (evolving) number of assigned cores to each solver. For
the case of ω, each entry represents the (evolving) weight associated to each solver. The size of both
vectors is fixed and equals to the number of solvers (represented by K) used by the Portfolio. Initially,
when solving the first instance: (1) All weights (all entries of ω) are set to 1. (2) All the probability
vector (all entries of π) are set to K1 .
Roughly speaking, at each round of the algorithm’s execution, the “best solver” is learned and its
entry in ω is augmented. This allows to adjust the number of cores for each solver by updating the π
vector. According to the EXP3 approach, using γ ∈ [0, 1], the update of ω is completed by the formula (1)
and the update of π is then made by the formula (2).
γ
( π[s].K
)

ω[s] = ω[s]e

if s is the best solver (1)

π[s] = (1 − γ)(

ω[s]
∑Ks=1 ω[s]

)+

γ
K

(2)

At the following execution of the Portfolio, the number of cores associated to a solver s is
round(π[s] × T ), where T is the total number of used cores. Algorithm 1 gives a formal description
of the proposed leaning Portfolio based-solvers.
Figure 1 shows an example of the design of our learning Portfolio which configures automatically
solvers with the best number of cores according to the weight and probability vectors. At the beginning,
as example, the learning Portfolio takes the following inputs: the instance which represents the SAT
problem, the number of cores used in the search (120) and the name of he problem (P1). As first step,
the Portfolio checks in the data base if P1 is solved before with 120 cores. In this particular case, the
answer is yes, P1 was solved with 120 cores. The solvers are configured according to the probability
vectors with round(0.54 × 120) = 65 cores for solver 1 and round(0.46 × 120) = 55 cores for solver
2. Otherwise, if P1 have not been solved yet, we assign to each solver the same number of cores
0.5 × 120 = 60. After fixing the number of cores, the solvers are executed in parallel. The first solver
which finishes its work (solver 1), updates the data base. Using for example γ = 0.2, the first entry in
4

	

Parallel Learning Portfolio-based solvers
Tarek Menouer
Tarek Menouer et al. / Procedia Computer Science 108C (2017)
335–344and Souheib Baarir

Figure 1: Learning Portfolio based-solvers
0.2

the weight vector will be equal to 1.2×( 0.54×2 ) = 1.46. The second entry does not change. However, the
0.2
first entry in the probability vector will be equal to (1 − 0.2)( 1.46
2.46 ) + 2 = 0.575 and the second entry
0.2
1
will be equal to (1 − 0.2)( 2.46 ) + 2 = 0.425.

4

Experiments

To show the effectiveness of our approach, we run a benchmark on a set of 34 SAT (resp. 34 UNSAT)
instances grouped in three SAT (resp. four UNSAT) problems. These problems where chosen from the
different SAT contests [23]. For our experiments, we used a parallel machine with a bi-processor Intel
Xeon X5650 (2.67 GHz) with 12 cores and 48 GB of RAM. In all experiments, we use three parallel
SAT solvers: Treengling [7], Plingling [7] and Glucose-update [2]. These solvers are the best parallel
solvers 1 . The computation time presented in this section are given in seconds and there are an average
of three runs. To calculate the average time, we solved in the first step all instances of all problems.
Then, in the second and third steps, we used a new empty data base, and we solved all instances of all
problems, as well at the end we did an average computing time between the time obtained in the three
steps. The speed convergence constant (γ) used in our learning Portfolio is fixed to 0.2.
The 34 SAT instances used in this experiments section are grouped in three problems [23]: (1)
Scheduling problem (all instances with a name start by atc enc*); (2) Industrial random SAT problem
(all instances with a name start by jgiraldezlevy.2200.9086.08.40.*); (3) Cryptography problem (all
instances with a name start by 00*.*). The 34 UNSAT instances used in this experiments section are
grouped in four problems [23]: (1) Scheduling problem (all instances with a name start by pb *); (2)
Hardware problem (all instances with a name start by 6s*); (3) Hardware problem (all instances with a
name start by *pipe *); (4) Cryptography problem (all instances with a name start hitag2-*).

4.1

The Classical vs. the learning Portfolio-based solvers

In our first experiments, we implemented a classical version of a Portfolio model. As internal solvers,
we used the aforementioned three solvers (Treengling [7], Plingling [7] and Glucose-update [2]) and the
computing cores are dispatched fairly between the three solvers (4 cores for each solver). This Portfolio
is compared to our learning Portfolio.
Figure 2 (resp. figure 3) shows the results of our experiments in terms of average speed-up when
using 3, 6, 9 and 12 cores. Each of the four configurations is used for solving all aforementioned
instances. Here, we can easily observe that our learning Portfolio solver scales better when compared
to the classical Portfolio with a different number of cores (3, 6, 9 and 12).
1 According to the ranking of solvers in the parallel track of SAT competitions: Treengeling is ranked first in SAT 2016 and
second in SAT 2015, Plingling is ranked second in SAT 2016 and third in SAT 2015, Glucose-update is ranked first in SAT 2015
and fourth in SAT 2016.

5

339

Tarek Menouer et al. / Procedia Computer Science 108C (2017) 335–344
Parallel Learning Portfolio-based solvers
Tarek Menouer and Souheib Baarir

Classical Portfolio-based solvers
Learning Portfolio-based solvers

Classical Portfolio-based solvers
Learning Portfolio-based solvers

2.89

2.5

Speedup

Speedup

2.45
2.18
2.02
1.86

2.07
1.98
1.66

1.55

1.48

1.02

1.21
1.1
1

3SolversX3Cores

3SolversX6Cores

3SolversX9Cores

3SolversX12Cores

Figure 2: Comparison of the average speed-up for
solving 34 SAT instances

3SolversX3Cores

3SolversX6Cores

3SolversX9Cores

3SolversX12Cores

Figure 3: Comparison of the average speed-up for
solving 34 UNSAT instances

Table 1 shows the detail of computing time for solving the instances. We note that with the first and
the second instances of each SAT or UNSAT problem, the computing time is almost the same between
the classical and the learning Portfolio. However, from the third instance, our learning Portfolio gives
better performance. Table 1 also shows that the learning Portfolio gives the best total computing time
for solving all problems.

4.2

Comparison with an external learning Portfolio-based solvers

To the best of our knowledge, our parallel learning SAT Portfolio-based solvers is the first solver which is
able to configure automatically the number of cores between solvers. However, to do a comparison with
an external learning Portfolio-based solvers, we have developed a second learning Portfolio model using
the LRI learning algorithm[22] proposed for the Constraint Programming context [19]. The latter uses as
a search engine the same SAT solvers used by our EXP3 learning Portfolio (Treengling [7], Plingling [7]
and Glucose-update [2]) for solving the same set of SAT and UNSAT instances solved previously. Both
learning algorithms (LRI and EXP3) use the same speed convergence constant (γ = 0.2).
Figures 4 and 5 show the speedup obtained with the two learning Portfolio-based solvers using LRI
and our EXP3 learning algorithms for solving 34 instances associated to the three SAT problems and 34
instances associated to four UNSAT problems. For the both Portfolio models, the speedup is calculated
according to the classical Portfolio with 3 solvers and 3 cores without a learning algorithm; that means
each solver is executed using one computing core. As result, we note that our learning Portfolio using
EXP3 algorithm gives the best performance. This good results can be explain by the fact that the EXP3
algorithm presents better convergences properties than the LRI algorithm [9].
Learning Portfolio with EXP3 learning algoithm
Learning Portfolio with LRI learning algoithm

Learning Portfolio with EXP3 learning algoithm
Learning Portfolio with LRI learning algoithm

2.89

2.5

Speedup

2.49
Speedup

340	

2.24
2.02
1.94

2.14
2.07
1.71
1.48
1.19
1.1
1.02

1.05
3SolversX3Cores

3SolversX6Cores

3SolversX9Cores

3SolversX12Cores

Figure 4: Comparison of the average speed-up for
solving 34 SAT instances

6

3SolversX3Cores

3SolversX6Cores

3SolversX9Cores

3SolversX12Cores

Figure 5: Comparison of the average speed-up for
solving 34 UNSAT instances

	

Tarek Menouer et al. / Procedia Computer Science 108C (2017) 335–344
Parallel Learning Portfolio-based solvers
Tarek Menouer and Souheib Baarir
problem
type

SAT
Problems

UNSAT
Problems

Total time

Instances

Classical Portfolio-based solvers
6 cores
9 cores
625,99
507,42
829,04
867,73
484,33
157,74
374,50
163,81
568,31
555,25
1244,64
2265,17
307,94
481,48
777,06
948,20
36,53
46,60
865,23
359,03
16,09
3,67
1,27
1,31
914,89
1044,97
440,42
424,52
1186,95
816,85
980,43
1087,82
1274,73
966,45
57,77
54,30
354,80
303,40
32,93
28,33
198,14
192,69
111,51
96,93
130,13
81,14
118,91
108,24
27,61
23,68
168,57
155,12
70,10
74,10
496,26
236,81
786,58
489,51
672,24
595,03
964,82
924,92
977,71
1034,10
1074,70
978,22
1842,84
1346,05

jgiraldezlevy.2200.9086.08.40.117.cnf
jgiraldezlevy.2200.9086.08.40.136.cnf
jgiraldezlevy.2200.9086.08.40.149.cnf
jgiraldezlevy.2200.9086.08.40.158.cnf
jgiraldezlevy.2200.9086.08.40.2.cnf
jgiraldezlevy.2200.9086.08.40.33.cnf
jgiraldezlevy.2200.9086.08.40.41.cnf
jgiraldezlevy.2200.9086.08.40.79.cnf
jgiraldezlevy.2200.9086.08.40.93.cnf
jgiraldezlevy.2200.9086.08.40.83.cnf
jgiraldezlevy.2200.9086.08.40.20.cnf
jgiraldezlevy.2200.9086.08.40.28.cnf
002-80-12.cnf
004-80-8.cnf
005-80-12.cnf
007-80-12.cnf
008-80-12.cnf
atco enc1 opt1 03 56.cnf
atco enc1 opt1 04 32.cnf
atco enc1 opt1 05 21.cnf
atco enc1 opt1 10 15.cnf
atco enc1 opt1 10 21.cnf
atco enc1 opt1 15 240.cnf
atco enc1 opt1 18 18.cnf
atco enc2 opt1 05 21.cnf
atco enc2 opt1 10 21.cnf
atco enc2 opt1 15 100.cnf
atco enc2 opt2 05 9.cnf
atco enc2 opt2 10 21.cnf
atco enc3 opt1 03 53.cnf
atco enc3 opt1 04 50.cnf
atco enc3 opt1 13 48.cnf
atco enc3 opt2 05 21.cnf
atco enc3 opt2 18 44.cnf

3 cores
640,16
1513,66
475,79
401,62
2265,15
2137,44
1308,28
136,74
43,14
2741,84
3,77
8,15
1240,52
828,95
1426,64
804,77
922,51
13,80
312,47
48,25
306,70
73,06
96,91
125,16
42,36
300,71
135,95
259,74
1618,60
1643,77
1382,71
1588,61
536,61
1040,12

11pipe q0 k.cnf
10pipe k.cnf
8pipe k.cnf
8pipe q0 k.cnf
7pipe k.cnf
9pipe k.cnf
10pipe q0 k.cnf
6s130-opt.cnf
6s13-opt.cnf
6s16-opt.cnf
6s17-opt.cnf
6s133.cnf
6s153.cnf
6s19.cnf
6s9.cnf
6s151.cnf
6s126.cnf
hitag2-7-60-0-0xe8fa35372ed37e2-80.cnf
hitag2-8-60-0-0x1eb82244d7f1c3c-47.cnf
hitag2-8-60-0-0xfba1a41b5dfd7f7-52.cnf
hitag2-8-60-0-0xdcdbc8bf368ee73-37.cnf
hitag2-10-60-0-0x8edc44db7837bbf-65.cnf
pb 200 03 lb 01.cnf
pb 200 03 lb 02.cnf
pb 200 05 lb 00.cnf
pb 200 10 lb 15.cnf
pb 300 04 lb 05.cnf
pb 300 04 lb 06.cnf
pb 300 05 lb 11.cnf
pb 300 10 lb 06.cnf
pb 400 03 lb 05.cnf
pb 400 03 lb 07.cnf
pb 400 09 lb 02.cnf
pb 400 09 lb 03.cnf

445,90
695,08
184,17
83,94
84,56
239,77
300,07
353,42
362,27
371,60
460,29
308,29
80,99
343,50
312,52
0,41
6067,33
1524,01
1254,66
1779,50
1757,85
2349,65
92,72
107,57
45,30
32,62
28,14
120,80
234,91
42,34
60,50
112,79
51,03
73,62

360,27
634,53
158,69
76,54
84,10
180,01
261,38
271,71
295,43
288,99
323,45
231,55
48,40
285,62
252,46
0,45
2280,17
1659,09
1925,80
2574,89
2268,34
1862,72
62,82
99,33
45,05
36,45
26,42
84,58
159,29
29,09
48,01
92,49
43,27
64,15

All instances

20362

17115

Learning Portfolio-based solvers
6 cores
9 cores
659,75
521,21
860,01
883,57
165,09
124,10
50,02
149,55
506,81
320,29
918,32
1576,90
305,35
375,46
605,60
862,13
27,20
28,14
847,59
235,41
15,91
3,27
1,26
1,27
972,54
1041,80
448,22
422,48
860,21
696,57
784,42
800,20
994,14
871,05
50,94
57,12
360,52
302,54
30,65
25,56
141,22
109,69
104,05
90,32
111,37
78,99
105,00
96,48
27,24
19,85
146,76
116,63
47,42
46,36
349,93
180,51
543,11
405,77
556,67
446,99
814,43
593,30
920,34
692,56
776,30
452,42
1139,46
532,19

12 cores
414,32
576,14
138,77
116,32
813,92
733,83
729,77
726,42
74,78
246,81
3,54
1,37
702,87
293,41
698,47
893,79
881,34
20,86
265,41
27,84
177,69
83,60
66,00
69,88
21,82
99,42
62,17
332,06
577,28
603,86
676,10
917,26
714,21
1190,55

3 cores
561,86
1522,34
476,00
609,25
2025,75
2105,82
1129,14
136,22
43,28
2734,21
2,54
7,75
1240,46
841,29
1229,33
741,11
922,38
13,68
313,56
48,09
303,11
73,02
90,41
116,33
40,49
300,32
131,16
247,95
1608,62
1622,64
1377,78
1593,60
531,70
1048,13

12 cores
416,81
553,49
69,26
95,57
542,34
493,07
277,82
431,78
47,96
191,72
3,30
1,26
685,30
306,41
519,10
702,12
864,75
19,93
262,82
26,94
122,02
74,68
50,14
66,11
18,66
83,54
41,36
284,10
358,48
420,07
535,16
633,81
423,29
695,00

343,75
605,66
151,17
68,73
77,65
166,61
256,05
200,70
228,52
191,73
206,28
173,30
27,50
228,81
183,69
0,47
1906,32
786,13
649,09
957,22
1317,43
771,04
46,53
98,62
30,92
30,92
22,07
56,97
137,10
25,04
36,14
64,67
39,06
58,59

314,57
561,89
147,58
62,77
79,01
193,37
228,27
152,33
176,79
182,36
179,20
172,27
28,59
167,99
170,50
0,46
1399,74
483,54
454,56
651,97
674,70
560,70
40,16
78,36
28,49
25,49
18,40
44,75
167,60
21,69
32,88
58,69
38,77
52,46

447,91
703,73
182,08
84,33
83,25
236,46
294,84
354,41
364,70
373,16
453,53
303,52
81,91
251,50
252,00
0,41
3651,42
1519,13
1281,04
1682,82
1775,01
2345,44
93,29
107,46
45,45
33,72
26,77
113,36
232,80
43,02
34,84
74,39
34,41
52,43

360,03
627,15
154,79
72,56
67,82
176,33
238,41
279,23
293,61
277,67
229,06
155,81
37,14
211,28
217,74
0,42
1934,35
1676,88
1753,09
2481,82
1937,56
1417,70
61,01
94,01
40,99
32,33
21,06
56,43
116,11
21,18
35,62
42,57
32,99
48,34

331,01
567,98
145,85
64,34
69,38
144,41
200,22
197,15
220,30
147,73
158,80
125,71
24,68
145,15
122,34
0,45
1538,91
727,43
678,75
686,78
636,02
527,56
48,48
96,25
28,51
22,36
17,85
45,22
119,34
17,76
26,03
43,31
31,27
41,90

313,81
531,60
134,01
56,12
67,88
132,73
187,44
148,90
176,43
135,06
130,07
108,36
19,97
128,33
98,09
0,45
1331,74
483,08
453,67
501,13
528,32
385,88
41,33
75,70
26,72
18,51
15,95
31,57
86,51
16,14
22,95
35,77
35,02
42,66

10144

7650

17615

15203

7999

6501

Table 1: Comparison of execution times obtained with the classical and the learning Portfolio

4.3

Comparison of computing time obtained with 3 solvers run in isolation and
the Learning Portfolio-based solvers using EXP3 algorithm

Tables 2 (res. table 3) shows a comparison between the computing time associated to the three SAT
(resp. four UNSAT) problems using 3 solvers run in isolation with 12 cores for each solver and our
learning Portfolio with 3 solvers using also 12 cores. For this experimentation, we add a time out of
36000 seconds for each solver. Each time a solver exceeds the time out, we stop the execution and
refer the time by +3600 in the both tables ( 2 and 3). These tables shows the existence of a solver that
7

341

342	

Tarek Menouer et al. / Procedia Computer Science 108C (2017) 335–344
Parallel Learning Portfolio-based solvers
Tarek Menouer and Souheib Baarir
Instances of
SAT problems

Computing times with three solvers in isolation
with 12 cores for each solver
Plingling
Treengling
681,86
71,34
1299,01
153,71
1895,09
76,36
207,96
38,72
+3600,00
131,22
+3600,00
127,76
+3600,00
185,47
+3600,00
30,56
43,96
118,87
837,85
54,35
0,75
21,45
1,16
175,41

Computing time with the learning Portfolio
using 3 solvers and 12 cores
Learning Portfolio with EXP3 algorithm
416,81
553,49
69,26
95,57
542,34
493,07
277,82
431,78
47,96
191,72
3,30
1,26

jgiraldezlevy.2200.9086.08.40.117.cnf
jgiraldezlevy.2200.9086.08.40.136.cnf
jgiraldezlevy.2200.9086.08.40.149.cnf
jgiraldezlevy.2200.9086.08.40.158.cnf
jgiraldezlevy.2200.9086.08.40.2.cnf
jgiraldezlevy.2200.9086.08.40.33.cnf
jgiraldezlevy.2200.9086.08.40.41.cnf
jgiraldezlevy.2200.9086.08.40.79.cnf
jgiraldezlevy.2200.9086.08.40.93.cnf
jgiraldezlevy.2200.9086.08.40.83.cnf
jgiraldezlevy.2200.9086.08.40.20.cnf
jgiraldezlevy.2200.9086.08.40.28.cnf

Glucose
+3600,00
384,50
38,84
363,92
+3600,00
1020,92
576,60
2539,99
485,48
923,80
72,35
1513,03

002-80-12.cnf
004-80-8.cnf
005-80-12.cnf
007-80-12.cnf
008-80-12.cnf

612,09
272,47
451,11
615,99
773,07

2524,81
1608,97
+3600,00
3070,90
1579,74

+3600,00
+3600,00
+3600,00
+3600,00
+3600,00

685,30
306,41
519,10
702,12
864,75

atco enc1 opt1 03 56.cnf
atco enc1 opt1 04 32.cnf
atco enc1 opt1 05 21.cnf
atco enc1 opt1 10 15.cnf
atco enc1 opt1 10 21.cnf
atco enc1 opt1 15 240.cnf
atco enc1 opt1 18 18.cnf
atco enc2 opt1 05 21.cnf
atco enc2 opt1 10 21.cnf
atco enc2 opt1 15 100.cnf
atco enc2 opt2 05 9.cnf
atco enc2 opt2 10 21.cnf
atco enc3 opt1 03 53.cnf
atco enc3 opt1 04 50.cnf
atco enc3 opt1 13 48.cnf
atco enc3 opt2 05 21.cnf
atco enc3 opt2 18 44.cnf

16,15
144,57
21,04
83,52
57,10
39,68
47,27
14,64
58,21
32,41
103,33
198,51
369,88
507,56
595,66
386,98
588,32

47,12
304,50
66,88
129,66
98,85
105,38
74,51
77,90
127,54
123,72
573,12
574,15
751,69
789,20
981,85
978,09
1687,13

146,23
719,76
241,48
654,40
279,65
591,42
261,38
226,01
382,39
1256,43
2850,15
1096,79
3499,67
2544,98
2932,96
3529,11
+3600,00

19,93
262,82
26,94
122,02
74,68
50,14
66,11
18,66
83,54
41,36
284,10
358,48
420,07
535,16
633,81
423,29
695,00

Total

+21109,98

+39243,29

+43998,97

10318,16

Table 2: Comparison of execution times obtained with three solvers run in isolation with 12 cores for
each one and our learning Portfolio-based 3 solvers with 12 cores for solving three SAT problems
dominates among others for each problem, when the problem changes, the best solve changes also. The
best solver is not necessarily the solver which always solve all instances of the same problem.
4.3.1

The case of solving one problem with several instances

In this case, it is clear that for each instance the learning Portfolio cannot obtain a better performance
than the best solver, because the best solver is executed with 12 cores and the learning solver schedules
12 cores between three solvers. However, we note in this experience two interesting results: (1) For
each instance, the learning Portfolio is always ranked in the second position after the best solver;
(2) For each problem, when the best solver does not find a solution at first, our learning Portfolio
is ranked in the first position. This can be explained by the fact that the learning solver gives for
each instance the opportunity to execute all solvers with different number of cores. In table 3, for the
second class of instance, generally, the best solver is Glucose, however for the instances 6s151.cnf (resp.
6s126.cnf) Glucose doesn’t find a solution in 1 hour (+3600) and our learning solver finds a solution
in 0.45 seconds (resp. 1331.74 seconds). In SAT context, for some problems, the computing time for
solving some instances with solver x using one core is better than the time obtained for solving the same
instances with solver y using 12 cores. This depends on the algorithm used by the solver.
4.3.2

The case of solving several problems with several instances for each problem

Here, the most important result is that the learning Portfolio optimizes the computing time (as it is
presented in the last line of tables 2 and 3) compared to the others solvers with 12 cores for each one
and it is ranked as the best one.
8

	

Tarek Menouer et al. / Procedia Computer Science 108C (2017) 335–344
Parallel Learning Portfolio-based solvers
Tarek Menouer and Souheib Baarir
Instances of
UNSAT problems

Computing times with three solvers in isolation
with 12 cores for each solver
Plingling
Treengling
241,45
382,57
517,60
982,21
126,97
241,01
59,5
125,51
55,85
156,75
172,89
365,90
157,23
339,23

Computing time with the learning Portfolio
using 3 solvers and 12 cores
Learning Portfolio with EXP3 algorithm
313,81
531,60
134,01
56,12
67,88
132,73
187,44

11pipe q0 k.cnf
10pipe k.cnf
8pipe k.cnf
8pipe q0 k.cnf
7pipe k.cnf
9pipe k.cnf
10pipe q0 k.cnf

Glucose
345,55
560,84
241,83
45,16
75,44
86,05
203,90

6s130-opt.cnf
6s13-opt.cnf
6s16-opt.cnf
6s17-opt.cnf
6s133.cnf
6s153.cnf
6s19.cnf
6s9.cnf
6s151.cnf
6s126.cnf

60,05
69,01
57,03
63,21
50,15
11,38
63,04
60,15
+3600,00
+3600,00

1812,13
1624,08
1631,72
1649,05
1483,72
252,66
1431,29
1446,13
0,43
726,21

+3600,00
+3600,00
2857,33
+3600,00
+3600,00
1364,26
2439,41
2925,25
0,49
+3600,0

148,9
176,43
135,06
130,07
108,36
19,97
128,33
98,09
0,45
1331,74

hitag2-7-60-0-0xe8fa35372ed37e2-80.cnf
hitag2-8-60-0-0x1eb82244d7f1c3c-47.cnf
hitag2-8-60-0-0xfba1a41b5dfd7f7-52.cnf
hitag2-8-60-0-0xdcdbc8bf368ee73-37.cnf
hitag2-10-60-0-0x8edc44db7837bbf-65.cnf

+3600,00
2785,77
+3600,00
+3600,00
3256,97

828,58
469,25
728,10
537,39
460

177,02
176,96
236,67
215,77
243,47

483,08
453,67
501,13
528,32
385,88

17,55
25,29
9,81
7,95
11,87
21,76
79,51
13,37
17,87
25,50
30,71
39,29

117,25
114,45
45,32
23,35
24,56
37,11
120,53
35,60
67,43
116,35
59,23
91,32

828,72
899,26
208,51
138,79
173,09
285,43
3601,00
244,41
434,09
801,81
352,91
676,68

41,33
75,70
26,72
18,51
15,95
31,57
86,51
16,14
22,95
35,77
35,02
42,66

+26348,01

17265,02

+39875,44

6501,86

pb
pb
pb
pb
pb
pb
pb
pb
pb
pb
pb
pb

200
200
200
200
300
300
300
300
400
400
400
400

03
03
05
10
04
04
05
10
03
03
09
09

lb
lb
lb
lb
lb
lb
lb
lb
lb
lb
lb
lb

01.cnf
02.cnf
00.cnf
15.cnf
05.cnf
06.cnf
11.cnf
06.cnf
05.cnf
07.cnf
02.cnf
03.cnf

Total

Table 3: Comparison of execution times obtained with three solvers run in isolation with 12 cores for
each one and our learning Portfolio-based 3 solvers with 12 cores for solving four UNSAT problems

5

Conclusion and future work

In this work 2 we presented a parallel SAT learning Portfolio-based solver designed to improve the
performance of solving SAT instances. The novelty of this Portfolio, compared to previous parallel SAT
solvers, is its ability to automatically configure the number of computing cores for each solver using
EXP3 learning algorithm according to a previous experimentations. A good results are obtained using
this learning Portfolio for solving several instances of the same and different problems.
As a perspective, we propose to apply our approach in the context of Constraint Programming (CP)
to have a single framework based on learning Portfolio which solve at the same time several SAT and
CP problems. Finally, for this work, the experiments were performed employing only parallel machine
that uses 12 cores, so it would be interesting as a second perspective to use machines with big number
of cores to address harder problems.

References
[1] Gilles Audemard, Benoı̂t Hoessen, Said Jabbour, Jean-Marie Lagniez, and Cédric Piette. PeneLoPe, a Parallel
Clause-Freezer Solver. In SAT Challenge: Solver and Benchmarks Descriptions, pages 43–44, France, 2012.
[2] Gilles Audemard, Jean-Marie Lagniez, and Laurent Simon. Improving glucose for incremental sat solving
with assumptions: Application to mus extraction. In Proceedings of the 16th International Conference on
Theory and Applications of Satisfiability Testing, SAT’13, pages 309–317, 2013.
2 Funded

by the OPENMIAGE ANR-15-IDFN-0006-12 project.

9

343

344	

Parallel Learning Portfolio-based solvers
Menouer
and Souheib Baarir
Tarek Menouer et al. / Procedia Computer Science 108CTarek
(2017)
335–344

[3] Gilles Audemard and Laurent Simon. Predicting learnt clauses quality in modern sat solvers. In Proceedings
of the 21st International Jont Conference on Artifical Intelligence, IJCAI’09, pages 399–404, 2009.
[4] Peter Auer, Nicolò Cesa-Bianchi, and Paul Fischer. Finite-time analysis of the multiarmed bandit problem.
Machine Learning, 47(2):235–256, 2002.
[5] Peter Auer, Nicolò Cesa-Bianchi, Yoav Freund, and Robert E. Schapire. The nonstochastic multiarmed bandit
problem. SIAM J. Comput., 32(1):48–77, January 2003.
[6] Omar Besbes, Yonatan Gur, and Assaf Zeevi. Optimal exploration-exploitation in a multi-armed-bandit problem with non-stationary rewards. arXiv preprint arXiv:1405.3316, 2014.
[7] A Biere. Lingeling, plingeling, picosat and precosat at sat race 2010. In Technical Report 10/1, Institute for
Formal Models and Verification, Johannes Kepler University, 2010.
[8] Armin Biere. Lingeling, Plingeling and Treengeling entering the SAT competition 2013. Proceedings of SAT
Competition 2013, page 51, 2013.
[9] M. Boudard, J. Bernauer, D. Barth, J. Cohen, and A. Denise. GARN: Sampling RNA 3D Structure Space
with Game Theory and Knowledge-Based Scoring Strategies. PLoS ONE, 10(8):e0136444, August 2015.
[10] Wahid Chrabakh and Rich Wolski. Gradsat: A parallel sat solver for the grid, 2003.
[11] DIMACS challenge. Satisfiability. Suggested format., 1993.
[12] Youssef Hamadi, Said Jabbour, and Lakhdar Sais. Manysat: a parallel sat solver. Journal on Satisfiability,
Boolean Modeling and Computation, 6:245–262, 2008.
[13] Youssef Hamadi and Lakhdar Sais. Manysat: a parallel sat solver. JOURNAL ON SATISFIABILITY,
BOOLEAN MODELING AND COMPUTATION (JSAT), 6, 2009.
[14] Jinbo Huang. The effect of restarts on the efficiency of clause learning. In Proceedings of the 20th International Joint Conference on Artifical Intelligence, IJCAI’07, pages 2318–2323, 2007.
[15] Bernard Jurkowiak, Chu Min Li, and Gil Utard. Parallelizing satz using dynamic workload balancing. Electronic Notes in Discrete Mathematics, 9:174–189, 2001.
[16] Bernard Jurkowiak, Chu Min Li, and Gil Utard. A parallelization scheme based on work stealing for a class
of sat solvers. J. Autom. Reason., 34(1):73–101, January 2005.
[17] Matthew Lewis, Tobias Schubert, and Bernd Becker. Multithreaded sat solving. Asia and South Pacific Design
Automation Conference, 0:926–931, 2007.
[18] R. Martins, V. Manquinho, and I. Lynce. Improving search space splitting for parallel sat solving. In Tools
with Artificial Intelligence (ICTAI), 22nd IEEE International Conference on, volume 1, pages 336–343, 2010.
[19] Tarek Menouer, Nitin Sukhija, and Bertrand Le Cun. A learning portfolio solver for optimizing the performance of constraint programming problems on multi-core computing systems. Concurrency and Computation: Practice and Experience, pages n/a–n/a, 2016. cpe.3840.
[20] Matthew W. Moskewicz, Conor F. Madigan, Ying Zhao, Lintao Zhang, and Sharad Malik. Chaff: Engineering
an efficient sat solver. In Proceedings of the 38th Annual Design Automation Conference, 2001.
[21] Kei Ohmura and Kazunori Ueda. c-sat: A parallel sat solver for clusters. In Theory and Applications of
Satisfiability Testing-SAT 2009, pages 524–537. Springer, 2009.
[22] P. S. Sastry, V. V. Phansalkar, and M. A. L. Thathachar. Decentralized learning of nash equilibria in multiperson stochastic games with incomplete information. IEEE Transactions on Systems, Man, and Cybernetics,
24(5):769–777, May 1994.
[23] Sat competition: http://www.satcompetition.org/. Accessed: 25-01-2017.
[24] Dale Schuurmans and Finnegan Southey. Local search characteristics of incomplete SAT procedures. In
Proceedings of the Seventeenth National Conference on Artificial Intelligence and Twelfth Conference on on
Innovative Applications of Artificial Intelligence, Austin, Texas, USA., pages 297–302, 2000.
[25] Joo P. Marques Silva and Karem A. Sakallah. Grasp: A search algorithm for propositional satisfiability. IEEE
Trans. Computers, 48(5):506–521, 1999.

10

