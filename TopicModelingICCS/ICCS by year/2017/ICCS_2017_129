Available online at www.sciencedirect.com

ScienceDirect

This space is reserved for the Procedia header, do not use it
This space
is reserved
for the
Procedia
header, do not use it
Procedia
Computer Science
108C
(2017) 89–98
This space is reserved for the Procedia header, do not use it

International Conference on Computational Science, ICCS 2017, 12-14 June 2017,
Switzerland with Sublinear Time
Fully-Dynamic GraphZurich,
Algorithms

Fully-Dynamic Graph Algorithms with Sublinear Time
Inspired
by Distributed
Fully-Dynamic
Graph
Algorithms Computing
with Sublinear Time
Inspired
by Distributed
Computing
Leonid by
Barenboim
and Tzalik
Maimon∗
Inspired
Distributed
Computing
∗
Leonid Barenboim and Tzalik Maimon
Open University of Israel
∗
Leonid
Barenboim
and
leonidb@openu.ac.il
; tzali.tm@gmail.com
Open University
ofTzalik
Israel Maimon
leonidb@openu.ac.il ; tzali.tm@gmail.com
Open University of Israel
leonidb@openu.ac.il ; tzali.tm@gmail.com

Abstract
Abstract
We study dynamic graphs in the fully-dynamic centralized setting. In this setting the vertex
We
study
graphs
the fully-dynamic
In thissuch
setting
vertex
set
of
size dynamic
n of a graph
G isinfixed,
and the edge centralized
set changessetting.
step-by-step,
thatthe
each
step
Abstract
set of size
norofremoves
a graph an
G edge.
is fixed,
and
theinedge
set
changes
step-by-step,
such that
each
step
either
adds
The
goal
this
setting
is
maintaining
a
solution
to
a
certain
We study dynamic graphs in the fully-dynamic centralized setting. In this setting the vertex
either
adds
or maximal
removes an
edge. The
goal
in thisafter
setting
isstep,
maintaining
a each
solution
to
aexecuted
certain
problem
(e.g.,
matching,
edge
coloring)
each
such
that
step
is
set of size n of a graph G is fixed, and the edge set changes step-by-step, such that each step
problem
(e.g., maximal
matching,
edge is
coloring)update-time.
after each step,
each
stepsetting
is executed
efficiently.
runningan
time
of aThe
step
Onesuch
canthat
think
of this
as a
either addsThe
or removes
edge.
goalcalled
in this setting is maintaining
a solution
to a certain
efficiently.
The running
time
of a step
isa called
update-time.
Oneiscan
think of this
setting as a
dynamic
network
that
is
monitored
by
central
processor
that
responsible
for
maintaining
problem (e.g., maximal matching, edge coloring) after each step, such that each step is executed
dynamic
network
that isfor
monitored
by a central
processor
that is responsible
for maintaining
the solution.
Currently,
several
central
problems,
the best-known
deterministic
algorithms
efficiently.
The
running time
of a step
is called
update-time.
One can think
of this setting
as a
the
solution.
Currently,
for
several
central
problems,
the best-known
deterministic
algorithms
for
general
graphs
are
the
naive
ones
which
have
update-time
O(n).
This
is
the
case
for
maximal
dynamic network that is monitored by a central processor that is responsible for maintaining
for
generaland
graphs
are the
naive ones which have update-time
O(n). This
is the casein
fornmaximal
matching
proper
O(∆)-edge-coloring.
question
existence
ofdeterministic
sublinear
updatethe solution.
Currently,
for several central The
problems,
theofbest-known
algorithms
matching
and proper
O(∆)-edge-coloring.
The question
of existence
of sublinear
in open.
n updatetime
deterministic
algorithms
for
dense
graphs
and
general
graphs
remained
wide
We
for general graphs are the naive ones which have update-time O(n). This is the case for maximal
time
deterministic
algorithms
for sublinear
dense graphs
and general
graphs remained
wideforopen.
We
address
this
question
by
devising
update-time
deterministic
algorithms
maximal
matching and proper O(∆)-edge-coloring. The question of existence2 of sublinear in n updateaddress
this
question
bybounded
devisingneighborhood
sublinear update-time
deterministic
algorithms
for maximal
matching
in
graphs
with
independence
o(n/
log
n),
and
for
proper
O(∆)time deterministic algorithms for dense graphs and general graphs 2remained wide open. We
matching
in graphs
with bounded
neighborhood
o(n/ log n),independence
and for proper
O(∆)edge-coloring
in general
familyupdate-time
ofindependence
bounded neighborhood
a very
address
this question
by graphs.
devisingThe
sublinear
deterministic algorithms
for is
maximal
edge-coloring
in
general
graphs.
The family
of well
bounded
neighborhood
independence
is
a very
2 For
wide
family
of
dense
graphs
that
represent
very
various
networks.
graphs
with
constant
matching in graphs with bounded neighborhood independence o(n/ log n),
√ and for proper O(∆)wide
family of dense
graphs that
represent
very
well
various
networks.
For
graphs
with
constant
neighborhood
independence,
our
maximal
matching
algorithm
has
Õ(
n)
update-time.
Our
√
edge-coloring in general graphs. The family
of bounded neighborhood √
independence is a very
neighborhood independence,
our
maximal
matching
algorithm
has
Õ(
n)
update-time.
Our
∆)
update-time
for
general
graphs.
O(∆)-edge-coloring
algorithms
has
Õ(
√ very well various networks. For graphs with constant
wide family of dense graphs that represent
√certain distributed alO(∆)-edge-coloring
algorithms
hasemploy
Õ( ∆)a update-time
for that
general
graphs.
In
order
to
obtain
our
results
we
novel
approach
adapts
neighborhood independence, our maximal
matching algorithm has Õ( n) update-time. Our
In order to
our results
wetoemploy
a novel approach
that adapts certain
distributed algorithms
of obtain
the LOCAL
setting
the√centralized
fully-dynamic
O(∆)-edge-coloring
algorithms
has Õ(
∆) update-time
for generalsetting.
graphs.This is achieved by
gorithms of the
the work
LOCAL
setting
to theperforms,
centralized
fully-dynamic
setting. This
is achieved
by
optimizing
each
processors
and
efficiently
simulating
a
distributed
algoIn order to obtain our results we employ a novel approach that adapts certain distributed
aloptimizing
the work each
processors
performs, isand
efficiently
simulating
a distributed
algorithm
in
a
centralized
setting.
The
simulation
efficient
thanks
to
a
careful
selection
of
the
gorithms of the LOCAL setting to the centralized fully-dynamic setting. This is achieved by
rithm in parts
a centralized
setting.
The
efficient
thanks to
careful selection
the
network
algorithm
is simulation
invoked
on,isand
and
by deducing
thea solution
from theofaddioptimizing thethat
workthe
each
processors
performs,
efficiently
simulating
a distributed
algonetwork
parts thatthat
the isalgorithm
is the
invoked
on, and
by deducing
the
solution
from the
additional
information
present
in
centralized
setting,
but
not
in
the
distributed
one.
Our
rithm in a centralized setting. The simulation is efficient thanks to a careful selection of the
tional information
that isnetwork
present in the centralized
setting,demonstrate
but not in the
distributed
one. Our
experiments
various
our from
algorithms
are
network partsonthat
the algorithmtopologies
is invokedand
on,scenarios
and by deducing
the that
solution
the addiexperiments on in
various
network
topologies
and
scenarios
demonstrate
that our
algorithms
are
highly-efficient
practice.
We
believe
that
our
approach
is
of
independent
interest
and
may
tional information that is present in the centralized setting, but not in the distributed one. Our
highly-efficient
inadditional
practice. problems.
We believe that our approach is of independent interest and may
be
applicable
to
experiments on various network topologies and scenarios demonstrate that our algorithms are
be applicable to additional problems.
highly-efficient
in Published
practice.
We
believe
that our Simulation,
approach isMaximal
of independent
Keywords:
Dynamic
Graphs,byLarge-Scale
Networks,
Matching,interest
Coloringand may
©
2017 The Authors.
Elsevier
B.V.
Keywords:
Dynamic
Graphs,ofproblems.
Large-Scale
Maximal
Matching,
Coloring Science
Peer-review
under
the scientific Networks,
committee ofSimulation,
the International
Conference
on Computational
be applicable
toresponsibility
additional
∗ This research has been supported by the Open University of Israel’s Research Fund, and by the Israeli
Keywords:
Graphs,
Large-Scale
Networks,
Simulation,
Maximal
Matching,
Coloring
∗ This research
Academy
of Dynamic
Science,
Partby
of this
work has
been
performed
while
Leonid
Barenboim
wasthe
affiliated
hasgrant
been724/15.
supported
the Open
University
of Israel’s
Research
Fund,
and by
Israeli
with
the
joint
program
of
the
Simons
institute
at
UC
Berkeley
and
Weizmann
institute
of
science.
Academy of Science, grant 724/15. Part of this work has been performed while Leonid Barenboim was affiliated
∗
research
has been
by the at
Open
of Israel’s
Research
Fund,
and by the Israeli
withThis
the joint
program
of thesupported
Simons institute
UC University
Berkeley and
Weizmann
institute
of science.
Academy of Science, grant 724/15. Part of this work has been performed while Leonid Barenboim was affiliated
1
with the joint program of the Simons institute at UC Berkeley and Weizmann institute of science.

1

1877-0509 © 2017 The Authors. Published by Elsevier B.V.
Peer-review under responsibility of the scientific committee of the International Conference on Computational Science
10.1016/j.procs.2017.05.098

1

90	

Fully-Dynamic Graph Algorithms...
Barenboim
and Maimon
Leonid Barenboim et al. / Procedia Computer Science 108C (2017)
89–98

1

Introduction

1.1 Problems and Results
We consider the Dynamic Graphs (centralized) setting in which the number of vertices n is
fixed, and in each step an edge is either removed or added to a graph G = (V, E). Thus, the
number of edges m changes in each step. This setting attracted a lot of attention recently,
due to its relevance to various fields such as communication networks, molecular biology (e.g.,
metabolic network modeling), neural networks, VLSI design, and computer graphics, in which
graphs change rapidly. In the field of networks, for instance, a central processor may have to
monitor the entire network for changes, and update a certain solution accordingly after each
change. Sublinear-time algorithms are crucial in this context. Numerous graph problems have
been studied in this setting. Notable examples include maximal matching and edge coloring. In
particular, they are useful for link scheduling in wireless networks that may change frequently.
A matching is a subset of edges M ⊆ E, such that no vertex of V belongs to more than
one edge in M . Vertices that do not belong to edges of M are called free vertices. A maximal
matching is a matching M , such that there is no edge in E \M with both its endpoints free. (It is
well known that a maximal matching is not necessarily a maximum cardinality matching, but it
is a 2-approximation of it.) The goal of the dynamic maximal matching problem is maintaining
a maximal matching after each step of addition or removal of an edge, where initially the graph
consists of n vertices and no edges. A centralized dynamic algorithm defines the sequential
operations that have to be performed on addition and removal of an edge in order to preserve
the desired solution. The running time1 , called update-time, is the maximum of the running
times of an addition operation and a removal operation.
The dynamic maximal matching and approximate maximum matching problems have been
very intensively studied in the last years [5, 7, 8, 12, 15, 16] (SODA’2016 alone has four papers
on the subject). Nevertheless, no deterministic centralized algorithm for maximal matching in
general graphs that beats the naive2 update-time of O(n) is currently known. (For randomized
algorithms better running times are known, and this problem can be solved with O(log n)
expected amortized update-time [5]. Such algorithms, however, are less suitable when every
step has to be executed as efficiently as possible.) In STOC’2013 Neiman and Solomon [15]
achieved a significant √
progress by devising a deterministic dynamic maximal matching algorithm
with update-time O( m), i.e., obtaining a sublinear in n time for sparse graphs. Since then,
several papers studied the problem on sparse graphs [7, 16]. However, the question of existence
of sublinear in n deterministic algorithm for general graphs, and in particular for dense graphs
remains wide open.
In the current paper we make a major step towards settling this question, and devise deterministic algorithms with sublinear in n update-time, for a very wide family of dense graphs.
Specifically, our algorithms are applicable to graphs with bounded neighborhood independence.
A graph has neighborhood independence c if each vertex has at most c independent neighbors
(i.e., at most c neighbors with no edges between them). A family of constant neighborhood independence includes line graphs, unit disk graphs, unit ball graphs, graphs of bounded growth,
and many other families of graphs. Note that there are graphs in these families that have
1 All running times mentioned in the current paper are worst-case, unless stated otherwise. In particular,
the running times of all our algorithms are worst-case running times.
2 The naive maximal matching algorithm works as follows. On addition of an edge, it is added to the
matching if its endpoints are free. On removal of an edge that belongs to the matching, its endpoints become
free, and a search for substitutions is performed on edges adjacent on the two endpoints. Consequently, at most
two new edges may be added to the matching. On removal of an edge that does not belong to the matching, no
additional operations are performed.

2

	

Fully-Dynamic Graph Algorithms...
Barenboim
and Maimon
Leonid Barenboim et al. / Procedia Computer Science 108C (2017)
89–98

Ω(n2 ) edges. (A clique is just one example.) For graphs of √
constant independence our maximal matching algorithm has deterministic update-time Õ( n). More generally, we obtain
deterministic sublinear in n update-time for an even
√ wider family of graphs with neighborhood
independence c = o(n/ log2 n). (Specifically, Õ( cn) update-time.) We remark that there are
also sparse graphs of bounded neighborhood independence. For example, low-degree graphs
have low neighborhood independence. Also, any graph with c ≥ 2 can be obtained by a series
of addition and removal operations starting from an edge-less graph, such that after each step
the intermediate graph has neighborhood independence ≤ c.
To the best of our knowledge, the situation with dynamic proper edge-coloring is similar
to that of maximal matching, in the sense that currently the best algorithm is the naive one
with O(n) update time. We significantly improve this result √
for general graphs by devising a
deterministic algorithm that employs O(∆) colors and has Õ( ∆) update-time.
1.2 Our Approach
We introduce a novel approach for solving centralized dynamic graph problems using distributed
computing techniques. In this approach we first identify algorithms that can be implemented
in a certain way in the standard distributed LOCAL model. In this model a communication
network is represented by a graph. Computation proceeds in rounds where each vertex receives
and sends messages to its neighbors, and performs local computations. We observe that some
algorithms that can be implemented in this model where each vertex sends o(n) messages and
performs o(n) local computations can be adapted to the centralized dynamic setting. Indeed, if
each vertex is required to communicate only with a small number of neighbors, then an update
in the centralized setting may be performed efficiently.
This scheme is not straightforward, however, and works only in certain algorithms, since the
models of distributed computing and of dynamic graphs are considerably different. Nevertheless,
the dynamic centralized setting has the advantage that the graph is globally accessible to all
vertices. (In contrast, in the LOCAL distributed setting a vertex can access only its r-hopneighborhood for some parameter r.) Consequently, we are able to employ ideas from LOCAL
distributed algorithms in conjunction with maintaining appropriate global data structures in
order to achieve our goals. Our approach illustrates the importance of reducing the amount of
local computation of processors. While local efficiency inside processors is often unrestricted in
the study of distributed algorithms, our work demonstrates that in certain scenarios both local
efficiency and round efficiency are crucial, and should be analyzed.
This approach is applied to the maximal matching problem in the following way. We maintain local and global data structures that hold free vertices. Specifically, there is a local data
structure per vertex that holds free neighbors of small degree. In addition, there is a global
data structure that holds a bounded number of free vertices with large degrees. Our algorithm
performs searches both in the local and global data structures. The operations on local data
structures can be seen as a message exchange in the distributed setting. For example, once
a free vertex is found and changes its state to matched, it notifies its neighbors by sending
messages. Since the number of neighbors of vertices in the local structures is small, this can be
implemented in the centralized setting efficiently.
We also apply this approach to edge coloring, but using a different technique. Specifically,
there are efficient proper coloring distributed algorithms that employ defective colorings [2, 4].
We are able to adapt this technique to the centralized dynamic setting. Again, this is made
possible by bounding the number of messages that have to be sent. Specifically, once a defective
coloring is given in conjunction with a proper one, in each update we need to send messages only
over edges of a certain color of the defective coloring to maintain a proper coloring. Moreover,
the defective coloring itself can be maintained more efficiently than maintaining a proper one
3

91

92	

Fully-Dynamic Graph Algorithms...
Barenboim
and Maimon
Leonid Barenboim et al. / Procedia Computer Science 108C (2017)
89–98

in the naive way. It is plausible that our approach can be applied to additional problems.
1.3 Related Work
The main previously-known approaches for obtaining dynamic algorithms are clustering [11] and
sparsification [10]. These approaches do not seem to yield deterministic sublinear update-time
algorithms for maximal matching or proper O(∆)-edge-coloring.
A deterministic algorithm
√
for maximal matching with amortized update time O((n + m) 2/2 ) was devised in [13]. As
discussed
√ above, this was significantly improved in [15] that obtained deterministic updatem). An (1 + )-approximation for maximum cardinality matching with update-time
time
O(
√
O( m−2 ) was obtained in [12]. Recently, Bernstein and Stein [7] obtained a deterministic
(3/2 + )-approximation with amortized update time O(m1/4 −2.5 ). Very recently, a (2 + )approximation with deterministic polylogarithmic update-time was obtained in [6]. (We remark
that approximate maximum cardinality matchings are not necessarily maximal matchings.) Efficient algorithms for sparse graphs were obtained in [15, 7, 16]. Defective coloring was extensively
studied from the graph-theoretic perspective. See, e.g., [9] and references therein. Distributed
algorithms for defective coloring and proper coloring were devised in [2, 4]. Distributed coloring
of graphs with bounded neighborhood independence was obtained in [3].

2

Preliminaries

G = (V  , E  ) is a subgraph of G = (V, E) if V  ⊆ V , E  ⊆ E ∩(V  ×V  ). The set of neighbors of a
vertex v ∈ V is denoted Γ(v). We denote Γ+ (v) = Γ(v) ∪ {v}. The degree of a vertex v denoted
by degv is the size of Γ(v). The maximum degree of a graph G is denoted by ∆ = ∆(G).
The number of neighbors of v ∈ V in a subgraph G of G is denoted by degG (v). Thus,
degv = degG (v). An independent set of vertices is a set of vertices with no edges between them.

3

The Generic Method

For a network G = (V, E), we define the work of a processor v ∈ V in round r as the number
of operations that v performs in round r. More precisely, in each round, v sends messages,
receives messages, and performs local computations. In order to send messages it perform
write operations of the messages to be sent. Similarly, for receiving messages, it performs read
operations from its mailbox. (Since a processor is allowed to send a message to a subset of its
neighbors, and read only some of the received messages, it is possible that the number of such
write and read operations is sublinear in the number of neighbors of v.) Thus, the work of v
in round r is the sum of the number of its read operations, the number of its write operations,
and the number of operation of its local computations in that round. We denote the work of
v in round r by W (v, r). The work of an execution is the total work of all processors in this
execution. Specifically, if an execution
k  R lasts for k rounds, then the work of the execution,
denoted We (R) is We (R) =
v∈V W (v, i). The work of an algorithm A for n-vertex
i=1
graphs, denoted W (A), is the worst case work of an execution of A on an n-vertex graph. Note
that if a vertex v  ∈ V is inactive in some round j ∈ [k], then W (v  , j) = 0. There may be
executions in which many vertices are inactive.
A distributed algorithm has the fixing property if it is able to receive as input a partial
solution to a problem, and produce a complete solution. Specifically, suppose that we are given
a complete solution H to a graph problem (e.g., a graph in which all edges are properly colored),
and then the graph changes (e.g., some edges are removed and new ones are added), forming a
new graph H  . A distributed algorithm with a fixing property is such that is able to produce
4

	

Fully-Dynamic Graph Algorithms...
Barenboim
and Maimon
Leonid Barenboim et al. / Procedia Computer Science 108C (2017)
89–98

a proper solution H  , given the partially-proper solution H  [14, 1]. Obviously, the amount of
change permitted in a step affects the work required by a distributed algorithm in order to fix
the solution. Therefore, in the current paper we are mostly interested in the scenario where
there are only few changes in each step. However, since the work of an algorithm is measured
only by active processors, scenarios in which there is more than one edge or vertex that changes
at a time may still be of interest, even for sublinear algorithms.
Consider a dynamic distributed scenario in which a set of edges is either added or removed
in each step. Suppose that we are given an algorithm A with a fixing property, for a certain
problem. Suppose that the work of the algorithm A required to fix a solution is W (A). We will
refer to this as fixing work. Then we can obtain a dynamic algorithm for the centralized setting
as follows. For each processor v ∈ V we define the set of local data structures used by v in the
algorithm A. For each v ∈ V we denote this set by L(v). Next, we simulate the execution of
the distributed algorithm A by active vertices. Specifically, we perform the simulation round by
round. In each round, we simulate each vertex u in the set of active vertices U ⊆ V . We go over
all vertices of U sequentially, one by one, and for each such vertex execute all its operations for
the corresponding round. In each completed round r of the simulation, the local structures have
the same states as those of the distributed algorithm executed on the same input graph. Once
we are done with the simulation, the data structures have the same states as in the completed
execution of the distributed algorithm, and the required solution can be deduced. The running
time of an execution of acentralized
algorithm obtained from a simulation of a distributed

k
execution of k rounds is r=1 u∈Ur W (u, r), where Ur is the set of active vertices in round
r. This is exactly the work of that distributed execution. Hence, the worst-case running time
of the centralized algorithm is the (worst-case) work of the distributed algorithm W (A).
Theorem 3.1. Suppose that we are given a distributed algorithm A with a fixing property,
and that the fixing work of A is W (A). Then we obtain a centralized dynamic algorithm with
update-time O(W (A)). In particular, if W (A) = o(n) then the update-time is o(n).
Although the above method is very general, it does not fully utilize the power of the centralized dynamic setting. Specifically, in the centralized setting the entire graph is available, while
in the distributed setting each vertex can access only its k-hop neighborhood within k rounds.
In order to take advantage of this capability of the centralized setting, we make the following
change to the classical distributed setting. We add an ultra vertex v0 that is always connected
to all other vertices v ∈ V . Consequently, the diameter of the resulting graph is always at most
2. The goal of this ultra vertex is to store global data structures describing the entire graph,
and performing global computations. We remark that such a modification makes little sense in
the LOCAL model of distributed computing, since every computable problem can be solved in
O(1) rounds in graphs with diameter O(1). However, such a solution is only possible if work is
unrestricted. But, once work is taken into account, the setting becomes much more interesting.
In this new setting our goal is to design a distributed algorithm whose work
k is as small as
possible.
(The
work
of
an
execution
R
of
k
rounds
is
defined
by:
W
(R)
=
e
i=1 (W (v0 , i) +

W
(v,
i)).)
Such
a
distributed
algorithm
is
translated
into
a
centralized
dynamic one
v∈V
exactly as in the previous case. (See Theorem 3.1.) Consequently, the running time of the
produced centralized dynamic algorithm is the fixing work of the distributed algorithm.
Theorem 3.2. Suppose that we are given an algorithm A with a fixing property for the setting
with an ultra-vertex, and that the fixing work of the algorithm is W (A). Then we obtain a
centralized dynamic algorithm with update-time O(W (A)).
5

93

94	

Fully-Dynamic Graph Algorithms...
Barenboim
and Maimon
Leonid Barenboim et al. / Procedia Computer Science 108C (2017)
89–98

4

Maximal Matching

We describe a fully dynamic maximal matching algorithm that requires sublinear time for graphs
with bounded neighborhood independence. Due to space limitations, instead of providing a
distributed algorithm and then converting it into a centralized dynamic one, we start directly
with the centralized dynamic algorithm, and explain the ideas from the distributed setting that
are used. (e.g., local structures, message announcements). The main challenge of the algorithm
is finding a matching for a vertex that becomes free as a result of removing an edge adjacent
on it. To this end, we will maintain the following data structures.
- A data structure R that holds the representation of G = (V, E). The vertices of V are stored
in an array. Each entry of the array corresponds to a vertex v ∈ V , and stores a data structure
of adjacent vertices of v. This data structure is represented using a balanced binary tree where
vertex identity numbers serve as keys. In addition, for each entry in the array that corresponds
to a vertex v ∈ V , there is a Boolean variable mv indicating whether v is matched, and an
integer variable degv representing the current degree of v.
- A global data structure F that holds all free vertices of G that have sufficiently large degree
d, for some parameter d = o(n/ log n). The data structure F is represented using a balanced
binary tree where vertex identity numbers serve as keys.
- Local data structures L(v) for each v ∈ V that hold all free neighbors of v that do not belong
to F (i.e., free neighbors whose degree is less than d). The data structures L(v) are represented
using balanced binary trees where vertex identity numbers serve as keys.
- A data structure M that holds all matched edges in G. The data structure M is represented
by a balanced binary tree where the key of an edge (u, v) is min(ID(u), ID(v)).
Each time a matched vertex v ∈ V with less than d neighbors becomes free, it announces
this fact to all its current neighbors u ∈ Γ(v). Consequently, these neighbors update their data
structure L(u) accordingly, i.e., add v to L(u). Each time a free vertex v ∈ V with less than
d neighbors becomes matched, it announces this fact to all its current neighbors u ∈ Γ(v) who
update their data structures L(u) by removing v from L(u). Each time a matched vertex v ∈ V
with at least d neighbors becomes free it joins F . Each time a free vertex v ∈ V with at least
d neighbors becomes matched it is removed from F . If the degree of a free vertex v ∈ V grows
from d − 1 to d (as a result of adding an edge), it announce this fact to its current neighbors
u ∈ Γ(v) who remove v from L(u). Then v is added to F . On the other hand, if the degree of a
free vertex v ∈ V decreases from d to d − 1 (as a result of removing an edge), then v is removed
from F , and is added to L(u), for all current neighbors u ∈ Γ(v) of v.
An insertion operation of an edge (u, v) checks whether u and v are free, and if so adds the
edge (u, v) to M . Then, according to the rules described above, it updates the data structures
F ,L(u),L(v), and L(w) for each w ∈ Γ(u) ∪ Γ(v), if necessary. A deletion operation performs
updates in these data structures as well, in an appropriate way. If a matched edge (u, v) was
deleted, then we remove it from M , and its endpoints become free. Consequently, a search for
a matching for u and a matching for v is performed. See pseudocode below.
The correctness of the operations is based on the following assertions. Their detailed proof
is omitted form this version of the manuscript due to lack of space.
(1) The set F consists of all free vertices of G with degree at least d.
(2) For each v ∈ V , the set L(v) consists of all free neighbors of v with degree less than d.
(3) The set M is a maximal matching of G.
Next, we analyze the running time of the operations. To this end we need the following
simple but crucial observation (Lemma 4.1.) Then, we analyze the size of F (Lemma 4.2).

6

	

Fully-Dynamic Graph Algorithms...
Barenboim
and Maimon
Leonid Barenboim et al. / Procedia Computer Science 108C (2017)
89–98

Insert(u, v)
1: insert the edge (u, v) to R
2: degu := degu +1; degv := degv +1
3: if (not mu and not mv ) then
4: . . M := M ∪ {(u, v)}
5: . . mu := mv := true
6: Update-ins(u, v)
Update-ins(u, v)
1: if (mu and mv ) then
2: . . if degu ≤ d then
3: . . . . for each w ∈ Γ(u) do
. . . . . . L(w) := L(w) \ {u}
4: . . else F := F \ {u}
5: . . if degv ≤ d then
6: . . . . for each w ∈ Γ(v) do
. . . . . . L(w) := L(w) \ {v}
7: . . else F := F \ {v}
8: else if (mv and not mu ) then
9: . . . . if (degu < d) then
10: . . . . . . . L(v) := L(v) ∪ {u}
11: . . . . else if (degu = d) then
12: . . . . . . . for each w ∈ Γ(u) do
13: . . . . . . . . . . L(w) := L(w) \ {u}
14: . . . . . . . . F := F ∪ {u}
15: else if (mu and not mv ) then
16: . . . . if (degv < d) then
17: . . . . . . . L(u) := L(u) ∪ {v}
18: . . . . else if (degv = d) then
19: . . . . . . . for each w ∈ Γ(v) do
20: . . . . . . . . . . L(w) := L(w) \ {v}
21: . . . . . . . . F := F ∪ {v}
Delete(u, v)
1: remove the edge (u, v) from R
2: degu := degu −1 ; degv := degv −1
3: if (u, v) in M then
4: . . M := M \ {(u, v)}
5: . . mu := mv := f alse
6: . . Find-alternative(u, v)
7: Update-del(u, v)
Find-alternative(u, v)
1: found := f alse
2: if (L(u) = ∅) then

. . . . found := true
. . . . w := L(u).firstElement()
. . . . M := M ∪ {(u, w)}
6: . . . . mu := mw := true
7: . . . . for each (x ∈ Γ(w))
8: . . . . . . L(x) := L(x) \ {w}
9: else
10: . . . for each w ∈ F
11: . . . . . if not found and (u, w) ∈ E then
12: . . . . . . . . . found := true
13: . . . . . . . . . M := M ∪ {(u, w)}
14: . . . . . . . . . mu := mw := true
15: . . . . . . . . . F := F \ {w}
16: found := f alse
17: if (L(v) = ∅) then
18: . . . . found := true
19: . . . . w := L(v).firstElement()
20: . . . . M := M ∪ {(v, w)}
21: . . . . mv := mw := true
22: . . . . for each (x ∈ Γ(w))
23: . . . . . . L(x) := L(x) \ {w}
24: else
25: . . . for each w ∈ F
26: . . . . . if not found and (v, w) ∈ E then
27: . . . . . . . . . found = true
28: . . . . . . . . . M := M ∪ {(v, w)}
29: . . . . . . . . . mv := mw := true
30: . . . . . . . . . F := F \ {w}
Update-del(u, v)
1: L(u) := L(u) \ {v}
2: L(v) := L(v) \ {u}
3: if (not mu ) then
4: . . . . if (degu ≥ d) then F := F ∪ {u}
5: . . . . else
6: . . . . . . F := F \ {u}
7: . . . . . . for each w ∈ Γ(u)
8: . . . . . . . . L(w) := L(w) ∪ {u}
9: if (not mv ) then
10: . . . . if (degv ≥ d) then F := F ∪ {v}
11: . . . . else
12: . . . . . . F := F \ {v}
13: . . . . . . for each w ∈ Γ(v)
14: . . . . . . . . L(w) := L(w) ∪ {v}
3:
4:
5:

Lemma 4.1. Let M be a maximal matching of G = (V, E). Then the set of free vertices of V
is an independent set.
Lemma 4.2. Let G be a graph with neighborhood independence at most c, for some positive
integer c. Let F be the set of all free vertices of G with degree at least d, for some positive
7

95

96	

Fully-Dynamic Graph Algorithms...
Barenboim
and Maimon
Leonid Barenboim et al. / Procedia Computer Science 108C (2017)
89–98

integer d. Then |F | ≤ c · n/d.
Proof. Consider a vertex v ∈ V . The vertex v can have at most c neighbors in F , since all
vertices
in F are free and independent. (See Lemma 4.1.) Therefore,


F }| = v∈V |Γ(v) ∩ F | ≤ c · n. Also,
u∈F degG (u) = |{e : e ∈ E and e has an endpoint in
each vertex in F has at least d neighbors. Thus d·|F | ≤ u∈F degG (u). Hence |F | ≤ c·n/d.

We employ Lemma 4.2 in the running time analysis of the insertion and deletion operations.

Lemma 4.3. (1) Operation Insert requires O(d log n) time.
(2) Operation Delete requires O((c · n/d) · log n + d log n) time.
Proof. (1) Each step of operation Insert except for the invocation of Update-ins requires
O(log n) time. Procedure Update-ins performs a constant number of traversals over the sets
Γ(u) and Γ(v). Each such traversal is performed only if the number of elements in the corresponding set is at most d. The running time for handling each element in the set is O(log n).
(2) Each step of operation Delete except for the invocations of Find-alternative and Update-del
requires O(log n) time. Procedure Find-alternative performs a constant number of traversals
over sets of neighbors of vertices that belong to L(u) and L(v). Each vertex that belongs to
L(u) or L(v) has at most d neighbors, and thus each traversal requires O(d log n) time. In
addition, Find-alternative traverses the set F . This requires O(|F | log n) = O((c · n/d) log n)
running time. (See Lemma 4.2.) Finally, Procedure Update-del performs a constant number of
traversals of sets with at most d elements, and thus also requires O(d log n) time.
The above-mentioned results give rise to the following.
Theorem 4.4. For any integers c, d > 0, there is a fully-dynamic deterministic maximalmatching algorithm for graphs of neighborhood independence at most c with O((c · n/d) · log n +
d log n) update-time.
Corollary 4.5. There is a fully-dynamic deterministic maximal-matching
algorithm for graphs
√
with constant neighborhood independence that requires O( n log n) update-time.
Corollary 4.6. There is a fully-dynamic deterministic maximal-matching algorithm for graphs
with neighborhood independence o(n/ log2 n) that requires sublinear update-time.

5

Experimental Results of Maximal Matching

We present here the results of the simulations we executed with our algorithm. We adapt the
classical models of G(n, p) (Erdős-Rényi model) and Preferential Attachment (Barabási-Albert
model) to the dynamic setting. Specifically, the first model we use is G(n, p, q, r, s), where n is
the number of vertices in the graph, p is the probability of adding an edge, q is the probability
of removing an edge, r defines whether the next step is an addition or a removal of an edge
(i.e., the type of the step is addition with probability r and removal with probability 1 − r),
and s is the size of a sequence of operations of the same type per step. The second model
we use is P A(n, r, s), where n, r and s are as in the first model, but higher degree vertices
have higher chances of being connected. Specifically, in each addition operation, a node that is
selected uniformly at random is connected to a random vertex, where higher-degree vertices have
higher probabilities. In each removal operation a vertex that is selected uniformly at random
is disconnected from one of its neighbors, where the probability of a neighbor to disconnect is
inverse-proportional to its degree.
8

	

Fully-Dynamic Graph Algorithms...
Barenboim
and Maimon
Leonid Barenboim et al. / Procedia Computer Science 108C (2017)
89–98

We executed our experiments on various graphs, with up to 100, 000 vertices and 10, 000, 000
edges. To this end, we defined the number of steps i to be between 1, 000, 000 and 10, 000, 000.
All experiments started with graphs with n vertices and no edges, and in each step an edge (or
several edges, if s > 1) is added or removed
according to the model. We measured how many
√
free vertices have a degree higher than n in each step, and recorded the maximum value per
experiment over all its steps. (See the ”Free High” columns in the tables.) Each experiment
(a row in a table) was repeated several times, and the maximum value of ”Free High”√was
recorded. This is the only parameter that could make the update-time be greater than O( n).
Therefore, experimentally √
verifying that it is sufficiently low is crucial. In all our experiments
this value did not exceed n, and it was often even smaller than that. See Table 1 and Table 2. Another set of experiments we performed is on graphs that remain bipartite, where
both parts have equal number of vertices. Such graphs have very large number of independent
vertices (all vertices of the same part), and may reflect a difficult case. However, as it turned
out, the number of free vertices with high degrees remained small even in this case. See Table 3.

6

Coloring Algorithms

A d-defective p-coloring of edges is an edge coloring using p colors such that each
√ vertex has
at √
most d edges with the same color adjacent on it. Any graph admits an O( ∆)-defective
O( ∆) coloring. (See, e.g.,
√ [9].) Moreover, we can maintain such a coloring in the sequential
dynamic setting within Õ( ∆) update-time. The full proof is omitted from the current version.
Theorem 5.1. For any integer k ≥ 2, there is a fully-dynamic deterministic algorithm for
2∆/k + 1-defective k-coloring of edges for general graphs with update time O(k log ∆) per
operation, where ∆ is the maximum degree of the graph in the end of the operation.
√
√
Note that in a ∆-defective ∆-coloring,
each subgraph induced√by edges of the same
√
a proper O( ∆)-edge-coloring can
color class has maximum degree O( ∆). Consequently,
√
be maintained within each such subgraph with O( ∆)-update time. The combination of the
9

97

98	

Fully-Dynamic Graph Algorithms...
Barenboim
and Maimon
Leonid Barenboim et al. / Procedia Computer Science 108C (2017)
89–98

√
√
defective color of an edge with its proper color in its subgraph provides a√proper O( ∆× ∆) =
O(∆)-edge-colorig of the entire graph. The overall running time is Õ( ∆).
√
Theorem 5.2. Fully-dynamic deterministic O(∆)-edge-coloring has O( ∆ log ∆) update-time.

7

Conclusion

Our method for simulating distributed algorithms in a centralized setting produces efficient
dynamic algorithms. In particular, it can be applied to two central graph problems, namely
maximal matching and edge coloring. We hope that this will lead to further research of these
and additional problems. Deterministic maximal matching with o(n) update-time is still a very
challenging open problem in general graphs. Hopefully, our work that achieves this goal for a
very wide family of dense graphs can be a stepping stone towards solving this open problem.

Acknowledgments

The authors are grateful to Valerie King for fruitful discussions and helpful remarks.

References
[1] L. Barenboim. Deterministic (∆+1)-coloring in sublinear (in ∆) time in static, dynamic and faulty
networks. Proc. 34th ACM Symp. on Principles of Distributed Computing, p. 345-354, 2015.
[2] L. Barenboim, and M. Elkin. Deterministic distributed vertex coloring in polylogarithmic time.
In Proc. of the 29th ACM Symp. on Principles of Distributed Computing, pages 410-419, 2010.
[3] L. Barenboim, and M. Elkin. Distributed deterministic edge coloring using bounded neighborhood
independence. Proc. 30th ACM Symp. on Principles of Distributed Computing, p. 129-138, 2011.
[4] L. Barenboim, M. Elkin, and F. Kuhn. Distributed (∆ + 1)-coloring in linear (in ∆) time. SIAM
Journal on Computing, 43(1):72-95, 2014.
[5] S. Baswana, M. Gupta, and S. Sen. Fully Dynamic Maximal Matching in O(log n) Update Time.
In Proc. IEEE 52nd Annual Symp. on Foundations of Computer Science, pages 383-392, 2011.
[6] S. Bhattacharya, M. Henzinger, and D. Nanongkai. New Deterministic Approximation Algorithms
for Fully Dynamic Matching. In Proc. of the 48th ACM Symposium on Theory of Computing, 2016.
[7] A. Bernstein, and C. Stein. Faster Fully Dynamic Matchings with Small Approximation Ratios. In
Proc. of the 27th Annual ACM-SIAM Symposium on Discrete Algorithms, pages 692 - 711, 2016.
[8] R. Chitnis, G. Cormode, H. Esfandiari, M. Hajiaghayi, A. McGregor, M. Monemizadeh and
S. Vorotnikova. Kernelization via Sampling with Applications to Dynamic Graph Streams. In
Proc. of the 27th Annual ACM-SIAM Symp. on Discrete Algorithms, pages 1326 - 1344, 2016.
[9] L. Cowen, W. Goddard, and C. Jesurum. Coloring with defect. In Proc. of the 8th ACM-SIAM
Symp. on Discrete Algorithms, pages 548–557, 1997.
[10] D. Eppstein, Z. Galil, G. F. Italiano, and A. Nissenzweig. Sparsification - A technique for speeding
up dynamic graph algorithms. Journal of ACM, 44(5):669-696, 1997.
[11] G. N. Frederickson. Data structures for on-line updating of minimum spanning trees. SIAM
Journal on Computing, 14(4):781798, 1985.
[12] M. Gupta, and R. Peng. Fully Dynamic (1 + )-Approximate Matchings. In Proc. of the IEEE
54th Annual Symposium on Foundations of Computer Science, pages 548 - 557, 2013.
[13] Z. Ivković, and E. L. Lloyd. Fully dynamic maintenance of vertex cover. In Proc. of the 19th
International Workshop on Graph-Theoretic Concepts in Computer Science, pages 99-111, 1993.
[14] M. König, and R. Wattenhofer. On local fixing. In Proc. of the 17th International Conference on
Principles of Distributed Systems, pages 191 - 205, 2013.
[15] O. Neiman, and S. Solomon. Simple deterministic algorithms for fully dynamic maximal matching.
In Proc. of the 45th ACM Symposium on Theory of Computing, pages 745-754, 2013.
[16] D. Peleg, and S. Solomon. Dynamic (1+)-Approximate Matchings: A Density-Sensitive Approach.
In Proc. of the 27th Annual ACM-SIAM Symposium on Discrete Algorithms, pages 712-729, 2016.

10

