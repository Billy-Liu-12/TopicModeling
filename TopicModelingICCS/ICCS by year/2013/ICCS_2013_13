Available online at www.sciencedirect.com

Procedia Computer Science 18 (2013) 531 – 540

International Conference on Computational Science, ICCS 2013

Applying CP(F D), CLP(F D) and CFLP(F D) to a Real-Life
Employee Timetabling Problem
Ignacio Casti˜neiras∗, Fernando S´aenz-P´erez∗∗
Universidad Complutense de Madrid, Spain

Abstract
This paper presents a case study based on a real-life Employee Timetabling Problem, formulating it and then making a comparison of its modeling and solution with three diﬀerent programming paradigms embedding Finite Domain constraint solving:
Constraint Programming, Constraint Logic Programming and Constraint Functional Logic Programming. The analysis uses the
systems Gecode, SICStus clpfd and T OY(F D) (with its two diﬀerent versions relying on the Gecode and SICStus solvers,
resp.) The modeling comparison via code examples points out the diﬀerent abstraction levels the systems allow. The solving
comparison uses diﬀerent order-of-magnitude instances to perform a head-to-head comparison among the diﬀerent systems.
Keywords: Employee Timetabling Problems, Constraint Programming Systems Comparison, Modeling, Performance

1. Introduction
An Employee Timetabling Problem (ETP) is concerned with assigning a number of employees to a given set of
shifts over a ﬁxed period of time, and is present in almost any industry [1]. The ETP is known to be NP-complete,
and thus many diﬀerent approaches from Mathematical Programming and Heuristics have been used to tackle it
(see for example [2], [3] and [4]). However, the constraint-oriented nature of an ETP makes the use of Constraint
Programming techniques over Finite Domains (F D) a suitable approach to model and solve it (see for example
[5], [6] and [7].)
In this paper we present a case study based on a real-life ETP coming from a technical department of the
Spanish public television. A ﬁrst formulation was done in [8]. It was reformulated in [9] on demand of a concrete
instance (with a ﬁxed structure) which included new requirements also embodying optimization. The main contribution of the paper is, ﬁrst, to formulate an algorithm for solving a parametric version of the ETP, and, second,
making an in-depth analysis of its modeling and solution among the diﬀerent paradigms underlying constraint
programming techniques. Although an extensive and standardized benchmark would be necessary to draw general conclusions of the comparison of diﬀerent paradigms, in this paper we focus on this ETP, as it is a real-life
problem with complex characteristics (non-monolithic and including constraint programming independent components), exploiting the features of the diﬀerent paradigms for tuning the modeling and solution of the problem.
∗ Dept.

Sistemas Inform´aticos y Computaci´on, ncasti@fdi.ucm.es
Ingenier´ıa del Software e Inteligencia Artiﬁcial, fernan@sip.ucm.es
This work has been partially supported by the Spanish projects TIN2008-06622-C03-01, UCM-BSCH-GR58/08-910502, and S2009TIC-1465.
∗∗ Dept.

1877-0509 © 2013 The Authors. Published by Elsevier B.V. Open access under CC BY-NC-ND license.
Selection and peer review under responsibility of the organizers of the 2013 International Conference on Computational Science
doi:10.1016/j.procs.2013.05.217

532

Ignacio Castiñeiras and Fernando Sáenz-Pérez / Procedia Computer Science 18 (2013) 531 – 540

Departing from a single algorithm, we decide to program the ETP using state-of-the-art systems relying on
general purpose languages for the paradigms of Constraint Programming (CP(F D)) [10], Constraint Logic Programming (CLP(F D)) [11] and Constraint Functional-Logic Programming (CFLP(F D)) [12]. Thus, we have
selected the systems Gecode [13] (used directly over C++), SICStus Prolog and T OY(F D) (using the two versions T OY(F Dg) and T OY(F Ds), relying on the Gecode and SICStus solvers, resp. [14].) We have discarded
using Gecode via a high-level speciﬁc-purpose CP(F D) language as MiniZinc [15], as the constraint independent components are more naturally expressed in C++, and to tackle our non-monolithic problem it would have
been necessary to develop several models and coordinate them via an external script. We have also discarded
the Monadic Constraint Programming Framework (CFP(F D)) [16], as T OY(F D) already provides functional
features and it also interfaces Gecode as its external solver.
The structure of the paper is as follows: Section 2 presents the new formulation of the ETP, as well as the
algorithm the systems follow to solve it. Section 3 presents the modeling analysis, using code examples to show the
diﬀerent abstraction levels the systems provide. Section 4 presents the performance analysis, using diﬀerent orderof-magnitude instances to analyze the results obtained by the systems (including speciﬁc subsections devoted to
compare the performance of each T OY(F D) version w.r.t. the one achieved by its host solver). Finally, Section
5 reports some conclusions and future work.
2. The Real-Life ETP
This section presents both the formulation of the ETP problem and the algorithm the systems follow to solve
it (ﬁrst giving an outline, and then explaining each step in detail.) Besides this general explanation, an instanceoriented one can be found in [17], where the problem description, the solving approach and the algorithm description are explained for a concrete instance (including the set of variables and constraints posted to the solver, as
well as any other additional data structure being used.)
Problem Description: A department is ﬁlling its employee timetabling dc ≡ {dc1 , . . . , dcnd } of nd days.
There are diﬀerent kinds of working days ws ≡ {ws1 , . . . , wsk } (each one containing diﬀerent shifts wsi ≡
[wsi1 , . . . , wsim ]), and there is an injection from dc to ws. If wsi provides m shifts, then for each day dc x = wsi
there must be m workers at the department (each shift is assigned to a single worker). The department employs
w ≡ (nt×ntw)+1 workers. nt×ntw of them are regular workers divided into nt teams of ntw workers: {w1 , . . . , wntw }
belong to team t1 , {wntw+1 , . . . , w2∗ntw } belong to team t2 , and so on. The absences abs ≡ {(wi1 , dc j1 ), . . . , (wil , dc jl )}
of pairs (regular worker, day) are provided, and there is an extra worker ew which belongs to no team and is only
selected by demand for coping with regular workers absences.
Each team ti is selected to work each nt days. If ti is selected on day dc j only {w(i−1)∗ntw+1 , . . . , wi∗ntw } (the
regular workers of that team) and ew are able to work at the department on that day. The extra worker ew can be
selected to work just 1 out of each er consecutive days. For each day dc j , the selected ti provides (due to absences)
0 ≤ a ≤ ntw available workers to be assigned to the m available shifts of the day. If a ≥ m then ew and any possible
remaining regular worker do not have to work (they are assigned to shifts of 0 hours). If a = m − 1 then ew is
selected to work, coping with one of the m shifts of dc j . If a < m − 1 then there is no possible assignment, and
ti can not be selected for dc j . Given s ≡ {s1 , . . . , sg } as the set of diﬀerent shift types that ws provides, T ti ,sz is a
measure of the distribution of shifts of type sz to the regular workers of ti . Supposing that {w(i−1)∗ntw+1 , . . . , wi∗ntw }
are assigned to [cv1 , . . . , cvntw ] shifts of type sz during the nd days, then T ti ,sz represents the diﬀerence between
the maximum and minimum of these cv values. Shift distribution is constrained by T , representing the maximum
value any T t,s can take.
Scheduled timetabling contains h working hours, so each regular worker is expected to work h/(nt × ntw)
hours. Any more worked hour is considered as an extra hour. Optimization arises in the problem because the
department must pay regular workers for each extra hour they work, and any hour that ew works is paid as e f
extra hours of a regular worker. Optimal schedule minimizes the extra hour payment.
Solving Approach: Let us name p tt the algorithm for solving an instance of the parametric timetabling. It
receives the input parameters nd, nt, ntw, er, e f , ws and T . Special input parameters P, W and S S are provided to
conﬁgure the F D constraint solver. P sets the propagation mode to incremental or batch [18]. W and S S set the
search strategy to: Order the variables by workers or days, and label the variables by ﬁrst unbound or ﬁrst fail,

Ignacio Castiñeiras and Fernando Sáenz-Pérez / Procedia Computer Science 18 (2013) 531 – 540

533

resp. The result computed by p tt is the pair (timetabling, eh). The former is an nd × w assignment (where each
position (i, j) represents the shift assigned on day j to worker i). The latter represents the total amount of extra
hours of such assignment.
The main idea of the algorithm is to solve the problem by decomposing it into independent subproblems
(exponentially easier to be solved), and then solve them sequentially. The idea of splitting the problem relies on
the fact that only one team works each day, and the diﬀerent teams rotate (each ti works exactly each nt days).
However, the diﬀerent teams are linked by the fact that ew can not be selected to work more than 1 out of each
er consecutive days. Thus, the algorithm relies on a four stage process: (i) team assign, (ii) tt split, (iii) tt solve
and (iv) tt map. First stage team assign just concerns with ﬁnding any feasible bijection tda (teams to days
assignment) from dc to teams, such that: (1) For each day dci there are enough workers (of the selected team
t j ) available to cope with the shifts, and (2) The er constraint is entailed. Starting from a feasible bijection tdai ,
the stages tt split, tt solve and tt map are executed, generating nt subproblems, solving them and mapping the
solution to (timetabling, eh). It is important to remark that, given nt, each possible bijection tdan0 only explores
1/nt! of the total search space. To ﬁnd the timetabling with optimal eh, all feasible bijections {tda1 , . . . , tdan } must
be computed and scheduled.
Algorithm Description: Finally we provide a description of each stage, to understand both the modeling
analysis and the code of the models (available online at: http://gpd.sip.ucm.es/ncasti/models.zip).
Stage team assign: (1) Create T able, an {nd × (ntw + 1)} matrix of variables. (2) Fit abs to oabs (a list of lists
representing the absences ordered per day.) Create atd (a list of lists representing the absences per day and team)
and etd (a list of lists representing the request of ew per day and team). (3) Create the arrays of nd F D variables d
(di ≡ team assigned to dci ), a (ai ≡ amount of regular worker absences on dci ) and e (ei ≡ is ew requested on dci ).
(4) Initialize d to {1, . . . , nt}, constrained by di == di+nt , and by an all diﬀerent constraint over {d1 , . . . , dnt }. (5)
Initialize a to {0, . . . , ntw}. Each mi (amount of shifts to be covered on dci ) is explored to prune ai upper bound.
Link d, a and atd. (6) Initialize e to 0, 1. The sum of each {ei , . . . , ei+er } is constrained to be ≤ 1. Link d, e and
etd. (7) Label d to obtain the feasible team assignments tda.
Stage tt split: (1) Receive T able, d, e and oabs from team assign. (2) Compute T otZ (a list of lists representing the selected worker absences per day), using di and oabsi to know which selected regular workers are absent
on dci , and ei to know if ew is selected for dci . (3) For each dci traverse T ablei , binding to zero each variable
indexed by T otZi . (4) Split T able by teams: {tt1 , . . . , ttnt }, each of them an {(nd/nt) × (ntw + 1)} matrix.
Stage tt solve (sequentially called to solve each tti , from now on just tt): (1) Transpose tt to obtain trans tt, a
matrix {(ntw + 1) × (nd/nt)} ordered by workers instead of by days. (2) For each day dci = ws j of tt: Parse ws j to
obtain the diﬀerent working slots, say values v (and their cardinalities, say c). Initialize tti with domain v, and post
a global constraint ensuring their distribution with (v, c). (3) Compute ls (a list of the diﬀerent kind of shifts s x to
be scheduled in tt). (4) Compute ln (a mate list for ls, where each lni contains the number of shifts of type lsi to be
scheduled in tt). (5) For each lsi : Generate new (ntw + 1) variables cv, each cvk assigned to the amount of shifts of
type lsi the worker trans ttk is assigned to, and the sum of cv constrained to be lni . (6) Tight the distribution with
T by constraining the diﬀerences of cv to be in the domain {−T, . . . , T }. (7) Compute the extra hours of tt via the
sum of the hours of the regular workers (and a comparison with standard hours to be accomplished) plus the sum
of the hours of ew × e f . (8) Label tt to ﬁnd the assignment that minimizes the extra hours.
Stage tt map: (1) Receive the solved {(tt1 , eh1 ), . . . , (ttnt , ehnt)}, mapping them to (timetabling, eh).
3. Modeling Analysis
This section presents the main diﬀerences in modeling the ETP in Gecode, SICStus and T OY(F D). A
subsection is devoted to each task, and code examples are used for a better understanding. Italics and Typewriter
notations are used to refer to the algorithm and to the code, resp (e.g., tt and TT or tti and TT[i].)
F D Solver Abstraction: SICStus and T OY(F D) abstract to the user the diﬀerent elements taking place in
F D constraint solving, making the management of decision variables, constraints, objective function, constraint
store and constraint solver transparent to the user. This abstraction also includes constraint propagation, the notion
of search engine and search control. In the case of Gecode, the user has to deal with all this features by using the
API to manage the objects needed for F D constraint solving. Fig. 1 contains a fragment of p tt, the main entry

534

Ignacio Castiñeiras and Fernando Sáenz-Pérez / Procedia Computer Science 18 (2013) 531 – 540

---------------------------------- Gecode -------------------------------bool p =
|
//III. TT Solve
(((string) argv[10]) == "true"); |
while ((sat) && (i < nT)){
//I. Team Assign
|
sat= slv[i]->tt_solve(p,...,h);
StageI* s = new StageI;
|
BAB<StageIII> eng(slv[i]);
bool sat = s->team_assign(p, nD, nT, |
while (StageIII* ss= eng.next())
nTW, eR, ..., oAbs) |
slv[i] = ss;
if (sat){
|
eh += slv[i]->get_eh();
DFS<StageI> engine(s);
|
}
while (StageI* sol= engine.next()){|
//IV. TT Map
//II. TT Split
|
tt_map(s, slv, nD, ..., nTW);
s = sol;
|
for (int k = 0; k < nT; k++)
vector<StageIII*> slv;
|
delete slv[k];
int h= tt_split(p, s, slv, nD,
| } //end while StageI
nT, nTW, ..., dC);
| delete s; ...
------------ SICStus ----------------------------------TOY---------------set_prop(P, NTeams, P1, P3),
|set_prop P == true,
team_assign(P1, ..., D),
|team_assign ... == (..., D),
tt_split(..., D, Table, TT, H),
|tt_split ... D == (..., Table,TT,H),
zipWith_tt_solve(P3, ..., TT, LEH), |sum (zipWith (tt_solve ...) TT C)
sum(LEH, #=, EH),
|
(#=) EH,
Fig. 1. Fragment of p tt

point of the Gecode, SICStus and T OY(F D) models, resp. It shows that the code of SICStus and T OY(F D)
(left and right bottom columns, resp.) is simpler and neater than the code of Gecode (top of both columns), which
carries out the management of diﬀerent objects, including its garbage collection.
Using Multiple Solvers: Fig. 1 shows that, in Gecode, a solver StageI* s is being used to perform
team assign. Then, for each feasible team assignment tdan0 found, a new vector slv of solvers is created,
where each slv[i] deals with performing tt solve for a concrete tti of tdan0 . StageI and StageIII are two
diﬀerent C++ classes inheriting by Space (which is the abstraction that Gecode provides for a constraint solver.)
Modeling a CSP (variables, constraints and search strategy) in Gecode requires an Space subclass devoted to it.
As ﬁnding each tdan0 and scheduling each tti are diﬀerent CSP’s, diﬀerent Space subclasses are needed. But,
since parallel solving is not being used, one would try to sequentially post and solve the independent tt subproblems within s, instead of using slv. However, the API of Gecode requires each Space to be wrapped into a
search engine to perform a search strategy (and this precludes the posting of new constraints on it.) Fig. 1 shows
that s is wrapped into the search engine engine, reaching the stage tt solve in search mode. At that moment,
s is prepared to further looking for more feasible tda (via engine.next()), but not to receive the constraints of
each tti , which must use slv[i].
SICStus and T OY(F D) should have the same kind of problems, at least the version T OY(F Dg) (which uses
Gecode as its F D solver.) However, as both systems abstract the F D constraint solving objects, the way they
manage the intermix of constraint posting with search procedures is transparent to the user. Fig. 1 shows that both
SICStus and T OY(F D) models include no notion of the solver performing each stage.
Associating with a Solver: The proposed algorithm (cf. Section 2) states that d variables are labeled in step
(7) of team assign, and that their bound values are accessed in step (3) of tt split to compute T otZ. Only labeling
d requests the solver constraint propagation. However, in Gecode, the variables are no independent, but attached
as attributes to a concrete solver. Fig. 1 shows that, whereas in SICStus and T OY(F D) d is freely passed as an
argument to tt split, in Gecode the whole s solver must be passed, to be further inspected within the function
in order to obtain the values of its associated d attributes.
Non-determinism: SICStus and T OY(F D) support model reasoning, made explicit in their goal computations with the use of non-deterministic predicates and functions (resp.), which contain diﬀerent clauses/rules to
be explored in order until one matches and satisﬁes the declared conditions. Computation then continues, but

Ignacio Castiñeiras and Fernando Sáenz-Pérez / Procedia Computer Science 18 (2013) 531 – 540

535

--------------- Gecode --------------|----------- SICSTUS ---------------void put_zero(bool p, int i, int j){ |%put_zeros/2(?List, +Index).
IntVarArray v(this->tt[i]);
|put_zeros(L, I) :rel(*this, v[j] == 0, p_level); |
nth1(I, L, 0, _).
if (prop)
|------------ TOY ------------------this->status();
|put_zeros:: [int] -> int -> [int]
}
|put_zeros L I = L <==
|
splitAt (I-1) L == (A, [0|Bs])
Fig. 2. Code of put zeros

the unexplored clauses/rules remain there, waiting for an eventual backtracking (triggered via a fail of the goal,
or via user request for more solutions to the goal) which continue their exploration. When such backtracking is
performed, the whole goal computation is restored to the point the system has backtracked to.
The proposed algorithm (cf. Section 2) states that the variables of d are labeled in step (7) of team assign.
Starting from each feasible tda found, the stages tt split, tt solve and tt map are performed to schedule it. The
SICStus and T OY(F D) models use a labeling expression at the end of team assign, whose action allows
model reasoning. Fig. 1 shows that, by using this expression, it suﬃces to call the diﬀerent stages in order.
Backtracking to the labeling is performed if: (a) There is no possible assignment for the tdan0 being explored
(fail) or (b) After scheduling tdan0 there could be more tda to be explored. As backtracking restores all the
computation to the state it had in step (7) of team assign, in particular Table is restored to be again an (nd ×
ntw + 1) matrix of fresh variables.
In Gecode there is no model reasoning. Fig. 1 shows that an explicit while loop is necessary to compute (one
by one, with engine.next()) each feasible tda, calling tt split, tt solve and tt map. Also, as there is no
restoration, each loop iteration must create new slv and Table (as its variables becoming bound while scheduling
a tdan0 would not be restored to be fresh variables for the next while loop iteration.) Thus, the proposed algorithm
must be altered in the Gecode model, creating Table after team assign.
Distinguishing Logical and Decision Variables: As a CP system, the operational mechanism of Gecode
exclusively relies on constraint solving. There exist just decision variables, created with an initial domain, further
pruned by constraint propagation. However, SICStus and T OY(F D) belong to the CLP and CFLP paradigms,
and thus constraint solving is coordinated by the operational semantics of the system, based on SLD resolution and
lazy narrowing, resp. These systems rely on logical variables, which are syntactically uniﬁed by a Herbrand (H)
solver. The F D solver is used to manage any F D primitive constraint arisen in the computation, and each logic
variable involved on such this primitive must be ﬁrstly attributed [19]. In the SICStus and T OY(F D) models,
this attribution is transparent to the user.
The proposed algorithm (cf. Section 2) states that: (i) T able is created in step (1) of team assign. (ii) The
variables of T able representing absences are bound to zero in step (4) of tt split. (iii) T able is split into tt in step
(5) of tt split, where each tti is independently solved in tt solve. On the one hand, in the SICStus and T OY(F D)
models, these tasks are performed by the H solver. To represent Table, new fresh logic variables are created
(which are not taken into account by the F D solver until an F D constraint involves them). Binding some of
them to zero is treated as a syntactic uniﬁcation. Splitting Table into TT implies variable uniﬁcation between
the two representations (Table and TT[i]) of the same logic variable. On the other hand, in the Gecode model,
the scheme using slv precludes creating Table and then splitting it into TT. Let us suppose that Table would
be modeled in s’ by creating new IntVars and posting as many rel constraints as variables should be bound
to zero. Then, to split it to TT, the variables and constraints of the ﬁrst team must be posted to slv[0], and so
on. But, to link Table and TT[0], equality constraints between mate representations of the same variable must
be posted. However, mate representations are placed in diﬀerent models s’ and slv[0]; so, none of them can
contain the link constraint. Thus, we alter the proposed algorithm by not creating Table, but directly TT.
Fig. 2 presents the code of put zeros. It shows that, whereas in the SICStus and T OY(F D) models the
variables of Table are syntactically uniﬁed to 0 by the H solver, in the Gecode model the variables of TT are
constrained to 0 by the F D solver. The predicate nth1 takes as input arguments a list L and an index I, given
as output elements the indexed element of the list E and the rest of the list without this element NL. The function

536

Ignacio Castiñeiras and Fernando Sáenz-Pérez / Procedia Computer Science 18 (2013) 531 – 540

------------ SICStus ----------------|------------ TOY ------------------zipWith_rworkers_abs(NTW,D,OAbs,TWZ),|zipWith (foldl put_zeros)
EId is NTW+1,
| Table
zipWith_e_worker_day_abs(EId, E,
| (zipWith (e_worker_day_abs (NTW+1))
TWZ, TotZ),| E
zipWith_put_zeros(Table, TotZ),
| (zipWith (rworkers_abs NTW) D OAbs))
|== Table,
Fig. 3. Fragment of tt split

splitAt uses I and L to split the list in two sublists A and B. Both SICStus and T OY(F D) use pattern matching
to implicitly unify the variable, forcing E and the head of B to be 0 in order to make the predicate or the function
succeed, resp.
Functional Features: Besides the tasks related to pure constraint programming, the use of functional features
(as higher-order functions, functional notation, patterns or curried constraints) increase the expressiveness of
T OY(F D) w.r.t. SICStus, easing the modeling of the problem and generating a more maintainable, neat and less
error prone code. As an example, the proposed algorithm states that T otZ is computed in step (2) of tt split and
used in step (3) of tt split to bind to zero the variables of T able representing absences.
Fig. 3 contains a fragment of tt split, where: (a) rworkers abs uses D[i] and OAbs[i] to ﬁlter only the
absences of the selected working team for day i. (b) e worker day abs adds the extra worker as an absence in
case it is not requested to work on day i. (c) put zeros uses TotZ[i] to bind to zero the absences of Table for
day i. The functional component give the following advantages to the T OY(F D) model: (i) The use of the higher
order functions zipWith and foldl (which have the same semantics as in standard functional programming, e.g.,
Haskell [20]) allows to perform steps (2) and (3) of tt split in just one line of code. (ii) By supporting functional
notation, the code avoids the creation of TWZ, EId or TotZ. (iii) The partially applied function (rworkers abs
NTW) (requesting two arguments, instead of the three requested by rworkers abs) can be passed as a pattern to
the zipWith function.
In contrast, the lack of this functional component in SICStus enlarges the amount of code needed. For
example, the lack of higher order functions implies using an extra predicate for each diﬀerent higher-order
application done in the T OY(F D) code (see Fig. 3, where the extra predicates zipWith rworkers abs,
zipWith e worker day abs and zipWith put zeros are needed to compute the three diﬀerent applications
of zipWith in T OY(F D)).
4. Performance Analysis
This section analyzes the performance of Gecode, SICStus and the two T OY(F D) versions (available at
http://gpd.sip.ucm.es/ncasti/TOY(FD).zip) for solving the ETP previously modeled.
Setting-up the experiments: Three instances are used, with nd = 7, 15 and 21. They are relevant to the performance analysis, as their solving times are of diﬀerent orders of magnitude (tenths of second, seconds and minutes,
resp.) The rest of the input arguments are ﬁxed: dc is assumed to start on Monday (where any week contains ﬁve
working days followed by weekend), nt = 3, ntw = 4, er = 3, e f = 2 and ws = [[20, 22, 24], [24, 24]] (representing the shifts for a working and a weekend day, resp.) abs = [(w1 , d1 ), (w2 , d1 ), (w5 , d1 ), (w5 , d6 ), (w6 , d1 ), (w6 , d6 ),
(w7 , d1 ), (w7 , d6 ), (w10 , d1 ), (w10 , d6 ), (w11 , d1 ), (w11 , d6 ), (w12 , d1 ), (w12 , d6 )], which, in conjunction with dc, leads
to only two feasible tda, as only the ﬁrst team can work on day 1 (both tda requests ew on days 1 and 6.) T = 1,
allowing small diﬀerences between the shifts assigned to each regular worker of the team.
For the fairness of the comparison, a single solver conﬁguration is set to all the systems. Fortunately, this
conﬁguration results to be the one with best performance for all the systems: P = true, setting incremental
propagation to the posting of the constraints. The search strategy (W, S S ) is set to order the variables by workers
and then label them by ﬁrst unbound. The ﬁltering algorithms for the global constraints all di f f erent, count and
global cardinality are set to value consistency.
Finally, for the fairness in the measurement of the elapsed time, all the systems execute the instances within the
SICStus framework, making use of the SICStus predicate statistics(runtime, [X, ]) [21] (which uniﬁes X

Ignacio Castiñeiras and Fernando Sáenz-Pérez / Procedia Computer Science 18 (2013) 531 – 540

nd
7

15

21

System
Gecode
T OY(F Dg)
SICStus
T OY(F Ds)
Gecode
T OY(F Dg)
SICStus
T OY(F Ds)
Gecode
T OY(F Dg)
SICStus
T OY(F Ds)

Time
0.03
0.33
0.16
0.19
0.70
1.05
1.53
3.03
63.09
63.69
198.50
334.66

Slow-Down
1.00
11.00
5.33
6.33
1.00
1.50
2.19
4.33
1.00
1.01
3.15
5.30

Lab. Time
0.03
0.06
0.09
0.06
0.69
0.70
1.50
2.78
63.06
63.47
198.41
334.31

Lab. Slow-Down
1.00
2.00
3.00
2.00
1.00
1.01
2.17
4.03
1.00
1.01
3.15
5.30

537

Lab %
100.00
18.18
56.25
31.58
98.57
66.67
98.04
91.75
99.95
99.65
99.95
99.90

Table 1. T OY(F D) Obtained Results for the ETP

to the CPU time used while executing, excluding memory management and system calls). Whereas for SICStus
and T OY(F D) this setup comes by free (as T OY(F D) is implemented in SICStus Prolog), the Gecode model is
executed within SICStus via wrapping its C++ main function into a SICStus predicate p (see the SICStus interface
to C++ [21]) and then executing p on the SICStus engine.
Table 1 presents the obtained results. The ﬁrst and second columns represent the instance being solved and the
system solving it, resp. Whereas the third column represents the runtime for solving the instance, the ﬁfth column
focuses in the runtime for just solving the labeling of tt solve for all the teams. Both columns are measured in
seconds, with precision set to two decimal digits. The fourth and the sixth columns represent the slow-down of
the systems w.r.t. Gecode for the times obtained in the third and ﬁfth columns, resp. Finally, the seventh column
measures the ratio between solving the labelings and the time for solving the instance. Benchmarks are run in a
machine with an Intel Dual Core 2.4Ghz processor and 4GB RAM memory. The OS used is Ubuntu 12.04 LTS
(32 bits.) The SICStus version used is 4.2.0. GCC 4.6.3 tools are used to compile and link the C++ code of
T OY(F Dg) and the wrapped Gecode model.
Comparing Gecode with SICStus: (1) Gecode is faster than SICStus for solving the instances of the presented problem. Also, the obtained slow-downs reveal that there is a linear relation between the size of the
instances and the slow-down obtained. Whereas this does not hold for nd = 7 (where the negligible 0.13 seconds
diﬀerence leads to a 5.33 slow-down), it clearly does for nd = 15 and nd = 21 (where the elapsed time of SICStus
and Gecode turn to be of seconds and minutes, leading to slow-downs of 2.19 and 3.15, resp.) (2) As the size of
the instances linearly scale, the percentage of time in solving their labelings scales exponentially until reaching
almost the 100% of the solving time. Thus, it is straightforward to see that the obtained slow-down obtained for
SICStus w.r.t. Gecode (column 4) directly comes from the slow-down obtained for solving their labelings (column
6). (3) The number of absences is ﬁxed for the three instances. Thus, as the size of the instances scale, so it does
the number of variables and constraints involved in the labeling. (4) By considering (1), (2) and (3), we observe
that there is a linear relation between the size of a labeling and the slow-down obtained.
Comparing T OY(F Dg) with SICStus: (5) T OY(F Dg) is slower than SICStus for solving the nd = 7
instance, but faster for solving the nd = 15 and nd = 21 ones. This could be expected after the conclusions
obtained in (1) and (2). On the one hand, this reveals that additional surcharges arise in T OY(F Dg), coming
from: (6) lazy narrowing and (7) interfacing the external solver of Gecode. On the other hand, most of the eﬀort
for solving nd = 15 and almost all the eﬀort for solving nd = 21 rely on solving their labelings. As T OY(F Dg) is
using Gecode, and Gecode is faster than SICStus for solving the labelings, it makes sense that T OY(F Dg) would
be faster than SICStus. Amdahl’s law [22] establishes that the improvement in the performance of a system due
to the alteration of one of its components is limited by the fraction of time that component is used. The obtained
results encourage the idea of interfacing external state-of-the-art solvers into T OY(F D) (or into other CLP(F D)
or CFLP(F D) systems), as it is seen that the interfaced solver can improve the system performance even on small
problem instances (as the nd = 15 proposed, which is solved in just one second.)

538

Ignacio Castiñeiras and Fernando Sáenz-Pérez / Procedia Computer Science 18 (2013) 531 – 540

System
SICStus-21
T OY(F Ds)-21
SICS/T OY-21

Time
76.79
132.83
0.58

Cons.
230
230
1.00

Prun.
77,611,102
77,611,102
1.00

Back.
1,418,269
1,418,269
1.00

Entail.
63,033,153
63,033,153
1.00

Resump.
122,367,180
122,367,180
1.00

Table 2. Results of fd statistics applied to the hardest labeling

Comparing T OY(F Dg) with T OY(F Ds): The results of Table 1 give us some insights for distinguishing
between the surcharges of T OY(F Dg) coming from (6) and (7). Let us focus in the instance nd = 15. (8) Whereas
the labeling percentage time of T OY(F Ds) is 91.75% (and 98.04% in SICStus), for T OY(F Dg) is 66.87% (and
98.57% in Gecode). (9) Thus, the SICStus computation only leads a 1.96% of its solving time for SLD resolution
and the incremental propagation of its posted constraint set, in contrast to the 8.25% (an amount of 0.25 seconds)
that T OY(F Ds) spends in lazy narrowing and incremental propagation. In T OY(F Dg), 0.25 seconds would
represent a 23.81% of its elapsed time. It is for sure that the time that T OY(F Ds) and T OY(F Dg) spend in
lazy narrowing is exactly the same, as both systems have the same implementation (just diﬀering on their F D
solver interface) and are running the same T OY(F D) program. (10) By considering (8) and (9) we conclude that
the surcharge arisen in T OY(F Ds) (resp. T OY(F Dg)) due to lazy narrowing is smaller than the 8.25% of its
solving time (23.81% for T OY(F Dg), resp.) (11) The Gecode computation only leads a 1.43% of its solving
time for performing the incremental propagation of the constraints that are posted (one by one) to the store. In
contrast, T OY(F Dg) spends the 33.33% of its solving time in lazy narrowing, managing the communication
with the external Gecode solver and requesting the incremental propagation of the constraint set.
By considering (10) and (11) we conclude that T OY(F Dg) spends a minimum of 33.33 - (23.81 + 1.43)
= 8.09% on managing the communication with its external Gecode solver. Coming back to the comparison of
T OY(F Dg) and SICStus, this 8.09% represents a surcharge of 0.085 seconds for T OY(F Dg) w.r.t. SICStus. But, as T OY(F Dg) spends 1.01 seconds on the labelings and SICStus 2.17 seconds, the performance of
T OY(F Dg) is still better than the one of SICStus.
Comparing T OY(F D) with Gecode and SICStus: (12) All the systems solve the instance nd = 21 in the
interval of 1-6 minutes. However, on each case the solving of its labelings represent more than the 99% of the
solving time, and thus the time the system spent in the rest of the tasks is negligible for the system performance.
In this setting, one would expect T OY(F Ds) and T OY(F Dg) to match the solving times reached by SICStus
and Gecode, resp. They are using the same formulation of the problem, the same algorithm for solving it, and
the same constraint solver library. They are labeling the same variable set by using the same search strategy. The
results reveal that, whereas T OY(F Dg) and Gecode conﬁrm the expected results, T OY(F Ds) and SICStus does
not. Thus, we discuss the reasons of such these diﬀerent behaviors separately.
Comparing T OY(F Ds) with SICStus: (13) The reported results reveal that T OY(F Ds) is slower than
SICStus for solving nd = 21, with a slow-down of 1.69. The predicate fd statistics provides the current
state of clpfd: Number of constraints posted, backtrackings, prunings, entailments and resumptions. As we are
dealing with an optimization problem, this number is the result after exploring the whole search tree.
Table 2 presents the results from inspecting the solver when solving one of the labelings for one of the feasible
team conﬁgurations of nd = 21. Surprisingly, we can see that the results obtained are exactly the same for SICStus
and T OY(F Ds), revealing they are traversing exactly the same search tree, exploring the same nodes, pruning
exactly the same and backtracking the same number of times. Moreover, as the labeling is placed at the end of the
stage tt solve, we have carefully studied the statistics obtained when incrementally posting the constraints of
the problem, and they are always the same for SICStus and T OY(F Ds).
Another way of accessing to the internal state of clpfd is by using the predicate call residue, which prints
the set of variables (with their current domain) and the set of indexicals (propagators) posted to the solver. We
have called call residue in the SICStus and T OY(F Ds) models just before triggering the labeling primitive,
obtaining that the internal state of the store is exactly the same in both SICStus and T OY(F Ds): Same number of
variables with same domain (besides the internal identiﬁer of the variables, which is higher in T OY(F Ds) than
in SICStus) and same number of constraints (with exactly the same structure for all the indexicals).
To check if the diﬀerent performance is due to memory problems, we have integrated the SICStus model

Ignacio Castiñeiras and Fernando Sáenz-Pérez / Procedia Computer Science 18 (2013) 531 – 540

into T OY(F Ds), making it possible to trigger its execution within a T OY(F Ds) session (via the execution of
a T OY(F Ds) primitive). Interestingly, in this new context, the elapsed time the SICStus model spends on its
labeling primitive matches the one obtained by the T OY(F Ds) model, revealing that the load of the T OY(F D)
libraries on top of SICStus (to launch a T OY(F Ds) session) leaves a smaller amount of free memory to further
tackling the labeling execution. Unfortunately, requesting a garbage collection before triggering the labeling primitive give us the same performance results as before. So, in conclusion, even using the same model formulations,
for almost any model requesting a non negligible time for performing its labelings there would be an inherent
penalization of the T OY(F Ds) performance w.r.t. the one obtained by SICStus.
Comparing T OY(F Dg) with Gecode: (14) The reported results reveal that T OY(F Dg) is slower than
Gecode for solving nd = 7 and nd = 15, but for nd = 21 it clearly matches the elapsed time reached by Gecode.
Also, by focusing just on the time T OY(F Dg) and Gecode spend on performing the labelings of nd = 15, it
is seen again that T OY(F Dg) clearly matches the solving time reached by Gecode. This reveals that, for each
instance requesting Gecode a non negligible time for performing its labelings (as nd = 7 does), T OY(F Dg)
would spend in performing their own labelings exactly the same time as Gecode does. (15) By referring back to
(2), the behavior presented in (14) allows T OY(F Dg) to match the performance obtained by Gecode for those
instances where the percentage of time in solving their labelings reaches almost the 100% of the solving time.
Table 3 presents the results from inspecting Gecode and T OY(F Dg) when solving the same labeling of
Table 2. The third, fourth and ﬁfth columns represent the explored nodes, backtracks and propagators triggered
during the search. Besides that, as search in Gecode is based on hybrid recomputation techniques (see [23] for
a comparison with trailing), a copy method is required for cloning Spaces during the search, and the eﬃciency
of this method aﬀects the eﬃciency of the search itself. The sixth and seventh columns of Table 3 represent the
number of calls to the copy method and the total amount of time spent on running it during the labeling.
The results of Table 3 reveal that T OY(F Dg) is reproducing exactly the same search as the original Gecode
model: Traversing exactly the same search tree, exploring the same nodes, pruning exactly the same (with a slight
diﬀerence in the number of propagators triggered, coming from the initial higher domain that T OY(F Dg) assigns
to any new variable created) and backtracking the same number of times. By setting the Gecode clone parameters
c d (commit distance) and a d (adaptative distance) to their default values, both T OY(F Dg) and Gecode are
requesting the same calls to the copy method, and, again due to the use of the same variable and constraint set,
they spend the same time for copying the variable set each time the copy method is executed. Finally, coming
back to the diﬀerent performance obtained by Gecode and SICStus, a comparison of Table 2 and Table 3 allows
us to claim that they are traversing exactly the same search tree, as both Gecode and SICStus (and thus also
T OY(F Dg) and T OY(F Ds)) are obtaining exactly the same number of backtrackings during the search.
5. Conclusions and Future Work
In this paper we have presented a case study based on a real-life ETP coming from a technical department of
the Spanish public television. The paper have presented an empirical comparison of the modeling and solution
of the ETP among the diﬀerent paradigms underlying constraint programming techniques. Due to the complex
characteristics of the ETP (non-monolithic and with constraint programming independent components) we have
formulated a single algorithm, and we have decided to program it using the state-of-the-art CP(F D), CLP(F D)
and CFLP(F D) systems Gecode, SICStus Prolog and T OY(F D) (last one with two diﬀerent versions relying on
the Gecode and SICStus solvers, resp.)
We have pointed out via code examples that the high abstraction level of SICStus and T OY(F D) eases
the modeling of the problem, in contrast to Gecode, which has to deal with the diﬀerent elements taking place
System
Gecode-21
T OY(F Dg)-21
Gecode/T OY(F Dg)-21

Time
24.12
24.36
1.01

Nodes.
2,836,539
2,836,539
1.00

Back.
1,418,269
1,418,269
1.00

Table 3. Results from inspecting the search for the hardest labeling

Prop.
88,455,074
89,411,906
0.99

Copy calls.
1,418,270
1,418,270
1.00

Copy time.
1.61
1.62
1.01

539

540

Ignacio Castiñeiras and Fernando Sáenz-Pérez / Procedia Computer Science 18 (2013) 531 – 540

in constraint solving. By using the H solver, both SICStus and T OY(F D) ﬁt better the algorithm proposed,
dealing to clearer structured models. Finally, the functional component of T OY(F D) enhances formulations
w.r.t. SICStus, allowing to develop a more elegant, neat and less error-prone model.
The solving comparison points out that both Gecode and T OY(F Dg) are faster than SICStus for solving
the ETP problem, revealing that the better performance of its solver overcomes the arisen surcharges from the
interface. Also, for all the systems, as the size of the instances linearly scale, the percentage of time in solving
their labelings reaches almost the 100% of the solving time. In this context, one would expect the performance of
T OY(F Ds) and T OY(F Dg) to match the obtained by SICStus and Gecode, resp. On the one hand, T OY(F Ds)
and SICStus do not conﬁrm the expected results, and there is a big slow-down in the performance of T OY(F Ds)
w.r.t. SICStus, which directly comes from the smaller amount of free memory that T OY(F Ds) has (to tackle
the labelings) after loading the T OY(F D) libraries on top of SICStus (to launch a T OY(F Ds) session.) So,
in conclusion, even using the same model formulations, for almost any model requesting a non negligible time
for performing its labelings there would be an inherent penalization of the T OY(F Ds) performance w.r.t. the
one obtained by SICStus. On the other hand, T OY(F Dg) and Gecode conﬁrm the expected results, and for
each instance requesting Gecode a non negligible time for performing their labelings, T OY(F Dg) would spent
in performing their own labelings exactly the same time as Gecode does, as it reproduces exactly the same search
as the original Gecode model (in terms of nodes explored, backtrackings, and cost of running the copy method
inherent to the Gecode search.) Although the T OY(F D) performance is penalized by its inherent lazy narrowing
and its communication with its interfaced solver, the results obtained reveal that when the search is about one
minute, the elapsed time of these tasks becomes nearly negligible, and the elapsed time of T OY(F Dg) matches
the obtained by Gecode.
References
[1] M. Pinedo, Planning and Scheduling in Manufacturing and Services, Springer Series in Operations Research, 2004.
[2] F. Aloul, B. Al-rawi, A. Al-farra, B. Al-roh, Solving Employee Timetabling Problems Using Boolean Satisﬁability, in: Innovations’06,
1–5, IEEE, 2006.
[3] A. Schaerf, A. Meisels, Solving Employee Timetabling Problems by Generalized Local Search, in: In Proc. Italian AI Ass, 493–502,
Springer, 1999.
ˇ ucha, Z. Hanz´alek, An Evolutionary Algorithm in a Multistage Approach for an Employee Rostering Problem with a
[4] Z. B¨aumelt, P. S˚
High Diversity of Shifts, in: PATAT’10, 97–112, Springer, 2010.
[5] C. Artigues, M. Gendreau, L.-M. Rousseau, A. Vergnaud, Solving an Integrated Employee Timetabling and Job-Shop Scheduling Problem via Hybrid Branch-and-Bound, in: Computers & Operational Research 36, 8, 2330–2340, Elsevier, 2009.
[6] H. Rudov, K. Murray, University Course Timetabling with Soft Constraints, in: PATAT’02, 310–328, LNCS 2740. Springer, 2003.
[7] N. Brauner, R. Echahed, G. Finke, H. Gregor, F. Prost, Specializing narrowing for timetable generation: A case study., in: PADL, 2005,
pp. 22–36.
[8] R. Gonz´alez-del-Campo and F. S´aenz-P´erez, Programmed Search in a Timetabling Problem over Finite Domains, in: ENTCS, 177,
253–267, Elsevier, 2007.
[9] I. Casti˜neiras, F. S´aenz-P´erez, A CFLP Approach for Modeling and Solving a Real Life Employee Timetabling Problem, in:
COPLAS’11, 63–71, 2011.
[10] K. Marriott, P. J. Stuckey, Programming with Constraints, MIT Press, 1998.
[11] J. Jaﬀar, M. Maher, Constraint Logic Programming: A Survey, in: The Journal of Logic Programming, 19–20. 503–581, Elsevier, 1994.
[12] M. Hanus, Multi-Paradigm Declarative Languages, in: ICLP’07, 45–75, LNCS 4670. Springer, 2007.
[13] Gecode 3.7.3: Generic Constraint Development Environment, http://www.gecode.org/.
[14] I. Casti˜neiras, F. S´aenz-P´erez, Improving the Performance of FD Constraint Solving in a CFLP System, in: FLOPS’12, 88–103, LNCS
7294. Springer, 2012.
[15] MiniZinc 1.6, http://www.g12.csse.unimelb.edu.au/minizinc/.
[16] P. Wuille, T. Schrijvers, Parameterized models for on-line and oﬀ-line use, in: WFLP, 2010, pp. 101–118.
[17] I. Casti˜neiras, F. S´aenz-P´erez, Real-Life Employee Timetabling Problem: Instance Example, Tech. rep., http://gpd.sip.ucm.es/
ncasti/TR_02_13.pdf (2013).
[18] M. Wallace, J. Schimpf, K. Shen, W. Harvey, On Benchmarking Constraint Logic Programming Platforms, in: Constraints, 9, 1, 5–34,
Centre for Research on Transportation, 2004.
[19] C. Holzbaur, Speciﬁcation of Constraint Based Inference Mechanism through Extended Uniﬁcation (1990).
[20] S. Peyton-Jones, Haskell 98 Language and Libraries: the Revised Report, http://www.haskell.org/onlinereport/ (2002).
[21] Mats Carlsson et. al, SICStus Prolog User’s Manual, http://www.sics.se/ (2012).
[22] G. M. Amdahl, Validity of the Single Processor Approach to Achieving Large Scale Computing Capabilities, in: AFIPS’67, 483–485,
ACM, 1967.
[23] R. M. Reischuk, C. Schulte, P. J. Stuckey, G. Tack, Maintaining state in propagation solvers, in: CP’09, 692–706, LNCS 5732, 2009.

