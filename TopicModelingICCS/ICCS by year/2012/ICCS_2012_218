Available online at www.sciencedirect.com

Procedia Computer Science 9 (2012) 966 – 975

International Conference on Computational Science, ICCS 2012

High Performance Parallelization of COMPSYN on a Cluster of
Multicore Processors with GPUs
Ferdinando Alessia , Annalisa Massinia,∗, Roberto Basilib
a Department
b Istituto

of Computer Science, Sapienza University of Rome, Italy
Nazionale di Geoﬁsica e Vulcanologia, Rome, Italy

Abstract
In this work we propose a high performance parallelization of the software package COMPSYN, devoted to
the production of syntethic seismograms, on a cluster of multicore processors with multiple GPUs. To design and
implement the proposed high performance version, we started from a na¨ıve parallel version of COMPSYN. The
na¨ıve version consists in a simple parallelization on both device side, obtained by exploiting CUDA, and host side,
obtained by exploiting the MPI paradigm and OpenMP API. The proposed high performance version implements
several practical techniques of CUDA programming and deeply exploits the GPU architecture, thus achieving a much
better performance with respect to the na¨ıve version. We compare the performance of the proposed high performance
version and that of the na¨ıve one with the performance of the version running on the cluster of multicore processors
without invoking the GPUs. We obtain for the high performance GPU version a speedup of 25x over the version
running on the cluster of multicore processors without GPUs against the 10x of the na¨ıve version. Regarding the
sequential version, we estimate about 380x the speedup of the high performance GPU version against the about 140x
of the na¨ıve version.
Keywords: GPU, CUDA, synthetic seismogram

1. Introduction
Graphics Processing Units (GPUs) have emerged as general purpose computing architectures thanks to their massive parallelism, ﬂoating point capability, low cost, and also thanks to their presence in commodity computer systems.
The GPU’s rapid increase in both programmability and capability has inspired researchers to map computationally
demanding problems to the GPU. The simulation of wave propagation represents a typical context demanding massive computation. The study of earthquake wave propagation allows to formulate models describing the Earth surface
motion and to foresee the consequences of earthquakes. To verify the accuracy of a model, real seismograms are
compared with synthetic ones obtained by assuming several observers are deployed over an area of interest.
The COMPSYN package [1] is a set of applications designed for producing synthetic seismograms. Unfortunately,
the COMPSYN execution is a dramatically time consuming activity. The only way to reduce the time necessary to
simulate a study scenario is to simplify the scenario itself, obtaining results often too far from the desired ones.
∗ Corresponding

author
Email address: massini@di.uniroma1.it (Annalisa Massini)

1877-0509 © 2012 Published by Elsevier Ltd. Open access under CC BY-NC-ND license.
doi:10.1016/j.procs.2012.04.103

Ferdinando Alessi et al. / Procedia Computer Science 9 (2012) 966 – 975

967

A na¨ıve parallel version of COMPSYN [2] is considered in this work, as a starting point to design a high performance version which deeply exploits CUDA and the GPU architecture. The considered na¨ıve parallel version is
built on the highly parallel structure of COMPSYN, and exploits the computing power of GPUs and the presence of
the several multicore processors in the cluster. The na¨ıve parallel version of COMPSYN achieves a speedup of about
140x with respect to the original sequential version. Despite the obtained speedup, the na¨ıve version is quite basic.
In this work we propose a high performance version of COMPSYN designed by using in a sound way the GPU
architecture and CUDA, exhibiting a much better performance. The valuable improvement in the performance is
obtained by using several of the practical techniques of the CUDA programming, namely the register spilling, the
coalescing in the memory accessess, the use of the page-locked (pinned) memory and the texture memory.
To the end of evaluating the eﬃcacy of the techniques introduced in the proposed new version, and the consequent
improvement of the performance, we compare the new version and the na¨ıve one by using a real case study. In
particular, we obtain for the high performance GPU version a speedup of 25x over the version running on the cluster
of multicore processors without GPUs against the 10x of the na¨ıve version. Regarding the sequential version, we can
estimate about 380x the speedup of the high performance GPU version against the about 140x of the na¨ıve version,
computed in both cases by using the execution time values of a single node system.
The advantages of the new high performance parallel version of COMPSYN are the possibility of studying complex scenarios, that is scenarios consisting of a very high number of observers, thus overcoming the computational
necessity of reducing the points of observation, and the possibility of producing synthetic seismograms in very short
time, providing geophysicists with a quick version of an already tested tool, which now allows them to verify their
hypotheses in quasi-real time.
2. Related work
General Purpose computing on GPU (GPGPU) represents a valid approach for many problems requiring an intensive computing activity. GPGPU is a valid alternative for High Performance computing and three of the top ﬁve
positions in the Top 500 Computers are GPU based architectures [3].
The GPU architecture is naturally devoted to intrinsically parallel problems. Among simulation problems, the
seismic and geophysical contexts represent a challenging ﬁeld of applications, that can beneﬁt from parallelization on
GPUs. Numerical seismic modeling aims at simulating seismic wave propagation in a geological medium in order
to generate synthetic seismograms, that are the seismograms that a set of sensors would record, given an assumed
structure of the subsurface. Among the numerous approaches to seismic modeling, direct methods based on approximating the geological model by a numerical mesh are of particular interest. In fact, this approch can give very accurate
results. A drawback of this approach is its high computational demand, even in the case of eﬃcient implementations.
Finite Diﬀerence techniques in the Time Domain, FDTD, are widely used to solve the seismic wave equation, as
well as the Navier-Stokes’ equation and the Maxwell’s equation. The large use of FD based methods is principally
due to their simplicity. Regarding the FD method for seismic reverse time migration in the case of an acoustic
medium with constant density, Abdelkhalek [4] and Micikevicius [5] have proposed optimized implementations. In
[6], Abdelkhalek et al. extend [4] to the case of heterogeneous density and design a fast parallel simulator that solves
the acoustic wave equation on a GPU cluster. They consider the ﬁnite diﬀerence approach on regular meshes, in both
2D and 3D cases and solve the acoustic wave equation in both density domains, constant and variable. They obtain a
speedup of 10x for Reverse Time Migration and up to 30x for the modeling application over a sequential code running
on general purpose CPU. In [7], Mic´ea et al. improve the results of Micikevicius, [5], by applying his methodology
to a full elastic wave equation and to a real 3D model and adding Convolution Perfectly Matched Layer (CPML)
absorbing layers. The improvement is due to a faster access to the CPML arrays on the GPU and to the use of MPI to
obtain an eﬃcient handling in the use of several GPUs.
Other widely used approaches are the Finite-Element, FE, method and the Spectral-Element, SE, method. Several
solutions for GPU have been proposed for the FE method, see e.g. [8, 9]. In the case of the SE method, the implementation requires a very large mesh of elements to cover the Earth and the derived computations are very expensive
in terms of CPU time and memory occupation. In [10], Komatitsch et al. describe the results obtained by porting
the geophysics software package SPECFEM3D, based on the spectral-element method, onto graphic cards for the 3D
numeric simulation of the seismic wave propagation in the Earth. These authors use the mesh coloring technique to

968

Ferdinando Alessi et al. / Procedia Computer Science 9 (2012) 966 – 975

attenuate the problem of the dependencies among data generated by the ﬁnite-element method. The obtained speedup
is 25x in the best case. In [11], Komatitsch et al. extend the porting of SPECFEM3D to execute on GPU clusters.
They exploit MPI to manage data transfer, and obtain an almost full overlap of computation and communication, by
using non-blocking MPI in combination with a suﬃciently large amount of device memory. They show the average
elapsed time per time step of the SE method algorithm for simulations on 4 to 192 GPUs and demonstrate the weak
scalability on GPU clusters.
3. The COMPSYN package
COMPSYN is a software package developed by Spudich and Xu [1] for calculating ground motions caused by
ﬁnite sources in vertically varying media. COMPSYN produces synthetic seismograms for hypothetical earthquake
ruptures occuring on faults of ﬁnite spatial extent.
COMPSYN uses the numerical techniques of Spudich and Archuleta [12] to evaluate the representation theorem integrals on a fault surface and exploits the discrete-wavenumber ﬁnite-element method of Olson et al. [13] to calculate
Green’s functions for the medium.
In particular the k-th component of displacement at observation position y and time t is ([12]):
um (y, t) =

∞

dt
−∞

Σ

Γi j

δ
Gmi (y, t − t ; x, 0)dΣ
δx j

where x is a point on surface Σ, Γ is the stress glut characterizing the seismic source, and Gmi (y, t − t ; x, 0) is the m-th
component of displacement at position y and time t − t caused by an instantaneous force of unit impulse applied in i
direction at position x and time t = 0 (i.e. the usual point force Green’s function), where the summation convention
applies over repeated indices.
By using the reciprocity relation for Green’s functions, the deﬁnition of stress glut and of the associated traction
Tm and by Fourier transforming from the time domain to the frequency domain, we obtain ([12]):
um (y, ω) =

Σ

s(x, ω) • Tm (x, ω; y, 0)dΣ

COMPSYN consists of ﬁve applications: OLSON, XOLSON, TFAULT, SLIP, and SEESLO, that were designed for
operating in cascade, with each subsequent program using the output of the previous, in the order they are listed above.
COMPSYN assumes that the Earth model is deﬁned in a 3-dimensional Cartesian space and the Earth’s structure is a
function of 1 dimension (z, depth) and has a free surface at z = 0.
The application OLSON calculates Green’s functions in the wavenumber and frequency domain for laterally homogeneous velocity structures, which consist of piecewise linear functions of depth with possible discontinuities [13].
OLSON takes in input a ﬁle describing the Earth’s structure as represented by a set of horizontal layers, i.e. a structure
that is laterally homogeneous and vertically heterogeneous. OLSON is computationally very time-consuming but it
has to be run only once for Earth structure.
XOLSON simply rearranges the results produced by the OLSON application. XOLSON is fairly fast and it has to
be run once for Earth structure.
TFAULT reads the user’s deﬁnition of a fault plane, the observers locations and the output ﬁles (.XOO ﬁles)
created by XOLSON. It then applies the Bessel transform to the values interpolated between the discrete expansion
coeﬃcients in the .XOO ﬁle. TFAULT is computationally time consuming.
SLIP reads a rupture model from the .SLD ﬁle and the TFAULT output ﬁles, and forms the dot product of the
slip and Green’s functions and integrates this function over the fault to produce the spectra of ground motions at the
observer locations.
SEESLO Fourier transforms the seismic spectra to the time domain, ﬁlters the seismograms according to userinput parameters, plots the seismograms, and writes the ﬁltered velocity and displacement time series to ASCII output
ﬁles.

Ferdinando Alessi et al. / Procedia Computer Science 9 (2012) 966 – 975

969

3.1. The TFAULT application
The application TFAULT has been chosen for the parallelization of COMPSYN since it is the most time consuming
module. TFAULT reads the frequency-wavenumber domain output from XOLSON in the .XOO ﬁle to calculate
frequency domain Green’s functions for traction on a user-deﬁned fault surface for a set of observer locations. The
fault is idealized as a plane, and the intersection of this plane with the Earth’s surface determines the x axis. The
(u, v) coordinate system lies in the fault plane, where u is the coordinate along strike (parallel to the x axis), and v
is the downdip coordinate. The uv origin coincides with the xyz origin of coordinates. The tractions are calculated
on a grid of points on the fault plane, where the sample point spacing in u is du and the spacing in v is dv. To
calculate the traction at a desired fault point (u, v), TFAULT determines the corresponding values of epicentral radius
r and depth z. It linearly interpolates between the discrete expansion coeﬃcients in the .XOO ﬁle. Finally, TFAULT
Bessel transforms the XOLSON output from the wavenumber-frequency domain to the space-frequency domain, and
it evaluates these Green’s functions on the user-deﬁned grid of points on the fault plane.
The computation performed in TFAULT requires ﬁve nested loops, that are, from the outermost to the innermost, the
observer loop, Loop 1, the frequency loop, Loop 2, the two loop for the grid points, dv loop, Loop 3 and du loop,
Loop 4, and the innermost loop on wavenumbers, Loop 5.
4. The na¨ıve parallelization
This Section describes the na¨ıve parallel version of COMPSYN [2]. The parallelization involves its most timeconsuming module, TFAULT (Section 3). COMPSYN was originally written in the FORTRAN programming language; we translated TFAULT into C, considering that CUDA C oﬀers a better support with respect to CUDA Fortran.
The loop based structure of TFAULT has determined which part of the application could be parallelized on the host
side and which on the GPU. For the parallelization host side, MPI is used to allow the execution of COMPSYN on
a computer cluster, and OpenMP API is used to maximize the application performance on multicore processors. The
parallelization device side is obtained by exploiting CUDA to develop the code for GPUs.
4.1. Determining the kernel
The TFAULT module is inherently parallel, consisting of ﬁve nested loops. Converting a loop into a CUDA kernel
is straightforward unless the loop has dependencies among iterations. To choose which loop to transfer to the GPU it
is important to evaluate the complexity of the operations performed inside each loop. The loop choosen for becoming
the kernel is Loop 4, that is the loop over the sample points on lines of constant depth on the fault surface. Even though
Loop 4 has a higher number of iterations than the other loops, this number is not great enough to eﬀectively exploit
the GPU capabilities. For this reason, more Loops 4, related to consecutive iterations of Loop 3, has been grouped
in the same GPU grid. As a consequence, the algorithm is reorganized by splitting Loop 3 into two phases: the ﬁrst
phase gathers the information needed by each iteration for its computing tasks on the GPU, whereas the second phase
consists of a sequence of grid launches. Such a sequence is composed by the number of launches needed for executing
all iterations in Loop 3 and is determined at runtime by the number of iterations of Loop 3. In this way, a number of
grid launches much smaller than the number of iterations of Loop 3 is obtained, and the number of executed CUDA
threads is increased of an order of magnitude, from hundreds to thousands threads.
4.2. Thread block conﬁguration
The choice of the number and size of blocks is of primary importance for the execution conﬁguration. In the na¨ıve
parallel version, the block size was chosen in such a way that it divides the number of iterations of every loop in a grid.
According to the indications provided in [14], which suggests a block size between 64 and 256 for obtaining better
performances, and considered the permitted occupancy (ratio of active threads to the maximum number of threads
supported per multiprocessor) for the kernel, a good value for the block size is any of the possible warp size multiple
of 64, 128 or 192, for each grid (256 provides a lower occupancy). Among these three options, the best choice is
dynamically determined at run-time as the largest block size which produces the least number of CUDA threads, even
if unrequested but usable output is produced (void threads). As an example, given three loops in the same grid with
respectively 256, 384 and 512 iterations, the most convenient choice is a block size of 128 that produces no void
threads. A block size of 192 would instead produce 32 void threads from the last loop.

970

Ferdinando Alessi et al. / Procedia Computer Science 9 (2012) 966 – 975

4.3. Memory accesses
Memory accesses represent one of the principal limiting factors to performance. To obtain eﬃcient memory
transfers, the several types of memory supported by CUDA should be used with great care. For these reasons, the
minimization of host-to-device transfers is of primary importance. To reduce the impact of host-to-device transfers,
we batch several transfers by moving the contents of the *.XOO ﬁle and the data related to Bessel functions in a single
large transfer per execution. Similarly, also other per-grid-launch data are batched together into a single transfer.
For the *.XOO ﬁle, we choose global memory, in fact the coalescing in the accesses makes texture memory not
necessary, whereas the other memory spaces are not large enough. Concerning the device-to-device transfers, the use
of shared memory and cooperation among threads in the same block provide coalesced accesses to global memory.
The two (vertical and horizontal) arrays of weights needed to perform linear interpolation between values in
the look-up table of Bessel functions, and the two arrays of zeros of the same functions are transferred following a
diﬀerent strategy. These arrays are small in size and accessed in read-only mode at the same address by all threads of
a block. These features allow moving them in the constant memory and taking advantage of the fact that the constant
memory is cached. The last data-set to transfer is the output array. Since each grid has a diﬀerent number of threads
(proportional to the number of Loops 3 grouped) and produces a diﬀerent amount of output, the output array has a
diﬀerent size at each GPU execution. To eliminate the overhead of multiple re-allocations, a large enough array is
pre-allocated. It can be stored in the global memory because it is accessed in write-only mode and a fully coalesced
access can be designed.
4.4. Host side parallelization: multicore processors and clusters
A complete parallelization of COMPSYN involves the exploitation of multicore processors and clusters, that is
the parallelization on the host side.
In a multicore processor, the use of several cores corresponds to the generation of a set of ﬂows of execution
at CPU level. This leads to the creation of several CUDA grids at the same time. The execution of the CUDA
grids in a sequential manner would imply a competition for the GPU among the CPU threads, as well as other
drawbacks. To avoid the sequential execution of the CUDA grids, the available grids are merged in a single big grid
that can be processed only at once. Since an eﬃcient merge requires similarity among the grids, with respect to
the used parameters, Loop 1, the loop over the observers, is the most appropriate loop to choose for the multicore
parallelization. In fact, Loop 2 would impede this approach since it works with diﬀerent frequencies. The strategy
of merging the grids related to diﬀerent observers working with the same frequency value in a single grid, allows
increasing the number of CUDA threads proportionally to the observers treated in parallel by the CPU. Compared with
the one-grid-per-CPU-thread strategy, this approach allows the management of the GPU by a unique CPU thread, the
master thread, thus avoiding the overhead of a GPU context switch. This level of parallelization is implemented by
making use of the OpenMP standard [15, 16].
The parallelization of TFAULT on a cluster of multicore processor is based on the partitioning of the observers
among the cluster nodes, that are composed of a multicore CPU and a GPU. Since the use of a cluster instead of
a single multicore processor implies the use of an architecture with distributed memory rather than shared memory,
the use of the MPI paradigm [17, 16] for the message passing is preferable. We associate one MPI task to one node
(multicore processor-GPU). Due to the limited inter-process communications, the resulting overhead is not signiﬁcant.
5. High performance parallelization of TFAULT
In this section we describe the several practical techniques, whose addition characterizes the high performance
parallel version of the TFAULT module of COMPSYN and that signiﬁcantly improve the speedup with respect to the
Na¨ıve version [2]. In the following Subsections we will clearly highlight what are the new contributions of this work
with respect to the Na¨ıve version.
5.1. Accuracy of the produced seismograms
The ﬁrst step in analyzing and improving the Na¨ıve version of COMPSYN is the veriﬁcation of the accuracy of
the produced seismograms.

Ferdinando Alessi et al. / Procedia Computer Science 9 (2012) 966 – 975

971

The single precision ﬂoating point representation used in the original version of the TFAULT has been adopted also
for the parallelized code. We didn’t use double precision because it generates a lower throughput. The comparison
between the results produced by the original version and the Na¨ıve version revealed that the parallel version produced
slightly diﬀerent values. This diﬀerence was due to the deviations of CUDA operations from the standard IEEE 754
in Tesla. In fact division and square root are implemented in a non-standard-compliant way, and addition and multiply
are often combined in a single multiply-add operation. The TFAULT module executes many of these operations, often
chained in cascade, thus providing results deviating from those obtained by a CPU that uses the IEEE 754 standard.
In this work we exploit the software implementation of the non-standard operation fmad (multiply-add) and
fsqrt. Obviously, software operations are slower and could imply a greater request of registers by the kernel. Then
the substitution of the non-standard operation has been limited to some cases. Finally all the ﬂoating point constants
have been explicitly deﬁned as single precision constants. If this deﬁnition is omitted, such constants are automatically
deﬁned as double precision values, and conversion instructions would be necessary to use them for single precision
computations.
5.2. Analyzing and improving the memory handling
As already observed, the data accesses and data transfers, both host-device and device-device, are of primary
importance. The consequent limitation to performance can be overcome by wisely handling of the diﬀerent memory
spaces oﬀered by CUDA. As described for the Na¨ıve version, see Subsection 4.3, the most consistent transfer regards
the input parameters that are to be moved at each grid launch and are batched to proceed with only one transfer, as
well as for the transfer of output parameters.
In this work, for these last two data-sets, we introduce the use of the page-locked (or pinned) memory to attain the
highest bandwidth host-device. This kind of memory is a scarce resource and an excessive request could degrade the
performance. For this reason we introduce an implicit way of controlling the size of allocated pinned memory: the
user can decide how many streams, that are ordered sequences of operations to execute on device, to use. We design a
circular buﬀer of streams, each of which has an associated pool of pinned memory. In this way, the more streams the
user requests, the larger page-locked memory will be allocated. By associating streams to pinned memory it is also
possible to make the host-device transfers, that are usually blocking, in an asynchronous way, thus overlapping CPU
computations with transfers and with device computations too, signiﬁcantly improving the performances.
One of the most important topics in GPU programming is how to deal with the diﬀerent memory spaces oﬀered
by CUDA and by the speciﬁc GPU card utilized, that in our case is the Tesla architecture. As already observed in
Subsection 4.3, the content of the *.XOO ﬁle exceeds in size every memory space, except global and texture memory.
In the Na¨ıve version, the global memory was chosen to take advantage of coalesced accesses. In so doing, the fact
that each thread in a block accesses the same address with the same instruction allows introducing the collaboration
among threads by using the shared memory. In particular, since every thread in a block moves a diﬀerent element
of the *.XOO ﬁle from global to shared memory according to its id, it is easy to obtain a coalesced access. Since
the shared memory is a limited resource, it is preferable to transfer one section of the needed record at a time. To
realize this kind of transfer, only the threads belonging to the ﬁrst warp of a block are used, avoiding divergency in
the remaining warps, whose threads are not involved at all with prefetching.
In this work, we use the data prefetching technique to increase the number of instructions executed between the
data loading from global memory and the use of loaded data. The advantage of prefetching arises from the fact that
each section of the *.XOO ﬁle transferred in the shared memory is used in only one iteration of Loop 5, which can
not be executed before data are made available. To hide the wait, the technique of data prefetching allows requesting
data for the next iteration while available data are used by the current iteration.
In the Na¨ıve version, the two arrays of weights for the interpolation between values in the look-up table of Bessel
functions, and the two arrays of zeros of the same functions are moved to the constant memory to take advantage of
the fact that the constant memory is cached, exploiting the fact that these arrays are small in size and accessed just in
read-only mode at the same address by all threads in a block.
In this work, to better exploit the design of the constant cache, we use an array of structs obtained by merging the
above four arrays in one array of ﬂoat4: in this way we have a value for each array in the same cache entry. Along
with these arrays, we transfer to constant memory also the new parameters introduced by passing to the many-core
parallel version of the code. To allocate all the arrays and parameters in this memory space in a dynamic fashion, we
preallocate a buﬀer as large as permitted by the available hardware. Then, we handle this buﬀer by means of oﬀsets.

972

Ferdinando Alessi et al. / Procedia Computer Science 9 (2012) 966 – 975

In the Na¨ıve version, for the output array, an array suﬃciently large for the entire execution is pre-allocated, to
eliminate the overhead of multiple re-allocations. Since this array is accessed in write-only mode, it is stored in the
global memory.
In this work, we use the shared memory as an intermediate support, in a two-step procedure. Notice that the
all-in-once transfer of the output values to shared memory would require an amount of shared memory space which
would heavily aﬀect occupancy.
A key point of this high performance version of the TFAULT is how we handle the look-up tables for the Bessel
functions and the consequent gain in term of performance. In fact we choose to move Bessel look-up tables to the
texture memory. This memory space has its roots in the usual purpose of graphic cards, that is accelerating 2D
graphics. Thus texture memory, although is a read-only space, oﬀers diﬀerent assets over global memory, such as
optimization for 2D spatial locality and, more essential for this work, a cache. In the Na¨ıve version, the look-up tables
do not exhibit 2D locality, and are accessed by threads in a non-fully coalesced manner in global memory and always
in read-only mode. In this work we exploit these features and take advantage of the power of texture memory space.
With a minimal programming eﬀort, we move the Bessel datasets to texture memory and obtain all the beneﬁts of
cached accesses aﬀecting in a heavy manner the performance.
5.3. Improving the execution conﬁguration
Keeping the device as busy as possible is of primary importance. First of all we analyzed the occupancy reached
by the GPU code. The kernel is quite complex and it requires a huge number of registers. On the contrary, the request
of shared memory is not high, thus it does not represent a critical resource for our problem.
To limit the request of registers diﬀerent expedients can be introduced. A ﬁrst simple strategy to help the compiler
in reducing register pressure is to deﬁne variables with the minimum required scope. Moreover, variables shared
among kernel instances can be stored, as the name suggests, in the shared memory.
In this work we adopt the technique of spilling registers to shared memory to lower the request of registers. The
key aspect is that storing a block sized array of four bytes variables in shared memory for a register does not cause any
bank conﬂicts, if data are accessed by means of the thread id. Alternatively, it is also possible that the nvcc compiler
executes the registers spilling by itself using the maxrregcount option. Unfortunately, the use of the compiler for
this task has a drawback. In fact in this case the spilling involves the local memory, that is far slower than shared
memory (for architectures older than the Fermi).
Once a good resource request is guaranteed, a further problem to deal with is to organize threads in such a way
to produce well populated warps, since warps represent the smallest executable units on GPUs. The number of
CUDA threads depends on the number of iterations in Loop 3. This number represents the density of sampling in the
horizontal direction, and it is computed always as a value greater than a minimum chosen by the user and adjusted
according to frequency and depth.
5.4. Remarks on occupancy
The number of registers used by a kernel and shared memory requirements can have a signiﬁcant impact on the
number of resident warps, hence on the occupancy.
For complex kernels like that derived from TFAULT, it is hard to obtain a high occupancy. However with only 6
warps, hence 192 CUDA threads, and an occupancy of almost 19% on a Tesla T10, an MP can hide registers latency.
We considered alternative techniques providing diﬀerent latencies. In Table 1 the values of occupancy, obtained by
varying the block size, are shown.
The best occupancy is 38% and is obtained by using 34 registers. Increasing the occupancy to 50% requires to
limit the number of registers for CUDA thread to 32 (this is the limitation for devices with cc 1.2 or 1.3). We couldn’t
lower the number of registers to 32, but notice that an improvement of the occupancy (especially over 50%) does not
always imply an improvement of the performance.
6. Performance analysis
Our experimental setup is a cluster of four identical nodes composed respectively by two quad-core Intel Xeon
E5520 CPUs operating at 2.26 GHz connected by a PCI Express-2 bus to two Tesla T10 GPUs. Each T10 processor

973

Ferdinando Alessi et al. / Procedia Computer Science 9 (2012) 966 – 975

Block
size

Registers
per block

Shared memory
per block (bytes)

# active
blocks

Occupancy

32
64
128
192
224
256

1088
2176
4352
6528
7616
8704

768 + 256
1536 + 256
3072 + 256
4608 + 256
5376 + 256
6144 + 256

6
6
3
2
1
1

19%
38%
38%
38%
22%
25%

Table 1: Occupancy values for kernel on a device of cc 1.2 or 1.3, per block size. In the shared memory column the ﬁrst value indicates the number
of bytes needed for the register spilling, the second value is a ﬁxed quantity of bytes needed for the parameter sharing among threads in the same
block, such as the coeﬃcients in the *.XOO ﬁle.

has 240 cores, 4 GB memory and memory bandwidth of ∼102 GB/s. T10 processors are available in group of four as
Tesla S1070 GPU Computing System. Each node runs Linux kernel 2.6.27 whereas the network is Gigabit Ethernet.
To evaluate the performance of the parallelized version of COMPSYN, we ran the simulation related to a dataset
already used by seismologists in a real case. We considered the data related to the earthquake of Colﬁorito, that struck
the regions of Umbria and Marche, central Italy, in 1997 [18]. We performed the test considering 256 observers, for
each of which 287 diﬀerent frequencies are required. The grid associated with the fault plane consists of up to 120000
points. Even though the *.XOO ﬁle Colﬁorito, with his size of 1.4 GB, does not require even half of the T10 processor
memory, this test case results very challenging for the available hardware setup.
To evaluate the performance of the high performance versions of TFAULT proposed in this work, we consider the
following diﬀerent versions for the comparison:
TFaultMPI the version running on the multicore CPUs cluster;
TFaultCUDA the Na¨ıve version realized for the multicore CPUs cluster with GPU associated to each node;
TFaultCUDA-HP the ﬁrst high performance version, which includes the use of page-locked memory, and streams
to overlap transfers and computations;
TFaultCUDA-HPTexture the second high performance version, which extends previous versions making use of
texture memory as described in Subsection 5.2.
The introduction of the page-locked memory in the ﬁrst high performance version, TFaultCUDA-HP, provides the
improvement of the execution time shown in Figure 1(a). In particular we estimate about 5x the contribution to the
speedup over the original version due to the use of the page-locked memory.
TFaultMPI

1 node
2 nodes
3 nodes
4 nodes

execution time
61126 s
(16 h 59 m)
32084 s
(8 h 55 m)
20728 s
(5 h 45 m)
15532 s
(4 h 19 m)

TFaultCUDA
execution time
6428 s
(1 h 47 m)
3242 s
(54 m)
2024 s
(33.7 m)
1511 s
(25.2 m)

TFaultCUDA-HP

speedup
9.5x
9.9x
10.2x
10.3x

execution time
4157 s
(1 h 9 m)
2089 s
(34.8 m)
1492 s
(24.9 m)
985 s
(16.4 m)

speedup
14.7x
15.4x
13.9x
15.8x

TFaultCUDA-HPTexture
execution time
2389 s
(39.8 m)
1212 s
(20.2 m)
838 s
(14 m)
619 s
(10.3 m)

speedup
25.6x
26.5x
24.7x
25.1x

Table 2: Execution time and speedup for TFaultMPI and the three diﬀerent versions of TFaultCUDA, on Colﬁorito test case, using from 1 up to 4
computing nodes.

To the purpose of evaluating the performance of the CUDA versions over the cluster one, we measure the execution
time required by the four versions by using 1 up to 4 nodes of the cluster. The numerical results are shown in Table

974

Ferdinando Alessi et al. / Procedia Computer Science 9 (2012) 966 – 975

TFaultMPI

70000

12000

page-locked memory

10000

pageable memory

TFaultCUDA
60000
TFaultCUDA-HP

Time (s)

Time (s)

50000

8000
6000
4000

TFaultCUDA-HPTexture

40000
30000
20000

2000

10000

0
1

2

4

6

8
0

Number of GPUs
a)

1 node

2 nodes

b)

3 nodes

4 nodes

Figure 1: (a) Comparison of execution time with and without using page-locked memory. (b) Comparison of execution time for the four parallelized
versions: TFaultMPI and the three CUDA versions.

2 and the related diagram in Figure 1(b). The main measure used to evaluate the performance of a new proposal is
the speedup that the new version gains with respect to the original one, that is computed as the ratio between the
execution time of the original version and the time required by the new one. For the three TFaultCUDA versions,
we compute the speedup values with respect to TFaultMPI, namely the ratio between the TFaultMPI execution time
and the considered TFaultCUDA execution time, running on the same input data. Results are shown in Table 2 and
Figure 2(a). As one can notice from Table 2, the incremental improvements related to the three diﬀerent versions
TFaultCUDA vs TFaultMPI

40,00

450

TFaultCUDA-HP vs TFaultMPI

35,00

400

TFaultCUDA-HPTexture vs TFaultMPI

350

30,00

300
250

Speedup

Speedup

25,00
20,00
15,00
10,00

200
150

100
50
0

5,00

TFaultMPI

0,00
1 node

2 nodes

a)

3 nodes

4 nodes

TFaultCUDA

TFaultCUDA-HP

TFAULT parallel version
b)

TFaultCUDAHPTexture

Figure 2: (a) Speedup obtained by the three CUDA versions with respect to the TFaultMPI version. (b) Speedup obtained by TFaultMPI and the
three diﬀerent TFaultCUDA versions with respect to the original version of TFAULT.

of the TFaultCUDA demonstrate how memory management aﬀects CUDA applications performances. In fact, each
version signiﬁcantly gains in terms of performance upon the previous one. In particular, the complete version, using
the page-locked memory and the texture memory, achieves a speedup of 25x over the TFaultMPI.
In addition, a comparison between the original version of TFAULT and the four parallel versions has been performed by re-running the original code on a single node. Being the original version of TFAULT sequential, it is
executed on one CPU core of the single node. Due to the long time required to perform the simulation over the whole
set of 256 observers, we made the simulation for a smaller subset and derived the value for 256 observers. A rough
estimate of the speedup gives us a factor of about 380 for TFaultCUDA-HPTexture version against the about 140x of
the na¨ıve version, TFaultCUDA. The values of the speedup over the original version are shown in Figure 2(b).

Ferdinando Alessi et al. / Procedia Computer Science 9 (2012) 966 – 975

975

7. Conclusions and future work
We propose a high performance parallelization of the package COMPSYN, designed to run on a multicore processor cluster with several GPU. The new version is obtained starting from a na¨ıve parallel version of COMPSYN,
consisting in the parallelization of the most time-consuming module of COMPSYN, TFAULT, both device side, exploiting CUDA, and host side, obtained by exploiting the MPI paradigm and the OpenMP API. The proposed high
performance version implements several of the practical techniques of CUDA programming and deeply exploits the
GPU architecture. Namely, we implemented the register spilling, the coalesced access to the memory, the use of the
page-locked (pinned) memory and the texture memory. To evaluate the performance of the proposed high performance
version, and the beneﬁts derived from the use of the practical tecniques suitable in using the GPUs, we distinguish
diﬀerent implementations of TFAULT. The comparison is based on the simulations performed by utilizing as a reference, the values of a real case study. In particular, we obtain for TFaultCUDA-HPTexture a speedup of 25x over the
TFaultMPI, against the 10x of the na¨ıve version, TFaultCUDA. Regarding the sequential version, we estimate about
380x the speedup of TFaultCUDA-HPTexture against the about 140x of the na¨ıve version, obtained in both cases by
using a single node of the cluster. Thanks to the balancing of the workload obtained by distributing the computation
related to the diﬀerent observers on the available cluster nodes, the package is naturally scalable.
The advantages deriving from the high performance version proposed in this work, make the use of COMPSYN
eﬀective even in the most complex scenarios.
Acknowledgments Thanks goes to L. Badiali and F. Zanolin for setting up the GPU cluster, and to G. Zonno for
insights on Colﬁorito earthquake. This work was developed under the Collaboration Agreement between Dept. of
Computer Science, Sapienza University of Rome and Istituto Nazionale di Geoﬁsica e Vulcanologia, Rome, Italy,
2011. This work was partially supported by Project n. C26G074ABJ, 2007, Cluster of multicore processor for
advanced computation, Sapienza University of Rome.
References
[1] P. Spudich, L. Xu, Documentation of software package COMPSYN sxv3.11: programs for earthquake ground motion calculation using
complete 1-D Greens functions, International Handbook of Earthquake and Engineering Seismology, 2002.
[2] F. Alessi, A. Massini, R. Basili, Accelerating the production of synthetic seismograms by a multicore processor cluster with multiple GPUs,
in: PDP, 2012.
[3] The Top 500 Supercomputer Sites, http://www.top500.org/ (2011).
´
[4] R. Abdelkhalek, Evaluation
des acc´el´erateurs de calcul GPGPU pour la mod´elisation sismique, master thesis, ENSEIRB, Bordeaux, France
(2007).
[5] P. Micikevicius, 3D ﬁnite diﬀerence computation on GPUs using CUDA, in: Workshop on General Purpose Processing on Graphics Processing Units, ACM, 2009.
[6] R. Abdelkhalek, H. Calandra, O. Coulaud, J. Roman, G. Latu, Fast seismic modeling and Reverse Time Migration on a GPU cluster, in: High
Performance Computing & Simulation, IEEE, 2009.
[7] D. Mich´ea, D. Komatitsch, Accelerating a three-dimensional ﬁnite-diﬀerence wave propagation code using gpu graphics cards, Geophys. J.
Int. 182 (2010) 380–402.
[8] D. G¨oddeke, R. Strzodka, J. Mohd-Yusof, P. McCormick, S. H. M. Buijssen, M. Grajewski, S. Turek, Exploring weak scalability for FEM
calculations on a GPU–enhanced cluster, Parallel Computing 33 (10–11) (2007) 685–699.
[9] M. Geveler, D. Ribbrock, D. G¨oddeke, P. Zajac, S. Turek, Eﬃcient ﬁnite element geometric multigrid solvers for unstructured grids on GPUs,
in: PARENG, 2011.
[10] D. Komatitsch, D. Mich´ea, G. Erlebacher, Porting a high-order ﬁnite-element earthquake modeling application to NVIDIA graphics cards
using CUDA, J. Parallel Distrib. Comput. 69 (2009) 451–460.
[11] D. Komatitsch, D. G¨oddeke, G. Erlebacher, D. Mich´ea, Modeling the propagation of elastic waves using spectral elements on a cluster of 192
GPUs, Computer Science - Research and Development 25 (1–2) (2010) 75–82.
[12] P. Spudich, R. Archuleta, Techniques for earthquake ground-motion calculation with applications to source parameterization of ﬁnite faults,
Seismic Strong Motion Synthetics, B. A. Bolt, 1987, pp. 205–265.
[13] A. Olson, J. Orcutt, G. Frazier, The discrete wavenumber/ﬁnite element method for synthetic seismograms, Geophys. J. Int. 77 (1984) 421–
460.
[14] NVIDIA CUDA C Best practices guide, vers. 3.2 (2010).
[15] The OpenMP API speciﬁcation for parallel programming, http://openmp.org.
[16] L. Smith, Mixed Mode MPI/OpenMP Programming, Edinburgh Parallel Computing Centre, 2000.
[17] MPI: A Message-Passing Interface standard, http://www.mpi.org.
[18] CPTI Working Group, Catalogo parametrico dei terremoti italiani, version 2004 (CPTI04), http://emidius.mi.ingv.it/CPTI04/,
INGV, Bologna (2004).

