Available online at www.sciencedirect.com

Procedia Computer Science 9 (2012) 449 – 458

International Conference on Computational Science, ICCS 2012

Improving the automatic derivation of choreography-conforming
web services systems ✩
Pablo Rabanala , Ismael Rodrígueza , Jose A. Mateob , Gregorio Díazb,1
a Departamento

de Sistemas Informáticos y Computación, Universidad Complutense de Madrid (UCM)
C/ Prof. José García Santesmases, s/n. 28040. Madrid, España
prabanal@fdi.ucm.es, isrodrig@sip.ucm.es
b Departamento de Sistemas Informáticos, Universidad de Castilla-La Mancha (UCLM)
Avda. de España, s/n. 02071. Albacete, España
jmateo@dsi.uclm.es, gregorio@dsi.uclm.es

Abstract
We present DIEGO 2.0, a new version of our tool DIEGO. Given a WS-CDL choreography, it automatically extracts a set of WS-BPEL web services such that, if these services interact with each other, they necessarily produce
the behavior deﬁned in the choreography even if the natural projection does not work. This is achieved by introducing
some control messages which make services coordinate as expected. The main improvement with respect to the previous version of the tool is that the number of these messages has been dramatically reduced. We formally deﬁne the
new derivation, prove its correctness, and empirically compare the efﬁciency of new and former derivation algorithms.
We also introduce other improvements of the new tool version, such as the testing engine.
Keywords: Derivation, WS-BPEL orchestrations, WS-CDL choreographies, conformance, tools.

1. Introduction
The deﬁnition of a web service-oriented system involves two complementary views: Orchestration and choreography. The orchestration concerns the internal behavior of a web service in terms of invocations to other services. It is
supported, e.g., by WS-BPEL (Web Services Business Process Execution Language), which is considered the de-facto
standard language for describing the workﬂow of a web service. On the other hand, the choreography concerns the
observable interaction among web services. It can be deﬁned, e.g., by using WS-CDL (Web Services Choreography
Description Language). Thus, the collaborative behavior, described by the choreography, should be the result of the
interaction of the individual behaviors of each involved party, which are deﬁned via the orchestration.
In this paper, we present DIEGO 2.0, a new version of our tool for DerIving chorEoGraphy-cOnforming web
service systems. Given a choreography deﬁned in (a subset of) WS-CDL, DIEGO automatically extracts a set of
services deﬁned in WS-BPEL such that the interaction of these services necessarily leads to the behavior deﬁned by
✩ Research partially supported by the Spanish government with the projects TIN2009-14312-C02-02, and TIN2009-14312-C02-01, and the
JCCLM regional project PEII09-0232-7745.
1 Corresponding author

1877-0509 © 2012 Published by Elsevier Ltd. Open access under CC BY-NC-ND license.
doi:10.1016/j.procs.2012.04.048

450

Pablo Rabanal et al. / Procedia Computer Science 9 (2012) 449 – 458

the choreography. Although DIEGO transforms WS-CDL into WS-BPEL, it internally works with a modiﬁcation
of ﬁnite state machines (FSMs). First, DIEGO transforms the WS-CDL choreography into a variant of FSM where
involved services are explicitly identiﬁed. Next it extracts, from this FSM-based model, services deﬁned by means of
a different kind of FSMs variant where input buffers are used to support asynchronous communications. Finally, these
FSM extensions are transformed into WS-BPEL. The WS-CDL constructions included in our model are interaction,
sequence, and while, leaving as future work the inclusion of other constructions such as the parallel operator and
workunits.2

Figure 1: Example of a natural projection.
The main problem arisen in the derivation of services from a choreography is the fact that the natural projection
does not necessarily produce a set of services conforming to the choreography. In the natural projection (see Figure 1),
the structure of states and transitions of the choreography (Chor) is directly copied into derived services (X, Y, Z).
Therefore, if the choreography has a transition from state s1 to s2 where service X sends message a to service Y,
then the derived service X has a transition from s1 to s2 where it sends a to Y, the derived service Y has a transition
from s1 to s2 where it receives a from X, and all the rest of derived services (not involved in this choreography
step) have a null transition from s1 to s2 , i.e. they change their state doing nothing (Z in Figure 1). It is known
that this straightforward derivation scheme produces sets of derived services that could not behave as deﬁned by
the choreography. On the one hand, derived services could tackle non-determinism in an inconsistent way when
running together. In a choreography state where several transitions (choices) are available, each service could follow
a different path, thus leading to inconsistent subsequent states in each service. On the other hand, services which
are not involved in the current step could silently evolve to some subsequent state and send messages as required by
subsequent transitions before the services involved in the current step actually do, thus incorrectly overtaking them.
Moreover, since the communication medium may delay messages any arbitrarily long time, it may happen that a
message m is sent after message m, but m arrives to its destination service before m, yielding a race condition.
In previous works [5, 6, 13], theoretical FSM-based models for deﬁning orchestrations and choreographies are
presented. The choice of FSM variant models, rather than models based on e.g. process algebra or Petri nets, is based
on their wide use in other related ﬁelds from which some notions are borrowed, such as formal testing methods. In
particular, some conformance relations to decide whether a set of services necessarily produces the behavior deﬁned
by a choreography are presented, and derivation algorithms to automatically extract the former from the latter are
given. These algorithms tackle the problems mentioned before by adding some control messages which make services
coordinate as expected by the choreography. The correctness of these algorithms with respect to these conformance
relations is formally proved.
Unfortunately, the original version of DIEGO [12] has some important limitations. The most important one is
the big number of additional messages exchanged between services in order to make them correctly coordinate. In
each choreography step, coordinating messages are sent to all services in order to make them mimic the path of the
choreography being executed. However, this scheme can be modiﬁed in order to avoid sending messages to services
which are not involved in the current step. In particular, non-involved services can be informed later about what
choreography state they should be in, only when they are involved again in the step under execution. This change
complicates the deﬁnition of the derivation algorithms, but strongly improves the efﬁciency of derived services.
2 Thus, in our language model, the concurrency is the result of the parallel interaction between different services, but each service does not
contain parallel processes internally. Still, this model captures the conceptual difﬁculty of deriving services that correctly interact with each other,
which is our goal.

Pablo Rabanal et al. / Procedia Computer Science 9 (2012) 449 – 458

451

Besides, the new version allows users to systematically analyze any alternative derivation algorithm. After introducing the new algorithm, the tool automatically tests the system of derived services by randomly applying the
language operational semantics (i.e. it randomly chooses the execution path among all available execution paths)
and compares the observations with those permitted by the choreography under different conformance requirements:
Sending (that is, with respect to moments when messages are sent), processing (w.r.t. moments when messages are
processed), and synchronization (both). Moreover, in order to improve the observability of derived systems, they can
be executed either step by step or immediately upon termination (or upon some given point), and simulations are exported to text ﬁles. The main advantage of using DIEGO is that web service designers can rapidly obtain executable
prototypes from a choreography deﬁnition, which may help them to debug the system in early stages of the development process or even serve as executable skeletons for constructing the implementations from them. DIEGO 2.0 is
available at the site http://www.dsi.uclm.es/retics/diego/.
The rest of the paper is organized as follows. Below, we review some related works. In Section 3 we formally
deﬁne our centralized and decentralized derivation algorithms. In Section 4 we report experiments where we compare the performance of services derived by our enhanced algorithms with the performance of previous derivation
algorithms. We ﬁnish the paper with some conclusions and future work. All proofs can be found at the tool site.
2. Related Work
In this section we brieﬂy compare our proposal with some works related to ours. Most of papers tackling web
services transformations in the literature present translations based on some transformation language (e.g. XSLT).
One of the main proposals in this community is the work proposed by Mendling and Hafner [10]. In this work,
authors propose a transformation between some elements of WS-CDL into WS-BPEL. Furthermore, a prototype is
implemented as a proof of concept of the proposal. The main disadvantage of this work is that authors do not provide
any mechanism to verify either the correction of the generated stubs or when the generated services behave as intended
in the choreography. This lack is common in tools and prototypes providing similar transformations, typically due to
the fact that they are not formally deﬁned. An example of this is found in the proposal by Khadka et al [7], where
authors describe the transformation from WS-CDL into WS-BPEL by using the ATLAS transformation Language.
Next we consider other proposals based upon formally descriptions. Most of approaches in the literature study
the conditions that are necessary to make the natural projection work, i.e. to make naturally projected services necessarily work as deﬁned in the choreography. On the contrary, we consider that the previous problems can be ﬁxed
if appropriate control messages are added to make services correctly coordinate. Thus, we consider that all choreographies are realizable indeed. In [11], Zongyan et al. identify and face the problems appearing when deriving
an implementable projection from a choreography. Authors deﬁne the concept of restricted natural choreography,
which must fulﬁll two structural conditions, and show that this kind of choreography is easily implementable. A new
concept, the dominant role of a choice, is proposed for dealing with projection in non-restricted choreographies. At
each non-deterministic choice, this dominant role is the one that makes the decision. The main difference with our
proposal is that they consider synchronous communications, whereas we consider asynchronous communications in
addition to arbitrarily long medium delays. Moreover, they modify the choice operator to introduce the dominant role
and solve the non-determinism, though it is not a native option in choreography specitications. Salaün and Bultan [14]
formalize choreographies by means of asynchronous communication with process algebra. However, no solution for
non-deterministic choices is provided and no correctness proof is presented. In contrast, authors enhance the proposal
by introducing a tool offering the possibility to use bounded buffers and reason about them. Van der Aalst et al. [15]
present an approach for formalizing compliance and reﬁnement notions, which are applied to service systems speciﬁed using Open Workﬂow Nets (a type of Petri Nets) where the communication is asynchronous. Authors show how
the contract reﬁnement can be performed independently, and they check whether contracts do not contain cycles. A
similar approach is followed by Caires and Vieira [3]. They deﬁne a formal framework called conversation types and
present techniques to ensure the progress of systems involving several interleaved conversations/sessions. Bravetti
and Zavattaro [2] compare systems of orchestrations and choreographies by means of a testing relation. Systems are
represented by using a process algebraic notation, and operational semantics for this language are deﬁned as LTS. In
[9], Lucchi and Mazzara provide a formalization of conformance with π-calculus. By means of automata, Baldoni et
al. [1] deﬁne a conformance notion that checks whether the interoperability is guaranteed. Moreover, Decker et al. [4]
show how the Business Process Modeling Notation (BPMN) and BPEL can be used during the choreography design.

452

Pablo Rabanal et al. / Procedia Computer Science 9 (2012) 449 – 458

Table 1: Comparison between Lanese et al. work and our work.
Our work
Lanese et al.

synchr.
X

asynchr.

send. vs proc.

full vs partial

send + proc

X

disjoint
X

immediate vs delayed
delayed
immediate

Lanese et al. in [8] developed a very detailed and broad study to compare these kind of systems. Their objective
is bridging the gap between the WS-CDL and BPEL languages by formally deﬁning them and then ﬁnding out the
features systems should have to be equivalent if the natural projection is used. This work is based on the idea of well
formed conditions, which depend on the properties one wants to preserve in each case. Table 1 presents a comparison
of the relations proposed by this work and FSM-based conformance relations given in [13]. The ﬁrst four columns
compare relations in terms of different types of communication, i.e., sync- vs. async- semantics, when messages are
produced/sent or when they are processed by the addressee, and full behaviors against part of them. In the next two
columns, we show the presence of a relation considering simultaneously sending and processing behaviors/traces, and
the disjoint conformance relationship given in [8]. The last column of the table illustrates if messages are immediately
stored in input buffers or they can be delayed by the medium.
Let us note that most of the previous works are mainly theoretical, whereas our work focuses on applying our
formal model to the tool DIEGO in order to effectively transform WS-CDL speciﬁcations into WS-BPEL orchestrations. There are some tools that formally deﬁne either WS-CDL or WS-BPEL such as WS-Engineer3 , XFD-DEVS4 ,
WSMod, WSAT, WS-VERIFY, PI4SOA. However, they focus on the analysis of the models obtained from the formalization process, and they are not concerned about the kind of transformations tackled in our proposal.
3. Deriving Conforming Services
In this section we present our optimized centralized and decentralized derivation algorithms. Both algorithms are
deﬁned by using some auxiliary notions from previous works [5, 6, 13]. Due to the lack of space, we focus here on
formally presenting the new algorithms and informally sketching the rest of necessary notions.
In order to illustrate the application of the proposed notions to a system, we present a small case study that will
guide the presentation of some concepts and will serve as the basis for the deﬁnition of examples. This case study
is a typical purchase process that uses Internet as a business context for a transaction. There are three actors in this
example: a customer, a seller, and a supplier. The purchase works as follows: “A customer wants to buy a product
by using Internet. There are several sellers that offer different products in web-pages servers. The customer contacts
a seller in order to buy the desired product. The seller checks the stock and contacts a supplier. Finally, the supplier
delivers the product to the customer.” The behavior of each participant is deﬁned as follows:
• Customer: It contacts the seller to buy a product. After consulting the product list, it can either order a product
or do nothing. If the customer decides to buy a product, then it must send the seller the information about the
product and the payment method. After the payment is done, it waits to receive the product from a supplier.
• Seller: It receives the customer order and the payment method. The seller checks if there is enough stock to
deliver the order and sends an acceptance notiﬁcation to the customer. If there is stock to deliver the order, then
it contacts a supplier to deliver the product.
• Supplier: It gathers the order and the customer information in order to deliver the product to the customer.
Let us introduce the main notions of the formal framework.
FSM-based model for the choreography: The choreography model focuses on representing the interaction of
services as a whole. It is deﬁned as a tuple (S , M, ID, sin , T ) where S denotes the set of states, M is the set of
messages, ID is the set of service identiﬁers, sin ∈ S is the initial state, and T is the set of transitions. A transition
t ∈ T is a tuple (s, m, snd, adr, s ) where s, s ∈ S are the initial and ﬁnal states, respectively, m ∈ M is the message,
3 Available
4 Available

at: http://www.doc.ic.ac.uk/ltsa/eclipse/wsengineer/
at: http://duniptechnologies.com/research/xfddevs/

Pablo Rabanal et al. / Procedia Computer Science 9 (2012) 449 – 458

453

and snd, adr ∈ ID are the sender and the addressee of the message, respectively. A transition (s, m, snd, adr, s )
m/(snd→adr)
is also denoted by s −−−−−−−−−−−−−→ s . Each choreography transition denotes a message action where some service
sends a message to another one. The actual conﬁguration of a choreography consists just in the current state of
its FSM model. In Figure 2a, the choreography C of our Internet purchase process is shown, and it is deﬁned as
(S 2a , M2a , ID2a , s0 , T 2a ) where S 2a = {s0, s1, . . .}, M2a = {iProd, lProd, . . .}, ID2a = {WS 1, WS 2, WS 3}, s0 is the
initial state, and T 2a = {(s0, iProd, WS 1, WS 2, s1), (s1, lProd, WS 2, WS 1, s2), . . .}. In the example, WS 1 is the
customer, WS 2 represents the seller, and WS 3 the supplier.

(a) FSM of the choreography C for the online purchase process.

(b) Decentralized derived FSM of the supplier (WS3).

Figure 2: FSMs automatically generated with DIEGO.
FSM-based model for the orchestration: The behavior of a web service in terms of its interaction with other
web services is represented by a ﬁnite state machine (id, S , I, O, sin , T ) where id ∈ ID is the identiﬁer of the service and ID is the set of service identiﬁers, S is the set of states, I is the set of input messages, O is the set
of output messages, sin ∈ S is the initial state, and T is the set of transitions. Each transition t ∈ T is a tuple (s, i, snd, o, adr, s ) where s, s ∈ S are the initial and ﬁnal states respectively, i ∈ I is the message that must
be received to trigger the transition, snd ∈ ID is the required sender of i, o ∈ O is the output message which
is sent if the transition is taken, and adr ∈ ID is the addressee of o. A transition (s, i, snd, o, adr, s ) is also de(snd,i)/(adr,o)
noted by s −−−−−−−−−−−−−→ s . Each service is endowed with an input buffer to store messages received but not
yet processed, so this transition is triggered if there is a message i from snd in the service input buffer. The
actual conﬁguration of an orchestration consists of two elements: its current state and the contents of its input
buffer. Transitions can also be triggered without consuming any input (i.e. proactively) or without producing any
output. This is denoted in our formalism by using a null (−−, −−) input/output symbol, respectively. In Figure 2b, a web service deﬁnition for the supplier is shown, and it is deﬁned as (WS 3, S 2b , I2b , O2b , s0iampassive, T 2b )
where WS 3 is the name of the orchestration, S 2b = {s0iampassive, s7ichoose9, . . .}, I2b = {takemychoice8ats6,
PickOrder, . . .}, O2b = {youcanchooseats7, DeliverOrder, . . .}, s0iampassive is the initial state, and T 2b = {(s0iampassive, takemychoice8ats6, WS 2, null, null, s6takingchoice8 f romWS 2ats6), (s6takingchoice8 f romWS 2ats6, PickOrder, WS 2, youcanchooseats7, WS 3, s7iampassive), . . .}. In fact, this is the supplier service deﬁnition which is
automatically extracted from the choreography by our decentralized service derivation algorithm, presented later.
In both models, traces (i.e. sequences of events that can be produced by systems) are represented in a similar way,
i.e., each event is denoted by a message, a sender, and an addressee (snd, m, adr). However, in the orchestration model,
events may refer to either the moments when messages are sent or the moments when messages are processed by their
corresponding receivers (both moments differ because we consider an asynchronous environment). The operational
semantics, which deﬁnes how orchestrations and choreographies evolve step-by-step, is given in [5, 13]. In particular,
the semantics given in [13], assumed in this paper, allows each message to be delayed in the communication medium
for any arbitrarily long time. Based on the traces of choreographies and orchestrations, formal relations (conformance
relations) are deﬁned to determine whether a system of orchestrations necessarily produces the behavior required by
a choreography. Several relations are given. On the one hand, the conformance of the system of services may be
established in terms of sending actions (conf s ), processing actions (conf p ) or both (conf). On the other hand,
systems of services may be required to be able to perform all non-deterministic paths deﬁned in the choreography
(the superscript f is added to the relation symbol), or only at least one of them (without superscript). As a result,

454

Pablo Rabanal et al. / Procedia Computer Science 9 (2012) 449 – 458

the conformance relations conf s , conf p , conf, conf sf , conf pf , conf f , as well as their corresponding prime
counterparts (i.e. conf s , . . . , where control messages are ignored), are formally deﬁned in [5, 13].
As commented previously, the problems of the natural projection (inconsistent non-deterministic choices and race
conditions) cannot be solved unless we introduce some additional control messages to be in charge of coordinating
services as required by the choreography. In this way, systems conforming to the choreography (up to original
choreography messages, i.e. ignoring additional control messages) can be derived. Two optimized derivation methods,
centralized and decentralized, are now presented. First, an auxiliary notion is introduced.
m /(a →b ),...,m /(a →b )

1
1
Deﬁnition 3.1. Let C = (S , M, ID, s1 , T ) be a choreography. Let s −−−−1−−−−
−−−−
−−−−−n−−−−n−−−−n→ s be a shorthand for
m2 /(a2 →b2 )
mn /(an →bn )
m1 /(a1 →b1 )
∃ s1 , . . . , sn−1 : s −−−−−−−−−−−→ s1 ∈ T, s1 −−−−−−−−−−−→ s2 ∈ T, . . . , sn−1 −−−−−−−−−−−→ s ∈ T . For all state s ∈ S and
id ∈ ID, upToSnd(C, s, id) is deﬁned as

s

m /(a →b ),...,m /(a →b )

1
1
−−−−
−−−−−n−−−−n−−−−n→ s ∧ a1 , b1 , . . . , an , bn
((s −−−−1−−−−

m

/(id→b

)

n+1
n+1
id) ∨ s = s ) ∧ s −−−−
−−−−−−−−−
−−→ s ∈ T

representing the set of choreography states s we can reach from state s in such a way that the service id acts as
sender in s but does not participate in the intermediate transitions from s to s either as sender or as receiver. And
upToRcv(C, s, id) is deﬁned as
s

m /(a →b ),...,m /(a →b )

1
1
−−−−
−−−−−n−−−−n−−−−n→ s ∧ a1 , b1 , . . . , an , bn
((s −−−−1−−−−

m

/(a

→id)

n+1
id) ∨ s = s ) ∧ s −−−−
−−−−−n+1
−−−−−−→ s ∈ T

representing the set of choreography states s we can reach from state s in such a way that the service id acts as
receiver in s but does not participate in the intermediate transitions from s to s either as sender or as receiver.
Next we deﬁne our new derivation algorithms to extract service orchestrations from choreographies. First we
deﬁne the centralized derivation method. A centralized solution may look counter-intuitive to model web services,
but there are speciﬁc systems where a centralized solution is needed since some decisions depend on a unique service.
For example, multiplayer online games are played via a centralized game server, and centralized peer-to-peer systems
are based on a central server which is used for indexing functions and bootstrap the entire system. In the centralized
derivation, all services are naturally projected from the choreography, but some projected transitions are deleted
whereas others are added. Any sequence of inactive (null) transitions in the projection which ends with an effective
transition (i.e. a sending or a reception) is replaced by a single transition doing only the effective action, allowing the
service to skip all pointless transitions during its idle period. A new service, called orchestrator, is added to decide
the path in each non-deterministic choice of the choreography. It propagates its decisions to the services involved in
the selected transition and makes services not overtake each other. This is achieved by making the orchestrator and
the rest of services exchange some control messages. In order to avoid a wrong processing ordering of messages in
different choreography steps, the orchestrator blocks those services trying to go further than the orchestrator itself.
It is worth noting that, since null projected transitions are deleted in the rest of services, the orchestrator must be
able to coordinate services that became idle at different previous choreography states. This complicates the algorithm
deﬁnition but strongly improves the system efﬁciency, as we will illustrate in Section 4.
Deﬁnition 3.2. Let C = (S , M, ID, s1 , T ) be a choreography machine with ID = {id1 , . . . , idn } and S = {s1 , . . . , sl }.
m/(id→adr)
m/(id→adr)
For all s ∈ S and id ∈ ID, let T s,id = {s −−−−−−−−−−−→ s | ∃ adr, m, s : s −−−−−−−−−−−→ s ∈ T }. For all 1 ≤ j ≤ |T s,id |, let
t s,id, j denote the j-th transition of T s,id according to some arbitrary ordering criterium.
For all 1 ≤ i ≤ n, the controlled service for C and idi , denoted controlled(C, idi ), is a service Mi =
(idi , S i , Ii , Oi ,s1iampassive , T i ), where S i , Ii , Oi consist of all states, inputs, and outputs appearing in transitions described
next and, for all sq ∈ S , the following transitions are in T i :
• For all sr ∈ S such that sq ∈ upToRcv(C, sr , idi ) (i.e. there is a path from sr to sq where idi does nothing, but idi
m/(snd→idi )
may receive a message at sq ) and for all t = sq −−−−−−−−−−−→
s q ∈ T (i.e. for all transitions where idi is the receiver
at sq ) we have the following transitions, where we assume t = t sq ,snd, j :
t

1
(i) sriampassive −−→
sqtakingchoice j o fsnd atsq where t1 = (orc, takechoice j o f snd at sq )/(null, null) (the orchestrator tells idi that
idi will be the receiver at this state, as well as the choice it must take).

455

Pablo Rabanal et al. / Procedia Computer Science 9 (2012) 449 – 458
t

q
2
(ii) sqtakingchoice j o fsnd atsq −−→
siampassive
where t2 = (snd, m)/(orc, received) (idi receives the message and tells the
orchestrator that it can initiate next transition).

• If |T sq ,idi | ≥ 1 (that is, idi is a service that sends a message at, at least, one transition leaving the choreography state
m/(id →adr)
sq ) then, for all 1 ≤ j ≤ |T sq ,idi |, we have the following transitions, where we assume t sq ,idi , j = sq −−−−−−i−−−−−→ s q :
t

q
3
(i) For all sr ∈ S such that sq ∈ upToSnd(C, sr , idi ) we have the transition sriampassive −−→
siampassive
where t3 =
(orc, takeyourchoice j at sq )/(adr, m) (the orchestrator tells the service that its j-th sending transition will be taken
and the service sends the message of that transition).

The orchestrator of C, denoted by orchestrator(C), is a service O = (orc, S , I , O , s1 , T ), where S , I , O
consist of all states, inputs, and outputs appearing in transitions described next and, for all sq ∈ S , snd ∈ ID, and
m/(snd→rcv)
1 ≤ j ≤ |T sq ,snd | we have the following transitions in T , where we assume t sq ,snd, j = sq −−−−−−−−−−−→ s q :
t

4
sqstartingchoice j o fsnd where t4 = (null, null)/ (snd, takeyourchoice j at sq ) (the orchestrator tells the sender that
• sq −−→
one of its transitions will be taken, as well as which one).

t

5
sqtakingchoice j o fsnd where t5 = (null, null)/(rcv, takechoice j o f snd at sq ) (the orchestrator tells the
• sqstartingchoice j o fsnd −−→
receiver that one of the transitions of snd will be taken, as well as which one).

t

6
s q where t6 = (rcv, received)/(null, null) (the orchestrator receives the acknowledgement from
• sqtakingchoice j o fsnd −−→
the receiver and the choreography transition is ﬁnished).

Theorem 3.3. Let C = (S , M, ID, sin , T ) be a choreography with ID = {id1 , . . . , idn }. Let S = (controlled(C, id1 ),
. . . , controlled(C, idn ), orchestrator(C)). For all conformance relationships conf x ∈ {conf s , conf p ,
conf , conf sf , conf pf , conf f } we have S conf x C.
Let us introduce the new decentralized derivation algorithm. In this algorithm, the coordination responsibility is
distributed among the participants. This approach is more realistic in cases where we cannot assume the existence of
an almost omniscient orchestrator owning the relevant information to decide (as we need to assume in the centralized
derivation). Again, services are derived by a natural projection, although sequences of idle transitions ending with
an active transition are replaced by the latter transition, and some control messages between the services themselves
(not with any orchestrator) are added. For each choreography state having several outgoing transitions, we assume
that services being able to send a message are ordered according to any arbitrary criterion. The ﬁrst service chooses
between (a) taking one of the transitions it may trigger at the current state, or (b) refusing to do so and delegating the
transition election to the next potentially-deciding service. In case (b), the next service also chooses either (a) or (b),
and so on until the last deciding service, which, if reached, must choose (a). When a service in the sequence chooses
(a), it tells its choice to the receiver of its message and next sends the message. When the receiver gets it, it sends a
message to the ﬁrst deciding service of the new choreography state, meaning that the decision-making process of that
new state may begin. Figure 2b shows the derived orchestration of the supplier for the online purchase process. Notice
that this machine is generated automatically by DIEGO and is depicted by using the system viewer implemented in
the tool. Due to the lack of space, we do not present the rest of derived services of the case study, but they can be
easily extracted by using the tool, as this choreography example is included in the ﬁles of the downloadable version
of the application (in path ..\DIEGO2.0\Other_Choreographies\chorFig6.xml).
Deﬁnition 3.4. Let C = (S , M, ID, s1 , T ) be a choreography machine with ID = {id1 , . . . , idn } and S = {s1 , . . . , sl }.
m/(id→adr)
m/(id→adr)
For all s ∈ S and id ∈ ID, let T s,id = {s −−−−−−−−−−−→ s | ∃ adr, m, s : s −−−−−−−−−−−→ s ∈ T }. For all 1 ≤ j ≤ |T s,id |, let
t s,id, j denote the j-th transition of T s,id according to some arbitrary ordering criterium.
For all s ∈ S , let [α1s , . . . , αhs s ] denote any arbitrarily-ordered sequence of all identiﬁers in id ∈ ID such that
|T s,id | ≥ 1.
For all 1 ≤ i ≤ n, the decentralized service for C and idi , denoted decentral(C, idi ), is a service Mi =
(idi , S i , Ii , Oi , sin , T i ), where S i , Ii , Oi consist of all states, inputs, and outputs appearing in transitions described next
and, for all sq ∈ S , the following transitions are in T i :

456

Pablo Rabanal et al. / Procedia Computer Science 9 (2012) 449 – 458

• For all sr ∈ S such that sq ∈ upToRcv(C, sr , idi ) (i.e. there is a path from sr to sq where idi does nothing, but idi
m/(snd→idi )
may receive a message at sq ) and for all t = sq −−−−−−−−−−−→
s q ∈ T (i.e. for all transitions where idi is the receiver
q
at s ) we have the following transitions, where we assume t = t sq ,snd, j :
t

7
sqtakingchoice j o fsnd where t7 = (snd, takemychoice j at sq )/(null, null) (the service choosing at this state
(i) sriampassive −−→
tells idi that idi will be the receiver at this state).

t

q
8
(ii) If there exists at least one transition leaving s q in T then we also have the transition sqtakingchoice j o fsnd −−→
siampassive
q

where t8 = (snd, m)/(α1s , youcanchooseat s q ) (idi receives the message and tells the ﬁrst sender of the new state
that it can initiate the decision-making of the next state).
(snd,m)/(null,null)
q
Else, sqtakingchoice j o fsnd −−−−−−−−−−−−−−−−−→ siampassive
.
q

• If we have idi = αks such that 1 ≤ k ≤ h sq (that is, idi is a service that sends a message at, at least, one transition
sq
leaving the choreography state sq ) then we have the following additional transitions, where we assume (idi )− = αk−1
q
s
and (idi )+ = αk+1
:
(a) Take the appropriate choice:
m/(a→b)

q

(a.1) If idi is the ﬁrst service deciding at sq , i.e. idi = α1s : Let J = {b | ∃ s , m, a : s −
−−−−−−−→ sq ∈ T }.
t
9
For all sr ∈ S such that sq ∈ upToSnd(C, sr , idi ) and for all b ∈ J we have sriampassive −−→
sqicanchoose where
t9 = (b, youcanchooseat sq )/(null, null) (the receiver of the previous choreography transition tells idi that it can
start the decision-making of choreography state sq ).
t

10
(a.2) Else: For all sr ∈ S such that sq ∈ upToSnd(C, sr , idi ) we have the transition sriampassive −−→
sqicanchoose where
t10 = ((idi )− , youcanchooseat sq )/(null, null) (the previous service which can decide at the current state tells idi
and it will not, so idi can).

t

11
sqiampassive where
(b) If idi is not the last service deciding at sq , i.e. idi αhs sq : We have the transition sqicanchoose −−→
t11 = (null, null)/((idi )+ , youcanchooseat sq ) (idi refuses to choose and tells the next service that it can choose)
q

m/(id →adr)

(c) For all 1 ≤ j ≤ |T sq ,idi | we have the following transitions, where we assume t sq ,idi , j = sq −−−−−−i−−−−−→ s q .
t

12
sqichoose j where t12 = (null, null)/ (adr, takemychoice j at sq ) (idi chooses its j-th transition and
(c.1) sqicanchoose −−→
informs the receiver of that transition about it).

(null,null)/(adr,m)

q
(c.2) sqichoose j −−−−−−−−−−−−−−−−−→ siampassive
(idi sends the message required by the choreography and moves to a passive
state).
1

Besides, if idi = α1s then sin = s1icanchoose else sin = s1iampassive .
Theorem 3.5. Let C = (S , M, ID, sin , T ) be a choreography with ID = {id1 , . . . , idn }. Let S = (decentral(C, id1 ), . . . ,
decentral(C, idn )). For all conf x ∈ {conf s , conf p , conf , conf sf , conf pf , conf f } we have S conf x C.
4. Experiments
In this section we compare the performance of our centralized and decentralized derivations, as well as them
with derivations implemented in the former DIEGO version (deﬁned in [13]), in terms of the number of messages
exchanged among the services. We compare them by using several choreographies where the number of involved web
services differs or the choreography depth (i.e. the depth of the tree denoting the choreography form) varies. The tool
DIEGO 2.0, as well as all choreographies mentioned in experiments described here and other related material, are
available at http://www.dsi.uclm.es/retics/diego/.
Experiments performed with the automatic testing functionality of DIEGO 2.0 show that new algorithms suppress
a high amount of unnecessary control messages between the services, yielding a very efﬁcient derivation. Decreasing
the message trafﬁc is very important in order to reduce the network congestion. We empirically observe that, in
former derivation algorithms, most of avoidable control messages are sent to services that are not involved in the
current choreography step indeed. On the contrary, in new optimized algorithms, for each service, any sequence of

Pablo Rabanal et al. / Procedia Computer Science 9 (2012) 449 – 458

457

consecutive null transitions, departing at state s, and followed by a non-null transition reaching state s , is replaced
by a single transition from s to s . These transitions make the service immediately advance a different number of
choreography steps, depending on its current state. Thus, services must be informed of the transition to be taken at
each time, and also of what choreography state this transition belongs to.
Let us introduce our choreography examples. In choreography cExp1_2ws, only two services participate in a
single branching point. In choreography cExp1_3ws, cExp1_2ws is modiﬁed by adding a new participant service,
yielding a choreography where three web services participate in a single choice point. By changing the number of participant services in cExp1_2ws, we create the rest of the choreographies used in the experiments, where 4, 5, . . . , 10
web services are involved (these choreographies are called cExp1_4ws, cExp1_5ws, . . . , cExp1_10ws). We compare
the number of messages exchanged among the services by using our tool DIEGO 2.0, in particular, the web services
simulator included in it. The results are shown in Table 2. The ﬁrst column of Table 2, called Version, shows the
algorithm version, 1.0 (former version) or 2.0 (optimized version); column Choreography shows the name of the
choreography used in the experiment; column Msgs Centr. shows the number of messages exchanged between services when running the simulation for the centralized derivation; ﬁnally, column Msgs Decentr. shows the number of
messages exchanged between services when running the simulation for the decentralized derivation. Regarding column Msgs Decentr., sometimes an interval appears. This means that the derivation version under consideration needed
different numbers of messages in different executions. Notice that the choreography non-determinism is simulated
by making random choices in the simulator, so the number of messages upon termination may vary depending on the
path chosen. We have characterized the number of messages exchanged with respect to the number of web services
involved in the branching point (p) and the choreography depth (q), respectively (last two lines of Table 2).
Table 2: Comparison between centralized and decentralized derivation methods for algorithm versions 1.0 and 2.0.
Version
1.0
2.0
1.0
2.0
1.0
2.0
1.0
2.0
1.0
2.0
1.0
2.0
1.0
2.0
1.0
2.0
1.0
2.0
1.0
2.0

Choreography Msgs Centr. Msgs Decentr.
cExp1_2ws
11
8-9
cExp1_2ws
6
4-6
cExp1_3ws
16
11-13
cExp1_3ws
6
4-8
cExp1_4ws
21
14-17
cExp1_4ws
6
4-10
cExp1_5ws
26
17-21
cExp1_5ws
6
4-12
cExp1_6ws
31
20-25
cExp1_6ws
6
4-14
cExp1_7ws
36
23-29
cExp1_7ws
6
4-16
cExp1_8ws
41
26-33
cExp1_8ws
6
4-18
cExp1_9ws
46
29-37
cExp1_9ws
6
4-20
cExp1_10ws
51
32-41
cExp1_10ws
6
4-22
cExp1_pws
5*p+1
3*p+2 , 4*p+1
cExp1_pws
6
4 , 2*(p+1)

Choreography Msgs Centr. Msgs Decentr.
cExp2_d=3
18
18
cExp2_d=3
12
9
cExp2_d=4
27
27
cExp2_d=4
18
14
cExp2_d=5
36
36
cExp2_d=5
24
19
cExp2_d=6
45
45
cExp2_d=6
30
24
cExp2_d=7
54
54
cExp2_d=7
36
29
cExp2_d=8
63
63
cExp2_d=8
42
34
cExp2_d=9
72
72
cExp2_d=9
48
39
cExp2_d=10
81
81
cExp2_d=10
54
44
cExp2_d=11
90
90
cExp2_d=11
60
49
cExp2_d=q
9*(q-1)
9*(q-1)
cExp2_d=q
6*(q-1)
5*q-6

The results illustrate that the number of messages exchanged in the former versions of the centralized and decentralized derivation algorithms grows linearly with the number of services involved in the choice point of the choreography, whereas the number of messages exchanged in the optimized versions remains constant in the centralized
version and in the lowest bounds of the decentralized version. So, if the number of web services increases, the number
of messages exchanged is not affected in the centralized case. Furthermore, if we include more branches leaving the
same choice state and the number of web services being able to send increases, then the number of messages required
for communication increases linearly in the upper bounds in the decentralized version since they have to agree on
which one will act. However, this does not affect the centralized version because the orchestrator makes the decision
in a single step, without consulting the rest of services.
In our second experiment, we use choreographies where only two web services are involved and we modify the
depth of the tree representing the choreography. Thus, cExp2_d = 3 is a choreography with two branches and depth 3,
choreography cExp2_d = 4 is similar to the previous one but with depth 4, and so on up to cExp2_d = 11 with depth
11. Results are also presented in Table 2. As we can observe, in both versions, the number of messages increases

458

Pablo Rabanal et al. / Procedia Computer Science 9 (2012) 449 – 458

linearly with the depth of the choreography. However the number of messages in the optimized version is lower,
and it also grows more slowly. This difference would be greater in choreographies with higher number of involved
services, because more unnecessary messages would be avoided in optimized derivations. The single branching point
of choreographies involves a single service so, for each choreography, all executions of the optimized decentralized
derivation require a constant number of messages.
5. Conclusions
In this paper we have introduced a new version of our services derivation tool, DIEGO. To the best of our knowledge, DIEGO is the only tool that derives correct sets of WS-BPEL services from WS-CDL choreographies even in
cases where the natural projection does not work, without requiring any well-formedness conditions, and in an integrated way not requiring any human interaction in the derivation. The new version described in this paper, DIEGO 2.0,
provides algorithms that are more efﬁcient, and it incorporates additional features such as testing of derived services,
which automatically compares the behavior of the derived services with the corresponding choreography. Besides, we
have formally deﬁned the new derivation algorithms and proved their correctness.
As future work, we plan to enrich our formal FSM-based choreography and orchestration languages with variables
and temporal conditions. Moreover, we are planning to extend our operational semantics with the parallel operator
and with WS-CDL workunits to model conditional behavior. We will also design new derivation algorithms for these
new enhanced models and implement them in DIEGO.
References
[1] M. Baldoni, C. Baroglio, A. K. Chopra, N. Desai, V. Patti, and M. P. Singh. Choice, interoperability, and conformance in interaction protocols
and service choreographies. In International Conference on Autonomous Agents and Multiagent Systems (AAMAS’09), vol. 2, pp. 843-850,
2009.
[2] M. Bravetti and G. Zavattaro. Contract-based discovery and composition of web services. In SFM 2009, Lecture Notes in Computer Science,
vol. 5569, pp. 261-295, 2009.
[3] L. Caires and H. T. Vieira. Conversation types. Theoretical Computer Science, vol. 411, pp. 4399-4440, 2010.
[4] G. Decker, O. Kopp, F. Leymann, K. Pﬁtzner, and M. Weske. Modeling service choreographies using BPMN and BPEL4Chor. In International Conference on Advanced Information Systems Engineering (CAiSE’08), pp. 79-93, 2008.
[5] G. Díaz and I. Rodríguez. Automatically deriving choreography-conforming systems of services. In IEEE International Conference on
Services Computing (SCC’09), pp. 9-16, 2009.
[6] G. Díaz and I. Rodríguez. Checking the conformance of orchestrations with respect to choreographies in web services: A formal approach.
In IFIP International Conference FMOODS and FORTE (FMOODS/FORTE’09), pp. 231-236, 2009.
[7] R. Khadka, B. Sapkota, L. Ferreira Pires, M. S. van, and S. Jansen. Wscdl to ws-bpel: A case study of atl-based transformation. In
International Workshop on Model Transformation with ATL (MtATL’11), vol. 742, pp. 89-103, 2011.
[8] I. Lanese, C. Guidi, F. Montesi, and G. Zavattaro. Bridging the gap between interaction- and process-oriented choreographies. In International
Conference on Software Engineering and Formal Methods (SEFM’08), pp. 323-332, 2008.
[9] R. Lucchi and M. Mazzara. A pi-calculus based semantics for ws-bpel. Journal of Logic and Algebraic Programming, vol. 70, pp. 96-118,
2007.
[10] J. Mendling and M. Hafner. From inter-organizational workﬂows to process execution: Generating bpel from ws-cdl. In On the Move to
Meaningful Internet Systems 2005 (OTM’05 Workshops), vol. 3762, pp. 506-515. 2005.
[11] Z. Qiu, X. Zhao, C. Cai, and H. Yang. Towards the theoretical foundation of choreography. In World Wide Web Conference (WWW’07), pp.
973-982, 2007.
[12] P. Rabanal, J. Mateo, I. Rodriguez, and G. Diaz. DIEGO: A tool for DerIving chorEoGraphy-cOnforming web service systems. In International Conference on Web Services (ICWS’11), pp. 187-194, 2011.
[13] I. Rodriguez, G. Diaz, P. Rabanal, and J. A. Mateo. A centralized and a decentralized method to automatically derive choreographyconforming web service systems. Journal of Logic and Algebraic Programming, vol. 81, pp. 127-159, 2012.
[14] G. Salaün and T. Bultan. Realizability of choreographies using process algebra encodings. In International Conference Integrated Formal
Methods (IFM’09), pp. 167-182, 2009.
[15] W. M. P. van der Aalst, N. Lohmann, P. Massuthe, C. Stahl, and K. Wolf. From public views to private views - correctness-by-design for
services. In Web Services and Formal Methods (WS-FM’07), pp. 139,153, 2007.

